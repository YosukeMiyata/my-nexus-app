"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/msgpackr@1.11.5";
exports.ids = ["vendor-chunks/msgpackr@1.11.5"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/iterators.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/iterators.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeIter: () => (/* binding */ decodeIter),\n/* harmony export */   encodeIter: () => (/* binding */ encodeIter),\n/* harmony export */   packIter: () => (/* binding */ packIter),\n/* harmony export */   unpackIter: () => (/* binding */ unpackIter)\n/* harmony export */ });\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pack.js */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/pack.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unpack.js */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/unpack.js\");\n\n\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - msgpackr pack options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nfunction packIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return packIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return packIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * packIterSync (objectIterator, options) {\n  const packr = new _pack_js__WEBPACK_IMPORTED_MODULE_0__.Packr(options)\n  for (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\nasync function * packIterAsync (objectIterator, options) {\n  const packr = new _pack_js__WEBPACK_IMPORTED_MODULE_0__.Packr(options)\n  for await (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - unpackr options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nfunction unpackIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const unpackr = new _unpack_js__WEBPACK_IMPORTED_MODULE_1__.Unpackr(options)\n  let incomplete\n  const parser = (chunk) => {\n    let yields\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk])\n      incomplete = undefined\n    }\n\n    try {\n      yields = unpackr.unpackMultiple(chunk)\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition)\n        yields = err.values\n      } else {\n        throw err\n      }\n    }\n    return yields\n  }\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  }\n}\nconst decodeIter = unpackIter\nconst encodeIter = packIter//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbXNncGFja3JAMS4xMS41L25vZGVfbW9kdWxlcy9tc2dwYWNrci9pdGVyYXRvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlDO0FBQ0k7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0NBQStDO0FBQzFELFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDTywrQ0FBK0M7QUFDdEQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMkNBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMkNBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBdUQ7QUFDbEUsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNPLGlEQUFpRDtBQUN4RDtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLCtDQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3lvdXN1a2UvTXlQcm9qZWN0L215LW5leHVzLWFwcC9ub2RlX21vZHVsZXMvLnBucG0vbXNncGFja3JAMS4xMS41L25vZGVfbW9kdWxlcy9tc2dwYWNrci9pdGVyYXRvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFja3IgfSBmcm9tICcuL3BhY2suanMnXG5pbXBvcnQgeyBVbnBhY2tyIH0gZnJvbSAnLi91bnBhY2suanMnXG5cbi8qKlxuICogR2l2ZW4gYW4gSXRlcmFibGUgZmlyc3QgYXJndW1lbnQsIHJldHVybnMgYW4gSXRlcmFibGUgd2hlcmUgZWFjaCB2YWx1ZSBpcyBwYWNrZWQgYXMgYSBCdWZmZXJcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBvbmx5IEFzeW5jIEl0ZXJhYmxlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgYW4gQXN5bmMgSXRlcmFibGUuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfEl0ZXJhdG9yfEFzeW5jSXRlcmFibGV8QXN5bmNJdGVyYXRvcn0gb2JqZWN0SXRlcmF0b3IgLSBpdGVyYWJsZSBzb3VyY2UsIGxpa2UgYSBSZWFkYWJsZSBvYmplY3Qgc3RyZWFtLCBhbiBhcnJheSwgU2V0LCBvciBjdXN0b20gb2JqZWN0XG4gKiBAcGFyYW0ge29wdGlvbnN9IFtvcHRpb25zXSAtIG1zZ3BhY2tyIHBhY2sgb3B0aW9uc1xuICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3J8UHJvbWlzZS48QXN5bmNJdGVyYWJsZUl0ZXJhdG9yPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhY2tJdGVyIChvYmplY3RJdGVyYXRvciwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghb2JqZWN0SXRlcmF0b3IgfHwgdHlwZW9mIG9iamVjdEl0ZXJhdG9yICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBJdGVyYWJsZSwgQXN5bmMgSXRlcmFibGUsIG9yIGEgUHJvbWlzZSBmb3IgYW4gQXN5bmMgSXRlcmFibGUnKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3RJdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHBhY2tJdGVyU3luYyhvYmplY3RJdGVyYXRvciwgb3B0aW9ucylcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0SXRlcmF0b3IudGhlbiA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqZWN0SXRlcmF0b3JbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHBhY2tJdGVyQXN5bmMob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEl0ZXJhYmxlLCBBc3luYyBJdGVyYWJsZSwgSXRlcmF0b3IsIEFzeW5jIEl0ZXJhdG9yLCBvciBhIFByb21pc2UnKVxuICB9XG59XG5cbmZ1bmN0aW9uICogcGFja0l0ZXJTeW5jIChvYmplY3RJdGVyYXRvciwgb3B0aW9ucykge1xuICBjb25zdCBwYWNrciA9IG5ldyBQYWNrcihvcHRpb25zKVxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iamVjdEl0ZXJhdG9yKSB7XG4gICAgeWllbGQgcGFja3IucGFjayh2YWx1ZSlcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiAqIHBhY2tJdGVyQXN5bmMgKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhY2tyID0gbmV3IFBhY2tyKG9wdGlvbnMpXG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygb2JqZWN0SXRlcmF0b3IpIHtcbiAgICB5aWVsZCBwYWNrci5wYWNrKHZhbHVlKVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gSXRlcmFibGUvSXRlcmF0b3IgaW5wdXQgd2hpY2ggeWllbGRzIGJ1ZmZlcnMsIHJldHVybnMgYW4gSXRlcmFibGVJdGVyYXRvciB3aGljaCB5aWVsZHMgc3luYyBkZWNvZGVkIG9iamVjdHNcbiAqIE9yLCBnaXZlbiBhbiBBc3luYyBJdGVyYWJsZS9JdGVyYXRvciB3aGljaCB5aWVsZHMgcHJvbWlzZXMgcmVzb2x2aW5nIGluIGJ1ZmZlcnMsIHJldHVybnMgYW4gQXN5bmNJdGVyYWJsZUl0ZXJhdG9yLlxuICogQHBhcmFtIHtJdGVyYWJsZXxJdGVyYXRvcnxBc3luY0l0ZXJhYmxlfEFzeW5jSXRlcmFibGVJdGVyYXRvcn0gYnVmZmVySXRlcmF0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSB1bnBhY2tyIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yfFByb21pc2UuPEFzeW5jSXRlcmFibGVJdGVyYXRvcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVucGFja0l0ZXIgKGJ1ZmZlckl0ZXJhdG9yLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFidWZmZXJJdGVyYXRvciB8fCB0eXBlb2YgYnVmZmVySXRlcmF0b3IgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEl0ZXJhYmxlLCBBc3luYyBJdGVyYWJsZSwgSXRlcmF0b3IsIEFzeW5jIEl0ZXJhdG9yLCBvciBhIHByb21pc2UnKVxuICB9XG5cbiAgY29uc3QgdW5wYWNrciA9IG5ldyBVbnBhY2tyKG9wdGlvbnMpXG4gIGxldCBpbmNvbXBsZXRlXG4gIGNvbnN0IHBhcnNlciA9IChjaHVuaykgPT4ge1xuICAgIGxldCB5aWVsZHNcbiAgICAvLyBpZiB0aGVyZSdzIGluY29tcGxldGUgZGF0YSBmcm9tIHByZXZpb3VzIGNodW5rLCBjb25jYXRpbmF0ZSBhbmQgdHJ5IGFnYWluXG4gICAgaWYgKGluY29tcGxldGUpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmNvbmNhdChbaW5jb21wbGV0ZSwgY2h1bmtdKVxuICAgICAgaW5jb21wbGV0ZSA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB5aWVsZHMgPSB1bnBhY2tyLnVucGFja011bHRpcGxlKGNodW5rKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5pbmNvbXBsZXRlKSB7XG4gICAgICAgIGluY29tcGxldGUgPSBjaHVuay5zbGljZShlcnIubGFzdFBvc2l0aW9uKVxuICAgICAgICB5aWVsZHMgPSBlcnIudmFsdWVzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHlpZWxkc1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidWZmZXJJdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAqIGl0ZXIgKCkge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBidWZmZXJJdGVyYXRvcikge1xuICAgICAgICB5aWVsZCAqIHBhcnNlcih2YWx1ZSlcbiAgICAgIH1cbiAgICB9KSgpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGJ1ZmZlckl0ZXJhdG9yW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAoYXN5bmMgZnVuY3Rpb24gKiBpdGVyICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYnVmZmVySXRlcmF0b3IpIHtcbiAgICAgICAgeWllbGQgKiBwYXJzZXIodmFsdWUpXG4gICAgICB9XG4gICAgfSkoKVxuICB9XG59XG5leHBvcnQgY29uc3QgZGVjb2RlSXRlciA9IHVucGFja0l0ZXJcbmV4cG9ydCBjb25zdCBlbmNvZGVJdGVyID0gcGFja0l0ZXIiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/iterators.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/node-index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/node-index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALWAYS: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.ALWAYS),\n/* harmony export */   C1: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.C1),\n/* harmony export */   DECIMAL_FIT: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.DECIMAL_FIT),\n/* harmony export */   DECIMAL_ROUND: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.DECIMAL_ROUND),\n/* harmony export */   Decoder: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.Decoder),\n/* harmony export */   DecoderStream: () => (/* reexport safe */ _stream_js__WEBPACK_IMPORTED_MODULE_3__.UnpackrStream),\n/* harmony export */   Encoder: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.Encoder),\n/* harmony export */   EncoderStream: () => (/* reexport safe */ _stream_js__WEBPACK_IMPORTED_MODULE_3__.PackrStream),\n/* harmony export */   FLOAT32_OPTIONS: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.FLOAT32_OPTIONS),\n/* harmony export */   NEVER: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.NEVER),\n/* harmony export */   Packr: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.Packr),\n/* harmony export */   PackrStream: () => (/* reexport safe */ _stream_js__WEBPACK_IMPORTED_MODULE_3__.PackrStream),\n/* harmony export */   Unpackr: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.Unpackr),\n/* harmony export */   UnpackrStream: () => (/* reexport safe */ _stream_js__WEBPACK_IMPORTED_MODULE_3__.UnpackrStream),\n/* harmony export */   addExtension: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.addExtension),\n/* harmony export */   clearSource: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.clearSource),\n/* harmony export */   decode: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.decode),\n/* harmony export */   decodeIter: () => (/* reexport safe */ _iterators_js__WEBPACK_IMPORTED_MODULE_4__.decodeIter),\n/* harmony export */   encode: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.encode),\n/* harmony export */   encodeIter: () => (/* reexport safe */ _iterators_js__WEBPACK_IMPORTED_MODULE_4__.encodeIter),\n/* harmony export */   isNativeAccelerationEnabled: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.isNativeAccelerationEnabled),\n/* harmony export */   mapsAsObjects: () => (/* binding */ mapsAsObjects),\n/* harmony export */   pack: () => (/* reexport safe */ _pack_js__WEBPACK_IMPORTED_MODULE_0__.pack),\n/* harmony export */   roundFloat32: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.roundFloat32),\n/* harmony export */   unpack: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.unpack),\n/* harmony export */   unpackMultiple: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_1__.unpackMultiple),\n/* harmony export */   useRecords: () => (/* binding */ useRecords)\n/* harmony export */ });\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pack.js */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/pack.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unpack.js */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/unpack.js\");\n/* harmony import */ var _struct_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./struct.js */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/struct.js\");\n/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/stream.js\");\n/* harmony import */ var _iterators_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./iterators.js */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/iterators.js\");\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! module */ \"module\");\n\n\n;\n\n\nconst useRecords = false\nconst mapsAsObjects = true\n;\n\n\nconst nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === 'true';\n\nif (!nativeAccelerationDisabled) {\n\tlet extractor\n\ttry {\n\t\tif (typeof require == 'function')\n\t\t\textractor = require('msgpackr-extract')\n\t\telse\n\t\t\textractor = (0,module__WEBPACK_IMPORTED_MODULE_5__.createRequire)(\"file:///Users/yousuke/MyProject/my-nexus-app/node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/node-index.js\")('msgpackr-extract')\n\t\tif (extractor)\n\t\t\t(0,_unpack_js__WEBPACK_IMPORTED_MODULE_1__.setExtractor)(extractor.extractStrings)\n\t} catch (error) {\n\t\t// native module is optional\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbXNncGFja3JAMS4xMS41L25vZGVfbW9kdWxlcy9tc2dwYWNrci9ub2RlLWluZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpSDtBQUMwQztBQUMzSixDQUFvQjtBQUNrRztBQUMvRDtBQUNoRDtBQUNBO0FBQ1AsQ0FBMEM7QUFDSjs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBYSxDQUFDLHFIQUFlO0FBQzVDO0FBQ0EsR0FBRyx3REFBWTtBQUNmLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy95b3VzdWtlL015UHJvamVjdC9teS1uZXh1cy1hcHAvbm9kZV9tb2R1bGVzLy5wbnBtL21zZ3BhY2tyQDEuMTEuNS9ub2RlX21vZHVsZXMvbXNncGFja3Ivbm9kZS1pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBQYWNrciwgRW5jb2RlciwgYWRkRXh0ZW5zaW9uLCBwYWNrLCBlbmNvZGUsIE5FVkVSLCBBTFdBWVMsIERFQ0lNQUxfUk9VTkQsIERFQ0lNQUxfRklUIH0gZnJvbSAnLi9wYWNrLmpzJ1xuZXhwb3J0IHsgVW5wYWNrciwgRGVjb2RlciwgQzEsIHVucGFjaywgdW5wYWNrTXVsdGlwbGUsIGRlY29kZSwgRkxPQVQzMl9PUFRJT05TLCBjbGVhclNvdXJjZSwgcm91bmRGbG9hdDMyLCBpc05hdGl2ZUFjY2VsZXJhdGlvbkVuYWJsZWQgfSBmcm9tICcuL3VucGFjay5qcydcbmltcG9ydCAnLi9zdHJ1Y3QuanMnXG5leHBvcnQgeyBQYWNrclN0cmVhbSwgVW5wYWNrclN0cmVhbSwgUGFja3JTdHJlYW0gYXMgRW5jb2RlclN0cmVhbSwgVW5wYWNrclN0cmVhbSBhcyBEZWNvZGVyU3RyZWFtIH0gZnJvbSAnLi9zdHJlYW0uanMnXG5leHBvcnQgeyBkZWNvZGVJdGVyLCBlbmNvZGVJdGVyIH0gZnJvbSAnLi9pdGVyYXRvcnMuanMnXG5leHBvcnQgY29uc3QgdXNlUmVjb3JkcyA9IGZhbHNlXG5leHBvcnQgY29uc3QgbWFwc0FzT2JqZWN0cyA9IHRydWVcbmltcG9ydCB7IHNldEV4dHJhY3RvciB9IGZyb20gJy4vdW5wYWNrLmpzJ1xuaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gJ21vZHVsZSdcblxuY29uc3QgbmF0aXZlQWNjZWxlcmF0aW9uRGlzYWJsZWQgPSBwcm9jZXNzLmVudi5NU0dQQUNLUl9OQVRJVkVfQUNDRUxFUkFUSU9OX0RJU0FCTEVEICE9PSB1bmRlZmluZWQgJiYgcHJvY2Vzcy5lbnYuTVNHUEFDS1JfTkFUSVZFX0FDQ0VMRVJBVElPTl9ESVNBQkxFRC50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG5cbmlmICghbmF0aXZlQWNjZWxlcmF0aW9uRGlzYWJsZWQpIHtcblx0bGV0IGV4dHJhY3RvclxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgcmVxdWlyZSA9PSAnZnVuY3Rpb24nKVxuXHRcdFx0ZXh0cmFjdG9yID0gcmVxdWlyZSgnbXNncGFja3ItZXh0cmFjdCcpXG5cdFx0ZWxzZVxuXHRcdFx0ZXh0cmFjdG9yID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpKCdtc2dwYWNrci1leHRyYWN0Jylcblx0XHRpZiAoZXh0cmFjdG9yKVxuXHRcdFx0c2V0RXh0cmFjdG9yKGV4dHJhY3Rvci5leHRyYWN0U3RyaW5ncylcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBuYXRpdmUgbW9kdWxlIGlzIG9wdGlvbmFsXG5cdH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/node-index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/pack.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/pack.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALWAYS: () => (/* binding */ ALWAYS),\n/* harmony export */   DECIMAL_FIT: () => (/* binding */ DECIMAL_FIT),\n/* harmony export */   DECIMAL_ROUND: () => (/* binding */ DECIMAL_ROUND),\n/* harmony export */   Encoder: () => (/* binding */ Encoder),\n/* harmony export */   FLOAT32_OPTIONS: () => (/* reexport safe */ _unpack_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT32_OPTIONS),\n/* harmony export */   NEVER: () => (/* binding */ NEVER),\n/* harmony export */   Packr: () => (/* binding */ Packr),\n/* harmony export */   RECORD_SYMBOL: () => (/* binding */ RECORD_SYMBOL),\n/* harmony export */   RESERVE_START_SPACE: () => (/* binding */ RESERVE_START_SPACE),\n/* harmony export */   RESET_BUFFER_MODE: () => (/* binding */ RESET_BUFFER_MODE),\n/* harmony export */   REUSE_BUFFER_MODE: () => (/* binding */ REUSE_BUFFER_MODE),\n/* harmony export */   addExtension: () => (/* binding */ addExtension),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   setWriteStructSlots: () => (/* binding */ setWriteStructSlots)\n/* harmony export */ });\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unpack.js */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/unpack.js\");\n\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nclass Packr extends _unpack_js__WEBPACK_IMPORTED_MODULE_0__.Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, target.byteLength - position)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end,\n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\t\t// don't keep large buffers around\n\t\t\t\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null\n\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\ttransitionsCount = 0\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = []\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = []\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * _unpack_js__WEBPACK_IMPORTED_MODULE_0__.mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\n\t\t\t\t\t\t\t// no extension found, write as plain object\n\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < 0x8000000000000000 && value >= -0x8000000000000000) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < 0x10000000000000000 && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else if (this.largeBigIntToString) {\n\t\t\t\t\t\treturn pack(value.toString());\n\t\t\t\t\t} else if (this.useBigIntExtension || this.moreTypes) {\n\t\t\t\t\t\tlet empty = value < 0 ? BigInt(-1) : BigInt(0)\n\n\t\t\t\t\t\tlet array\n\t\t\t\t\t\tif (value >> BigInt(0x10000) === empty) {\n\t\t\t\t\t\t\tlet mask = BigInt(0x10000000000000000) - BigInt(1) // literal would overflow\n\t\t\t\t\t\t\tlet chunks = []\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tchunks.push(value & mask)\n\t\t\t\t\t\t\t\tif ((value >> BigInt(63)) === empty) break\n\t\t\t\t\t\t\t\tvalue >>= BigInt(64)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tarray = new Uint8Array(new BigUint64Array(chunks).buffer)\n\t\t\t\t\t\t\tarray.reverse()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet invert = value < 0\n\t\t\t\t\t\t\tlet string = (invert ? ~value : value).toString(16)\n\t\t\t\t\t\t\tif (string.length % 2) {\n\t\t\t\t\t\t\t\tstring = '0' + string\n\t\t\t\t\t\t\t} else if (parseInt(string.charAt(0), 16) >= 8) {\n\t\t\t\t\t\t\t\tstring = '00' + string\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (hasNodeBuffer) {\n\t\t\t\t\t\t\t\tarray = Buffer.from(string, 'hex')\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tarray = new Uint8Array(string.length / 2)\n\t\t\t\t\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\t\t\t\t\tarray[i] = parseInt(string.slice(i * 2, i * 2 + 2), 16)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (invert) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < array.length; i++) array[i] = ~array[i]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (array.length + position > safeEnd)\n\t\t\t\t\t\t\tmakeRoom(array.length + position)\n\t\t\t\t\t\tposition = writeExtensionData(array, target, position, 0x42)\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set' +\n\t\t\t\t\t\t\t' largeBigIntToString to convert to string')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys;\n\t\t\tif (this.skipValues) {\n\t\t\t\tkeys = [];\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tif ((typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) &&\n\t\t\t\t\t\t!this.skipValues.includes(object[key]))\n\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeys = Object.keys(object)\n\t\t\t}\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size > 0xffff) {\n\t\t\t\tthrow new Error('Object is too large to serialize with fast 16-bit map size,' +\n\t\t\t\t' use the \"variableMapSize\" option to serialize this object');\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t}\n\n\t\t// create reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\n\t\tconst writeObject = checkUseRecords ? (object) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object) : writePlainObject(object)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttarget.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength))\n\t\ttargetView = target.dataView;\n\t\tposition = 0\n\t}\n\tset position (value) {\n\t\tposition = value;\n\t}\n\tget position() {\n\t\treturn position;\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, DataView, _unpack_js__WEBPACK_IMPORTED_MODULE_0__.C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message, error.cause ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, _unpack_js__WEBPACK_IMPORTED_MODULE_0__.typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x11, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\tif (!typedArray.buffer) typedArray = new Uint8Array(typedArray)\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nfunction addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\t(0,_unpack_js__WEBPACK_IMPORTED_MODULE_0__.addExtension)(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nfunction setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nconst pack = defaultPackr.pack\nconst encode = defaultPackr.pack\nconst Encoder = Packr\n\n;\nconst { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = _unpack_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT32_OPTIONS\nconst REUSE_BUFFER_MODE = 512\nconst RESET_BUFFER_MODE = 1024\nconst RESERVE_START_SPACE = 2048\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbXNncGFja3JAMS4xMS41L25vZGVfbW9kdWxlcy9tc2dwYWNrci9wYWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBLG9CQUFvQiwrQ0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQ0FBaUM7QUFDdkM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4Q0FBTTtBQUNuQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDO0FBQzlDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOElBQThJLDhDQUFNO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhCQUE4QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxTQUFTLDhCQUE4QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtREFBVztBQUN6QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4QjtBQUM5QixRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdEQUFrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLCtCQUErQixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ3NDO0FBQzdDLENBQTZDO0FBQ3RDLFFBQVEsNENBQTRDLEVBQUUsdURBQWU7QUFDckU7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMveW91c3VrZS9NeVByb2plY3QvbXktbmV4dXMtYXBwL25vZGVfbW9kdWxlcy8ucG5wbS9tc2dwYWNrckAxLjExLjUvbm9kZV9tb2R1bGVzL21zZ3BhY2tyL3BhY2suanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVW5wYWNrciwgbXVsdDEwLCBDMVR5cGUsIHR5cGVkQXJyYXlzLCBhZGRFeHRlbnNpb24gYXMgdW5wYWNrQWRkRXh0ZW5zaW9uIH0gZnJvbSAnLi91bnBhY2suanMnXG5sZXQgdGV4dEVuY29kZXJcbnRyeSB7XG5cdHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbn0gY2F0Y2ggKGVycm9yKSB7fVxubGV0IGV4dGVuc2lvbnMsIGV4dGVuc2lvbkNsYXNzZXNcbmNvbnN0IGhhc05vZGVCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJ1xuY29uc3QgQnl0ZUFycmF5QWxsb2NhdGUgPSBoYXNOb2RlQnVmZmVyID9cblx0ZnVuY3Rpb24obGVuZ3RoKSB7IHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KGxlbmd0aCkgfSA6IFVpbnQ4QXJyYXlcbmNvbnN0IEJ5dGVBcnJheSA9IGhhc05vZGVCdWZmZXIgPyBCdWZmZXIgOiBVaW50OEFycmF5XG5jb25zdCBNQVhfQlVGRkVSX1NJWkUgPSBoYXNOb2RlQnVmZmVyID8gMHgxMDAwMDAwMDAgOiAweDdmZDAwMDAwXG5sZXQgdGFyZ2V0LCBrZXlzVGFyZ2V0XG5sZXQgdGFyZ2V0Vmlld1xubGV0IHBvc2l0aW9uID0gMFxubGV0IHNhZmVFbmRcbmxldCBidW5kbGVkU3RyaW5ncyA9IG51bGxcbmxldCB3cml0ZVN0cnVjdFNsb3RzXG5jb25zdCBNQVhfQlVORExFX1NJWkUgPSAweDU1MDAgLy8gbWF4aW11bSBjaGFyYWN0ZXJzIHN1Y2ggdGhhdCB0aGUgZW5jb2RlZCBieXRlcyBmaXRzIGluIDE2IGJpdHMuXG5jb25zdCBoYXNOb25MYXRpbiA9IC9bXFx1MDA4MC1cXHVGRkZGXS9cbmV4cG9ydCBjb25zdCBSRUNPUkRfU1lNQk9MID0gU3ltYm9sKCdyZWNvcmQtaWQnKVxuZXhwb3J0IGNsYXNzIFBhY2tyIGV4dGVuZHMgVW5wYWNrciB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRzdXBlcihvcHRpb25zKVxuXHRcdHRoaXMub2Zmc2V0ID0gMFxuXHRcdGxldCB0eXBlQnVmZmVyXG5cdFx0bGV0IHN0YXJ0XG5cdFx0bGV0IGhhc1NoYXJlZFVwZGF0ZVxuXHRcdGxldCBzdHJ1Y3R1cmVzXG5cdFx0bGV0IHJlZmVyZW5jZU1hcFxuXHRcdGxldCBlbmNvZGVVdGY4ID0gQnl0ZUFycmF5LnByb3RvdHlwZS51dGY4V3JpdGUgPyBmdW5jdGlvbihzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnV0ZjhXcml0ZShzdHJpbmcsIHBvc2l0aW9uLCB0YXJnZXQuYnl0ZUxlbmd0aCAtIHBvc2l0aW9uKVxuXHRcdH0gOiAodGV4dEVuY29kZXIgJiYgdGV4dEVuY29kZXIuZW5jb2RlSW50bykgP1xuXHRcdFx0ZnVuY3Rpb24oc3RyaW5nLCBwb3NpdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlSW50byhzdHJpbmcsIHRhcmdldC5zdWJhcnJheShwb3NpdGlvbikpLndyaXR0ZW5cblx0XHRcdH0gOiBmYWxzZVxuXG5cdFx0bGV0IHBhY2tyID0gdGhpc1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fVxuXHRcdGxldCBpc1NlcXVlbnRpYWwgPSBvcHRpb25zICYmIG9wdGlvbnMuc2VxdWVudGlhbFxuXHRcdGxldCBoYXNTaGFyZWRTdHJ1Y3R1cmVzID0gb3B0aW9ucy5zdHJ1Y3R1cmVzIHx8IG9wdGlvbnMuc2F2ZVN0cnVjdHVyZXNcblx0XHRsZXQgbWF4U2hhcmVkU3RydWN0dXJlcyA9IG9wdGlvbnMubWF4U2hhcmVkU3RydWN0dXJlc1xuXHRcdGlmIChtYXhTaGFyZWRTdHJ1Y3R1cmVzID09IG51bGwpXG5cdFx0XHRtYXhTaGFyZWRTdHJ1Y3R1cmVzID0gaGFzU2hhcmVkU3RydWN0dXJlcyA/IDMyIDogMFxuXHRcdGlmIChtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gODE2MClcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWF4aW11bSBtYXhTaGFyZWRTdHJ1Y3R1cmUgaXMgODE2MCcpXG5cdFx0aWYgKG9wdGlvbnMuc3RydWN0dXJlZENsb25lICYmIG9wdGlvbnMubW9yZVR5cGVzID09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5tb3JlVHlwZXMgPSB0cnVlXG5cdFx0fVxuXHRcdGxldCBtYXhPd25TdHJ1Y3R1cmVzID0gb3B0aW9ucy5tYXhPd25TdHJ1Y3R1cmVzXG5cdFx0aWYgKG1heE93blN0cnVjdHVyZXMgPT0gbnVsbClcblx0XHRcdG1heE93blN0cnVjdHVyZXMgPSBoYXNTaGFyZWRTdHJ1Y3R1cmVzID8gMzIgOiA2NFxuXHRcdGlmICghdGhpcy5zdHJ1Y3R1cmVzICYmIG9wdGlvbnMudXNlUmVjb3JkcyAhPSBmYWxzZSlcblx0XHRcdHRoaXMuc3RydWN0dXJlcyA9IFtdXG5cdFx0Ly8gdHdvIGJ5dGUgcmVjb3JkIGlkcyBmb3Igc2hhcmVkIHN0cnVjdHVyZXNcblx0XHRsZXQgdXNlVHdvQnl0ZVJlY29yZHMgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gMzIgfHwgKG1heE93blN0cnVjdHVyZXMgKyBtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gNjQpXG5cdFx0bGV0IHNoYXJlZExpbWl0SWQgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzICsgMHg0MFxuXHRcdGxldCBtYXhTdHJ1Y3R1cmVJZCA9IG1heFNoYXJlZFN0cnVjdHVyZXMgKyBtYXhPd25TdHJ1Y3R1cmVzICsgMHg0MFxuXHRcdGlmIChtYXhTdHJ1Y3R1cmVJZCA+IDgyNTYpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWF4aW11bSBtYXhTaGFyZWRTdHJ1Y3R1cmUgKyBtYXhPd25TdHJ1Y3R1cmUgaXMgODE5MicpXG5cdFx0fVxuXHRcdGxldCByZWNvcmRJZHNUb1JlbW92ZSA9IFtdXG5cdFx0bGV0IHRyYW5zaXRpb25zQ291bnQgPSAwXG5cdFx0bGV0IHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCA9IDBcblxuXHRcdHRoaXMucGFjayA9IHRoaXMuZW5jb2RlID0gZnVuY3Rpb24odmFsdWUsIGVuY29kZU9wdGlvbnMpIHtcblx0XHRcdGlmICghdGFyZ2V0KSB7XG5cdFx0XHRcdHRhcmdldCA9IG5ldyBCeXRlQXJyYXlBbGxvY2F0ZSg4MTkyKVxuXHRcdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3IHx8ICh0YXJnZXQuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGFyZ2V0LmJ1ZmZlciwgMCwgODE5MikpXG5cdFx0XHRcdHBvc2l0aW9uID0gMFxuXHRcdFx0fVxuXHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMFxuXHRcdFx0aWYgKHNhZmVFbmQgLSBwb3NpdGlvbiA8IDB4ODAwKSB7XG5cdFx0XHRcdC8vIGRvbid0IHN0YXJ0IHRvbyBjbG9zZSB0byB0aGUgZW5kLFxuXHRcdFx0XHR0YXJnZXQgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUodGFyZ2V0Lmxlbmd0aClcblx0XHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldyB8fCAodGFyZ2V0LmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRhcmdldC5idWZmZXIsIDAsIHRhcmdldC5sZW5ndGgpKVxuXHRcdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwXG5cdFx0XHRcdHBvc2l0aW9uID0gMFxuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdHBvc2l0aW9uID0gKHBvc2l0aW9uICsgNykgJiAweDdmZmZmZmY4IC8vIFdvcmQgYWxpZ24gdG8gbWFrZSBhbnkgZnV0dXJlIGNvcHlpbmcgb2YgdGhpcyBidWZmZXIgZmFzdGVyXG5cdFx0XHRzdGFydCA9IHBvc2l0aW9uXG5cdFx0XHRpZiAoZW5jb2RlT3B0aW9ucyAmIFJFU0VSVkVfU1RBUlRfU1BBQ0UpIHBvc2l0aW9uICs9IChlbmNvZGVPcHRpb25zICYgMHhmZilcblx0XHRcdHJlZmVyZW5jZU1hcCA9IHBhY2tyLnN0cnVjdHVyZWRDbG9uZSA/IG5ldyBNYXAoKSA6IG51bGxcblx0XHRcdGlmIChwYWNrci5idW5kbGVTdHJpbmdzICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBbXVxuXHRcdFx0XHRidW5kbGVkU3RyaW5ncy5zaXplID0gSW5maW5pdHkgLy8gZm9yY2UgYSBuZXcgYnVuZGxlIHN0YXJ0IG9uIGZpcnN0IHN0cmluZ1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdGJ1bmRsZWRTdHJpbmdzID0gbnVsbFxuXHRcdFx0c3RydWN0dXJlcyA9IHBhY2tyLnN0cnVjdHVyZXNcblx0XHRcdGlmIChzdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdGlmIChzdHJ1Y3R1cmVzLnVuaW5pdGlhbGl6ZWQpXG5cdFx0XHRcdFx0c3RydWN0dXJlcyA9IHBhY2tyLl9tZXJnZVN0cnVjdHVyZXMocGFja3IuZ2V0U3RydWN0dXJlcygpKVxuXHRcdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMFxuXHRcdFx0XHRpZiAoc2hhcmVkTGVuZ3RoID4gbWF4U2hhcmVkU3RydWN0dXJlcykge1xuXHRcdFx0XHRcdC8vaWYgKG1heFNoYXJlZFN0cnVjdHVyZXMgPD0gMzIgJiYgc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPiAzMikgLy8gVE9ETzogY291bGQgc3VwcG9ydCB0aGlzLCBidXQgd291bGQgbmVlZCB0byB1cGRhdGUgdGhlIGxpbWl0IGlkc1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignU2hhcmVkIHN0cnVjdHVyZXMgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaGFyZWQgc3RydWN0dXJlcywgdHJ5IGluY3JlYXNpbmcgbWF4U2hhcmVkU3RydWN0dXJlcyB0byAnICsgc3RydWN0dXJlcy5zaGFyZWRMZW5ndGgpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zKSB7XG5cdFx0XHRcdFx0Ly8gcmVidWlsZCBvdXIgc3RydWN0dXJlIHRyYW5zaXRpb25zXG5cdFx0XHRcdFx0c3RydWN0dXJlcy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbClcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNoYXJlZExlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRsZXQga2V5cyA9IHN0cnVjdHVyZXNbaV1cblx0XHRcdFx0XHRcdGlmICgha2V5cylcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdGxldCBuZXh0VHJhbnNpdGlvbiwgdHJhbnNpdGlvbiA9IHN0cnVjdHVyZXMudHJhbnNpdGlvbnNcblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBsID0ga2V5cy5sZW5ndGg7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0bGV0IGtleSA9IGtleXNbal1cblx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV1cblx0XHRcdFx0XHRcdFx0aWYgKCFuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IGkgKyAweDQwXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCA9IHNoYXJlZExlbmd0aFxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaXNTZXF1ZW50aWFsKSB7XG5cdFx0XHRcdFx0c3RydWN0dXJlcy5uZXh0SWQgPSBzaGFyZWRMZW5ndGggKyAweDQwXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNTaGFyZWRVcGRhdGUpXG5cdFx0XHRcdGhhc1NoYXJlZFVwZGF0ZSA9IGZhbHNlXG5cdFx0XHRsZXQgZW5jb2RpbmdFcnJvcjtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChwYWNrci5yYW5kb21BY2Nlc3NTdHJ1Y3R1cmUgJiYgdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdClcblx0XHRcdFx0XHR3cml0ZVN0cnVjdCh2YWx1ZSk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRwYWNrKHZhbHVlKVxuXHRcdFx0XHRsZXQgbGFzdEJ1bmRsZSA9IGJ1bmRsZWRTdHJpbmdzO1xuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MpXG5cdFx0XHRcdFx0d3JpdGVCdW5kbGVzKHN0YXJ0LCBwYWNrLCAwKVxuXHRcdFx0XHRpZiAocmVmZXJlbmNlTWFwICYmIHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydCkge1xuXHRcdFx0XHRcdGxldCBpZHNUb0luc2VydCA9IHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydC5zb3J0KChhLCBiKSA9PiBhLm9mZnNldCA+IGIub2Zmc2V0ID8gMSA6IC0xKTtcblx0XHRcdFx0XHRsZXQgaSA9IGlkc1RvSW5zZXJ0Lmxlbmd0aDtcblx0XHRcdFx0XHRsZXQgaW5jcmVtZW50UG9zaXRpb24gPSAtMTtcblx0XHRcdFx0XHR3aGlsZSAobGFzdEJ1bmRsZSAmJiBpID4gMCkge1xuXHRcdFx0XHRcdFx0bGV0IGluc2VydGlvblBvaW50ID0gaWRzVG9JbnNlcnRbLS1pXS5vZmZzZXQgKyBzdGFydDtcblx0XHRcdFx0XHRcdGlmIChpbnNlcnRpb25Qb2ludCA8IChsYXN0QnVuZGxlLnN0cmluZ3NQb3NpdGlvbiArIHN0YXJ0KSAmJiBpbmNyZW1lbnRQb3NpdGlvbiA9PT0gLTEpXG5cdFx0XHRcdFx0XHRcdGluY3JlbWVudFBvc2l0aW9uID0gMDtcblx0XHRcdFx0XHRcdGlmIChpbnNlcnRpb25Qb2ludCA+IChsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQpKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpbmNyZW1lbnRQb3NpdGlvbiA+PSAwKVxuXHRcdFx0XHRcdFx0XHRcdGluY3JlbWVudFBvc2l0aW9uICs9IDY7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5jcmVtZW50UG9zaXRpb24gPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHVwZGF0ZSB0aGUgYnVuZGxlIHJlZmVyZW5jZSBub3dcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQsXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LmdldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQpICsgaW5jcmVtZW50UG9zaXRpb24pXG5cdFx0XHRcdFx0XHRcdFx0aW5jcmVtZW50UG9zaXRpb24gPSAtMTsgLy8gcmVzZXRcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRsYXN0QnVuZGxlID0gbGFzdEJ1bmRsZS5wcmV2aW91cztcblx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaW5jcmVtZW50UG9zaXRpb24gPj0gMCAmJiBsYXN0QnVuZGxlKSB7XG5cdFx0XHRcdFx0XHQvLyB1cGRhdGUgdGhlIGJ1bmRsZSByZWZlcmVuY2Ugbm93XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQsXG5cdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuZ2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCkgKyBpbmNyZW1lbnRQb3NpdGlvbilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gaWRzVG9JbnNlcnQubGVuZ3RoICogNjtcblx0XHRcdFx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0bWFrZVJvb20ocG9zaXRpb24pXG5cdFx0XHRcdFx0cGFja3Iub2Zmc2V0ID0gcG9zaXRpb25cblx0XHRcdFx0XHRsZXQgc2VyaWFsaXplZCA9IGluc2VydElkcyh0YXJnZXQuc3ViYXJyYXkoc3RhcnQsIHBvc2l0aW9uKSwgaWRzVG9JbnNlcnQpXG5cdFx0XHRcdFx0cmVmZXJlbmNlTWFwID0gbnVsbFxuXHRcdFx0XHRcdHJldHVybiBzZXJpYWxpemVkXG5cdFx0XHRcdH1cblx0XHRcdFx0cGFja3Iub2Zmc2V0ID0gcG9zaXRpb24gLy8gdXBkYXRlIHRoZSBvZmZzZXQgc28gbmV4dCBzZXJpYWxpemF0aW9uIGRvZXNuJ3Qgd3JpdGUgb3ZlciBvdXIgYnVmZmVyLCBidXQgY2FuIGNvbnRpbnVlIHdyaXRpbmcgdG8gc2FtZSBidWZmZXIgc2VxdWVudGlhbGx5XG5cdFx0XHRcdGlmIChlbmNvZGVPcHRpb25zICYgUkVVU0VfQlVGRkVSX01PREUpIHtcblx0XHRcdFx0XHR0YXJnZXQuc3RhcnQgPSBzdGFydFxuXHRcdFx0XHRcdHRhcmdldC5lbmQgPSBwb3NpdGlvblxuXHRcdFx0XHRcdHJldHVybiB0YXJnZXRcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LnN1YmFycmF5KHN0YXJ0LCBwb3NpdGlvbikgLy8gcG9zaXRpb24gY2FuIGNoYW5nZSBpZiB3ZSBjYWxsIHBhY2sgYWdhaW4gaW4gc2F2ZVN0cnVjdHVyZXMsIHNvIHdlIGdldCB0aGUgYnVmZmVyIG5vd1xuXHRcdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0XHRlbmNvZGluZ0Vycm9yID0gZXJyb3I7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKHN0cnVjdHVyZXMpIHtcblx0XHRcdFx0XHRyZXNldFN0cnVjdHVyZXMoKTtcblx0XHRcdFx0XHRpZiAoaGFzU2hhcmVkVXBkYXRlICYmIHBhY2tyLnNhdmVTdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMFxuXHRcdFx0XHRcdFx0Ly8gd2UgY2FuJ3QgcmVseSBvbiBzdGFydC9lbmQgd2l0aCBSRVVTRV9CVUZGRVJfTU9ERSBzaW5jZSB0aGV5IHdpbGwgKHByb2JhYmx5KSBjaGFuZ2Ugd2hlbiB3ZSBzYXZlXG5cdFx0XHRcdFx0XHRsZXQgcmV0dXJuQnVmZmVyID0gdGFyZ2V0LnN1YmFycmF5KHN0YXJ0LCBwb3NpdGlvbilcblx0XHRcdFx0XHRcdGxldCBuZXdTaGFyZWREYXRhID0gcHJlcGFyZVN0cnVjdHVyZXMoc3RydWN0dXJlcywgcGFja3IpO1xuXHRcdFx0XHRcdFx0aWYgKCFlbmNvZGluZ0Vycm9yKSB7IC8vIFRPRE86IElmIHRoZXJlIGlzIGFuIGVuY29kaW5nIGVycm9yLCBzaG91bGQgbWFrZSB0aGUgc3RydWN0dXJlcyBhcyB1bmluaXRpYWxpemVkIHNvIHRoZXkgZ2V0IHJlYnVpbHQgbmV4dCB0aW1lXG5cdFx0XHRcdFx0XHRcdGlmIChwYWNrci5zYXZlU3RydWN0dXJlcyhuZXdTaGFyZWREYXRhLCBuZXdTaGFyZWREYXRhLmlzQ29tcGF0aWJsZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZ2V0IHVwZGF0ZWQgc3RydWN0dXJlcyBhbmQgdHJ5IGFnYWluIGlmIHRoZSB1cGRhdGUgZmFpbGVkXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhY2tyLnBhY2sodmFsdWUsIGVuY29kZU9wdGlvbnMpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cGFja3IubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCA9IHNoYXJlZExlbmd0aFxuXHRcdFx0XHRcdFx0XHQvLyBkb24ndCBrZWVwIGxhcmdlIGJ1ZmZlcnMgYXJvdW5kXG5cdFx0XHRcdFx0XHRcdGlmICh0YXJnZXQubGVuZ3RoID4gMHg0MDAwMDAwMCkgdGFyZ2V0ID0gbnVsbFxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuQnVmZmVyXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGRvbid0IGtlZXAgbGFyZ2UgYnVmZmVycyBhcm91bmQsIHRoZXkgdGFrZSB0b28gbXVjaCBtZW1vcnkgYW5kIGNhdXNlIHByb2JsZW1zIChsaW1pdCBhdCAxR0IpXG5cdFx0XHRcdGlmICh0YXJnZXQubGVuZ3RoID4gMHg0MDAwMDAwMCkgdGFyZ2V0ID0gbnVsbFxuXHRcdFx0XHRpZiAoZW5jb2RlT3B0aW9ucyAmIFJFU0VUX0JVRkZFUl9NT0RFKVxuXHRcdFx0XHRcdHBvc2l0aW9uID0gc3RhcnRcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgcmVzZXRTdHJ1Y3R1cmVzID0gKCkgPT4ge1xuXHRcdFx0aWYgKHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCA8IDEwKVxuXHRcdFx0XHRzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQrK1xuXHRcdFx0bGV0IHNoYXJlZExlbmd0aCA9IHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoIHx8IDBcblx0XHRcdGlmIChzdHJ1Y3R1cmVzLmxlbmd0aCA+IHNoYXJlZExlbmd0aCAmJiAhaXNTZXF1ZW50aWFsKVxuXHRcdFx0XHRzdHJ1Y3R1cmVzLmxlbmd0aCA9IHNoYXJlZExlbmd0aFxuXHRcdFx0aWYgKHRyYW5zaXRpb25zQ291bnQgPiAxMDAwMCkge1xuXHRcdFx0XHQvLyBmb3JjZSBhIHJlYnVpbGQgb2NjYXNpb25hbGx5IGFmdGVyIGEgbG90IG9mIHRyYW5zaXRpb25zIHNvIGl0IGNhbiBnZXQgY2xlYW5lZCB1cFxuXHRcdFx0XHRzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gbnVsbFxuXHRcdFx0XHRzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgPSAwXG5cdFx0XHRcdHRyYW5zaXRpb25zQ291bnQgPSAwXG5cdFx0XHRcdGlmIChyZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlID0gW11cblx0XHRcdH0gZWxzZSBpZiAocmVjb3JkSWRzVG9SZW1vdmUubGVuZ3RoID4gMCAmJiAhaXNTZXF1ZW50aWFsKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcmVjb3JkSWRzVG9SZW1vdmUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmVbaV1bUkVDT1JEX1NZTUJPTF0gPSAwXG5cdFx0XHRcdH1cblx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmUgPSBbXVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBwYWNrQXJyYXkgPSAodmFsdWUpID0+IHtcblx0XHRcdHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGhcblx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4OTAgfCBsZW5ndGhcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRjXG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmZcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGRcblx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aClcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0fVxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRwYWNrKHZhbHVlW2ldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBwYWNrID0gKHZhbHVlKSA9PiB7XG5cdFx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbilcblxuXHRcdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWVcblx0XHRcdHZhciBsZW5ndGhcblx0XHRcdGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRsZXQgc3RyTGVuZ3RoID0gdmFsdWUubGVuZ3RoXG5cdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncyAmJiBzdHJMZW5ndGggPj0gNCAmJiBzdHJMZW5ndGggPCAweDEwMDApIHtcblx0XHRcdFx0XHRpZiAoKGJ1bmRsZWRTdHJpbmdzLnNpemUgKz0gc3RyTGVuZ3RoKSA+IE1BWF9CVU5ETEVfU0laRSkge1xuXHRcdFx0XHRcdFx0bGV0IGV4dFN0YXJ0XG5cdFx0XHRcdFx0XHRsZXQgbWF4Qnl0ZXMgPSAoYnVuZGxlZFN0cmluZ3NbMF0gPyBidW5kbGVkU3RyaW5nc1swXS5sZW5ndGggKiAzICsgYnVuZGxlZFN0cmluZ3NbMV0ubGVuZ3RoIDogMCkgKyAxMFxuXHRcdFx0XHRcdFx0aWYgKHBvc2l0aW9uICsgbWF4Qnl0ZXMgPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbiArIG1heEJ5dGVzKVxuXHRcdFx0XHRcdFx0bGV0IGxhc3RCdW5kbGVcblx0XHRcdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncy5wb3NpdGlvbikgeyAvLyBoZXJlIHdlIHVzZSB0aGUgMHg2MiBleHRlbnNpb24gdG8gd3JpdGUgdGhlIGxhc3QgYnVuZGxlIGFuZCByZXNlcnZlIHNwYWNlIGZvciB0aGUgcmVmZXJlbmNlIHBvaW50ZXIgdG8gdGhlIG5leHQvY3VycmVudCBidW5kbGVcblx0XHRcdFx0XHRcdFx0bGFzdEJ1bmRsZSA9IGJ1bmRsZWRTdHJpbmdzXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbl0gPSAweGM4IC8vIGV4dCAxNlxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSAzIC8vIHJlc2VydmUgZm9yIHRoZSB3cml0aW5nIGJ1bmRsZSBzaXplXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NjIgLy8gJ2InXG5cdFx0XHRcdFx0XHRcdGV4dFN0YXJ0ID0gcG9zaXRpb24gLSBzdGFydFxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0IC8vIHJlc2VydmUgZm9yIHdyaXRpbmcgYnVuZGxlIHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0XHR3cml0ZUJ1bmRsZXMoc3RhcnQsIHBhY2ssIDApIC8vIHdyaXRlIHRoZSBsYXN0IGJ1bmRsZXNcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYoZXh0U3RhcnQgKyBzdGFydCAtIDMsIHBvc2l0aW9uIC0gc3RhcnQgLSBleHRTdGFydClcblx0XHRcdFx0XHRcdH0gZWxzZSB7IC8vIGhlcmUgd2UgdXNlIHRoZSAweDYyIGV4dGVuc2lvbiBqdXN0IHRvIHJlc2VydmUgdGhlIHNwYWNlIGZvciB0aGUgcmVmZXJlbmNlIHBvaW50ZXIgdG8gdGhlIGJ1bmRsZSAod2lsbCBiZSB1cGRhdGVkIG9uY2UgdGhlIGJ1bmRsZSBpcyB3cml0dGVuKVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2IC8vIGZpeGV4dCA0XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NjIgLy8gJ2InXG5cdFx0XHRcdFx0XHRcdGV4dFN0YXJ0ID0gcG9zaXRpb24gLSBzdGFydFxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0IC8vIHJlc2VydmUgZm9yIHdyaXRpbmcgYnVuZGxlIHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBbJycsICcnXSAvLyBjcmVhdGUgbmV3IG9uZXNcblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnByZXZpb3VzID0gbGFzdEJ1bmRsZTtcblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnNpemUgPSAwXG5cdFx0XHRcdFx0XHRidW5kbGVkU3RyaW5ncy5wb3NpdGlvbiA9IGV4dFN0YXJ0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxldCB0d29CeXRlID0gaGFzTm9uTGF0aW4udGVzdCh2YWx1ZSlcblx0XHRcdFx0XHRidW5kbGVkU3RyaW5nc1t0d29CeXRlID8gMCA6IDFdICs9IHZhbHVlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjMVxuXHRcdFx0XHRcdHBhY2sodHdvQnl0ZSA/IC1zdHJMZW5ndGggOiBzdHJMZW5ndGgpO1xuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBoZWFkZXJTaXplXG5cdFx0XHRcdC8vIGZpcnN0IHdlIGVzdGltYXRlIHRoZSBoZWFkZXIgc2l6ZSwgc28gd2UgY2FuIHdyaXRlIHRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uXG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPCAweDIwKSB7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IDFcblx0XHRcdFx0fSBlbHNlIGlmIChzdHJMZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSAyXG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RyTGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSAzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IDVcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgbWF4Qnl0ZXMgPSBzdHJMZW5ndGggKiAzXG5cdFx0XHRcdGlmIChwb3NpdGlvbiArIG1heEJ5dGVzID4gc2FmZUVuZClcblx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbiArIG1heEJ5dGVzKVxuXG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPCAweDQwIHx8ICFlbmNvZGVVdGY4KSB7XG5cdFx0XHRcdFx0bGV0IGksIGMxLCBjMiwgc3RyUG9zaXRpb24gPSBwb3NpdGlvbiArIGhlYWRlclNpemVcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGMxID0gdmFsdWUuY2hhckNvZGVBdChpKVxuXHRcdFx0XHRcdFx0aWYgKGMxIDwgMHg4MCkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjMSA8IDB4ODAwKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDYgfCAweGMwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0XHRcdChjMSAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxuXHRcdFx0XHRcdFx0XHQoKGMyID0gdmFsdWUuY2hhckNvZGVBdChpICsgMSkpICYgMHhmYzAwKSA9PT0gMHhkYzAwXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0YzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKVxuXHRcdFx0XHRcdFx0XHRpKytcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gMTggfCAweGYwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDEyICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gNiAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDEyIHwgMHhlMFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZW5ndGggPSBzdHJQb3NpdGlvbiAtIHBvc2l0aW9uIC0gaGVhZGVyU2l6ZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxlbmd0aCA9IGVuY29kZVV0ZjgodmFsdWUsIHBvc2l0aW9uICsgaGVhZGVyU2l6ZSlcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChsZW5ndGggPCAweDIwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhhMCB8IGxlbmd0aFxuXHRcdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdFx0aWYgKGhlYWRlclNpemUgPCAyKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihwb3NpdGlvbiArIDIsIHBvc2l0aW9uICsgMSwgcG9zaXRpb24gKyAxICsgbGVuZ3RoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ5XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoXG5cdFx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJTaXplIDwgMykge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24gKyAzLCBwb3NpdGlvbiArIDIsIHBvc2l0aW9uICsgMiArIGxlbmd0aClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkYVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJTaXplIDwgNSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24gKyA1LCBwb3NpdGlvbiArIDMsIHBvc2l0aW9uICsgMyArIGxlbmd0aClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkYlxuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpXG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHR9XG5cdFx0XHRcdHBvc2l0aW9uICs9IGxlbmd0aFxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRpZiAodmFsdWUgPj4+IDAgPT09IHZhbHVlKSB7Ly8gcG9zaXRpdmUgaW50ZWdlciwgMzItYml0IG9yIGxlc3Ncblx0XHRcdFx0XHQvLyBwb3NpdGl2ZSB1aW50XG5cdFx0XHRcdFx0aWYgKHZhbHVlIDwgMHgyMCB8fCAodmFsdWUgPCAweDgwICYmIHRoaXMudXNlUmVjb3JkcyA9PT0gZmFsc2UpIHx8ICh2YWx1ZSA8IDB4NDAgJiYgIXRoaXMucmFuZG9tQWNjZXNzU3RydWN0dXJlKSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWVcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgMHgxMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Ncblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Rcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlID4+IDhcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlICYgMHhmZlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNlXG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID4+IDAgPT09IHZhbHVlKSB7IC8vIG5lZ2F0aXZlIGludGVnZXJcblx0XHRcdFx0XHRpZiAodmFsdWUgPj0gLTB4MjApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4MTAwICsgdmFsdWVcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID49IC0weDgwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQwXG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSArIDB4MTAwXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+PSAtMHg4MDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQxXG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEludDE2KHBvc2l0aW9uLCB2YWx1ZSlcblx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkMlxuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRJbnQzMihwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCB1c2VGbG9hdDMyXG5cdFx0XHRcdFx0aWYgKCh1c2VGbG9hdDMyID0gdGhpcy51c2VGbG9hdDMyKSA+IDAgJiYgdmFsdWUgPCAweDEwMDAwMDAwMCAmJiB2YWx1ZSA+PSAtMHg4MDAwMDAwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjYVxuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDMyKHBvc2l0aW9uLCB2YWx1ZSlcblx0XHRcdFx0XHRcdGxldCB4U2hpZnRlZFxuXHRcdFx0XHRcdFx0aWYgKHVzZUZsb2F0MzIgPCA0IHx8XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBjaGVja3MgZm9yIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdFx0XHRcdCgoeFNoaWZ0ZWQgPSB2YWx1ZSAqIG11bHQxMFsoKHRhcmdldFtwb3NpdGlvbl0gJiAweDdmKSA8PCAxKSB8ICh0YXJnZXRbcG9zaXRpb24gKyAxXSA+PiA3KV0pID4+IDApID09PSB4U2hpZnRlZCkge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uLS0gLy8gbW92ZSBiYWNrIGludG8gcG9zaXRpb24gZm9yIHdyaXRpbmcgYSBkb3VibGVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjYlxuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgdmFsdWUpXG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gOFxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aWYgKCF2YWx1ZSlcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGMwXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmIChyZWZlcmVuY2VNYXApIHtcblx0XHRcdFx0XHRcdGxldCByZWZlcmVlID0gcmVmZXJlbmNlTWFwLmdldCh2YWx1ZSlcblx0XHRcdFx0XHRcdGlmIChyZWZlcmVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghcmVmZXJlZS5pZCkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBpZHNUb0luc2VydCA9IHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydCB8fCAocmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0ID0gW10pXG5cdFx0XHRcdFx0XHRcdFx0cmVmZXJlZS5pZCA9IGlkc1RvSW5zZXJ0LnB1c2gocmVmZXJlZSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2IC8vIGZpeGV4dCA0XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzAgLy8gXCJwXCIgZm9yIHBvaW50ZXJcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIHJlZmVyZWUuaWQpXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0cmVmZXJlbmNlTWFwLnNldCh2YWx1ZSwgeyBvZmZzZXQ6IHBvc2l0aW9uIC0gc3RhcnQgfSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGV0IGNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3Jcblx0XHRcdFx0XHRpZiAoY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuXHRcdFx0XHRcdFx0d3JpdGVPYmplY3QodmFsdWUpXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcblx0XHRcdFx0XHRcdHBhY2tBcnJheSh2YWx1ZSlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNvbnN0cnVjdG9yID09PSBNYXApIHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLm1hcEFzRW1wdHlPYmplY3QpIHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ODBcblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsZW5ndGggPSB2YWx1ZS5zaXplXG5cdFx0XHRcdFx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg4MCB8IGxlbmd0aFxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRlXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDhcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZlxuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpXG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IFtrZXksIGVudHJ5VmFsdWVdIG9mIHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGFjayhrZXkpXG5cdFx0XHRcdFx0XHRcdFx0cGFjayhlbnRyeVZhbHVlKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gZXh0ZW5zaW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0bGV0IGV4dGVuc2lvbkNsYXNzID0gZXh0ZW5zaW9uQ2xhc3Nlc1tpXVxuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBleHRlbnNpb25DbGFzcykge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBleHRlbnNpb24gPSBleHRlbnNpb25zW2ldXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGV4dGVuc2lvbi53cml0ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGV4dGVuc2lvbi50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQgLy8gb25lIGJ5dGUgXCJ0YWdcIiBleHRlbnNpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gZXh0ZW5zaW9uLnR5cGVcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IHdyaXRlUmVzdWx0ID0gZXh0ZW5zaW9uLndyaXRlLmNhbGwodGhpcywgdmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAod3JpdGVSZXN1bHQgPT09IHZhbHVlKSB7IC8vIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYWNrQXJyYXkodmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVPYmplY3QodmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhY2sod3JpdGVSZXN1bHQpXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRUYXJnZXQgPSB0YXJnZXRcblx0XHRcdFx0XHRcdFx0XHRsZXQgY3VycmVudFRhcmdldFZpZXcgPSB0YXJnZXRWaWV3XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbnVsbFxuXHRcdFx0XHRcdFx0XHRcdGxldCByZXN1bHRcblx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gZXh0ZW5zaW9uLnBhY2suY2FsbCh0aGlzLCB2YWx1ZSwgKHNpemUpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVzdG9yZSB0YXJnZXQgYW5kIHVzZSBpdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBjdXJyZW50VGFyZ2V0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUYXJnZXQgPSBudWxsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IHNpemVcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHBvc2l0aW9uID4gc2FmZUVuZClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYWtlUm9vbShwb3NpdGlvbilcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9uOiBwb3NpdGlvbiAtIHNpemVcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSwgcGFjaylcblx0XHRcdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVzdG9yZSBjdXJyZW50IHRhcmdldCBpbmZvcm1hdGlvbiAodW5sZXNzIGFscmVhZHkgcmVzdG9yZWQpXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoY3VycmVudFRhcmdldCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBjdXJyZW50VGFyZ2V0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcgPSBjdXJyZW50VGFyZ2V0Vmlld1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChyZXN1bHQubGVuZ3RoICsgcG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRtYWtlUm9vbShyZXN1bHQubGVuZ3RoICsgcG9zaXRpb24pXG5cdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiA9IHdyaXRlRXh0ZW5zaW9uRGF0YShyZXN1bHQsIHRhcmdldCwgcG9zaXRpb24sIGV4dGVuc2lvbi50eXBlKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgaXNBcnJheSBhZnRlciBleHRlbnNpb25zLCBiZWNhdXNlIGV4dGVuc2lvbnMgY2FuIGV4dGVuZCBBcnJheVxuXHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdHBhY2tBcnJheSh2YWx1ZSlcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVzZSB0aGlzIGFzIGFuIGFsdGVybmF0ZSBtZWNoYW5pc20gZm9yIGV4cHJlc3NpbmcgaG93IHRvIHNlcmlhbGl6ZVxuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUudG9KU09OKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QganNvbiA9IHZhbHVlLnRvSlNPTigpXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgZm9yIHNvbWUgcmVhc29uIHZhbHVlLnRvSlNPTiByZXR1cm5zIGl0c2VsZiBpdCdsbCBsb29wIGZvcmV2ZXJcblx0XHRcdFx0XHRcdFx0XHRpZiAoanNvbiAhPT0gdmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFjayhqc29uKVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSB3cml0ZUZ1bmN0aW9uLCB1c2UgaXQsIG90aGVyd2lzZSBqdXN0IGVuY29kZSBhcyB1bmRlZmluZWRcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdmdW5jdGlvbicpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhY2sodGhpcy53cml0ZUZ1bmN0aW9uICYmIHRoaXMud3JpdGVGdW5jdGlvbih2YWx1ZSkpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIG5vIGV4dGVuc2lvbiBmb3VuZCwgd3JpdGUgYXMgcGxhaW4gb2JqZWN0XG5cdFx0XHRcdFx0XHRcdHdyaXRlT2JqZWN0KHZhbHVlKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWUgPyAweGMzIDogMHhjMlxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnYmlnaW50Jykge1xuXHRcdFx0XHRpZiAodmFsdWUgPCAweDgwMDAwMDAwMDAwMDAwMDAgJiYgdmFsdWUgPj0gLTB4ODAwMDAwMDAwMDAwMDAwMCkge1xuXHRcdFx0XHRcdC8vIHVzZSBhIHNpZ25lZCBpbnQgYXMgbG9uZyBhcyBpdCBmaXRzXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkM1xuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0QmlnSW50NjQocG9zaXRpb24sIHZhbHVlKVxuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgMHgxMDAwMDAwMDAwMDAwMDAwMCAmJiB2YWx1ZSA+IDApIHtcblx0XHRcdFx0XHQvLyBpZiB3ZSBjYW4gZml0IGFuIHVuc2lnbmVkIGludCwgdXNlIHRoYXRcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNmXG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRCaWdVaW50NjQocG9zaXRpb24sIHZhbHVlKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG92ZXJmbG93XG5cdFx0XHRcdFx0aWYgKHRoaXMubGFyZ2VCaWdJbnRUb0Zsb2F0KSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNiXG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIE51bWJlcih2YWx1ZSkpXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmxhcmdlQmlnSW50VG9TdHJpbmcpIHtcblx0XHRcdFx0XHRcdHJldHVybiBwYWNrKHZhbHVlLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy51c2VCaWdJbnRFeHRlbnNpb24gfHwgdGhpcy5tb3JlVHlwZXMpIHtcblx0XHRcdFx0XHRcdGxldCBlbXB0eSA9IHZhbHVlIDwgMCA/IEJpZ0ludCgtMSkgOiBCaWdJbnQoMClcblxuXHRcdFx0XHRcdFx0bGV0IGFycmF5XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgPj4gQmlnSW50KDB4MTAwMDApID09PSBlbXB0eSkge1xuXHRcdFx0XHRcdFx0XHRsZXQgbWFzayA9IEJpZ0ludCgweDEwMDAwMDAwMDAwMDAwMDAwKSAtIEJpZ0ludCgxKSAvLyBsaXRlcmFsIHdvdWxkIG92ZXJmbG93XG5cdFx0XHRcdFx0XHRcdGxldCBjaHVua3MgPSBbXVxuXHRcdFx0XHRcdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNodW5rcy5wdXNoKHZhbHVlICYgbWFzaylcblx0XHRcdFx0XHRcdFx0XHRpZiAoKHZhbHVlID4+IEJpZ0ludCg2MykpID09PSBlbXB0eSkgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA+Pj0gQmlnSW50KDY0KVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YXJyYXkgPSBuZXcgVWludDhBcnJheShuZXcgQmlnVWludDY0QXJyYXkoY2h1bmtzKS5idWZmZXIpXG5cdFx0XHRcdFx0XHRcdGFycmF5LnJldmVyc2UoKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGV0IGludmVydCA9IHZhbHVlIDwgMFxuXHRcdFx0XHRcdFx0XHRsZXQgc3RyaW5nID0gKGludmVydCA/IH52YWx1ZSA6IHZhbHVlKS50b1N0cmluZygxNilcblx0XHRcdFx0XHRcdFx0aWYgKHN0cmluZy5sZW5ndGggJSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyaW5nID0gJzAnICsgc3RyaW5nXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocGFyc2VJbnQoc3RyaW5nLmNoYXJBdCgwKSwgMTYpID49IDgpIHtcblx0XHRcdFx0XHRcdFx0XHRzdHJpbmcgPSAnMDAnICsgc3RyaW5nXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoaGFzTm9kZUJ1ZmZlcikge1xuXHRcdFx0XHRcdFx0XHRcdGFycmF5ID0gQnVmZmVyLmZyb20oc3RyaW5nLCAnaGV4Jylcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRhcnJheSA9IG5ldyBVaW50OEFycmF5KHN0cmluZy5sZW5ndGggLyAyKVxuXHRcdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdGFycmF5W2ldID0gcGFyc2VJbnQoc3RyaW5nLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNilcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoaW52ZXJ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgYXJyYXlbaV0gPSB+YXJyYXlbaV1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoYXJyYXkubGVuZ3RoICsgcG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHRtYWtlUm9vbShhcnJheS5sZW5ndGggKyBwb3NpdGlvbilcblx0XHRcdFx0XHRcdHBvc2l0aW9uID0gd3JpdGVFeHRlbnNpb25EYXRhKGFycmF5LCB0YXJnZXQsIHBvc2l0aW9uLCAweDQyKVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKHZhbHVlICsgJyB3YXMgdG9vIGxhcmdlIHRvIGZpdCBpbiBNZXNzYWdlUGFjayA2NC1iaXQgaW50ZWdlciBmb3JtYXQsIHVzZScgK1xuXHRcdFx0XHRcdFx0XHQnIHVzZUJpZ0ludEV4dGVuc2lvbiwgb3Igc2V0IGxhcmdlQmlnSW50VG9GbG9hdCB0byBjb252ZXJ0IHRvIGZsb2F0LTY0LCBvciBzZXQnICtcblx0XHRcdFx0XHRcdFx0JyBsYXJnZUJpZ0ludFRvU3RyaW5nIHRvIGNvbnZlcnQgdG8gc3RyaW5nJylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zaXRpb24gKz0gOFxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRpZiAodGhpcy5lbmNvZGVVbmRlZmluZWRBc05pbClcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGMwXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQgLy8gYSBudW1iZXIgb2YgaW1wbGVtZW50YXRpb25zIHVzZSBmaXhleHQxIHdpdGggdHlwZSAwLCBkYXRhIDAgdG8gZGVub3RlIHVuZGVmaW5lZCwgc28gd2UgZm9sbG93IHN1aXRlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyB0eXBlKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IHdyaXRlUGxhaW5PYmplY3QgPSAodGhpcy52YXJpYWJsZU1hcFNpemUgfHwgdGhpcy5jb2VyY2libGVLZXlBc051bWJlciB8fCB0aGlzLnNraXBWYWx1ZXMpID8gKG9iamVjdCkgPT4ge1xuXHRcdFx0Ly8gdGhpcyBtZXRob2QgaXMgc2xpZ2h0bHkgc2xvd2VyLCBidXQgZ2VuZXJhdGVzIFwicHJlZmVycmVkIHNlcmlhbGl6YXRpb25cIiAob3B0aW1hbGx5IHNtYWxsIGZvciBzbWFsbGVyIG9iamVjdHMpXG5cdFx0XHRsZXQga2V5cztcblx0XHRcdGlmICh0aGlzLnNraXBWYWx1ZXMpIHtcblx0XHRcdFx0a2V5cyA9IFtdO1xuXHRcdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdFx0aWYgKCh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSAmJlxuXHRcdFx0XHRcdFx0IXRoaXMuc2tpcFZhbHVlcy5pbmNsdWRlcyhvYmplY3Rba2V5XSkpXG5cdFx0XHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdClcblx0XHRcdH1cblx0XHRcdGxldCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg4MCB8IGxlbmd0aFxuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGVcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDhcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZlxuXHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHR9XG5cdFx0XHRsZXQga2V5XG5cdFx0XHRpZiAodGhpcy5jb2VyY2libGVLZXlBc051bWJlcikge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0a2V5ID0ga2V5c1tpXVxuXHRcdFx0XHRcdGxldCBudW0gPSBOdW1iZXIoa2V5KVxuXHRcdFx0XHRcdHBhY2soaXNOYU4obnVtKSA/IGtleSA6IG51bSlcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwYWNrKGtleSA9IGtleXNbaV0pXG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXHRcdChvYmplY3QpID0+IHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGUgLy8gYWx3YXlzIHVzaW5nIG1hcCAxNiwgc28gd2UgY2FuIHByZWFsbG9jYXRlIGFuZCBzZXQgdGhlIGxlbmd0aCBhZnRlcndhcmRzXG5cdFx0XHRsZXQgb2JqZWN0T2Zmc2V0ID0gcG9zaXRpb24gLSBzdGFydFxuXHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0bGV0IHNpemUgPSAwXG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0cGFjayhrZXkpXG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSlcblx0XHRcdFx0XHRzaXplKytcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHNpemUgPiAweGZmZmYpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPYmplY3QgaXMgdG9vIGxhcmdlIHRvIHNlcmlhbGl6ZSB3aXRoIGZhc3QgMTYtYml0IG1hcCBzaXplLCcgK1xuXHRcdFx0XHQnIHVzZSB0aGUgXCJ2YXJpYWJsZU1hcFNpemVcIiBvcHRpb24gdG8gc2VyaWFsaXplIHRoaXMgb2JqZWN0Jyk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0KysgKyBzdGFydF0gPSBzaXplID4+IDhcblx0XHRcdHRhcmdldFtvYmplY3RPZmZzZXQgKyBzdGFydF0gPSBzaXplICYgMHhmZlxuXHRcdH1cblxuXHRcdGNvbnN0IHdyaXRlUmVjb3JkID0gdGhpcy51c2VSZWNvcmRzID09PSBmYWxzZSA/IHdyaXRlUGxhaW5PYmplY3QgOlxuXHRcdChvcHRpb25zLnByb2dyZXNzaXZlUmVjb3JkcyAmJiAhdXNlVHdvQnl0ZVJlY29yZHMpID8gIC8vIHRoaXMgaXMgYWJvdXQgMiUgZmFzdGVyIGZvciBoaWdobHkgc3RhYmxlIHN0cnVjdHVyZXMsIHNpbmNlIGl0IG9ubHkgcmVxdWlyZXMgb25lIGZvci1pbiBsb29wIChidXQgbXVjaCBtb3JlIGV4cGVuc2l2ZSB3aGVuIG5ldyBzdHJ1Y3R1cmUgbmVlZHMgdG8gYmUgd3JpdHRlbilcblx0XHQob2JqZWN0KSA9PiB7XG5cdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zIHx8IChzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSlcblx0XHRcdGxldCBvYmplY3RPZmZzZXQgPSBwb3NpdGlvbisrIC0gc3RhcnRcblx0XHRcdGxldCB3cm90ZUtleXNcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbilcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gcmVjb3JkIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBmdWxsIG5ldyByZWNvcmQgYW5kIGluc2VydCBpdFxuXHRcdFx0XHRcdFx0bGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpXG5cdFx0XHRcdFx0XHRsZXQgbGFzdFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9uc1xuXHRcdFx0XHRcdFx0bGV0IG5ld1RyYW5zaXRpb25zID0gMFxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRsZXQga2V5ID0ga2V5c1tpXVxuXHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNpdGlvbnMrK1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG9iamVjdE9mZnNldCArIHN0YXJ0ICsgMSA9PSBwb3NpdGlvbikge1xuXHRcdFx0XHRcdFx0XHQvLyBmaXJzdCBrZXksIHNvIHdlIGRvbid0IG5lZWQgdG8gaW5zZXJ0LCB3ZSBjYW4ganVzdCB3cml0ZSByZWNvcmQgZGlyZWN0bHlcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24tLVxuXHRcdFx0XHRcdFx0XHRuZXdSZWNvcmQodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRcdFx0XHR9IGVsc2UgLy8gb3RoZXJ3aXNlIHdlIG5lZWQgdG8gaW5zZXJ0IHRoZSByZWNvcmQsIG1vdmluZyBleGlzdGluZyBkYXRhIGFmdGVyIHRoZSByZWNvcmRcblx0XHRcdFx0XHRcdFx0aW5zZXJ0TmV3UmVjb3JkKHRyYW5zaXRpb24sIGtleXMsIG9iamVjdE9mZnNldCwgbmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRcdFx0XHR3cm90ZUtleXMgPSB0cnVlXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbGFzdFRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXdyb3RlS2V5cykge1xuXHRcdFx0XHRsZXQgcmVjb3JkSWQgPSB0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdXG5cdFx0XHRcdGlmIChyZWNvcmRJZClcblx0XHRcdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0ICsgc3RhcnRdID0gcmVjb3JkSWRcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGluc2VydE5ld1JlY29yZCh0cmFuc2l0aW9uLCBPYmplY3Qua2V5cyhvYmplY3QpLCBvYmplY3RPZmZzZXQsIDApXG5cdFx0XHR9XG5cdFx0fSA6XG5cdFx0KG9iamVjdCkgPT4ge1xuXHRcdFx0bGV0IG5leHRUcmFuc2l0aW9uLCB0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9ucyB8fCAoc3RydWN0dXJlcy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpXG5cdFx0XHRsZXQgbmV3VHJhbnNpdGlvbnMgPSAwXG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSBpZiAodHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XVxuXHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0XHRcdFx0bmV3VHJhbnNpdGlvbnMrK1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvblxuXHRcdFx0fVxuXHRcdFx0bGV0IHJlY29yZElkID0gdHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXVxuXHRcdFx0aWYgKHJlY29yZElkKSB7XG5cdFx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDYwICYmIHVzZVR3b0J5dGVSZWNvcmRzKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKChyZWNvcmRJZCAtPSAweDYwKSAmIDB4MWYpICsgMHg2MFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlY29yZElkID4+IDVcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVjb3JkSWRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1JlY29yZCh0cmFuc2l0aW9uLCB0cmFuc2l0aW9uLl9fa2V5c19fIHx8IE9iamVjdC5rZXlzKG9iamVjdCksIG5ld1RyYW5zaXRpb25zKVxuXHRcdFx0fVxuXHRcdFx0Ly8gbm93IHdyaXRlIHRoZSB2YWx1ZXNcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpXG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSlcblx0XHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSByZWZlcmVuY2UgdG8gdXNlUmVjb3JkcyBpZiB1c2VSZWNvcmRzIGlzIGEgZnVuY3Rpb25cblx0XHRjb25zdCBjaGVja1VzZVJlY29yZHMgPSB0eXBlb2YgdGhpcy51c2VSZWNvcmRzID09ICdmdW5jdGlvbicgJiYgdGhpcy51c2VSZWNvcmRzO1xuXG5cdFx0Y29uc3Qgd3JpdGVPYmplY3QgPSBjaGVja1VzZVJlY29yZHMgPyAob2JqZWN0KSA9PiB7XG5cdFx0XHRjaGVja1VzZVJlY29yZHMob2JqZWN0KSA/IHdyaXRlUmVjb3JkKG9iamVjdCkgOiB3cml0ZVBsYWluT2JqZWN0KG9iamVjdClcblx0XHR9IDogd3JpdGVSZWNvcmRcblxuXHRcdGNvbnN0IG1ha2VSb29tID0gKGVuZCkgPT4ge1xuXHRcdFx0bGV0IG5ld1NpemVcblx0XHRcdGlmIChlbmQgPiAweDEwMDAwMDApIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBoYW5kbGluZyBmb3IgcmVhbGx5IGxhcmdlIGJ1ZmZlcnNcblx0XHRcdFx0aWYgKChlbmQgLSBzdGFydCkgPiBNQVhfQlVGRkVSX1NJWkUpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgYnVmZmVyIHdvdWxkIGJlIGxhcmdlciB0aGFuIG1heGltdW0gYnVmZmVyIHNpemUnKVxuXHRcdFx0XHRuZXdTaXplID0gTWF0aC5taW4oTUFYX0JVRkZFUl9TSVpFLFxuXHRcdFx0XHRcdE1hdGgucm91bmQoTWF0aC5tYXgoKGVuZCAtIHN0YXJ0KSAqIChlbmQgPiAweDQwMDAwMDAgPyAxLjI1IDogMiksIDB4NDAwMDAwKSAvIDB4MTAwMCkgKiAweDEwMDApXG5cdFx0XHR9IGVsc2UgLy8gZmFzdGVyIGhhbmRsaW5nIGZvciBzbWFsbGVyIGJ1ZmZlcnNcblx0XHRcdFx0bmV3U2l6ZSA9ICgoTWF0aC5tYXgoKGVuZCAtIHN0YXJ0KSA8PCAyLCB0YXJnZXQubGVuZ3RoIC0gMSkgPj4gMTIpICsgMSkgPDwgMTJcblx0XHRcdGxldCBuZXdCdWZmZXIgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUobmV3U2l6ZSlcblx0XHRcdHRhcmdldFZpZXcgPSBuZXdCdWZmZXIuZGF0YVZpZXcgfHwgKG5ld0J1ZmZlci5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhuZXdCdWZmZXIuYnVmZmVyLCAwLCBuZXdTaXplKSlcblx0XHRcdGVuZCA9IE1hdGgubWluKGVuZCwgdGFyZ2V0Lmxlbmd0aClcblx0XHRcdGlmICh0YXJnZXQuY29weSlcblx0XHRcdFx0dGFyZ2V0LmNvcHkobmV3QnVmZmVyLCAwLCBzdGFydCwgZW5kKVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRuZXdCdWZmZXIuc2V0KHRhcmdldC5zbGljZShzdGFydCwgZW5kKSlcblx0XHRcdHBvc2l0aW9uIC09IHN0YXJ0XG5cdFx0XHRzdGFydCA9IDBcblx0XHRcdHNhZmVFbmQgPSBuZXdCdWZmZXIubGVuZ3RoIC0gMTBcblx0XHRcdHJldHVybiB0YXJnZXQgPSBuZXdCdWZmZXJcblx0XHR9XG5cdFx0Y29uc3QgbmV3UmVjb3JkID0gKHRyYW5zaXRpb24sIGtleXMsIG5ld1RyYW5zaXRpb25zKSA9PiB7XG5cdFx0XHRsZXQgcmVjb3JkSWQgPSBzdHJ1Y3R1cmVzLm5leHRJZFxuXHRcdFx0aWYgKCFyZWNvcmRJZClcblx0XHRcdFx0cmVjb3JkSWQgPSAweDQwXG5cdFx0XHRpZiAocmVjb3JkSWQgPCBzaGFyZWRMaW1pdElkICYmIHRoaXMuc2hvdWxkU2hhcmVTdHJ1Y3R1cmUgJiYgIXRoaXMuc2hvdWxkU2hhcmVTdHJ1Y3R1cmUoa2V5cykpIHtcblx0XHRcdFx0cmVjb3JkSWQgPSBzdHJ1Y3R1cmVzLm5leHRPd25JZFxuXHRcdFx0XHRpZiAoIShyZWNvcmRJZCA8IG1heFN0cnVjdHVyZUlkKSlcblx0XHRcdFx0XHRyZWNvcmRJZCA9IHNoYXJlZExpbWl0SWRcblx0XHRcdFx0c3RydWN0dXJlcy5uZXh0T3duSWQgPSByZWNvcmRJZCArIDFcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChyZWNvcmRJZCA+PSBtYXhTdHJ1Y3R1cmVJZCkvLyBjeWNsZSBiYWNrIGFyb3VuZFxuXHRcdFx0XHRcdHJlY29yZElkID0gc2hhcmVkTGltaXRJZFxuXHRcdFx0XHRzdHJ1Y3R1cmVzLm5leHRJZCA9IHJlY29yZElkICsgMVxuXHRcdFx0fVxuXHRcdFx0bGV0IGhpZ2hCeXRlID0ga2V5cy5oaWdoQnl0ZSA9IHJlY29yZElkID49IDB4NjAgJiYgdXNlVHdvQnl0ZVJlY29yZHMgPyAocmVjb3JkSWQgLSAweDYwKSA+PiA1IDogLTFcblx0XHRcdHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF0gPSByZWNvcmRJZFxuXHRcdFx0dHJhbnNpdGlvbi5fX2tleXNfXyA9IGtleXNcblx0XHRcdHN0cnVjdHVyZXNbcmVjb3JkSWQgLSAweDQwXSA9IGtleXNcblxuXHRcdFx0aWYgKHJlY29yZElkIDwgc2hhcmVkTGltaXRJZCkge1xuXHRcdFx0XHRrZXlzLmlzU2hhcmVkID0gdHJ1ZVxuXHRcdFx0XHRzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IHJlY29yZElkIC0gMHgzZlxuXHRcdFx0XHRoYXNTaGFyZWRVcGRhdGUgPSB0cnVlXG5cdFx0XHRcdGlmIChoaWdoQnl0ZSA+PSAwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKHJlY29yZElkICYgMHgxZikgKyAweDYwXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gaGlnaEJ5dGVcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZFxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaGlnaEJ5dGUgPj0gMCkge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDUgLy8gZml4ZXh0IDJcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDcyIC8vIFwiclwiIHJlY29yZCBkZWZpbnRpb24gZXh0ZW5zaW9uIHR5cGVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAocmVjb3JkSWQgJiAweDFmKSArIDB4NjBcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBoaWdoQnl0ZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQgLy8gZml4ZXh0IDFcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDcyIC8vIFwiclwiIHJlY29yZCBkZWZpbnRpb24gZXh0ZW5zaW9uIHR5cGVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG5ld1RyYW5zaXRpb25zKVxuXHRcdFx0XHRcdHRyYW5zaXRpb25zQ291bnQgKz0gc2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkICogbmV3VHJhbnNpdGlvbnNcblx0XHRcdFx0Ly8gcmVjb3JkIHRoZSByZW1vdmFsIG9mIHRoZSBpZCwgd2UgY2FuIG1haW50YWluIG91ciBzaGFyZWQgc3RydWN0dXJlXG5cdFx0XHRcdGlmIChyZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGggPj0gbWF4T3duU3RydWN0dXJlcylcblx0XHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZS5zaGlmdCgpW1JFQ09SRF9TWU1CT0xdID0gMCAvLyB3ZSBhcmUgY3ljbGluZyBiYWNrIHRocm91Z2gsIGFuZCBoYXZlIHRvIHJlbW92ZSBvbGQgb25lc1xuXHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZS5wdXNoKHRyYW5zaXRpb24pXG5cdFx0XHRcdHBhY2soa2V5cylcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgaW5zZXJ0TmV3UmVjb3JkID0gKHRyYW5zaXRpb24sIGtleXMsIGluc2VydGlvbk9mZnNldCwgbmV3VHJhbnNpdGlvbnMpID0+IHtcblx0XHRcdGxldCBtYWluVGFyZ2V0ID0gdGFyZ2V0XG5cdFx0XHRsZXQgbWFpblBvc2l0aW9uID0gcG9zaXRpb25cblx0XHRcdGxldCBtYWluU2FmZUVuZCA9IHNhZmVFbmRcblx0XHRcdGxldCBtYWluU3RhcnQgPSBzdGFydFxuXHRcdFx0dGFyZ2V0ID0ga2V5c1RhcmdldFxuXHRcdFx0cG9zaXRpb24gPSAwXG5cdFx0XHRzdGFydCA9IDBcblx0XHRcdGlmICghdGFyZ2V0KVxuXHRcdFx0XHRrZXlzVGFyZ2V0ID0gdGFyZ2V0ID0gbmV3IEJ5dGVBcnJheUFsbG9jYXRlKDgxOTIpXG5cdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwXG5cdFx0XHRuZXdSZWNvcmQodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRrZXlzVGFyZ2V0ID0gdGFyZ2V0XG5cdFx0XHRsZXQga2V5c1Bvc2l0aW9uID0gcG9zaXRpb25cblx0XHRcdHRhcmdldCA9IG1haW5UYXJnZXRcblx0XHRcdHBvc2l0aW9uID0gbWFpblBvc2l0aW9uXG5cdFx0XHRzYWZlRW5kID0gbWFpblNhZmVFbmRcblx0XHRcdHN0YXJ0ID0gbWFpblN0YXJ0XG5cdFx0XHRpZiAoa2V5c1Bvc2l0aW9uID4gMSkge1xuXHRcdFx0XHRsZXQgbmV3RW5kID0gcG9zaXRpb24gKyBrZXlzUG9zaXRpb24gLSAxXG5cdFx0XHRcdGlmIChuZXdFbmQgPiBzYWZlRW5kKVxuXHRcdFx0XHRcdG1ha2VSb29tKG5ld0VuZClcblx0XHRcdFx0bGV0IGluc2VydGlvblBvc2l0aW9uID0gaW5zZXJ0aW9uT2Zmc2V0ICsgc3RhcnRcblx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4oaW5zZXJ0aW9uUG9zaXRpb24gKyBrZXlzUG9zaXRpb24sIGluc2VydGlvblBvc2l0aW9uICsgMSwgcG9zaXRpb24pXG5cdFx0XHRcdHRhcmdldC5zZXQoa2V5c1RhcmdldC5zbGljZSgwLCBrZXlzUG9zaXRpb24pLCBpbnNlcnRpb25Qb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gPSBuZXdFbmRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtpbnNlcnRpb25PZmZzZXQgKyBzdGFydF0gPSBrZXlzVGFyZ2V0WzBdXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IHdyaXRlU3RydWN0ID0gKG9iamVjdCkgPT4ge1xuXHRcdFx0bGV0IG5ld1Bvc2l0aW9uID0gd3JpdGVTdHJ1Y3RTbG90cyhvYmplY3QsIHRhcmdldCwgc3RhcnQsIHBvc2l0aW9uLCBzdHJ1Y3R1cmVzLCBtYWtlUm9vbSwgKHZhbHVlLCBuZXdQb3NpdGlvbiwgbm90aWZ5U2hhcmVkVXBkYXRlKSA9PiB7XG5cdFx0XHRcdGlmIChub3RpZnlTaGFyZWRVcGRhdGUpXG5cdFx0XHRcdFx0cmV0dXJuIGhhc1NoYXJlZFVwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdHBvc2l0aW9uID0gbmV3UG9zaXRpb247XG5cdFx0XHRcdGxldCBzdGFydFRhcmdldCA9IHRhcmdldDtcblx0XHRcdFx0cGFjayh2YWx1ZSk7XG5cdFx0XHRcdHJlc2V0U3RydWN0dXJlcygpO1xuXHRcdFx0XHRpZiAoc3RhcnRUYXJnZXQgIT09IHRhcmdldCkge1xuXHRcdFx0XHRcdHJldHVybiB7IHBvc2l0aW9uLCB0YXJnZXRWaWV3LCB0YXJnZXQgfTsgLy8gaW5kaWNhdGUgdGhlIGJ1ZmZlciB3YXMgcmUtYWxsb2NhdGVkXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBvc2l0aW9uO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRpZiAobmV3UG9zaXRpb24gPT09IDApIC8vIGJhaWwgYW5kIGdvIHRvIGEgbXNncGFjayBvYmplY3Rcblx0XHRcdFx0cmV0dXJuIHdyaXRlT2JqZWN0KG9iamVjdCk7XG5cdFx0XHRwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuXHRcdH1cblx0fVxuXHR1c2VCdWZmZXIoYnVmZmVyKSB7XG5cdFx0Ly8gdGhpcyBtZWFucyB3ZSBhcmUgZmluaXNoZWQgdXNpbmcgb3VyIG93biBidWZmZXIgYW5kIHdlIGNhbiB3cml0ZSBvdmVyIGl0IHNhZmVseVxuXHRcdHRhcmdldCA9IGJ1ZmZlclxuXHRcdHRhcmdldC5kYXRhVmlldyB8fCAodGFyZ2V0LmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aCkpXG5cdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0XHRwb3NpdGlvbiA9IDBcblx0fVxuXHRzZXQgcG9zaXRpb24gKHZhbHVlKSB7XG5cdFx0cG9zaXRpb24gPSB2YWx1ZTtcblx0fVxuXHRnZXQgcG9zaXRpb24oKSB7XG5cdFx0cmV0dXJuIHBvc2l0aW9uO1xuXHR9XG5cdGNsZWFyU2hhcmVkRGF0YSgpIHtcblx0XHRpZiAodGhpcy5zdHJ1Y3R1cmVzKVxuXHRcdFx0dGhpcy5zdHJ1Y3R1cmVzID0gW11cblx0XHRpZiAodGhpcy50eXBlZFN0cnVjdHMpXG5cdFx0XHR0aGlzLnR5cGVkU3RydWN0cyA9IFtdXG5cdH1cbn1cblxuZXh0ZW5zaW9uQ2xhc3NlcyA9IFsgRGF0ZSwgU2V0LCBFcnJvciwgUmVnRXhwLCBBcnJheUJ1ZmZlciwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkucHJvdG90eXBlKS5jb25zdHJ1Y3RvciAvKlR5cGVkQXJyYXkqLywgRGF0YVZpZXcsIEMxVHlwZSBdXG5leHRlbnNpb25zID0gW3tcblx0cGFjayhkYXRlLCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHNlY29uZHMgPSBkYXRlLmdldFRpbWUoKSAvIDEwMDBcblx0XHRpZiAoKHRoaXMudXNlVGltZXN0YW1wMzIgfHwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSA9PT0gMCkgJiYgc2Vjb25kcyA+PSAwICYmIHNlY29uZHMgPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0Ly8gVGltZXN0YW1wIDMyXG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoNilcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDZcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBzZWNvbmRzKVxuXHRcdH0gZWxzZSBpZiAoc2Vjb25kcyA+IDAgJiYgc2Vjb25kcyA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHQvLyBUaW1lc3RhbXAgNjRcblx0XHRcdGxldCB7IHRhcmdldCwgdGFyZ2V0VmlldywgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSgxMClcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDdcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpICogNDAwMDAwMCArICgoc2Vjb25kcyAvIDEwMDAgLyAweDEwMDAwMDAwMCkgPj4gMCkpXG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiArIDQsIHNlY29uZHMpXG5cdFx0fSBlbHNlIGlmIChpc05hTihzZWNvbmRzKSkge1xuXHRcdFx0aWYgKHRoaXMub25JbnZhbGlkRGF0ZSkge1xuXHRcdFx0XHRhbGxvY2F0ZUZvcldyaXRlKDApXG5cdFx0XHRcdHJldHVybiBwYWNrKHRoaXMub25JbnZhbGlkRGF0ZSgpKVxuXHRcdFx0fVxuXHRcdFx0Ly8gSW50ZW50aW9uYWxseSBpbnZhbGlkIHRpbWVzdGFtcFxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDMpXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRpbWVzdGFtcCA5NlxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDE1KVxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjN1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMTJcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmZcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpICogMTAwMDAwMClcblx0XHRcdHRhcmdldFZpZXcuc2V0QmlnSW50NjQocG9zaXRpb24gKyA0LCBCaWdJbnQoTWF0aC5mbG9vcihzZWNvbmRzKSkpXG5cdFx0fVxuXHR9XG59LCB7XG5cdHBhY2soc2V0LCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0aWYgKHRoaXMuc2V0QXNFbXB0eU9iamVjdCkge1xuXHRcdFx0YWxsb2NhdGVGb3JXcml0ZSgwKTtcblx0XHRcdHJldHVybiBwYWNrKHt9KVxuXHRcdH1cblx0XHRsZXQgYXJyYXkgPSBBcnJheS5mcm9tKHNldClcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUodGhpcy5tb3JlVHlwZXMgPyAzIDogMClcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpIHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDRcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzMgLy8gJ3MnIGZvciBTZXRcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHR9XG5cdFx0cGFjayhhcnJheSlcblx0fVxufSwge1xuXHRwYWNrKGVycm9yLCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKHRoaXMubW9yZVR5cGVzID8gMyA6IDApXG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKSB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDY1IC8vICdlJyBmb3IgZXJyb3Jcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDBcblx0XHR9XG5cdFx0cGFjayhbIGVycm9yLm5hbWUsIGVycm9yLm1lc3NhZ2UsIGVycm9yLmNhdXNlIF0pXG5cdH1cbn0sIHtcblx0cGFjayhyZWdleCwgYWxsb2NhdGVGb3JXcml0ZSwgcGFjaykge1xuXHRcdGxldCB7IHRhcmdldCwgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSh0aGlzLm1vcmVUeXBlcyA/IDMgOiAwKVxuXHRcdGlmICh0aGlzLm1vcmVUeXBlcykge1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNFxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3OCAvLyAneCcgZm9yIHJlZ2VYcFxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMFxuXHRcdH1cblx0XHRwYWNrKFsgcmVnZXguc291cmNlLCByZWdleC5mbGFncyBdKVxuXHR9XG59LCB7XG5cdHBhY2soYXJyYXlCdWZmZXIsIGFsbG9jYXRlRm9yV3JpdGUpIHtcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpXG5cdFx0XHR3cml0ZUV4dEJ1ZmZlcihhcnJheUJ1ZmZlciwgMHgxMCwgYWxsb2NhdGVGb3JXcml0ZSlcblx0XHRlbHNlXG5cdFx0XHR3cml0ZUJ1ZmZlcihoYXNOb2RlQnVmZmVyID8gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpIDogbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLCBhbGxvY2F0ZUZvcldyaXRlKVxuXHR9XG59LCB7XG5cdHBhY2sodHlwZWRBcnJheSwgYWxsb2NhdGVGb3JXcml0ZSkge1xuXHRcdGxldCBjb25zdHJ1Y3RvciA9IHR5cGVkQXJyYXkuY29uc3RydWN0b3Jcblx0XHRpZiAoY29uc3RydWN0b3IgIT09IEJ5dGVBcnJheSAmJiB0aGlzLm1vcmVUeXBlcylcblx0XHRcdHdyaXRlRXh0QnVmZmVyKHR5cGVkQXJyYXksIHR5cGVkQXJyYXlzLmluZGV4T2YoY29uc3RydWN0b3IubmFtZSksIGFsbG9jYXRlRm9yV3JpdGUpXG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVCdWZmZXIodHlwZWRBcnJheSwgYWxsb2NhdGVGb3JXcml0ZSlcblx0fVxufSwge1xuXHRwYWNrKGFycmF5QnVmZmVyLCBhbGxvY2F0ZUZvcldyaXRlKSB7XG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKVxuXHRcdFx0d3JpdGVFeHRCdWZmZXIoYXJyYXlCdWZmZXIsIDB4MTEsIGFsbG9jYXRlRm9yV3JpdGUpXG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVCdWZmZXIoaGFzTm9kZUJ1ZmZlciA/IEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyKSA6IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSwgYWxsb2NhdGVGb3JXcml0ZSlcblx0fVxufSwge1xuXHRwYWNrKGMxLCBhbGxvY2F0ZUZvcldyaXRlKSB7IC8vIHNwZWNpZmljIDB4QzEgb2JqZWN0XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDEpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uXSA9IDB4YzFcblx0fVxufV1cblxuZnVuY3Rpb24gd3JpdGVFeHRCdWZmZXIodHlwZWRBcnJheSwgdHlwZSwgYWxsb2NhdGVGb3JXcml0ZSwgZW5jb2RlKSB7XG5cdGxldCBsZW5ndGggPSB0eXBlZEFycmF5LmJ5dGVMZW5ndGhcblx0aWYgKGxlbmd0aCArIDEgPCAweDEwMCkge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24gfSA9IGFsbG9jYXRlRm9yV3JpdGUoNCArIGxlbmd0aClcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM3XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICsgMVxuXHR9IGVsc2UgaWYgKGxlbmd0aCArIDEgPCAweDEwMDAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZSg1ICsgbGVuZ3RoKVxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzhcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoICsgMSkgPj4gOFxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChsZW5ndGggKyAxKSAmIDB4ZmZcblx0fSBlbHNlIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uLCB0YXJnZXRWaWV3IH0gPSBhbGxvY2F0ZUZvcldyaXRlKDcgKyBsZW5ndGgpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjOVxuXHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGggKyAxKSAvLyBwbHVzIG9uZSBmb3IgdGhlIHR5cGUgYnl0ZVxuXHRcdHBvc2l0aW9uICs9IDRcblx0fVxuXHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDc0IC8vIFwidFwiIGZvciB0eXBlZCBhcnJheVxuXHR0YXJnZXRbcG9zaXRpb24rK10gPSB0eXBlXG5cdGlmICghdHlwZWRBcnJheS5idWZmZXIpIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5KVxuXHR0YXJnZXQuc2V0KG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkuYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aCksIHBvc2l0aW9uKVxufVxuZnVuY3Rpb24gd3JpdGVCdWZmZXIoYnVmZmVyLCBhbGxvY2F0ZUZvcldyaXRlKSB7XG5cdGxldCBsZW5ndGggPSBidWZmZXIuYnl0ZUxlbmd0aFxuXHR2YXIgdGFyZ2V0LCBwb3NpdGlvblxuXHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDIpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjNFxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aFxuXHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDMpXG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjNVxuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHR9IGVsc2Uge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24sIHRhcmdldFZpZXcgfSA9IGFsbG9jYXRlRm9yV3JpdGUobGVuZ3RoICsgNSlcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM2XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aClcblx0XHRwb3NpdGlvbiArPSA0XG5cdH1cblx0dGFyZ2V0LnNldChidWZmZXIsIHBvc2l0aW9uKVxufVxuXG5mdW5jdGlvbiB3cml0ZUV4dGVuc2lvbkRhdGEocmVzdWx0LCB0YXJnZXQsIHBvc2l0aW9uLCB0eXBlKSB7XG5cdGxldCBsZW5ndGggPSByZXN1bHQubGVuZ3RoXG5cdHN3aXRjaCAobGVuZ3RoKSB7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNFxuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDI6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ1XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgNDpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDZcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSA4OlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkN1xuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDE2OlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkOFxuXHRcdFx0YnJlYWtcblx0XHRkZWZhdWx0OlxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzdcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoXG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjOFxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gOFxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM5XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiAyNFxuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoID4+IDE2KSAmIDB4ZmZcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCA+PiA4KSAmIDB4ZmZcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZlxuXHRcdFx0fVxuXHR9XG5cdHRhcmdldFtwb3NpdGlvbisrXSA9IHR5cGVcblx0dGFyZ2V0LnNldChyZXN1bHQsIHBvc2l0aW9uKVxuXHRwb3NpdGlvbiArPSBsZW5ndGhcblx0cmV0dXJuIHBvc2l0aW9uXG59XG5cbmZ1bmN0aW9uIGluc2VydElkcyhzZXJpYWxpemVkLCBpZHNUb0luc2VydCkge1xuXHQvLyBpbnNlcnQgdGhlIGlkcyB0aGF0IG5lZWQgdG8gYmUgcmVmZXJlbmNlZCBmb3Igc3RydWN0dXJlZCBjbG9uZXNcblx0bGV0IG5leHRJZFxuXHRsZXQgZGlzdGFuY2VUb01vdmUgPSBpZHNUb0luc2VydC5sZW5ndGggKiA2XG5cdGxldCBsYXN0RW5kID0gc2VyaWFsaXplZC5sZW5ndGggLSBkaXN0YW5jZVRvTW92ZVxuXHR3aGlsZSAobmV4dElkID0gaWRzVG9JbnNlcnQucG9wKCkpIHtcblx0XHRsZXQgb2Zmc2V0ID0gbmV4dElkLm9mZnNldFxuXHRcdGxldCBpZCA9IG5leHRJZC5pZFxuXHRcdHNlcmlhbGl6ZWQuY29weVdpdGhpbihvZmZzZXQgKyBkaXN0YW5jZVRvTW92ZSwgb2Zmc2V0LCBsYXN0RW5kKVxuXHRcdGRpc3RhbmNlVG9Nb3ZlIC09IDZcblx0XHRsZXQgcG9zaXRpb24gPSBvZmZzZXQgKyBkaXN0YW5jZVRvTW92ZVxuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAweGQ2XG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IDB4NjkgLy8gJ2knXG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IGlkID4+IDI0XG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IChpZCA+PiAxNikgJiAweGZmXG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IChpZCA+PiA4KSAmIDB4ZmZcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gaWQgJiAweGZmXG5cdFx0bGFzdEVuZCA9IG9mZnNldFxuXHR9XG5cdHJldHVybiBzZXJpYWxpemVkXG59XG5cbmZ1bmN0aW9uIHdyaXRlQnVuZGxlcyhzdGFydCwgcGFjaywgaW5jcmVtZW50UG9zaXRpb24pIHtcblx0aWYgKGJ1bmRsZWRTdHJpbmdzLmxlbmd0aCA+IDApIHtcblx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihidW5kbGVkU3RyaW5ncy5wb3NpdGlvbiArIHN0YXJ0LCBwb3NpdGlvbiArIGluY3JlbWVudFBvc2l0aW9uIC0gYnVuZGxlZFN0cmluZ3MucG9zaXRpb24gLSBzdGFydClcblx0XHRidW5kbGVkU3RyaW5ncy5zdHJpbmdzUG9zaXRpb24gPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdGxldCB3cml0ZVN0cmluZ3MgPSBidW5kbGVkU3RyaW5nc1xuXHRcdGJ1bmRsZWRTdHJpbmdzID0gbnVsbFxuXHRcdHBhY2sod3JpdGVTdHJpbmdzWzBdKVxuXHRcdHBhY2sod3JpdGVTdHJpbmdzWzFdKVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRFeHRlbnNpb24oZXh0ZW5zaW9uKSB7XG5cdGlmIChleHRlbnNpb24uQ2xhc3MpIHtcblx0XHRpZiAoIWV4dGVuc2lvbi5wYWNrICYmICFleHRlbnNpb24ud3JpdGUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBoYXMgbm8gcGFjayBvciB3cml0ZSBmdW5jdGlvbicpXG5cdFx0aWYgKGV4dGVuc2lvbi5wYWNrICYmICFleHRlbnNpb24udHlwZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIGhhcyBubyB0eXBlIChudW1lcmljIGNvZGUgdG8gaWRlbnRpZnkgdGhlIGV4dGVuc2lvbiknKVxuXHRcdGV4dGVuc2lvbkNsYXNzZXMudW5zaGlmdChleHRlbnNpb24uQ2xhc3MpXG5cdFx0ZXh0ZW5zaW9ucy51bnNoaWZ0KGV4dGVuc2lvbilcblx0fVxuXHR1bnBhY2tBZGRFeHRlbnNpb24oZXh0ZW5zaW9uKVxufVxuZnVuY3Rpb24gcHJlcGFyZVN0cnVjdHVyZXMoc3RydWN0dXJlcywgcGFja3IpIHtcblx0c3RydWN0dXJlcy5pc0NvbXBhdGlibGUgPSAoZXhpc3RpbmdTdHJ1Y3R1cmVzKSA9PiB7XG5cdFx0bGV0IGNvbXBhdGlibGUgPSAhZXhpc3RpbmdTdHJ1Y3R1cmVzIHx8ICgocGFja3IubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCB8fCAwKSA9PT0gZXhpc3RpbmdTdHJ1Y3R1cmVzLmxlbmd0aClcblx0XHRpZiAoIWNvbXBhdGlibGUpIC8vIHdlIHdhbnQgdG8gbWVyZ2UgdGhlc2UgZXhpc3Rpbmcgc3RydWN0dXJlcyBpbW1lZGlhdGVseSBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUgaXQgYW5kIHdlIGFyZSBpbiB0aGUgcmlnaHQgdHJhbnNhY3Rpb25cblx0XHRcdHBhY2tyLl9tZXJnZVN0cnVjdHVyZXMoZXhpc3RpbmdTdHJ1Y3R1cmVzKTtcblx0XHRyZXR1cm4gY29tcGF0aWJsZTtcblx0fVxuXHRyZXR1cm4gc3RydWN0dXJlc1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldFdyaXRlU3RydWN0U2xvdHMod3JpdGVTbG90cywgbWFrZVN0cnVjdHVyZXMpIHtcblx0d3JpdGVTdHJ1Y3RTbG90cyA9IHdyaXRlU2xvdHM7XG5cdHByZXBhcmVTdHJ1Y3R1cmVzID0gbWFrZVN0cnVjdHVyZXM7XG59XG5cbmxldCBkZWZhdWx0UGFja3IgPSBuZXcgUGFja3IoeyB1c2VSZWNvcmRzOiBmYWxzZSB9KVxuZXhwb3J0IGNvbnN0IHBhY2sgPSBkZWZhdWx0UGFja3IucGFja1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IGRlZmF1bHRQYWNrci5wYWNrXG5leHBvcnQgY29uc3QgRW5jb2RlciA9IFBhY2tyXG5leHBvcnQgeyBGTE9BVDMyX09QVElPTlMgfSBmcm9tICcuL3VucGFjay5qcydcbmltcG9ydCB7IEZMT0FUMzJfT1BUSU9OUyB9IGZyb20gJy4vdW5wYWNrLmpzJ1xuZXhwb3J0IGNvbnN0IHsgTkVWRVIsIEFMV0FZUywgREVDSU1BTF9ST1VORCwgREVDSU1BTF9GSVQgfSA9IEZMT0FUMzJfT1BUSU9OU1xuZXhwb3J0IGNvbnN0IFJFVVNFX0JVRkZFUl9NT0RFID0gNTEyXG5leHBvcnQgY29uc3QgUkVTRVRfQlVGRkVSX01PREUgPSAxMDI0XG5leHBvcnQgY29uc3QgUkVTRVJWRV9TVEFSVF9TUEFDRSA9IDIwNDhcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/pack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/stream.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/stream.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PackrStream: () => (/* binding */ PackrStream),\n/* harmony export */   UnpackrStream: () => (/* binding */ UnpackrStream)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pack.js */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/pack.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unpack.js */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/unpack.js\");\n\n\n\nvar DEFAULT_OPTIONS = {objectMode: true}\n\nclass PackrStream extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform {\n\tconstructor(options) {\n\t\tif (!options)\n\t\t\toptions = {}\n\t\toptions.writableObjectMode = true\n\t\tsuper(options)\n\t\toptions.sequential = true\n\t\tthis.packr = options.packr || new _pack_js__WEBPACK_IMPORTED_MODULE_1__.Packr(options)\n\t}\n\t_transform(value, encoding, callback) {\n\t\tthis.push(this.packr.pack(value))\n\t\tcallback()\n\t}\n}\n\nclass UnpackrStream extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform {\n\tconstructor(options) {\n\t\tif (!options)\n\t\t\toptions = {}\n\t\toptions.objectMode = true\n\t\tsuper(options)\n\t\toptions.structures = []\n\t\tthis.unpackr = options.unpackr || new _unpack_js__WEBPACK_IMPORTED_MODULE_2__.Unpackr(options)\n\t}\n\t_transform(chunk, encoding, callback) {\n\t\tif (this.incompleteBuffer) {\n\t\t\tchunk = Buffer.concat([this.incompleteBuffer, chunk])\n\t\t\tthis.incompleteBuffer = null\n\t\t}\n\t\tlet values\n\t\ttry {\n\t\t\tvalues = this.unpackr.unpackMultiple(chunk)\n\t\t} catch(error) {\n\t\t\tif (error.incomplete) {\n\t\t\t\tthis.incompleteBuffer = chunk.slice(error.lastPosition)\n\t\t\t\tvalues = error.values\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow error\n\t\t} finally {\n\t\t\tfor (let value of values || []) {\n\t\t\t\tif (value === null)\n\t\t\t\t\tvalue = this.getNullValue()\n\t\t\t\tthis.push(value)\n\t\t\t}\n\t\t}\n\t\tif (callback) callback()\n\t}\n\tgetNullValue() {\n\t\treturn Symbol.for(null)\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbXNncGFja3JAMS4xMS41L25vZGVfbW9kdWxlcy9tc2dwYWNrci9zdHJlYW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBa0M7QUFDRDtBQUNJO0FBQ3JDLHVCQUF1Qjs7QUFFaEIsMEJBQTBCLDZDQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQ0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sNEJBQTRCLDZDQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQ0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3lvdXN1a2UvTXlQcm9qZWN0L215LW5leHVzLWFwcC9ub2RlX21vZHVsZXMvLnBucG0vbXNncGFja3JAMS4xMS41L25vZGVfbW9kdWxlcy9tc2dwYWNrci9zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnc3RyZWFtJ1xuaW1wb3J0IHsgUGFja3IgfSBmcm9tICcuL3BhY2suanMnXG5pbXBvcnQgeyBVbnBhY2tyIH0gZnJvbSAnLi91bnBhY2suanMnXG52YXIgREVGQVVMVF9PUFRJT05TID0ge29iamVjdE1vZGU6IHRydWV9XG5cbmV4cG9ydCBjbGFzcyBQYWNrclN0cmVhbSBleHRlbmRzIFRyYW5zZm9ybSB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMpXG5cdFx0XHRvcHRpb25zID0ge31cblx0XHRvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSA9IHRydWVcblx0XHRzdXBlcihvcHRpb25zKVxuXHRcdG9wdGlvbnMuc2VxdWVudGlhbCA9IHRydWVcblx0XHR0aGlzLnBhY2tyID0gb3B0aW9ucy5wYWNrciB8fCBuZXcgUGFja3Iob3B0aW9ucylcblx0fVxuXHRfdHJhbnNmb3JtKHZhbHVlLCBlbmNvZGluZywgY2FsbGJhY2spIHtcblx0XHR0aGlzLnB1c2godGhpcy5wYWNrci5wYWNrKHZhbHVlKSlcblx0XHRjYWxsYmFjaygpXG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIFVucGFja3JTdHJlYW0gZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9XG5cdFx0b3B0aW9ucy5vYmplY3RNb2RlID0gdHJ1ZVxuXHRcdHN1cGVyKG9wdGlvbnMpXG5cdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzID0gW11cblx0XHR0aGlzLnVucGFja3IgPSBvcHRpb25zLnVucGFja3IgfHwgbmV3IFVucGFja3Iob3B0aW9ucylcblx0fVxuXHRfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcblx0XHRpZiAodGhpcy5pbmNvbXBsZXRlQnVmZmVyKSB7XG5cdFx0XHRjaHVuayA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuaW5jb21wbGV0ZUJ1ZmZlciwgY2h1bmtdKVxuXHRcdFx0dGhpcy5pbmNvbXBsZXRlQnVmZmVyID0gbnVsbFxuXHRcdH1cblx0XHRsZXQgdmFsdWVzXG5cdFx0dHJ5IHtcblx0XHRcdHZhbHVlcyA9IHRoaXMudW5wYWNrci51bnBhY2tNdWx0aXBsZShjaHVuaylcblx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRpZiAoZXJyb3IuaW5jb21wbGV0ZSkge1xuXHRcdFx0XHR0aGlzLmluY29tcGxldGVCdWZmZXIgPSBjaHVuay5zbGljZShlcnJvci5sYXN0UG9zaXRpb24pXG5cdFx0XHRcdHZhbHVlcyA9IGVycm9yLnZhbHVlc1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMgfHwgW10pIHtcblx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsKVxuXHRcdFx0XHRcdHZhbHVlID0gdGhpcy5nZXROdWxsVmFsdWUoKVxuXHRcdFx0XHR0aGlzLnB1c2godmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjYWxsYmFjaykgY2FsbGJhY2soKVxuXHR9XG5cdGdldE51bGxWYWx1ZSgpIHtcblx0XHRyZXR1cm4gU3ltYm9sLmZvcihudWxsKVxuXHR9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/struct.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/struct.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pack.js */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/pack.js\");\n/* harmony import */ var _unpack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unpack.js */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/unpack.js\");\n\n/*\n\nFor \"any-data\":\n32-55 - record with record ids (-32)\n56 - 8-bit record ids\n57 - 16-bit record ids\n58 - 24-bit record ids\n59 - 32-bit record ids\n250-255 - followed by typed fixed width values\n64-250 msgpackr/cbor/paired data\narrays and strings within arrays are handled by paired encoding\n\nStructure encoding:\n(type - string (using paired encoding))+\n\nType encoding\nencoding byte - fixed width byte - next reference+\n\nEncoding byte:\nfirst bit:\n\t0 - inline\n\t1 - reference\nsecond bit:\n\t0 - data or number\n\t1 - string\n\nremaining bits:\n\tcharacter encoding - ISO-8859-x\n\n\nnull (0xff)+ 0xf6\nnull (0xff)+ 0xf7\n\n*/\n\n\n\n\nconst ASCII = 3; // the MIBenum from https://www.iana.org/assignments/character-sets/character-sets.xhtml (and other character encodings could be referenced by MIBenum)\nconst NUMBER = 0;\nconst UTF8 = 2;\nconst OBJECT_DATA = 1;\nconst DATE = 16;\nconst TYPE_NAMES = ['num', 'object', 'string', 'ascii'];\nTYPE_NAMES[DATE] = 'date';\nconst float32Headers = [false, true, true, false, false, true, true, false];\nlet evalSupported;\ntry {\n\tnew Function('');\n\tevalSupported = true;\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n}\n\nlet updatedPosition;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nlet textEncoder, currentSource;\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nconst encodeUtf8 = hasNodeBuffer ? function(target, string, position) {\n\treturn target.utf8Write(string, position, target.byteLength - position)\n} : (textEncoder && textEncoder.encodeInto) ?\n\tfunction(target, string, position) {\n\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t} : false\n\nconst TYPE = Symbol('type');\nconst PARENT = Symbol('parent');\n(0,_pack_js__WEBPACK_IMPORTED_MODULE_0__.setWriteStructSlots)(writeStruct, prepareStructures);\nfunction writeStruct(object, target, encodingStart, position, structures, makeRoom, pack, packr) {\n\tlet typedStructs = packr.typedStructs || (packr.typedStructs = []);\n\t// note that we rely on pack.js to load stored structures before we get to this point\n\tlet targetView = target.dataView;\n\tlet refsStartPosition = (typedStructs.lastStringStart || 100) + position;\n\tlet safeEnd = target.length - 10;\n\tlet start = position;\n\tif (position > safeEnd) {\n\t\ttarget = makeRoom(position);\n\t\ttargetView = target.dataView;\n\t\tposition -= encodingStart;\n\t\tstart -= encodingStart;\n\t\trefsStartPosition -= encodingStart;\n\t\tencodingStart = 0;\n\t\tsafeEnd = target.length - 10;\n\t}\n\n\tlet refOffset, refPosition = refsStartPosition;\n\n\tlet transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));\n\tlet nextId = typedStructs.nextId || typedStructs.length;\n\tlet headerSize =\n\t\tnextId < 0xf ? 1 :\n\t\t\tnextId < 0xf0 ? 2 :\n\t\t\t\tnextId < 0xf000 ? 3 :\n\t\t\t\t\tnextId < 0xf00000 ? 4 : 0;\n\tif (headerSize === 0)\n\t\treturn 0;\n\tposition += headerSize;\n\tlet queuedReferences = [];\n\tlet usedAscii0;\n\tlet keyIndex = 0;\n\tfor (let key in object) {\n\t\tlet value = object[key];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: 0,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null,\n\t\t\t\tdate64: null\n\t\t\t};\n\t\t}\n\t\tif (position > safeEnd) {\n\t\t\ttarget = makeRoom(position);\n\t\t\ttargetView = target.dataView;\n\t\t\tposition -= encodingStart;\n\t\t\tstart -= encodingStart;\n\t\t\trefsStartPosition -= encodingStart;\n\t\t\trefPosition -= encodingStart;\n\t\t\tencodingStart = 0;\n\t\t\tsafeEnd = target.length - 10\n\t\t}\n\t\tswitch (typeof value) {\n\t\t\tcase 'number':\n\t\t\t\tlet number = value;\n\t\t\t\t// first check to see if we are using a lot of ids and should default to wide/common format\n\t\t\t\tif (nextId < 200 || !nextTransition.num64) {\n\t\t\t\t\tif (number >> 0 === number && number < 0x20000000 && number > -0x1f000000) {\n\t\t\t\t\t\tif (number < 0xf6 && number >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number < 0x20 && !nextTransition.num32)) {\n\t\t\t\t\t\t\ttransition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\t\t\t\ttarget[position++] = number;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\ttargetView.setUint32(position, number, true);\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (number < 0x100000000 && number >= -0x80000000) {\n\t\t\t\t\t\ttargetView.setFloat32(position, number, true);\n\t\t\t\t\t\tif (float32Headers[target[position + 3] >>> 5]) {\n\t\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\tif (((xShifted = number * _unpack_js__WEBPACK_IMPORTED_MODULE_1__.mult10[((target[position + 3] & 0x7f) << 1) | (target[position + 2] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);\n\t\t\t\ttargetView.setFloat64(position, number, true);\n\t\t\t\tposition += 8;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tlet strLength = value.length;\n\t\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\t\tif ((strLength << 2) + refPosition > safeEnd) {\n\t\t\t\t\ttarget = makeRoom((strLength << 2) + refPosition);\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tposition -= encodingStart;\n\t\t\t\t\tstart -= encodingStart;\n\t\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\t\trefPosition -= encodingStart;\n\t\t\t\t\tencodingStart = 0;\n\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t}\n\t\t\t\tif (strLength > ((0xff00 + refOffset) >> 2)) {\n\t\t\t\t\tqueuedReferences.push(key, value, position - start);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet isNotAscii\n\t\t\t\tlet strStart = refPosition;\n\t\t\t\tif (strLength < 0x40) {\n\t\t\t\t\tlet i, c1, c2;\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[refPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trefPosition += encodeUtf8(target, value, refPosition);\n\t\t\t\t\tisNotAscii = refPosition - strStart > strLength;\n\t\t\t\t}\n\t\t\t\tif (refOffset < 0xa0 || (refOffset < 0xf6 && (nextTransition.ascii8 || nextTransition.string8))) {\n\t\t\t\t\t// short strings\n\t\t\t\t\tif (isNotAscii) {\n\t\t\t\t\t\tif (!(transition = nextTransition.string8)) {\n\t\t\t\t\t\t\tif (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {\n\t\t\t\t\t\t\t\t// we can safely change ascii to utf8 in place since they are compatible\n\t\t\t\t\t\t\t\ttransition.__type = UTF8;\n\t\t\t\t\t\t\t\tnextTransition.ascii8 = null;\n\t\t\t\t\t\t\t\tnextTransition.string8 = transition;\n\t\t\t\t\t\t\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, UTF8, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (refOffset === 0 && !usedAscii0) {\n\t\t\t\t\t\tusedAscii0 = true;\n\t\t\t\t\t\ttransition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);\n\t\t\t\t\t\tbreak; // don't increment position\n\t\t\t\t\t}// else ascii:\n\t\t\t\t\telse if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8)))\n\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, ASCII, 1);\n\t\t\t\t\ttarget[position++] = refOffset;\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Enable ascii16 at some point, but get the logic right\n\t\t\t\t\t//if (isNotAscii)\n\t\t\t\t\t\ttransition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);\n\t\t\t\t\t//else\n\t\t\t\t\t\t//transition = nextTransition.ascii16 || createTypeTransition(nextTransition, ASCII, 2);\n\t\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\t\tposition += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (value) {\n\t\t\t\t\tif (value.constructor === Date) {\n\t\t\t\t\t\ttransition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);\n\t\t\t\t\t\ttargetView.setFloat64(position, value.getTime(), true);\n\t\t\t\t\t\tposition += 8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else { // null\n\t\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -10); // match CBOR with this\n\t\t\t\t\tif (nextTransition) {\n\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\t\ttransition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\ttarget[position++] = value ? 0xf9 : 0xf8; // match CBOR with these\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -9); // match CBOR with this\n\t\t\t\tif (nextTransition) {\n\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\tfor (let i = 0, l = queuedReferences.length; i < l;) {\n\t\tlet key = queuedReferences[i++];\n\t\tlet value = queuedReferences[i++];\n\t\tlet propertyIndex = queuedReferences[i++];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: propertyIndex - keyIndex,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null\n\t\t\t};\n\t\t}\n\t\tlet newPosition;\n\t\tif (value) {\n\t\t\t/*if (typeof value === 'string') { // TODO: we could re-enable long strings\n\t\t\t\tif (position + value.length * 3 > safeEnd) {\n\t\t\t\t\ttarget = makeRoom(position + value.length * 3);\n\t\t\t\t\tposition -= start;\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\tnewPosition = position + target.utf8Write(value, position, 0xffffffff);\n\t\t\t} else { */\n\t\t\tlet size;\n\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\tif (refOffset < 0xff00) {\n\t\t\t\ttransition = nextTransition.object16;\n\t\t\t\tif (transition)\n\t\t\t\t\tsize = 2;\n\t\t\t\telse if ((transition = nextTransition.object32))\n\t\t\t\t\tsize = 4;\n\t\t\t\telse {\n\t\t\t\t\ttransition = createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\t\t\tsize = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttransition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);\n\t\t\t\tsize = 4;\n\t\t\t}\n\t\t\tnewPosition = pack(value, refPosition);\n\t\t\t//}\n\t\t\tif (typeof newPosition === 'object') {\n\t\t\t\t// re-allocated\n\t\t\t\trefPosition = newPosition.position;\n\t\t\t\ttargetView = newPosition.targetView;\n\t\t\t\ttarget = newPosition.target;\n\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\tposition -= encodingStart;\n\t\t\t\tstart -= encodingStart;\n\t\t\t\tencodingStart = 0;\n\t\t\t} else\n\t\t\t\trefPosition = newPosition;\n\t\t\tif (size === 2) {\n\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\tposition += 2;\n\t\t\t} else {\n\t\t\t\ttargetView.setUint32(position, refOffset, true);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t} else { // null or undefined\n\t\t\ttransition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\ttargetView.setInt16(position, value === null ? -10 : -9, true);\n\t\t\tposition += 2;\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\n\tlet recordId = transition[_pack_js__WEBPACK_IMPORTED_MODULE_0__.RECORD_SYMBOL];\n\tif (recordId == null) {\n\t\trecordId = packr.typedStructs.length;\n\t\tlet structure = [];\n\t\tlet nextTransition = transition;\n\t\tlet key, type;\n\t\twhile ((type = nextTransition.__type) !== undefined) {\n\t\t\tlet size = nextTransition.__size;\n\t\t\tnextTransition = nextTransition.__parent;\n\t\t\tkey = nextTransition.key;\n\t\t\tlet property = [type, size, key];\n\t\t\tif (nextTransition.enumerationOffset)\n\t\t\t\tproperty.push(nextTransition.enumerationOffset);\n\t\t\tstructure.push(property);\n\t\t\tnextTransition = nextTransition.parent;\n\t\t}\n\t\tstructure.reverse();\n\t\ttransition[_pack_js__WEBPACK_IMPORTED_MODULE_0__.RECORD_SYMBOL] = recordId;\n\t\tpackr.typedStructs[recordId] = structure;\n\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t}\n\n\n\tswitch (headerSize) {\n\t\tcase 1:\n\t\t\tif (recordId >= 0x10) return 0;\n\t\t\ttarget[start] = recordId + 0x20;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (recordId >= 0x100) return 0;\n\t\t\ttarget[start] = 0x38;\n\t\t\ttarget[start + 1] = recordId;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (recordId >= 0x10000) return 0;\n\t\t\ttarget[start] = 0x39;\n\t\t\ttargetView.setUint16(start + 1, recordId, true);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (recordId >= 0x1000000) return 0;\n\t\t\ttargetView.setUint32(start, (recordId << 8) + 0x3a, true);\n\t\t\tbreak;\n\t}\n\n\tif (position < refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\t// adjust positioning\n\t\ttarget.copyWithin(position, refsStartPosition, refPosition);\n\t\trefPosition += position - refsStartPosition;\n\t\ttypedStructs.lastStringStart = position - start;\n\t} else if (position > refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\ttypedStructs.lastStringStart = position - start;\n\t\treturn writeStruct(object, target, encodingStart, start, structures, makeRoom, pack, packr);\n\t}\n\treturn refPosition;\n}\nfunction anyType(transition, position, targetView, value) {\n\tlet nextTransition;\n\tif ((nextTransition = transition.ascii8 || transition.num8)) {\n\t\ttargetView.setInt8(position, value, true);\n\t\tupdatedPosition = position + 1;\n\t\treturn nextTransition;\n\t}\n\tif ((nextTransition = transition.string16 || transition.object16)) {\n\t\ttargetView.setInt16(position, value, true);\n\t\tupdatedPosition = position + 2;\n\t\treturn nextTransition;\n\t}\n\tif (nextTransition = transition.num32) {\n\t\ttargetView.setUint32(position, 0xe0000100 + value, true);\n\t\tupdatedPosition = position + 4;\n\t\treturn nextTransition;\n\t}\n\t// transition.float64\n\tif (nextTransition = transition.num64) {\n\t\ttargetView.setFloat64(position, NaN, true);\n\t\ttargetView.setInt8(position, value);\n\t\tupdatedPosition = position + 8;\n\t\treturn nextTransition;\n\t}\n\tupdatedPosition = position;\n\t// TODO: can we do an \"any\" type where we defer the decision?\n\treturn;\n}\nfunction createTypeTransition(transition, type, size) {\n\tlet typeName = TYPE_NAMES[type] + (size << 3);\n\tlet newTransition = transition[typeName] || (transition[typeName] = Object.create(null));\n\tnewTransition.__type = type;\n\tnewTransition.__size = size;\n\tnewTransition.__parent = transition;\n\treturn newTransition;\n}\nfunction onLoadedStructures(sharedData) {\n\tif (!(sharedData instanceof Map))\n\t\treturn sharedData;\n\tlet typed = sharedData.get('typed') || [];\n\tif (Object.isFrozen(typed))\n\t\ttyped = typed.map(structure => structure.slice(0));\n\tlet named = sharedData.get('named');\n\tlet transitions = Object.create(null);\n\tfor (let i = 0, l = typed.length; i < l; i++) {\n\t\tlet structure = typed[i];\n\t\tlet transition = transitions;\n\t\tfor (let [type, size, key] of structure) {\n\t\t\tlet nextTransition = transition[key];\n\t\t\tif (!nextTransition) {\n\t\t\t\ttransition[key] = nextTransition = {\n\t\t\t\t\tkey,\n\t\t\t\t\tparent: transition,\n\t\t\t\t\tenumerationOffset: 0,\n\t\t\t\t\tascii0: null,\n\t\t\t\t\tascii8: null,\n\t\t\t\t\tnum8: null,\n\t\t\t\t\tstring16: null,\n\t\t\t\t\tobject16: null,\n\t\t\t\t\tnum32: null,\n\t\t\t\t\tfloat64: null,\n\t\t\t\t\tdate64: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\ttransition = createTypeTransition(nextTransition, type, size);\n\t\t}\n\t\ttransition[_pack_js__WEBPACK_IMPORTED_MODULE_0__.RECORD_SYMBOL] = i;\n\t}\n\ttyped.transitions = transitions;\n\tthis.typedStructs = typed;\n\tthis.lastTypedStructuresLength = typed.length;\n\treturn named;\n}\nvar sourceSymbol = Symbol.for('source')\nfunction readStruct(src, position, srcEnd, unpackr) {\n\tlet recordId = src[position++] - 0x20;\n\tif (recordId >= 24) {\n\t\tswitch(recordId) {\n\t\t\tcase 24: recordId = src[position++]; break;\n\t\t\t// little endian:\n\t\t\tcase 25: recordId = src[position++] + (src[position++] << 8); break;\n\t\t\tcase 26: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16); break;\n\t\t\tcase 27: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16) + (src[position++] << 24); break;\n\t\t}\n\t}\n\tlet structure = unpackr.typedStructs && unpackr.typedStructs[recordId];\n\tif (!structure) {\n\t\t// copy src buffer because getStructures will override it\n\t\tsrc = Uint8Array.prototype.slice.call(src, position, srcEnd);\n\t\tsrcEnd -= position;\n\t\tposition = 0;\n\t\tif (!unpackr.getStructures)\n\t\t\tthrow new Error(`Reference to shared structure ${recordId} without getStructures method`);\n\t\tunpackr._mergeStructures(unpackr.getStructures());\n\t\tif (!unpackr.typedStructs)\n\t\t\tthrow new Error('Could not find any shared typed structures');\n\t\tunpackr.lastTypedStructuresLength = unpackr.typedStructs.length;\n\t\tstructure = unpackr.typedStructs[recordId];\n\t\tif (!structure)\n\t\t\tthrow new Error('Could not find typed structure ' + recordId);\n\t}\n\tvar construct = structure.construct;\n\tvar fullConstruct = structure.fullConstruct;\n\tif (!construct) {\n\t\tconstruct = structure.construct = function LazyObject() {\n\t\t}\n\t\tfullConstruct = structure.fullConstruct = function LoadedObject() {\n\t\t}\n\t\tfullConstruct.prototype = unpackr.structPrototype || {};\n\t\tvar prototype = construct.prototype = unpackr.structPrototype ? Object.create(unpackr.structPrototype) : {};\n\t\tlet properties = [];\n\t\tlet currentOffset = 0;\n\t\tlet lastRefProperty;\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet definition = structure[i];\n\t\t\tlet [ type, size, key, enumerationOffset ] = definition;\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tlet property = {\n\t\t\t\tkey,\n\t\t\t\toffset: currentOffset,\n\t\t\t}\n\t\t\tif (enumerationOffset)\n\t\t\t\tproperties.splice(i + enumerationOffset, 0, property);\n\t\t\telse\n\t\t\t\tproperties.push(property);\n\t\t\tlet getRef;\n\t\t\tswitch(size) { // TODO: Move into a separate function\n\t\t\t\tcase 0: getRef = () => 0; break;\n\t\t\t\tcase 1:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet ref = source.bytes[position + property.offset];\n\t\t\t\t\t\treturn ref >= 0xf6 ? toConstant(ref) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint16(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint32(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xffffff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tproperty.getRef = getRef;\n\t\t\tcurrentOffset += size;\n\t\t\tlet get;\n\t\t\tswitch(type) {\n\t\t\t\tcase ASCII:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tproperty.multiGetCount = 0;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (source.srcString) {\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*if (property.multiGetCount > 0) {\n\t\t\t\t\t\t\tlet asciiEnd;\n\t\t\t\t\t\t\tnext = firstRefProperty;\n\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tasciiEnd = dataView.getUint16(source.position + next.offset, true);\n\t\t\t\t\t\t\t\tif (asciiEnd < 0xff00)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tasciiEnd = null;\n\t\t\t\t\t\t\t} while((next = next.next));\n\t\t\t\t\t\t\tif (asciiEnd == null)\n\t\t\t\t\t\t\t\tasciiEnd = source.bytesEnd - refStart\n\t\t\t\t\t\t\tsource.srcString = src.toString('latin1', refStart, refStart + asciiEnd);\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (source.prevStringGet) {\n\t\t\t\t\t\t\tsource.prevStringGet.multiGetCount += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.prevStringGet = property;\n\t\t\t\t\t\t\tproperty.multiGetCount--;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\treturn (0,_unpack_js__WEBPACK_IMPORTED_MODULE_1__.readString)(src, ref + refStart, end - ref);\n\t\t\t\t\t\t//return src.toString('latin1', ref + refStart, end + refStart);\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase UTF8: case OBJECT_DATA:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (type === UTF8) {\n\t\t\t\t\t\t\treturn src.toString('utf8', ref + refStart, end + refStart);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentSource = source;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn unpackr.unpack(src, { start: ref + refStart, end: end + refStart });\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tcurrentSource = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase NUMBER:\n\t\t\t\t\tswitch(size) {\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet position = source.position + property.offset;\n\t\t\t\t\t\t\t\tlet value = dataView.getInt32(position, true)\n\t\t\t\t\t\t\t\tif (value < 0x20000000) {\n\t\t\t\t\t\t\t\t\tif (value > -0x1f000000)\n\t\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t\tif (value > -0x20000000)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(value & 0xff);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet fValue = dataView.getFloat32(position, true);\n\t\t\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\tlet multiplier = _unpack_js__WEBPACK_IMPORTED_MODULE_1__.mult10[((src[position + 3] & 0x7f) << 1) | (src[position + 2] >> 7)]\n\t\t\t\t\t\t\t\treturn ((multiplier * fValue + (fValue > 0 ? 0.5 : -0.5)) >> 0) / multiplier;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet value = dataView.getFloat64(source.position + property.offset, true);\n\t\t\t\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\t\t\t\tlet byte = src[source.position + property.offset];\n\t\t\t\t\t\t\t\t\tif (byte >= 0xf6)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(byte);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet value = src[source.position + property.offset];\n\t\t\t\t\t\t\t\treturn value < 0xf6 ? value : toConstant(value);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DATE:\n\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\treturn new Date(dataView.getFloat64(source.position + property.offset, true));\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tproperty.get = get;\n\t\t}\n\t\t// TODO: load the srcString for faster string decoding on toJSON\n\t\tif (evalSupported) {\n\t\t\tlet objectLiteralProperties = [];\n\t\t\tlet args = [];\n\t\t\tlet i = 0;\n\t\t\tlet hasInheritedProperties;\n\t\t\tfor (let property of properties) { // assign in enumeration order\n\t\t\t\tif (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {\n\t\t\t\t\t// these properties are not eagerly evaluated and this can be used for creating properties\n\t\t\t\t\t// that are not serialized as JSON\n\t\t\t\t\thasInheritedProperties = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tObject.defineProperty(prototype, property.key, { get: withSource(property.get), enumerable: true });\n\t\t\t\tlet valueFunction = 'v' + i++;\n\t\t\t\targs.push(valueFunction);\n\t\t\t\tobjectLiteralProperties.push('o[' + JSON.stringify(property.key) + ']=' + valueFunction + '(s)');\n\t\t\t}\n\t\t\tif (hasInheritedProperties) {\n\t\t\t\tobjectLiteralProperties.push('__proto__:this');\n\t\t\t}\n\t\t\tlet toObject = (new Function(...args, 'var c=this;return function(s){var o=new c();' + objectLiteralProperties.join(';') + ';return o;}')).apply(fullConstruct, properties.map(prop => prop.get));\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\treturn toObject.call(this, this[sourceSymbol]);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\t// return an enumerable object with own properties to JSON stringify\n\t\t\t\t\tlet resolved = {};\n\t\t\t\t\tfor (let i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t// TODO: check alwaysLazyProperty\n\t\t\t\t\t\tlet key = properties[i].key;\n\n\t\t\t\t\t\tresolved[key] = this[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t},\n\t\t\t\t// not enumerable or anything\n\t\t\t});\n\t\t}\n\t}\n\tvar instance = new construct();\n\tinstance[sourceSymbol] = {\n\t\tbytes: src,\n\t\tposition,\n\t\tsrcString: '',\n\t\tbytesEnd: srcEnd\n\t}\n\treturn instance;\n}\nfunction toConstant(code) {\n\tswitch(code) {\n\t\tcase 0xf6: return null;\n\t\tcase 0xf7: return undefined;\n\t\tcase 0xf8: return false;\n\t\tcase 0xf9: return true;\n\t}\n\tthrow new Error('Unknown constant');\n}\nfunction withSource(get) {\n\treturn function() {\n\t\treturn get(this[sourceSymbol]);\n\t}\n}\n\nfunction saveState() {\n\tif (currentSource) {\n\t\tcurrentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);\n\t\tcurrentSource.position = 0;\n\t\tcurrentSource.bytesEnd = currentSource.bytes.length;\n\t}\n}\nfunction prepareStructures(structures, packr) {\n\tif (packr.typedStructs) {\n\t\tlet structMap = new Map();\n\t\tstructMap.set('named', structures);\n\t\tstructMap.set('typed', packr.typedStructs);\n\t\tstructures = structMap;\n\t}\n\tlet lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;\n\tstructures.isCompatible = existing => {\n\t\tlet compatible = true;\n\t\tif (existing instanceof Map) {\n\t\t\tlet named = existing.get('named') || [];\n\t\t\tif (named.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t\tlet typed = existing.get('typed') || [];\n\t\t\tif (typed.length !== lastTypedStructuresLength)\n\t\t\t\tcompatible = false;\n\t\t} else if (existing instanceof Array || Array.isArray(existing)) {\n\t\t\tif (existing.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t}\n\t\tif (!compatible)\n\t\t\tpackr._mergeStructures(existing);\n\t\treturn compatible;\n\t};\n\tpackr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;\n\treturn structures;\n}\n\n(0,_unpack_js__WEBPACK_IMPORTED_MODULE_1__.setReadStruct)(readStruct, onLoadedStructures, saveState);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbXNncGFja3JAMS4xMS41L25vZGVfbW9kdWxlcy9tc2dwYWNrci9zdHJ1Y3QuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7O0FBRzBFO0FBQ1o7QUFDOUQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDZEQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOENBQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2IsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLE1BQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsMkJBQTJCLG1EQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBYTtBQUMxQjtBQUNBLHVCQUF1QjtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsaUVBQWlFO0FBQ2pFLDJGQUEyRjtBQUMzRixxSEFBcUg7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFVBQVU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQLGFBQWEsc0RBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EscUNBQXFDLDRDQUE0QztBQUNqRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhDQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxpREFBaUQ7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbUJBQW1CLGNBQWMsbUNBQW1DLE9BQU8sVUFBVTtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQWEiLCJzb3VyY2VzIjpbIi9Vc2Vycy95b3VzdWtlL015UHJvamVjdC9teS1uZXh1cy1hcHAvbm9kZV9tb2R1bGVzLy5wbnBtL21zZ3BhY2tyQDEuMTEuNS9ub2RlX21vZHVsZXMvbXNncGFja3Ivc3RydWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcblxuRm9yIFwiYW55LWRhdGFcIjpcbjMyLTU1IC0gcmVjb3JkIHdpdGggcmVjb3JkIGlkcyAoLTMyKVxuNTYgLSA4LWJpdCByZWNvcmQgaWRzXG41NyAtIDE2LWJpdCByZWNvcmQgaWRzXG41OCAtIDI0LWJpdCByZWNvcmQgaWRzXG41OSAtIDMyLWJpdCByZWNvcmQgaWRzXG4yNTAtMjU1IC0gZm9sbG93ZWQgYnkgdHlwZWQgZml4ZWQgd2lkdGggdmFsdWVzXG42NC0yNTAgbXNncGFja3IvY2Jvci9wYWlyZWQgZGF0YVxuYXJyYXlzIGFuZCBzdHJpbmdzIHdpdGhpbiBhcnJheXMgYXJlIGhhbmRsZWQgYnkgcGFpcmVkIGVuY29kaW5nXG5cblN0cnVjdHVyZSBlbmNvZGluZzpcbih0eXBlIC0gc3RyaW5nICh1c2luZyBwYWlyZWQgZW5jb2RpbmcpKStcblxuVHlwZSBlbmNvZGluZ1xuZW5jb2RpbmcgYnl0ZSAtIGZpeGVkIHdpZHRoIGJ5dGUgLSBuZXh0IHJlZmVyZW5jZStcblxuRW5jb2RpbmcgYnl0ZTpcbmZpcnN0IGJpdDpcblx0MCAtIGlubGluZVxuXHQxIC0gcmVmZXJlbmNlXG5zZWNvbmQgYml0OlxuXHQwIC0gZGF0YSBvciBudW1iZXJcblx0MSAtIHN0cmluZ1xuXG5yZW1haW5pbmcgYml0czpcblx0Y2hhcmFjdGVyIGVuY29kaW5nIC0gSVNPLTg4NTkteFxuXG5cbm51bGwgKDB4ZmYpKyAweGY2XG5udWxsICgweGZmKSsgMHhmN1xuXG4qL1xuXG5cbmltcG9ydCB7c2V0V3JpdGVTdHJ1Y3RTbG90cywgUkVDT1JEX1NZTUJPTCwgYWRkRXh0ZW5zaW9ufSBmcm9tICcuL3BhY2suanMnXG5pbXBvcnQge3NldFJlYWRTdHJ1Y3QsIG11bHQxMCwgcmVhZFN0cmluZ30gZnJvbSAnLi91bnBhY2suanMnO1xuY29uc3QgQVNDSUkgPSAzOyAvLyB0aGUgTUlCZW51bSBmcm9tIGh0dHBzOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL2NoYXJhY3Rlci1zZXRzL2NoYXJhY3Rlci1zZXRzLnhodG1sIChhbmQgb3RoZXIgY2hhcmFjdGVyIGVuY29kaW5ncyBjb3VsZCBiZSByZWZlcmVuY2VkIGJ5IE1JQmVudW0pXG5jb25zdCBOVU1CRVIgPSAwO1xuY29uc3QgVVRGOCA9IDI7XG5jb25zdCBPQkpFQ1RfREFUQSA9IDE7XG5jb25zdCBEQVRFID0gMTY7XG5jb25zdCBUWVBFX05BTUVTID0gWydudW0nLCAnb2JqZWN0JywgJ3N0cmluZycsICdhc2NpaSddO1xuVFlQRV9OQU1FU1tEQVRFXSA9ICdkYXRlJztcbmNvbnN0IGZsb2F0MzJIZWFkZXJzID0gW2ZhbHNlLCB0cnVlLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHRydWUsIHRydWUsIGZhbHNlXTtcbmxldCBldmFsU3VwcG9ydGVkO1xudHJ5IHtcblx0bmV3IEZ1bmN0aW9uKCcnKTtcblx0ZXZhbFN1cHBvcnRlZCA9IHRydWU7XG59IGNhdGNoKGVycm9yKSB7XG5cdC8vIGlmIGV2YWwgdmFyaWFudHMgYXJlIG5vdCBzdXBwb3J0ZWQsIGRvIG5vdCBjcmVhdGUgaW5saW5lIG9iamVjdCByZWFkZXJzIGV2ZXJcbn1cblxubGV0IHVwZGF0ZWRQb3NpdGlvbjtcbmNvbnN0IGhhc05vZGVCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJ1xubGV0IHRleHRFbmNvZGVyLCBjdXJyZW50U291cmNlO1xudHJ5IHtcblx0dGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxufSBjYXRjaCAoZXJyb3IpIHt9XG5jb25zdCBlbmNvZGVVdGY4ID0gaGFzTm9kZUJ1ZmZlciA/IGZ1bmN0aW9uKHRhcmdldCwgc3RyaW5nLCBwb3NpdGlvbikge1xuXHRyZXR1cm4gdGFyZ2V0LnV0ZjhXcml0ZShzdHJpbmcsIHBvc2l0aW9uLCB0YXJnZXQuYnl0ZUxlbmd0aCAtIHBvc2l0aW9uKVxufSA6ICh0ZXh0RW5jb2RlciAmJiB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKSA/XG5cdGZ1bmN0aW9uKHRhcmdldCwgc3RyaW5nLCBwb3NpdGlvbikge1xuXHRcdHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHN0cmluZywgdGFyZ2V0LnN1YmFycmF5KHBvc2l0aW9uKSkud3JpdHRlblxuXHR9IDogZmFsc2VcblxuY29uc3QgVFlQRSA9IFN5bWJvbCgndHlwZScpO1xuY29uc3QgUEFSRU5UID0gU3ltYm9sKCdwYXJlbnQnKTtcbnNldFdyaXRlU3RydWN0U2xvdHMod3JpdGVTdHJ1Y3QsIHByZXBhcmVTdHJ1Y3R1cmVzKTtcbmZ1bmN0aW9uIHdyaXRlU3RydWN0KG9iamVjdCwgdGFyZ2V0LCBlbmNvZGluZ1N0YXJ0LCBwb3NpdGlvbiwgc3RydWN0dXJlcywgbWFrZVJvb20sIHBhY2ssIHBhY2tyKSB7XG5cdGxldCB0eXBlZFN0cnVjdHMgPSBwYWNrci50eXBlZFN0cnVjdHMgfHwgKHBhY2tyLnR5cGVkU3RydWN0cyA9IFtdKTtcblx0Ly8gbm90ZSB0aGF0IHdlIHJlbHkgb24gcGFjay5qcyB0byBsb2FkIHN0b3JlZCBzdHJ1Y3R1cmVzIGJlZm9yZSB3ZSBnZXQgdG8gdGhpcyBwb2ludFxuXHRsZXQgdGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0bGV0IHJlZnNTdGFydFBvc2l0aW9uID0gKHR5cGVkU3RydWN0cy5sYXN0U3RyaW5nU3RhcnQgfHwgMTAwKSArIHBvc2l0aW9uO1xuXHRsZXQgc2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0bGV0IHN0YXJ0ID0gcG9zaXRpb247XG5cdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpIHtcblx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbik7XG5cdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0XHRwb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdHN0YXJ0IC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0cmVmc1N0YXJ0UG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRlbmNvZGluZ1N0YXJ0ID0gMDtcblx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHR9XG5cblx0bGV0IHJlZk9mZnNldCwgcmVmUG9zaXRpb24gPSByZWZzU3RhcnRQb3NpdGlvbjtcblxuXHRsZXQgdHJhbnNpdGlvbiA9IHR5cGVkU3RydWN0cy50cmFuc2l0aW9ucyB8fCAodHlwZWRTdHJ1Y3RzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdGxldCBuZXh0SWQgPSB0eXBlZFN0cnVjdHMubmV4dElkIHx8IHR5cGVkU3RydWN0cy5sZW5ndGg7XG5cdGxldCBoZWFkZXJTaXplID1cblx0XHRuZXh0SWQgPCAweGYgPyAxIDpcblx0XHRcdG5leHRJZCA8IDB4ZjAgPyAyIDpcblx0XHRcdFx0bmV4dElkIDwgMHhmMDAwID8gMyA6XG5cdFx0XHRcdFx0bmV4dElkIDwgMHhmMDAwMDAgPyA0IDogMDtcblx0aWYgKGhlYWRlclNpemUgPT09IDApXG5cdFx0cmV0dXJuIDA7XG5cdHBvc2l0aW9uICs9IGhlYWRlclNpemU7XG5cdGxldCBxdWV1ZWRSZWZlcmVuY2VzID0gW107XG5cdGxldCB1c2VkQXNjaWkwO1xuXHRsZXQga2V5SW5kZXggPSAwO1xuXHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0bGV0IHZhbHVlID0gb2JqZWN0W2tleV07XG5cdFx0bGV0IG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldO1xuXHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdHRyYW5zaXRpb25ba2V5XSA9IG5leHRUcmFuc2l0aW9uID0ge1xuXHRcdFx0XHRrZXksXG5cdFx0XHRcdHBhcmVudDogdHJhbnNpdGlvbixcblx0XHRcdFx0ZW51bWVyYXRpb25PZmZzZXQ6IDAsXG5cdFx0XHRcdGFzY2lpMDogbnVsbCxcblx0XHRcdFx0YXNjaWk4OiBudWxsLFxuXHRcdFx0XHRudW04OiBudWxsLFxuXHRcdFx0XHRzdHJpbmcxNjogbnVsbCxcblx0XHRcdFx0b2JqZWN0MTY6IG51bGwsXG5cdFx0XHRcdG51bTMyOiBudWxsLFxuXHRcdFx0XHRmbG9hdDY0OiBudWxsLFxuXHRcdFx0XHRkYXRlNjQ6IG51bGxcblx0XHRcdH07XG5cdFx0fVxuXHRcdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpIHtcblx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uKTtcblx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdFx0XHRwb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0c3RhcnQgLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdHJlZnNTdGFydFBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRyZWZQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0ZW5jb2RpbmdTdGFydCA9IDA7XG5cdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwXG5cdFx0fVxuXHRcdHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG5cdFx0XHRjYXNlICdudW1iZXInOlxuXHRcdFx0XHRsZXQgbnVtYmVyID0gdmFsdWU7XG5cdFx0XHRcdC8vIGZpcnN0IGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgdXNpbmcgYSBsb3Qgb2YgaWRzIGFuZCBzaG91bGQgZGVmYXVsdCB0byB3aWRlL2NvbW1vbiBmb3JtYXRcblx0XHRcdFx0aWYgKG5leHRJZCA8IDIwMCB8fCAhbmV4dFRyYW5zaXRpb24ubnVtNjQpIHtcblx0XHRcdFx0XHRpZiAobnVtYmVyID4+IDAgPT09IG51bWJlciAmJiBudW1iZXIgPCAweDIwMDAwMDAwICYmIG51bWJlciA+IC0weDFmMDAwMDAwKSB7XG5cdFx0XHRcdFx0XHRpZiAobnVtYmVyIDwgMHhmNiAmJiBudW1iZXIgPj0gMCAmJiAobmV4dFRyYW5zaXRpb24ubnVtOCAmJiAhKG5leHRJZCA+IDIwMCAmJiBuZXh0VHJhbnNpdGlvbi5udW0zMikgfHwgbnVtYmVyIDwgMHgyMCAmJiAhbmV4dFRyYW5zaXRpb24ubnVtMzIpKSB7XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5udW04IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDEpO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBudW1iZXI7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtMzIgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgNCk7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBudW1iZXIsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMCAmJiBudW1iZXIgPj0gLTB4ODAwMDAwMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQzMihwb3NpdGlvbiwgbnVtYmVyLCB0cnVlKTtcblx0XHRcdFx0XHRcdGlmIChmbG9hdDMySGVhZGVyc1t0YXJnZXRbcG9zaXRpb24gKyAzXSA+Pj4gNV0pIHtcblx0XHRcdFx0XHRcdFx0bGV0IHhTaGlmdGVkXG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgY2hlY2tzIGZvciByb3VuZGluZyBvZiBudW1iZXJzIHRoYXQgd2VyZSBlbmNvZGVkIGluIDMyLWJpdCBmbG9hdCB0byBuZWFyZXN0IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXQgdGhhdCBjb3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdFx0XHRcdFx0aWYgKCgoeFNoaWZ0ZWQgPSBudW1iZXIgKiBtdWx0MTBbKCh0YXJnZXRbcG9zaXRpb24gKyAzXSAmIDB4N2YpIDw8IDEpIHwgKHRhcmdldFtwb3NpdGlvbiArIDJdID4+IDcpXSkgPj4gMCkgPT09IHhTaGlmdGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTMyIHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDQpO1xuXHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTY0IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDgpO1xuXHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIG51bWJlciwgdHJ1ZSk7XG5cdFx0XHRcdHBvc2l0aW9uICs9IDg7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdFx0bGV0IHN0ckxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0cmVmT2Zmc2V0ID0gcmVmUG9zaXRpb24gLSByZWZzU3RhcnRQb3NpdGlvbjtcblx0XHRcdFx0aWYgKChzdHJMZW5ndGggPDwgMikgKyByZWZQb3NpdGlvbiA+IHNhZmVFbmQpIHtcblx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbSgoc3RyTGVuZ3RoIDw8IDIpICsgcmVmUG9zaXRpb24pO1xuXHRcdFx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0XHRzdGFydCAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRcdHJlZnNTdGFydFBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRcdFx0cmVmUG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0XHRlbmNvZGluZ1N0YXJ0ID0gMDtcblx0XHRcdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN0ckxlbmd0aCA+ICgoMHhmZjAwICsgcmVmT2Zmc2V0KSA+PiAyKSkge1xuXHRcdFx0XHRcdHF1ZXVlZFJlZmVyZW5jZXMucHVzaChrZXksIHZhbHVlLCBwb3NpdGlvbiAtIHN0YXJ0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgaXNOb3RBc2NpaVxuXHRcdFx0XHRsZXQgc3RyU3RhcnQgPSByZWZQb3NpdGlvbjtcblx0XHRcdFx0aWYgKHN0ckxlbmd0aCA8IDB4NDApIHtcblx0XHRcdFx0XHRsZXQgaSwgYzEsIGMyO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzdHJMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0YzEgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpXG5cdFx0XHRcdFx0XHRpZiAoYzEgPCAweDgwKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGMxIDwgMHg4MDApIHtcblx0XHRcdFx0XHRcdFx0aXNOb3RBc2NpaSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDYgfCAweGMwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODBcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0XHRcdChjMSAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxuXHRcdFx0XHRcdFx0XHQoKGMyID0gdmFsdWUuY2hhckNvZGVBdChpICsgMSkpICYgMHhmYzAwKSA9PT0gMHhkYzAwXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0aXNOb3RBc2NpaSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZilcblx0XHRcdFx0XHRcdFx0aSsrXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDE4IHwgMHhmMFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiAxMiAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDYgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpc05vdEFzY2lpID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgPj4gMTIgfCAweGUwXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDYgJiAweDNmIHwgMHg4MFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSAmIDB4M2YgfCAweDgwXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlZlBvc2l0aW9uICs9IGVuY29kZVV0ZjgodGFyZ2V0LCB2YWx1ZSwgcmVmUG9zaXRpb24pO1xuXHRcdFx0XHRcdGlzTm90QXNjaWkgPSByZWZQb3NpdGlvbiAtIHN0clN0YXJ0ID4gc3RyTGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZWZPZmZzZXQgPCAweGEwIHx8IChyZWZPZmZzZXQgPCAweGY2ICYmIChuZXh0VHJhbnNpdGlvbi5hc2NpaTggfHwgbmV4dFRyYW5zaXRpb24uc3RyaW5nOCkpKSB7XG5cdFx0XHRcdFx0Ly8gc2hvcnQgc3RyaW5nc1xuXHRcdFx0XHRcdGlmIChpc05vdEFzY2lpKSB7XG5cdFx0XHRcdFx0XHRpZiAoISh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uc3RyaW5nOCkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVkU3RydWN0cy5sZW5ndGggPiAxMCAmJiAodHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLmFzY2lpOCkpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBjYW4gc2FmZWx5IGNoYW5nZSBhc2NpaSB0byB1dGY4IGluIHBsYWNlIHNpbmNlIHRoZXkgYXJlIGNvbXBhdGlibGVcblx0XHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uLl9fdHlwZSA9IFVURjg7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24uYXNjaWk4ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbi5zdHJpbmc4ID0gdHJhbnNpdGlvbjtcblx0XHRcdFx0XHRcdFx0XHRwYWNrKG51bGwsIDAsIHRydWUpOyAvLyBzcGVjaWFsIGNhbGwgdG8gbm90aWZ5IHRoYXQgc3RydWN0dXJlcyBoYXZlIGJlZW4gdXBkYXRlZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgVVRGOCwgMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJlZk9mZnNldCA9PT0gMCAmJiAhdXNlZEFzY2lpMCkge1xuXHRcdFx0XHRcdFx0dXNlZEFzY2lpMCA9IHRydWU7XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uYXNjaWkwIHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBBU0NJSSwgMCk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gZG9uJ3QgaW5jcmVtZW50IHBvc2l0aW9uXG5cdFx0XHRcdFx0fS8vIGVsc2UgYXNjaWk6XG5cdFx0XHRcdFx0ZWxzZSBpZiAoISh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uYXNjaWk4KSAmJiAhKHR5cGVkU3RydWN0cy5sZW5ndGggPiAxMCAmJiAodHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLnN0cmluZzgpKSlcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgQVNDSUksIDEpO1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlZk9mZnNldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBUT0RPOiBFbmFibGUgYXNjaWkxNiBhdCBzb21lIHBvaW50LCBidXQgZ2V0IHRoZSBsb2dpYyByaWdodFxuXHRcdFx0XHRcdC8vaWYgKGlzTm90QXNjaWkpXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uc3RyaW5nMTYgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIFVURjgsIDIpO1xuXHRcdFx0XHRcdC8vZWxzZVxuXHRcdFx0XHRcdFx0Ly90cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uYXNjaWkxNiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgQVNDSUksIDIpO1xuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDE2KHBvc2l0aW9uLCByZWZPZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdvYmplY3QnOlxuXHRcdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IERhdGUpIHtcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5kYXRlNjQgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIERBVEUsIDgpO1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDY0KHBvc2l0aW9uLCB2YWx1ZS5nZXRUaW1lKCksIHRydWUpO1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gODtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIGtleUluZGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSB7IC8vIG51bGxcblx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IGFueVR5cGUobmV4dFRyYW5zaXRpb24sIHBvc2l0aW9uLCB0YXJnZXRWaWV3LCAtMTApOyAvLyBtYXRjaCBDQk9SIHdpdGggdGhpc1xuXHRcdFx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uO1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gPSB1cGRhdGVkUG9zaXRpb247XG5cdFx0XHRcdFx0fSBlbHNlIHF1ZXVlZFJlZmVyZW5jZXMucHVzaChrZXksIHZhbHVlLCBrZXlJbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdib29sZWFuJzpcblx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTggfHwgbmV4dFRyYW5zaXRpb24uYXNjaWk4IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDEpO1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSA/IDB4ZjkgOiAweGY4OyAvLyBtYXRjaCBDQk9SIHdpdGggdGhlc2Vcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd1bmRlZmluZWQnOlxuXHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IGFueVR5cGUobmV4dFRyYW5zaXRpb24sIHBvc2l0aW9uLCB0YXJnZXRWaWV3LCAtOSk7IC8vIG1hdGNoIENCT1Igd2l0aCB0aGlzXG5cdFx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbjtcblx0XHRcdFx0XHRwb3NpdGlvbiA9IHVwZGF0ZWRQb3NpdGlvbjtcblx0XHRcdFx0fSBlbHNlIHF1ZXVlZFJlZmVyZW5jZXMucHVzaChrZXksIHZhbHVlLCBrZXlJbmRleCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIGtleUluZGV4KTtcblx0XHR9XG5cdFx0a2V5SW5kZXgrKztcblx0fVxuXG5cdGZvciAobGV0IGkgPSAwLCBsID0gcXVldWVkUmVmZXJlbmNlcy5sZW5ndGg7IGkgPCBsOykge1xuXHRcdGxldCBrZXkgPSBxdWV1ZWRSZWZlcmVuY2VzW2krK107XG5cdFx0bGV0IHZhbHVlID0gcXVldWVkUmVmZXJlbmNlc1tpKytdO1xuXHRcdGxldCBwcm9wZXJ0eUluZGV4ID0gcXVldWVkUmVmZXJlbmNlc1tpKytdO1xuXHRcdGxldCBuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHR0cmFuc2l0aW9uW2tleV0gPSBuZXh0VHJhbnNpdGlvbiA9IHtcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRwYXJlbnQ6IHRyYW5zaXRpb24sXG5cdFx0XHRcdGVudW1lcmF0aW9uT2Zmc2V0OiBwcm9wZXJ0eUluZGV4IC0ga2V5SW5kZXgsXG5cdFx0XHRcdGFzY2lpMDogbnVsbCxcblx0XHRcdFx0YXNjaWk4OiBudWxsLFxuXHRcdFx0XHRudW04OiBudWxsLFxuXHRcdFx0XHRzdHJpbmcxNjogbnVsbCxcblx0XHRcdFx0b2JqZWN0MTY6IG51bGwsXG5cdFx0XHRcdG51bTMyOiBudWxsLFxuXHRcdFx0XHRmbG9hdDY0OiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRsZXQgbmV3UG9zaXRpb247XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHQvKmlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7IC8vIFRPRE86IHdlIGNvdWxkIHJlLWVuYWJsZSBsb25nIHN0cmluZ3Ncblx0XHRcdFx0aWYgKHBvc2l0aW9uICsgdmFsdWUubGVuZ3RoICogMyA+IHNhZmVFbmQpIHtcblx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbiArIHZhbHVlLmxlbmd0aCAqIDMpO1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IHN0YXJ0O1xuXHRcdFx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdFx0XHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld1Bvc2l0aW9uID0gcG9zaXRpb24gKyB0YXJnZXQudXRmOFdyaXRlKHZhbHVlLCBwb3NpdGlvbiwgMHhmZmZmZmZmZik7XG5cdFx0XHR9IGVsc2UgeyAqL1xuXHRcdFx0bGV0IHNpemU7XG5cdFx0XHRyZWZPZmZzZXQgPSByZWZQb3NpdGlvbiAtIHJlZnNTdGFydFBvc2l0aW9uO1xuXHRcdFx0aWYgKHJlZk9mZnNldCA8IDB4ZmYwMCkge1xuXHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ub2JqZWN0MTY7XG5cdFx0XHRcdGlmICh0cmFuc2l0aW9uKVxuXHRcdFx0XHRcdHNpemUgPSAyO1xuXHRcdFx0XHRlbHNlIGlmICgodHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm9iamVjdDMyKSlcblx0XHRcdFx0XHRzaXplID0gNDtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dHJhbnNpdGlvbiA9IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBPQkpFQ1RfREFUQSwgMik7XG5cdFx0XHRcdFx0c2l6ZSA9IDI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5vYmplY3QzMiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgT0JKRUNUX0RBVEEsIDQpO1xuXHRcdFx0XHRzaXplID0gNDtcblx0XHRcdH1cblx0XHRcdG5ld1Bvc2l0aW9uID0gcGFjayh2YWx1ZSwgcmVmUG9zaXRpb24pO1xuXHRcdFx0Ly99XG5cdFx0XHRpZiAodHlwZW9mIG5ld1Bvc2l0aW9uID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHQvLyByZS1hbGxvY2F0ZWRcblx0XHRcdFx0cmVmUG9zaXRpb24gPSBuZXdQb3NpdGlvbi5wb3NpdGlvbjtcblx0XHRcdFx0dGFyZ2V0VmlldyA9IG5ld1Bvc2l0aW9uLnRhcmdldFZpZXc7XG5cdFx0XHRcdHRhcmdldCA9IG5ld1Bvc2l0aW9uLnRhcmdldDtcblx0XHRcdFx0cmVmc1N0YXJ0UG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0cG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0c3RhcnQgLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0ZW5jb2RpbmdTdGFydCA9IDA7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0cmVmUG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcblx0XHRcdGlmIChzaXplID09PSAyKSB7XG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDE2KHBvc2l0aW9uLCByZWZPZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRwb3NpdGlvbiArPSAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIHJlZk9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgLy8gbnVsbCBvciB1bmRlZmluZWRcblx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5vYmplY3QxNiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgT0JKRUNUX0RBVEEsIDIpO1xuXHRcdFx0dGFyZ2V0Vmlldy5zZXRJbnQxNihwb3NpdGlvbiwgdmFsdWUgPT09IG51bGwgPyAtMTAgOiAtOSwgdHJ1ZSk7XG5cdFx0XHRwb3NpdGlvbiArPSAyO1xuXHRcdH1cblx0XHRrZXlJbmRleCsrO1xuXHR9XG5cblxuXHRsZXQgcmVjb3JkSWQgPSB0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdO1xuXHRpZiAocmVjb3JkSWQgPT0gbnVsbCkge1xuXHRcdHJlY29yZElkID0gcGFja3IudHlwZWRTdHJ1Y3RzLmxlbmd0aDtcblx0XHRsZXQgc3RydWN0dXJlID0gW107XG5cdFx0bGV0IG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblx0XHRsZXQga2V5LCB0eXBlO1xuXHRcdHdoaWxlICgodHlwZSA9IG5leHRUcmFuc2l0aW9uLl9fdHlwZSkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bGV0IHNpemUgPSBuZXh0VHJhbnNpdGlvbi5fX3NpemU7XG5cdFx0XHRuZXh0VHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLl9fcGFyZW50O1xuXHRcdFx0a2V5ID0gbmV4dFRyYW5zaXRpb24ua2V5O1xuXHRcdFx0bGV0IHByb3BlcnR5ID0gW3R5cGUsIHNpemUsIGtleV07XG5cdFx0XHRpZiAobmV4dFRyYW5zaXRpb24uZW51bWVyYXRpb25PZmZzZXQpXG5cdFx0XHRcdHByb3BlcnR5LnB1c2gobmV4dFRyYW5zaXRpb24uZW51bWVyYXRpb25PZmZzZXQpO1xuXHRcdFx0c3RydWN0dXJlLnB1c2gocHJvcGVydHkpO1xuXHRcdFx0bmV4dFRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5wYXJlbnQ7XG5cdFx0fVxuXHRcdHN0cnVjdHVyZS5yZXZlcnNlKCk7XG5cdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IHJlY29yZElkO1xuXHRcdHBhY2tyLnR5cGVkU3RydWN0c1tyZWNvcmRJZF0gPSBzdHJ1Y3R1cmU7XG5cdFx0cGFjayhudWxsLCAwLCB0cnVlKTsgLy8gc3BlY2lhbCBjYWxsIHRvIG5vdGlmeSB0aGF0IHN0cnVjdHVyZXMgaGF2ZSBiZWVuIHVwZGF0ZWRcblx0fVxuXG5cblx0c3dpdGNoIChoZWFkZXJTaXplKSB7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0aWYgKHJlY29yZElkID49IDB4MTApIHJldHVybiAwO1xuXHRcdFx0dGFyZ2V0W3N0YXJ0XSA9IHJlY29yZElkICsgMHgyMDtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDEwMCkgcmV0dXJuIDA7XG5cdFx0XHR0YXJnZXRbc3RhcnRdID0gMHgzODtcblx0XHRcdHRhcmdldFtzdGFydCArIDFdID0gcmVjb3JkSWQ7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRpZiAocmVjb3JkSWQgPj0gMHgxMDAwMCkgcmV0dXJuIDA7XG5cdFx0XHR0YXJnZXRbc3RhcnRdID0gMHgzOTtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDE2KHN0YXJ0ICsgMSwgcmVjb3JkSWQsIHRydWUpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA0OlxuXHRcdFx0aWYgKHJlY29yZElkID49IDB4MTAwMDAwMCkgcmV0dXJuIDA7XG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihzdGFydCwgKHJlY29yZElkIDw8IDgpICsgMHgzYSwgdHJ1ZSk7XG5cdFx0XHRicmVhaztcblx0fVxuXG5cdGlmIChwb3NpdGlvbiA8IHJlZnNTdGFydFBvc2l0aW9uKSB7XG5cdFx0aWYgKHJlZnNTdGFydFBvc2l0aW9uID09PSByZWZQb3NpdGlvbilcblx0XHRcdHJldHVybiBwb3NpdGlvbjsgLy8gbm8gcmVmc1xuXHRcdC8vIGFkanVzdCBwb3NpdGlvbmluZ1xuXHRcdHRhcmdldC5jb3B5V2l0aGluKHBvc2l0aW9uLCByZWZzU3RhcnRQb3NpdGlvbiwgcmVmUG9zaXRpb24pO1xuXHRcdHJlZlBvc2l0aW9uICs9IHBvc2l0aW9uIC0gcmVmc1N0YXJ0UG9zaXRpb247XG5cdFx0dHlwZWRTdHJ1Y3RzLmxhc3RTdHJpbmdTdGFydCA9IHBvc2l0aW9uIC0gc3RhcnQ7XG5cdH0gZWxzZSBpZiAocG9zaXRpb24gPiByZWZzU3RhcnRQb3NpdGlvbikge1xuXHRcdGlmIChyZWZzU3RhcnRQb3NpdGlvbiA9PT0gcmVmUG9zaXRpb24pXG5cdFx0XHRyZXR1cm4gcG9zaXRpb247IC8vIG5vIHJlZnNcblx0XHR0eXBlZFN0cnVjdHMubGFzdFN0cmluZ1N0YXJ0ID0gcG9zaXRpb24gLSBzdGFydDtcblx0XHRyZXR1cm4gd3JpdGVTdHJ1Y3Qob2JqZWN0LCB0YXJnZXQsIGVuY29kaW5nU3RhcnQsIHN0YXJ0LCBzdHJ1Y3R1cmVzLCBtYWtlUm9vbSwgcGFjaywgcGFja3IpO1xuXHR9XG5cdHJldHVybiByZWZQb3NpdGlvbjtcbn1cbmZ1bmN0aW9uIGFueVR5cGUodHJhbnNpdGlvbiwgcG9zaXRpb24sIHRhcmdldFZpZXcsIHZhbHVlKSB7XG5cdGxldCBuZXh0VHJhbnNpdGlvbjtcblx0aWYgKChuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb24uYXNjaWk4IHx8IHRyYW5zaXRpb24ubnVtOCkpIHtcblx0XHR0YXJnZXRWaWV3LnNldEludDgocG9zaXRpb24sIHZhbHVlLCB0cnVlKTtcblx0XHR1cGRhdGVkUG9zaXRpb24gPSBwb3NpdGlvbiArIDE7XG5cdFx0cmV0dXJuIG5leHRUcmFuc2l0aW9uO1xuXHR9XG5cdGlmICgobmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uLnN0cmluZzE2IHx8IHRyYW5zaXRpb24ub2JqZWN0MTYpKSB7XG5cdFx0dGFyZ2V0Vmlldy5zZXRJbnQxNihwb3NpdGlvbiwgdmFsdWUsIHRydWUpO1xuXHRcdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgMjtcblx0XHRyZXR1cm4gbmV4dFRyYW5zaXRpb247XG5cdH1cblx0aWYgKG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbi5udW0zMikge1xuXHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCAweGUwMDAwMTAwICsgdmFsdWUsIHRydWUpO1xuXHRcdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgNDtcblx0XHRyZXR1cm4gbmV4dFRyYW5zaXRpb247XG5cdH1cblx0Ly8gdHJhbnNpdGlvbi5mbG9hdDY0XG5cdGlmIChuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb24ubnVtNjQpIHtcblx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIE5hTiwgdHJ1ZSk7XG5cdFx0dGFyZ2V0Vmlldy5zZXRJbnQ4KHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0dXBkYXRlZFBvc2l0aW9uID0gcG9zaXRpb24gKyA4O1xuXHRcdHJldHVybiBuZXh0VHJhbnNpdGlvbjtcblx0fVxuXHR1cGRhdGVkUG9zaXRpb24gPSBwb3NpdGlvbjtcblx0Ly8gVE9ETzogY2FuIHdlIGRvIGFuIFwiYW55XCIgdHlwZSB3aGVyZSB3ZSBkZWZlciB0aGUgZGVjaXNpb24/XG5cdHJldHVybjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVUcmFuc2l0aW9uKHRyYW5zaXRpb24sIHR5cGUsIHNpemUpIHtcblx0bGV0IHR5cGVOYW1lID0gVFlQRV9OQU1FU1t0eXBlXSArIChzaXplIDw8IDMpO1xuXHRsZXQgbmV3VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25bdHlwZU5hbWVdIHx8ICh0cmFuc2l0aW9uW3R5cGVOYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHRuZXdUcmFuc2l0aW9uLl9fdHlwZSA9IHR5cGU7XG5cdG5ld1RyYW5zaXRpb24uX19zaXplID0gc2l6ZTtcblx0bmV3VHJhbnNpdGlvbi5fX3BhcmVudCA9IHRyYW5zaXRpb247XG5cdHJldHVybiBuZXdUcmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gb25Mb2FkZWRTdHJ1Y3R1cmVzKHNoYXJlZERhdGEpIHtcblx0aWYgKCEoc2hhcmVkRGF0YSBpbnN0YW5jZW9mIE1hcCkpXG5cdFx0cmV0dXJuIHNoYXJlZERhdGE7XG5cdGxldCB0eXBlZCA9IHNoYXJlZERhdGEuZ2V0KCd0eXBlZCcpIHx8IFtdO1xuXHRpZiAoT2JqZWN0LmlzRnJvemVuKHR5cGVkKSlcblx0XHR0eXBlZCA9IHR5cGVkLm1hcChzdHJ1Y3R1cmUgPT4gc3RydWN0dXJlLnNsaWNlKDApKTtcblx0bGV0IG5hbWVkID0gc2hhcmVkRGF0YS5nZXQoJ25hbWVkJyk7XG5cdGxldCB0cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGZvciAobGV0IGkgPSAwLCBsID0gdHlwZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0bGV0IHN0cnVjdHVyZSA9IHR5cGVkW2ldO1xuXHRcdGxldCB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbnM7XG5cdFx0Zm9yIChsZXQgW3R5cGUsIHNpemUsIGtleV0gb2Ygc3RydWN0dXJlKSB7XG5cdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV07XG5cdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdHRyYW5zaXRpb25ba2V5XSA9IG5leHRUcmFuc2l0aW9uID0ge1xuXHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRwYXJlbnQ6IHRyYW5zaXRpb24sXG5cdFx0XHRcdFx0ZW51bWVyYXRpb25PZmZzZXQ6IDAsXG5cdFx0XHRcdFx0YXNjaWkwOiBudWxsLFxuXHRcdFx0XHRcdGFzY2lpODogbnVsbCxcblx0XHRcdFx0XHRudW04OiBudWxsLFxuXHRcdFx0XHRcdHN0cmluZzE2OiBudWxsLFxuXHRcdFx0XHRcdG9iamVjdDE2OiBudWxsLFxuXHRcdFx0XHRcdG51bTMyOiBudWxsLFxuXHRcdFx0XHRcdGZsb2F0NjQ6IG51bGwsXG5cdFx0XHRcdFx0ZGF0ZTY0OiBudWxsLFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0dHJhbnNpdGlvbiA9IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCB0eXBlLCBzaXplKTtcblx0XHR9XG5cdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IGk7XG5cdH1cblx0dHlwZWQudHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcblx0dGhpcy50eXBlZFN0cnVjdHMgPSB0eXBlZDtcblx0dGhpcy5sYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gdHlwZWQubGVuZ3RoO1xuXHRyZXR1cm4gbmFtZWQ7XG59XG52YXIgc291cmNlU3ltYm9sID0gU3ltYm9sLmZvcignc291cmNlJylcbmZ1bmN0aW9uIHJlYWRTdHJ1Y3Qoc3JjLCBwb3NpdGlvbiwgc3JjRW5kLCB1bnBhY2tyKSB7XG5cdGxldCByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXSAtIDB4MjA7XG5cdGlmIChyZWNvcmRJZCA+PSAyNCkge1xuXHRcdHN3aXRjaChyZWNvcmRJZCkge1xuXHRcdFx0Y2FzZSAyNDogcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK107IGJyZWFrO1xuXHRcdFx0Ly8gbGl0dGxlIGVuZGlhbjpcblx0XHRcdGNhc2UgMjU6IHJlY29yZElkID0gc3JjW3Bvc2l0aW9uKytdICsgKHNyY1twb3NpdGlvbisrXSA8PCA4KTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI2OiByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXSArIChzcmNbcG9zaXRpb24rK10gPDwgOCkgKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDE2KTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI3OiByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXSArIChzcmNbcG9zaXRpb24rK10gPDwgOCkgKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDE2KSArIChzcmNbcG9zaXRpb24rK10gPDwgMjQpOyBicmVhaztcblx0XHR9XG5cdH1cblx0bGV0IHN0cnVjdHVyZSA9IHVucGFja3IudHlwZWRTdHJ1Y3RzICYmIHVucGFja3IudHlwZWRTdHJ1Y3RzW3JlY29yZElkXTtcblx0aWYgKCFzdHJ1Y3R1cmUpIHtcblx0XHQvLyBjb3B5IHNyYyBidWZmZXIgYmVjYXVzZSBnZXRTdHJ1Y3R1cmVzIHdpbGwgb3ZlcnJpZGUgaXRcblx0XHRzcmMgPSBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNyYywgcG9zaXRpb24sIHNyY0VuZCk7XG5cdFx0c3JjRW5kIC09IHBvc2l0aW9uO1xuXHRcdHBvc2l0aW9uID0gMDtcblx0XHRpZiAoIXVucGFja3IuZ2V0U3RydWN0dXJlcylcblx0XHRcdHRocm93IG5ldyBFcnJvcihgUmVmZXJlbmNlIHRvIHNoYXJlZCBzdHJ1Y3R1cmUgJHtyZWNvcmRJZH0gd2l0aG91dCBnZXRTdHJ1Y3R1cmVzIG1ldGhvZGApO1xuXHRcdHVucGFja3IuX21lcmdlU3RydWN0dXJlcyh1bnBhY2tyLmdldFN0cnVjdHVyZXMoKSk7XG5cdFx0aWYgKCF1bnBhY2tyLnR5cGVkU3RydWN0cylcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYW55IHNoYXJlZCB0eXBlZCBzdHJ1Y3R1cmVzJyk7XG5cdFx0dW5wYWNrci5sYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gdW5wYWNrci50eXBlZFN0cnVjdHMubGVuZ3RoO1xuXHRcdHN0cnVjdHVyZSA9IHVucGFja3IudHlwZWRTdHJ1Y3RzW3JlY29yZElkXTtcblx0XHRpZiAoIXN0cnVjdHVyZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgdHlwZWQgc3RydWN0dXJlICcgKyByZWNvcmRJZCk7XG5cdH1cblx0dmFyIGNvbnN0cnVjdCA9IHN0cnVjdHVyZS5jb25zdHJ1Y3Q7XG5cdHZhciBmdWxsQ29uc3RydWN0ID0gc3RydWN0dXJlLmZ1bGxDb25zdHJ1Y3Q7XG5cdGlmICghY29uc3RydWN0KSB7XG5cdFx0Y29uc3RydWN0ID0gc3RydWN0dXJlLmNvbnN0cnVjdCA9IGZ1bmN0aW9uIExhenlPYmplY3QoKSB7XG5cdFx0fVxuXHRcdGZ1bGxDb25zdHJ1Y3QgPSBzdHJ1Y3R1cmUuZnVsbENvbnN0cnVjdCA9IGZ1bmN0aW9uIExvYWRlZE9iamVjdCgpIHtcblx0XHR9XG5cdFx0ZnVsbENvbnN0cnVjdC5wcm90b3R5cGUgPSB1bnBhY2tyLnN0cnVjdFByb3RvdHlwZSB8fCB7fTtcblx0XHR2YXIgcHJvdG90eXBlID0gY29uc3RydWN0LnByb3RvdHlwZSA9IHVucGFja3Iuc3RydWN0UHJvdG90eXBlID8gT2JqZWN0LmNyZWF0ZSh1bnBhY2tyLnN0cnVjdFByb3RvdHlwZSkgOiB7fTtcblx0XHRsZXQgcHJvcGVydGllcyA9IFtdO1xuXHRcdGxldCBjdXJyZW50T2Zmc2V0ID0gMDtcblx0XHRsZXQgbGFzdFJlZlByb3BlcnR5O1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gc3RydWN0dXJlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bGV0IGRlZmluaXRpb24gPSBzdHJ1Y3R1cmVbaV07XG5cdFx0XHRsZXQgWyB0eXBlLCBzaXplLCBrZXksIGVudW1lcmF0aW9uT2Zmc2V0IF0gPSBkZWZpbml0aW9uO1xuXHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycpXG5cdFx0XHRcdGtleSA9ICdfX3Byb3RvXyc7XG5cdFx0XHRsZXQgcHJvcGVydHkgPSB7XG5cdFx0XHRcdGtleSxcblx0XHRcdFx0b2Zmc2V0OiBjdXJyZW50T2Zmc2V0LFxuXHRcdFx0fVxuXHRcdFx0aWYgKGVudW1lcmF0aW9uT2Zmc2V0KVxuXHRcdFx0XHRwcm9wZXJ0aWVzLnNwbGljZShpICsgZW51bWVyYXRpb25PZmZzZXQsIDAsIHByb3BlcnR5KTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcblx0XHRcdGxldCBnZXRSZWY7XG5cdFx0XHRzd2l0Y2goc2l6ZSkgeyAvLyBUT0RPOiBNb3ZlIGludG8gYSBzZXBhcmF0ZSBmdW5jdGlvblxuXHRcdFx0XHRjYXNlIDA6IGdldFJlZiA9ICgpID0+IDA7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0Z2V0UmVmID0gKHNvdXJjZSwgcG9zaXRpb24pID0+IHtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBzb3VyY2UuYnl0ZXNbcG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXRdO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZiA+PSAweGY2ID8gdG9Db25zdGFudChyZWYpIDogcmVmO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRnZXRSZWYgPSAoc291cmNlLCBwb3NpdGlvbikgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0bGV0IHJlZiA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVmID49IDB4ZmYwMCA/IHRvQ29uc3RhbnQocmVmICYgMHhmZikgOiByZWY7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdGdldFJlZiA9IChzb3VyY2UsIHBvc2l0aW9uKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRsZXQgcmVmID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRcdHJldHVybiByZWYgPj0gMHhmZmZmZmYwMCA/IHRvQ29uc3RhbnQocmVmICYgMHhmZikgOiByZWY7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHByb3BlcnR5LmdldFJlZiA9IGdldFJlZjtcblx0XHRcdGN1cnJlbnRPZmZzZXQgKz0gc2l6ZTtcblx0XHRcdGxldCBnZXQ7XG5cdFx0XHRzd2l0Y2godHlwZSkge1xuXHRcdFx0XHRjYXNlIEFTQ0lJOlxuXHRcdFx0XHRcdGlmIChsYXN0UmVmUHJvcGVydHkgJiYgIWxhc3RSZWZQcm9wZXJ0eS5uZXh0KVxuXHRcdFx0XHRcdFx0bGFzdFJlZlByb3BlcnR5Lm5leHQgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRsYXN0UmVmUHJvcGVydHkgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRwcm9wZXJ0eS5tdWx0aUdldENvdW50ID0gMDtcblx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRsZXQgcG9zaXRpb24gPSBzb3VyY2UucG9zaXRpb247XG5cdFx0XHRcdFx0XHRsZXQgcmVmU3RhcnQgPSBjdXJyZW50T2Zmc2V0ICsgcG9zaXRpb247XG5cdFx0XHRcdFx0XHRsZXQgcmVmID0gZ2V0UmVmKHNvdXJjZSwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiByZWYgIT09ICdudW1iZXInKSByZXR1cm4gcmVmO1xuXG5cdFx0XHRcdFx0XHRsZXQgZW5kLCBuZXh0ID0gcHJvcGVydHkubmV4dDtcblx0XHRcdFx0XHRcdHdoaWxlKG5leHQpIHtcblx0XHRcdFx0XHRcdFx0ZW5kID0gbmV4dC5nZXRSZWYoc291cmNlLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJylcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdGVuZCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdG5leHQgPSBuZXh0Lm5leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoZW5kID09IG51bGwpXG5cdFx0XHRcdFx0XHRcdGVuZCA9IHNvdXJjZS5ieXRlc0VuZCAtIHJlZlN0YXJ0O1xuXHRcdFx0XHRcdFx0aWYgKHNvdXJjZS5zcmNTdHJpbmcpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNvdXJjZS5zcmNTdHJpbmcuc2xpY2UocmVmLCBlbmQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0LyppZiAocHJvcGVydHkubXVsdGlHZXRDb3VudCA+IDApIHtcblx0XHRcdFx0XHRcdFx0bGV0IGFzY2lpRW5kO1xuXHRcdFx0XHRcdFx0XHRuZXh0ID0gZmlyc3RSZWZQcm9wZXJ0eTtcblx0XHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdFx0XHRhc2NpaUVuZCA9IGRhdGFWaWV3LmdldFVpbnQxNihzb3VyY2UucG9zaXRpb24gKyBuZXh0Lm9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGFzY2lpRW5kIDwgMHhmZjAwKVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdFx0YXNjaWlFbmQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9IHdoaWxlKChuZXh0ID0gbmV4dC5uZXh0KSk7XG5cdFx0XHRcdFx0XHRcdGlmIChhc2NpaUVuZCA9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdGFzY2lpRW5kID0gc291cmNlLmJ5dGVzRW5kIC0gcmVmU3RhcnRcblx0XHRcdFx0XHRcdFx0c291cmNlLnNyY1N0cmluZyA9IHNyYy50b1N0cmluZygnbGF0aW4xJywgcmVmU3RhcnQsIHJlZlN0YXJ0ICsgYXNjaWlFbmQpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc291cmNlLnNyY1N0cmluZy5zbGljZShyZWYsIGVuZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoc291cmNlLnByZXZTdHJpbmdHZXQpIHtcblx0XHRcdFx0XHRcdFx0c291cmNlLnByZXZTdHJpbmdHZXQubXVsdGlHZXRDb3VudCArPSAyO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c291cmNlLnByZXZTdHJpbmdHZXQgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRcdFx0cHJvcGVydHkubXVsdGlHZXRDb3VudC0tO1xuXHRcdFx0XHRcdFx0fSovXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZyhzcmMsIHJlZiArIHJlZlN0YXJ0LCBlbmQgLSByZWYpO1xuXHRcdFx0XHRcdFx0Ly9yZXR1cm4gc3JjLnRvU3RyaW5nKCdsYXRpbjEnLCByZWYgKyByZWZTdGFydCwgZW5kICsgcmVmU3RhcnQpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgVVRGODogY2FzZSBPQkpFQ1RfREFUQTpcblx0XHRcdFx0XHRpZiAobGFzdFJlZlByb3BlcnR5ICYmICFsYXN0UmVmUHJvcGVydHkubmV4dClcblx0XHRcdFx0XHRcdGxhc3RSZWZQcm9wZXJ0eS5uZXh0ID0gcHJvcGVydHk7XG5cdFx0XHRcdFx0bGFzdFJlZlByb3BlcnR5ID0gcHJvcGVydHk7XG5cdFx0XHRcdFx0Z2V0ID0gZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0XHRcdFx0XHRsZXQgcG9zaXRpb24gPSBzb3VyY2UucG9zaXRpb247XG5cdFx0XHRcdFx0XHRsZXQgcmVmU3RhcnQgPSBjdXJyZW50T2Zmc2V0ICsgcG9zaXRpb247XG5cdFx0XHRcdFx0XHRsZXQgcmVmID0gZ2V0UmVmKHNvdXJjZSwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiByZWYgIT09ICdudW1iZXInKSByZXR1cm4gcmVmO1xuXHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdGxldCBlbmQsIG5leHQgPSBwcm9wZXJ0eS5uZXh0O1xuXHRcdFx0XHRcdFx0d2hpbGUobmV4dCkge1xuXHRcdFx0XHRcdFx0XHRlbmQgPSBuZXh0LmdldFJlZihzb3VyY2UsIHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBlbmQgPT09ICdudW1iZXInKVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0ZW5kID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0bmV4dCA9IG5leHQubmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChlbmQgPT0gbnVsbClcblx0XHRcdFx0XHRcdFx0ZW5kID0gc291cmNlLmJ5dGVzRW5kIC0gcmVmU3RhcnQ7XG5cdFx0XHRcdFx0XHRpZiAodHlwZSA9PT0gVVRGOCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc3JjLnRvU3RyaW5nKCd1dGY4JywgcmVmICsgcmVmU3RhcnQsIGVuZCArIHJlZlN0YXJ0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRTb3VyY2UgPSBzb3VyY2U7XG5cdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHVucGFja3IudW5wYWNrKHNyYywgeyBzdGFydDogcmVmICsgcmVmU3RhcnQsIGVuZDogZW5kICsgcmVmU3RhcnQgfSk7XG5cdFx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudFNvdXJjZSA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIE5VTUJFUjpcblx0XHRcdFx0XHRzd2l0Y2goc2l6ZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdFx0XHRsZXQgcG9zaXRpb24gPSBzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXQ7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MzIocG9zaXRpb24sIHRydWUpXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlIDwgMHgyMDAwMDAwMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlID4gLTB4MWYwMDAwMDApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA+IC0weDIwMDAwMDAwKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdG9Db25zdGFudCh2YWx1ZSAmIDB4ZmYpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRsZXQgZlZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihwb3NpdGlvbiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBkb2VzIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdFx0XHRcdGxldCBtdWx0aXBsaWVyID0gbXVsdDEwWygoc3JjW3Bvc2l0aW9uICsgM10gJiAweDdmKSA8PCAxKSB8IChzcmNbcG9zaXRpb24gKyAyXSA+PiA3KV1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKChtdWx0aXBsaWVyICogZlZhbHVlICsgKGZWYWx1ZSA+IDAgPyAwLjUgOiAtMC41KSkgPj4gMCkgLyBtdWx0aXBsaWVyO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgODpcblx0XHRcdFx0XHRcdFx0Z2V0ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQ2NChzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxldCBieXRlID0gc3JjW3NvdXJjZS5wb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldF07XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoYnl0ZSA+PSAweGY2KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdG9Db25zdGFudChieXRlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdFx0Z2V0ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHZhbHVlID0gc3JjW3NvdXJjZS5wb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldF07XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlIDwgMHhmNiA/IHZhbHVlIDogdG9Db25zdGFudCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBEQVRFOlxuXHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgRGF0ZShkYXRhVmlldy5nZXRGbG9hdDY0KHNvdXJjZS5wb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldCwgdHJ1ZSkpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblx0XHRcdHByb3BlcnR5LmdldCA9IGdldDtcblx0XHR9XG5cdFx0Ly8gVE9ETzogbG9hZCB0aGUgc3JjU3RyaW5nIGZvciBmYXN0ZXIgc3RyaW5nIGRlY29kaW5nIG9uIHRvSlNPTlxuXHRcdGlmIChldmFsU3VwcG9ydGVkKSB7XG5cdFx0XHRsZXQgb2JqZWN0TGl0ZXJhbFByb3BlcnRpZXMgPSBbXTtcblx0XHRcdGxldCBhcmdzID0gW107XG5cdFx0XHRsZXQgaSA9IDA7XG5cdFx0XHRsZXQgaGFzSW5oZXJpdGVkUHJvcGVydGllcztcblx0XHRcdGZvciAobGV0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHsgLy8gYXNzaWduIGluIGVudW1lcmF0aW9uIG9yZGVyXG5cdFx0XHRcdGlmICh1bnBhY2tyLmFsd2F5c0xhenlQcm9wZXJ0eSAmJiB1bnBhY2tyLmFsd2F5c0xhenlQcm9wZXJ0eShwcm9wZXJ0eS5rZXkpKSB7XG5cdFx0XHRcdFx0Ly8gdGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGVhZ2VybHkgZXZhbHVhdGVkIGFuZCB0aGlzIGNhbiBiZSB1c2VkIGZvciBjcmVhdGluZyBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0Ly8gdGhhdCBhcmUgbm90IHNlcmlhbGl6ZWQgYXMgSlNPTlxuXHRcdFx0XHRcdGhhc0luaGVyaXRlZFByb3BlcnRpZXMgPSB0cnVlO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIHByb3BlcnR5LmtleSwgeyBnZXQ6IHdpdGhTb3VyY2UocHJvcGVydHkuZ2V0KSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblx0XHRcdFx0bGV0IHZhbHVlRnVuY3Rpb24gPSAndicgKyBpKys7XG5cdFx0XHRcdGFyZ3MucHVzaCh2YWx1ZUZ1bmN0aW9uKTtcblx0XHRcdFx0b2JqZWN0TGl0ZXJhbFByb3BlcnRpZXMucHVzaCgnb1snICsgSlNPTi5zdHJpbmdpZnkocHJvcGVydHkua2V5KSArICddPScgKyB2YWx1ZUZ1bmN0aW9uICsgJyhzKScpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc0luaGVyaXRlZFByb3BlcnRpZXMpIHtcblx0XHRcdFx0b2JqZWN0TGl0ZXJhbFByb3BlcnRpZXMucHVzaCgnX19wcm90b19fOnRoaXMnKTtcblx0XHRcdH1cblx0XHRcdGxldCB0b09iamVjdCA9IChuZXcgRnVuY3Rpb24oLi4uYXJncywgJ3ZhciBjPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKHMpe3ZhciBvPW5ldyBjKCk7JyArIG9iamVjdExpdGVyYWxQcm9wZXJ0aWVzLmpvaW4oJzsnKSArICc7cmV0dXJuIG87fScpKS5hcHBseShmdWxsQ29uc3RydWN0LCBwcm9wZXJ0aWVzLm1hcChwcm9wID0+IHByb3AuZ2V0KSk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAndG9KU09OJywge1xuXHRcdFx0XHR2YWx1ZShvbWl0VW5kZXJzY29yZWRQcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRvT2JqZWN0LmNhbGwodGhpcywgdGhpc1tzb3VyY2VTeW1ib2xdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICd0b0pTT04nLCB7XG5cdFx0XHRcdHZhbHVlKG9taXRVbmRlcnNjb3JlZFByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHQvLyByZXR1cm4gYW4gZW51bWVyYWJsZSBvYmplY3Qgd2l0aCBvd24gcHJvcGVydGllcyB0byBKU09OIHN0cmluZ2lmeVxuXHRcdFx0XHRcdGxldCByZXNvbHZlZCA9IHt9O1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdC8vIFRPRE86IGNoZWNrIGFsd2F5c0xhenlQcm9wZXJ0eVxuXHRcdFx0XHRcdFx0bGV0IGtleSA9IHByb3BlcnRpZXNbaV0ua2V5O1xuXG5cdFx0XHRcdFx0XHRyZXNvbHZlZFtrZXldID0gdGhpc1trZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZWQ7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIG5vdCBlbnVtZXJhYmxlIG9yIGFueXRoaW5nXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0dmFyIGluc3RhbmNlID0gbmV3IGNvbnN0cnVjdCgpO1xuXHRpbnN0YW5jZVtzb3VyY2VTeW1ib2xdID0ge1xuXHRcdGJ5dGVzOiBzcmMsXG5cdFx0cG9zaXRpb24sXG5cdFx0c3JjU3RyaW5nOiAnJyxcblx0XHRieXRlc0VuZDogc3JjRW5kXG5cdH1cblx0cmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdG9Db25zdGFudChjb2RlKSB7XG5cdHN3aXRjaChjb2RlKSB7XG5cdFx0Y2FzZSAweGY2OiByZXR1cm4gbnVsbDtcblx0XHRjYXNlIDB4Zjc6IHJldHVybiB1bmRlZmluZWQ7XG5cdFx0Y2FzZSAweGY4OiByZXR1cm4gZmFsc2U7XG5cdFx0Y2FzZSAweGY5OiByZXR1cm4gdHJ1ZTtcblx0fVxuXHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29uc3RhbnQnKTtcbn1cbmZ1bmN0aW9uIHdpdGhTb3VyY2UoZ2V0KSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0KHRoaXNbc291cmNlU3ltYm9sXSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKCkge1xuXHRpZiAoY3VycmVudFNvdXJjZSkge1xuXHRcdGN1cnJlbnRTb3VyY2UuYnl0ZXMgPSBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1cnJlbnRTb3VyY2UuYnl0ZXMsIGN1cnJlbnRTb3VyY2UucG9zaXRpb24sIGN1cnJlbnRTb3VyY2UuYnl0ZXNFbmQpO1xuXHRcdGN1cnJlbnRTb3VyY2UucG9zaXRpb24gPSAwO1xuXHRcdGN1cnJlbnRTb3VyY2UuYnl0ZXNFbmQgPSBjdXJyZW50U291cmNlLmJ5dGVzLmxlbmd0aDtcblx0fVxufVxuZnVuY3Rpb24gcHJlcGFyZVN0cnVjdHVyZXMoc3RydWN0dXJlcywgcGFja3IpIHtcblx0aWYgKHBhY2tyLnR5cGVkU3RydWN0cykge1xuXHRcdGxldCBzdHJ1Y3RNYXAgPSBuZXcgTWFwKCk7XG5cdFx0c3RydWN0TWFwLnNldCgnbmFtZWQnLCBzdHJ1Y3R1cmVzKTtcblx0XHRzdHJ1Y3RNYXAuc2V0KCd0eXBlZCcsIHBhY2tyLnR5cGVkU3RydWN0cyk7XG5cdFx0c3RydWN0dXJlcyA9IHN0cnVjdE1hcDtcblx0fVxuXHRsZXQgbGFzdFR5cGVkU3RydWN0dXJlc0xlbmd0aCA9IHBhY2tyLmxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGggfHwgMDtcblx0c3RydWN0dXJlcy5pc0NvbXBhdGlibGUgPSBleGlzdGluZyA9PiB7XG5cdFx0bGV0IGNvbXBhdGlibGUgPSB0cnVlO1xuXHRcdGlmIChleGlzdGluZyBpbnN0YW5jZW9mIE1hcCkge1xuXHRcdFx0bGV0IG5hbWVkID0gZXhpc3RpbmcuZ2V0KCduYW1lZCcpIHx8IFtdO1xuXHRcdFx0aWYgKG5hbWVkLmxlbmd0aCAhPT0gKHBhY2tyLmxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGggfHwgMCkpXG5cdFx0XHRcdGNvbXBhdGlibGUgPSBmYWxzZTtcblx0XHRcdGxldCB0eXBlZCA9IGV4aXN0aW5nLmdldCgndHlwZWQnKSB8fCBbXTtcblx0XHRcdGlmICh0eXBlZC5sZW5ndGggIT09IGxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGgpXG5cdFx0XHRcdGNvbXBhdGlibGUgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKGV4aXN0aW5nIGluc3RhbmNlb2YgQXJyYXkgfHwgQXJyYXkuaXNBcnJheShleGlzdGluZykpIHtcblx0XHRcdGlmIChleGlzdGluZy5sZW5ndGggIT09IChwYWNrci5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoIHx8IDApKVxuXHRcdFx0XHRjb21wYXRpYmxlID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICghY29tcGF0aWJsZSlcblx0XHRcdHBhY2tyLl9tZXJnZVN0cnVjdHVyZXMoZXhpc3RpbmcpO1xuXHRcdHJldHVybiBjb21wYXRpYmxlO1xuXHR9O1xuXHRwYWNrci5sYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gcGFja3IudHlwZWRTdHJ1Y3RzICYmIHBhY2tyLnR5cGVkU3RydWN0cy5sZW5ndGg7XG5cdHJldHVybiBzdHJ1Y3R1cmVzO1xufVxuXG5zZXRSZWFkU3RydWN0KHJlYWRTdHJ1Y3QsIG9uTG9hZGVkU3RydWN0dXJlcywgc2F2ZVN0YXRlKTtcblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/struct.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/unpack.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/unpack.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C1: () => (/* binding */ C1),\n/* harmony export */   C1Type: () => (/* binding */ C1Type),\n/* harmony export */   Decoder: () => (/* binding */ Decoder),\n/* harmony export */   FLOAT32_OPTIONS: () => (/* binding */ FLOAT32_OPTIONS),\n/* harmony export */   Unpackr: () => (/* binding */ Unpackr),\n/* harmony export */   addExtension: () => (/* binding */ addExtension),\n/* harmony export */   checkedRead: () => (/* binding */ checkedRead),\n/* harmony export */   clearSource: () => (/* binding */ clearSource),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   getPosition: () => (/* binding */ getPosition),\n/* harmony export */   isNativeAccelerationEnabled: () => (/* binding */ isNativeAccelerationEnabled),\n/* harmony export */   loadStructures: () => (/* binding */ loadStructures),\n/* harmony export */   mult10: () => (/* binding */ mult10),\n/* harmony export */   read: () => (/* binding */ read),\n/* harmony export */   readString: () => (/* binding */ readString),\n/* harmony export */   roundFloat32: () => (/* binding */ roundFloat32),\n/* harmony export */   setExtractor: () => (/* binding */ setExtractor),\n/* harmony export */   setReadStruct: () => (/* binding */ setReadStruct),\n/* harmony export */   typedArrays: () => (/* binding */ typedArrays),\n/* harmony export */   unpack: () => (/* binding */ unpack),\n/* harmony export */   unpackMultiple: () => (/* binding */ unpackMultiple)\n/* harmony export */ });\nvar decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nclass C1Type {}\nconst C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nclass Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nfunction getPosition() {\n\treturn position\n}\nfunction checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nfunction read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nfunction loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nlet isNativeAccelerationEnabled = false\n\nfunction setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nfunction readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn asSafeString(read())\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nfunction asSafeString(property) {\n\t// protect against expensive (DoS) string conversions\n\tif (typeof property === 'string') return property;\n\tif (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();\n\tif (property == null) return property + '';\n\tif (currentUnpackr.allowArraysInMapKeys && Array.isArray(property) && property.flat().every(item => ['string', 'number', 'boolean', 'bigint'].includes(typeof item))) {\n\t\treturn property.flat().toString();\n\t}\n\tthrow new Error(`Invalid property type for record: ${typeof property}`);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(asSafeString) // ensure that all keys are strings and\n\t// that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x42] = data => {\n\tlet headLength = (data.byteLength % 8) || 8\n\tlet head = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0])\n\tfor (let i = 1; i < headLength; i++) {\n\t\thead <<= BigInt(8)\n\t\thead += BigInt(data[i])\n\t}\n\tif (data.byteLength !== headLength) {\n\t\tlet view = new DataView(data.buffer, data.byteOffset, data.byteLength)\n\t\tlet decode = (start, end) => {\n\t\t\tlet length = end - start\n\t\t\tif (length <= 40) {\n\t\t\t\tlet out = view.getBigUint64(start)\n\t\t\t\tfor (let i = start + 8; i < end; i += 8) {\n\t\t\t\t\tout <<= BigInt(64n)\n\t\t\t\t\tout |= view.getBigUint64(i)\n\t\t\t\t}\n\t\t\t\treturn out\n\t\t\t}\n\t\t\t// if (length === 8) return view.getBigUint64(start)\n\t\t\tlet middle = start + (length >> 4 << 3)\n\t\t\tlet left = decode(start, middle)\n\t\t\tlet right = decode(middle, end)\n\t\t\treturn (left << BigInt((end - middle) * 8)) | right\n\t\t}\n\t\thead = (head << BigInt((view.byteLength - headLength) * 8)) | decode(headLength, view.byteLength)\n\t}\n\treturn head\n}\n\nlet errors = {\n\tError, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, AggregateError: typeof AggregateError === 'function' ? AggregateError : null,\n}\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\tif (!errors[data[0]]) {\n\t\tlet error = Error(data[1], { cause: data[2] })\n\t\terror.name = data[0]\n\t\treturn error\n\t}\n\treturn errors[data[0]](data[1], { cause: data[2] })\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle any other types that can cycle and make the code more robust if there are other extensions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse if (token >= 0x80 && token < 0x90 || token == 0xde || token == 0xdf)\n\t\ttarget = new Map()\n\telse if ((token >= 0xc7 && token <= 0xc9 || token >= 0xd4 && token <= 0xd8) && src[position + 1] === 0x73)\n\t\ttarget = new Set()\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (!refEntry.used) {\n\t\t// no cycle, can just use the returned read object\n\t\treturn refEntry.target = targetProperties // replace the placeholder with the real one\n\t} else {\n\t\t// there is a cycle, so we have to assign properties to original target\n\t\tObject.assign(target, targetProperties)\n\t}\n\n\t// copy over map/set entries if we're able to\n\tif (target instanceof Map)\n\t\tfor (let [k, v] of targetProperties.entries()) target.set(k, v)\n\tif (target instanceof Set)\n\t\tfor (let i of Array.from(targetProperties)) target.add(i)\n\treturn target\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nconst typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\t// we always have to slice to get a new ArrayBuffer that is aligned\n\tlet buffer = Uint8Array.prototype.slice.call(data, 1).buffer\n\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName) {\n\t\tif (typeCode === 16) return buffer\n\t\tif (typeCode === 17) return new DataView(buffer)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t}\n\treturn new glbl[typedArrayName](buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n}\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nfunction clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nfunction addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nconst mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nconst Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nconst unpack = defaultUnpackr.unpack\nconst unpackMultiple = defaultUnpackr.unpackMultiple\nconst decode = defaultUnpackr.unpack\nconst FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nfunction setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbXNncGFja3JAMS4xMS41L25vZGVfbW9kdWxlcy9tc2dwYWNrci91bnBhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsbUZBQW1GLE1BQU07QUFDekYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRSxPQUFPLDBKQUEwSixFQUFFO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsT0FBTztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ087QUFDUCxtQ0FBbUMsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3lvdXN1a2UvTXlQcm9qZWN0L215LW5leHVzLWFwcC9ub2RlX21vZHVsZXMvLnBucG0vbXNncGFja3JAMS4xMS41L25vZGVfbW9kdWxlcy9tc2dwYWNrci91bnBhY2suanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGRlY29kZXJcbnRyeSB7XG5cdGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxufSBjYXRjaChlcnJvcikge31cbnZhciBzcmNcbnZhciBzcmNFbmRcbnZhciBwb3NpdGlvbiA9IDBcbnZhciBhbHJlYWR5U2V0XG5jb25zdCBFTVBUWV9BUlJBWSA9IFtdXG52YXIgc3RyaW5ncyA9IEVNUFRZX0FSUkFZXG52YXIgc3RyaW5nUG9zaXRpb24gPSAwXG52YXIgY3VycmVudFVucGFja3IgPSB7fVxudmFyIGN1cnJlbnRTdHJ1Y3R1cmVzXG52YXIgc3JjU3RyaW5nXG52YXIgc3JjU3RyaW5nU3RhcnQgPSAwXG52YXIgc3JjU3RyaW5nRW5kID0gMFxudmFyIGJ1bmRsZWRTdHJpbmdzXG52YXIgcmVmZXJlbmNlTWFwXG52YXIgY3VycmVudEV4dGVuc2lvbnMgPSBbXVxudmFyIGRhdGFWaWV3XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdHVzZVJlY29yZHM6IGZhbHNlLFxuXHRtYXBzQXNPYmplY3RzOiB0cnVlXG59XG5leHBvcnQgY2xhc3MgQzFUeXBlIHt9XG5leHBvcnQgY29uc3QgQzEgPSBuZXcgQzFUeXBlKClcbkMxLm5hbWUgPSAnTWVzc2FnZVBhY2sgMHhDMSdcbnZhciBzZXF1ZW50aWFsTW9kZSA9IGZhbHNlXG52YXIgaW5saW5lT2JqZWN0UmVhZFRocmVzaG9sZCA9IDJcbnZhciByZWFkU3RydWN0LCBvbkxvYWRlZFN0cnVjdHVyZXMsIG9uU2F2ZVN0YXRlXG52YXIgQmxvY2tlZEZ1bmN0aW9uIC8vIHdlIHVzZSBzZWFyY2ggYW5kIHJlcGxhY2UgdG8gY2hhbmdlIHRoZSBuZXh0IGNhbGwgdG8gQmxvY2tlZEZ1bmN0aW9uIHRvIGF2b2lkIENTUCBpc3N1ZXMgZm9yXG4vLyBuby1ldmFsIGJ1aWxkXG50cnkge1xuXHRuZXcgRnVuY3Rpb24oJycpXG59IGNhdGNoKGVycm9yKSB7XG5cdC8vIGlmIGV2YWwgdmFyaWFudHMgYXJlIG5vdCBzdXBwb3J0ZWQsIGRvIG5vdCBjcmVhdGUgaW5saW5lIG9iamVjdCByZWFkZXJzIGV2ZXJcblx0aW5saW5lT2JqZWN0UmVhZFRocmVzaG9sZCA9IEluZmluaXR5XG59XG5cbmV4cG9ydCBjbGFzcyBVbnBhY2tyIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdGlmIChvcHRpb25zKSB7XG5cdFx0XHRpZiAob3B0aW9ucy51c2VSZWNvcmRzID09PSBmYWxzZSAmJiBvcHRpb25zLm1hcHNBc09iamVjdHMgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0b3B0aW9ucy5tYXBzQXNPYmplY3RzID0gdHJ1ZVxuXHRcdFx0aWYgKG9wdGlvbnMuc2VxdWVudGlhbCAmJiBvcHRpb25zLnRydXN0ZWQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdG9wdGlvbnMudHJ1c3RlZCA9IHRydWU7XG5cdFx0XHRcdGlmICghb3B0aW9ucy5zdHJ1Y3R1cmVzICYmIG9wdGlvbnMudXNlUmVjb3JkcyAhPSBmYWxzZSkge1xuXHRcdFx0XHRcdG9wdGlvbnMuc3RydWN0dXJlcyA9IFtdXG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLm1heFNoYXJlZFN0cnVjdHVyZXMpXG5cdFx0XHRcdFx0XHRvcHRpb25zLm1heFNoYXJlZFN0cnVjdHVyZXMgPSAwXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChvcHRpb25zLnN0cnVjdHVyZXMpXG5cdFx0XHRcdG9wdGlvbnMuc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPSBvcHRpb25zLnN0cnVjdHVyZXMubGVuZ3RoXG5cdFx0XHRlbHNlIGlmIChvcHRpb25zLmdldFN0cnVjdHVyZXMpIHtcblx0XHRcdFx0KG9wdGlvbnMuc3RydWN0dXJlcyA9IFtdKS51bmluaXRpYWxpemVkID0gdHJ1ZSAvLyB0aGlzIGlzIHdoYXQgd2UgdXNlIHRvIGRlbm90ZSBhbiB1bmluaXRpYWxpemVkIHN0cnVjdHVyZXNcblx0XHRcdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IDBcblx0XHRcdH1cblx0XHRcdGlmIChvcHRpb25zLmludDY0QXNOdW1iZXIpIHtcblx0XHRcdFx0b3B0aW9ucy5pbnQ2NEFzVHlwZSA9ICdudW1iZXInXG5cdFx0XHR9XG5cdFx0fVxuXHRcdE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucylcblx0fVxuXHR1bnBhY2soc291cmNlLCBvcHRpb25zKSB7XG5cdFx0aWYgKHNyYykge1xuXHRcdFx0Ly8gcmUtZW50cmFudCBleGVjdXRpb24sIHNhdmUgdGhlIHN0YXRlIGFuZCByZXN0b3JlIGl0IGFmdGVyIHdlIGRvIHRoaXMgdW5wYWNrXG5cdFx0XHRyZXR1cm4gc2F2ZVN0YXRlKCgpID0+IHtcblx0XHRcdFx0Y2xlYXJTb3VyY2UoKVxuXHRcdFx0XHRyZXR1cm4gdGhpcyA/IHRoaXMudW5wYWNrKHNvdXJjZSwgb3B0aW9ucykgOiBVbnBhY2tyLnByb3RvdHlwZS51bnBhY2suY2FsbChkZWZhdWx0T3B0aW9ucywgc291cmNlLCBvcHRpb25zKVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0aWYgKCFzb3VyY2UuYnVmZmVyICYmIHNvdXJjZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpXG5cdFx0XHRzb3VyY2UgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IEJ1ZmZlci5mcm9tKHNvdXJjZSkgOiBuZXcgVWludDhBcnJheShzb3VyY2UpO1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHNyY0VuZCA9IG9wdGlvbnMuZW5kIHx8IHNvdXJjZS5sZW5ndGhcblx0XHRcdHBvc2l0aW9uID0gb3B0aW9ucy5zdGFydCB8fCAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHBvc2l0aW9uID0gMFxuXHRcdFx0c3JjRW5kID0gb3B0aW9ucyA+IC0xID8gb3B0aW9ucyA6IHNvdXJjZS5sZW5ndGhcblx0XHR9XG5cdFx0c3RyaW5nUG9zaXRpb24gPSAwXG5cdFx0c3JjU3RyaW5nRW5kID0gMFxuXHRcdHNyY1N0cmluZyA9IG51bGxcblx0XHRzdHJpbmdzID0gRU1QVFlfQVJSQVlcblx0XHRidW5kbGVkU3RyaW5ncyA9IG51bGxcblx0XHRzcmMgPSBzb3VyY2Vcblx0XHQvLyB0aGlzIHByb3ZpZGVzIGNhY2hlZCBhY2Nlc3MgdG8gdGhlIGRhdGEgdmlldyBmb3IgYSBidWZmZXIgaWYgaXQgaXMgZ2V0dGluZyByZXVzZWQsIHdoaWNoIGlzIGEgcmVjb21tZW5kXG5cdFx0Ly8gdGVjaG5pcXVlIGZvciBnZXR0aW5nIGRhdGEgZnJvbSBhIGRhdGFiYXNlIHdoZXJlIGl0IGNhbiBiZSBjb3BpZWQgaW50byBhbiBleGlzdGluZyBidWZmZXIgaW5zdGVhZCBvZiBjcmVhdGluZ1xuXHRcdC8vIG5ldyBvbmVzXG5cdFx0dHJ5IHtcblx0XHRcdGRhdGFWaWV3ID0gc291cmNlLmRhdGFWaWV3IHx8IChzb3VyY2UuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKSlcblx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHQvLyBpZiBpdCBkb2Vzbid0IGhhdmUgYSBidWZmZXIsIG1heWJlIGl0IGlzIHRoZSB3cm9uZyB0eXBlIG9mIG9iamVjdFxuXHRcdFx0c3JjID0gbnVsbFxuXHRcdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG5cdFx0XHRcdHRocm93IGVycm9yXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBtdXN0IGJlIGEgVWludDhBcnJheSBvciBCdWZmZXIgYnV0IHdhcyBhICcgKyAoKHNvdXJjZSAmJiB0eXBlb2Ygc291cmNlID09ICdvYmplY3QnKSA/IHNvdXJjZS5jb25zdHJ1Y3Rvci5uYW1lIDogdHlwZW9mIHNvdXJjZSkpXG5cdFx0fVxuXHRcdGlmICh0aGlzIGluc3RhbmNlb2YgVW5wYWNrcikge1xuXHRcdFx0Y3VycmVudFVucGFja3IgPSB0aGlzXG5cdFx0XHRpZiAodGhpcy5zdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzID0gdGhpcy5zdHJ1Y3R1cmVzXG5cdFx0XHRcdHJldHVybiBjaGVja2VkUmVhZChvcHRpb25zKVxuXHRcdFx0fSBlbHNlIGlmICghY3VycmVudFN0cnVjdHVyZXMgfHwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IFtdXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1cnJlbnRVbnBhY2tyID0gZGVmYXVsdE9wdGlvbnNcblx0XHRcdGlmICghY3VycmVudFN0cnVjdHVyZXMgfHwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoID4gMClcblx0XHRcdFx0Y3VycmVudFN0cnVjdHVyZXMgPSBbXVxuXHRcdH1cblx0XHRyZXR1cm4gY2hlY2tlZFJlYWQob3B0aW9ucylcblx0fVxuXHR1bnBhY2tNdWx0aXBsZShzb3VyY2UsIGZvckVhY2gpIHtcblx0XHRsZXQgdmFsdWVzLCBsYXN0UG9zaXRpb24gPSAwXG5cdFx0dHJ5IHtcblx0XHRcdHNlcXVlbnRpYWxNb2RlID0gdHJ1ZVxuXHRcdFx0bGV0IHNpemUgPSBzb3VyY2UubGVuZ3RoXG5cdFx0XHRsZXQgdmFsdWUgPSB0aGlzID8gdGhpcy51bnBhY2soc291cmNlLCBzaXplKSA6IGRlZmF1bHRVbnBhY2tyLnVucGFjayhzb3VyY2UsIHNpemUpXG5cdFx0XHRpZiAoZm9yRWFjaCkge1xuXHRcdFx0XHRpZiAoZm9yRWFjaCh2YWx1ZSwgbGFzdFBvc2l0aW9uLCBwb3NpdGlvbikgPT09IGZhbHNlKSByZXR1cm47XG5cdFx0XHRcdHdoaWxlKHBvc2l0aW9uIDwgc2l6ZSkge1xuXHRcdFx0XHRcdGxhc3RQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdFx0XHRcdFx0aWYgKGZvckVhY2goY2hlY2tlZFJlYWQoKSwgbGFzdFBvc2l0aW9uLCBwb3NpdGlvbikgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YWx1ZXMgPSBbIHZhbHVlIF1cblx0XHRcdFx0d2hpbGUocG9zaXRpb24gPCBzaXplKSB7XG5cdFx0XHRcdFx0bGFzdFBvc2l0aW9uID0gcG9zaXRpb25cblx0XHRcdFx0XHR2YWx1ZXMucHVzaChjaGVja2VkUmVhZCgpKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXNcblx0XHRcdH1cblx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRlcnJvci5sYXN0UG9zaXRpb24gPSBsYXN0UG9zaXRpb25cblx0XHRcdGVycm9yLnZhbHVlcyA9IHZhbHVlc1xuXHRcdFx0dGhyb3cgZXJyb3Jcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2VxdWVudGlhbE1vZGUgPSBmYWxzZVxuXHRcdFx0Y2xlYXJTb3VyY2UoKVxuXHRcdH1cblx0fVxuXHRfbWVyZ2VTdHJ1Y3R1cmVzKGxvYWRlZFN0cnVjdHVyZXMsIGV4aXN0aW5nU3RydWN0dXJlcykge1xuXHRcdGlmIChvbkxvYWRlZFN0cnVjdHVyZXMpXG5cdFx0XHRsb2FkZWRTdHJ1Y3R1cmVzID0gb25Mb2FkZWRTdHJ1Y3R1cmVzLmNhbGwodGhpcywgbG9hZGVkU3RydWN0dXJlcyk7XG5cdFx0bG9hZGVkU3RydWN0dXJlcyA9IGxvYWRlZFN0cnVjdHVyZXMgfHwgW11cblx0XHRpZiAoT2JqZWN0LmlzRnJvemVuKGxvYWRlZFN0cnVjdHVyZXMpKVxuXHRcdFx0bG9hZGVkU3RydWN0dXJlcyA9IGxvYWRlZFN0cnVjdHVyZXMubWFwKHN0cnVjdHVyZSA9PiBzdHJ1Y3R1cmUuc2xpY2UoMCkpXG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBsb2FkZWRTdHJ1Y3R1cmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bGV0IHN0cnVjdHVyZSA9IGxvYWRlZFN0cnVjdHVyZXNbaV1cblx0XHRcdGlmIChzdHJ1Y3R1cmUpIHtcblx0XHRcdFx0c3RydWN0dXJlLmlzU2hhcmVkID0gdHJ1ZVxuXHRcdFx0XHRpZiAoaSA+PSAzMilcblx0XHRcdFx0XHRzdHJ1Y3R1cmUuaGlnaEJ5dGUgPSAoaSAtIDMyKSA+PiA1XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxvYWRlZFN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gbG9hZGVkU3RydWN0dXJlcy5sZW5ndGhcblx0XHRmb3IgKGxldCBpZCBpbiBleGlzdGluZ1N0cnVjdHVyZXMgfHwgW10pIHtcblx0XHRcdGlmIChpZCA+PSAwKSB7XG5cdFx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBsb2FkZWRTdHJ1Y3R1cmVzW2lkXVxuXHRcdFx0XHRsZXQgZXhpc3RpbmcgPSBleGlzdGluZ1N0cnVjdHVyZXNbaWRdXG5cdFx0XHRcdGlmIChleGlzdGluZykge1xuXHRcdFx0XHRcdGlmIChzdHJ1Y3R1cmUpXG5cdFx0XHRcdFx0XHQobG9hZGVkU3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyB8fCAobG9hZGVkU3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyA9IFtdKSlbaWRdID0gc3RydWN0dXJlXG5cdFx0XHRcdFx0bG9hZGVkU3RydWN0dXJlc1tpZF0gPSBleGlzdGluZ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnN0cnVjdHVyZXMgPSBsb2FkZWRTdHJ1Y3R1cmVzXG5cdH1cblx0ZGVjb2RlKHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdHJldHVybiB0aGlzLnVucGFjayhzb3VyY2UsIG9wdGlvbnMpXG5cdH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbigpIHtcblx0cmV0dXJuIHBvc2l0aW9uXG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tlZFJlYWQob3B0aW9ucykge1xuXHR0cnkge1xuXHRcdGlmICghY3VycmVudFVucGFja3IudHJ1c3RlZCAmJiAhc2VxdWVudGlhbE1vZGUpIHtcblx0XHRcdGxldCBzaGFyZWRMZW5ndGggPSBjdXJyZW50U3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMFxuXHRcdFx0aWYgKHNoYXJlZExlbmd0aCA8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aClcblx0XHRcdFx0Y3VycmVudFN0cnVjdHVyZXMubGVuZ3RoID0gc2hhcmVkTGVuZ3RoXG5cdFx0fVxuXHRcdGxldCByZXN1bHRcblx0XHRpZiAoY3VycmVudFVucGFja3IucmFuZG9tQWNjZXNzU3RydWN0dXJlICYmIHNyY1twb3NpdGlvbl0gPCAweDQwICYmIHNyY1twb3NpdGlvbl0gPj0gMHgyMCAmJiByZWFkU3RydWN0KSB7XG5cdFx0XHRyZXN1bHQgPSByZWFkU3RydWN0KHNyYywgcG9zaXRpb24sIHNyY0VuZCwgY3VycmVudFVucGFja3IpXG5cdFx0XHRzcmMgPSBudWxsIC8vIGRpc3Bvc2Ugb2YgdGhpcyBzbyB0aGF0IHJlY3Vyc2l2ZSB1bnBhY2sgY2FsbHMgZG9uJ3Qgc2F2ZSBzdGF0ZVxuXHRcdFx0aWYgKCEob3B0aW9ucyAmJiBvcHRpb25zLmxhenkpICYmIHJlc3VsdClcblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LnRvSlNPTigpXG5cdFx0XHRwb3NpdGlvbiA9IHNyY0VuZFxuXHRcdH0gZWxzZVxuXHRcdFx0cmVzdWx0ID0gcmVhZCgpXG5cdFx0aWYgKGJ1bmRsZWRTdHJpbmdzKSB7IC8vIGJ1bmRsZWQgc3RyaW5ncyB0byBza2lwIHBhc3Rcblx0XHRcdHBvc2l0aW9uID0gYnVuZGxlZFN0cmluZ3MucG9zdEJ1bmRsZVBvc2l0aW9uXG5cdFx0XHRidW5kbGVkU3RyaW5ncyA9IG51bGxcblx0XHR9XG5cdFx0aWYgKHNlcXVlbnRpYWxNb2RlKVxuXHRcdFx0Ly8gd2Ugb25seSBuZWVkIHRvIHJlc3RvcmUgdGhlIHN0cnVjdHVyZXMgaWYgdGhlcmUgd2FzIGFuIGVycm9yLCBidXQgaWYgd2UgY29tcGxldGVkIGEgcmVhZCxcblx0XHRcdC8vIHdlIGNhbiBjbGVhciB0aGlzIG91dCBhbmQga2VlcCB0aGUgc3RydWN0dXJlcyB3ZSByZWFkXG5cdFx0XHRjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyA9IG51bGxcblxuXHRcdGlmIChwb3NpdGlvbiA9PSBzcmNFbmQpIHtcblx0XHRcdC8vIGZpbmlzaGVkIHJlYWRpbmcgdGhpcyBzb3VyY2UsIGNsZWFudXAgcmVmZXJlbmNlc1xuXHRcdFx0aWYgKGN1cnJlbnRTdHJ1Y3R1cmVzICYmIGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzKVxuXHRcdFx0XHRyZXN0b3JlU3RydWN0dXJlcygpXG5cdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IG51bGxcblx0XHRcdHNyYyA9IG51bGxcblx0XHRcdGlmIChyZWZlcmVuY2VNYXApXG5cdFx0XHRcdHJlZmVyZW5jZU1hcCA9IG51bGxcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uID4gc3JjRW5kKSB7XG5cdFx0XHQvLyBvdmVyIHJlYWRcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgTWVzc2FnZVBhY2sgZGF0YScpXG5cdFx0fSBlbHNlIGlmICghc2VxdWVudGlhbE1vZGUpIHtcblx0XHRcdGxldCBqc29uVmlldztcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGpzb25WaWV3ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LCAoXywgdmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IGAke3ZhbHVlfW5gIDogdmFsdWUpLnNsaWNlKDAsIDEwMClcblx0XHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdFx0anNvblZpZXcgPSAnKEpTT04gdmlldyBub3QgYXZhaWxhYmxlICcgKyBlcnJvciArICcpJ1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdEYXRhIHJlYWQsIGJ1dCBlbmQgb2YgYnVmZmVyIG5vdCByZWFjaGVkICcgKyBqc29uVmlldylcblx0XHR9XG5cdFx0Ly8gZWxzZSBtb3JlIHRvIHJlYWQsIGJ1dCB3ZSBhcmUgcmVhZGluZyBzZXF1ZW50aWFsbHksIHNvIGRvbid0IGNsZWFyIHNvdXJjZSB5ZXRcblx0XHRyZXR1cm4gcmVzdWx0XG5cdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRpZiAoY3VycmVudFN0cnVjdHVyZXMgJiYgY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMpXG5cdFx0XHRyZXN0b3JlU3RydWN0dXJlcygpXG5cdFx0Y2xlYXJTb3VyY2UoKVxuXHRcdGlmIChlcnJvciBpbnN0YW5jZW9mIFJhbmdlRXJyb3IgfHwgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKCdVbmV4cGVjdGVkIGVuZCBvZiBidWZmZXInKSB8fCBwb3NpdGlvbiA+IHNyY0VuZCkge1xuXHRcdFx0ZXJyb3IuaW5jb21wbGV0ZSA9IHRydWVcblx0XHR9XG5cdFx0dGhyb3cgZXJyb3Jcblx0fVxufVxuXG5mdW5jdGlvbiByZXN0b3JlU3RydWN0dXJlcygpIHtcblx0Zm9yIChsZXQgaWQgaW4gY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMpIHtcblx0XHRjdXJyZW50U3RydWN0dXJlc1tpZF0gPSBjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlc1tpZF1cblx0fVxuXHRjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyA9IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWQoKSB7XG5cdGxldCB0b2tlbiA9IHNyY1twb3NpdGlvbisrXVxuXHRpZiAodG9rZW4gPCAweGEwKSB7XG5cdFx0aWYgKHRva2VuIDwgMHg4MCkge1xuXHRcdFx0aWYgKHRva2VuIDwgMHg0MClcblx0XHRcdFx0cmV0dXJuIHRva2VuXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGV0IHN0cnVjdHVyZSA9IGN1cnJlbnRTdHJ1Y3R1cmVzW3Rva2VuICYgMHgzZl0gfHxcblx0XHRcdFx0XHRjdXJyZW50VW5wYWNrci5nZXRTdHJ1Y3R1cmVzICYmIGxvYWRTdHJ1Y3R1cmVzKClbdG9rZW4gJiAweDNmXVxuXHRcdFx0XHRpZiAoc3RydWN0dXJlKSB7XG5cdFx0XHRcdFx0aWYgKCFzdHJ1Y3R1cmUucmVhZCkge1xuXHRcdFx0XHRcdFx0c3RydWN0dXJlLnJlYWQgPSBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlLCB0b2tlbiAmIDB4M2YpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBzdHJ1Y3R1cmUucmVhZCgpXG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHJldHVybiB0b2tlblxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodG9rZW4gPCAweDkwKSB7XG5cdFx0XHQvLyBtYXBcblx0XHRcdHRva2VuIC09IDB4ODBcblx0XHRcdGlmIChjdXJyZW50VW5wYWNrci5tYXBzQXNPYmplY3RzKSB7XG5cdFx0XHRcdGxldCBvYmplY3QgPSB7fVxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcblx0XHRcdFx0XHRsZXQga2V5ID0gcmVhZEtleSgpXG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycpXG5cdFx0XHRcdFx0XHRrZXkgPSAnX19wcm90b18nXG5cdFx0XHRcdFx0b2JqZWN0W2tleV0gPSByZWFkKClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb2JqZWN0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgbWFwID0gbmV3IE1hcCgpXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW47IGkrKykge1xuXHRcdFx0XHRcdG1hcC5zZXQocmVhZCgpLCByZWFkKCkpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hcFxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0b2tlbiAtPSAweDkwXG5cdFx0XHRsZXQgYXJyYXkgPSBuZXcgQXJyYXkodG9rZW4pXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcblx0XHRcdFx0YXJyYXlbaV0gPSByZWFkKClcblx0XHRcdH1cblx0XHRcdGlmIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhKVxuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShhcnJheSlcblx0XHRcdHJldHVybiBhcnJheVxuXHRcdH1cblx0fSBlbHNlIGlmICh0b2tlbiA8IDB4YzApIHtcblx0XHQvLyBmaXhzdHJcblx0XHRsZXQgbGVuZ3RoID0gdG9rZW4gLSAweGEwXG5cdFx0aWYgKHNyY1N0cmluZ0VuZCA+PSBwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHNyY1N0cmluZy5zbGljZShwb3NpdGlvbiAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24gKz0gbGVuZ3RoKSAtIHNyY1N0cmluZ1N0YXJ0KVxuXHRcdH1cblx0XHRpZiAoc3JjU3RyaW5nRW5kID09IDAgJiYgc3JjRW5kIDwgMTQwKSB7XG5cdFx0XHQvLyBmb3Igc21hbGwgYmxvY2tzLCBhdm9pZGluZyB0aGUgb3ZlcmhlYWQgb2YgdGhlIGV4dHJhY3QgY2FsbCBpcyBoZWxwZnVsXG5cdFx0XHRsZXQgc3RyaW5nID0gbGVuZ3RoIDwgMTYgPyBzaG9ydFN0cmluZ0luSlMobGVuZ3RoKSA6IGxvbmdTdHJpbmdJbkpTKGxlbmd0aClcblx0XHRcdGlmIChzdHJpbmcgIT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHN0cmluZ1xuXHRcdH1cblx0XHRyZXR1cm4gcmVhZEZpeGVkU3RyaW5nKGxlbmd0aClcblx0fSBlbHNlIHtcblx0XHRsZXQgdmFsdWVcblx0XHRzd2l0Y2ggKHRva2VuKSB7XG5cdFx0XHRjYXNlIDB4YzA6IHJldHVybiBudWxsXG5cdFx0XHRjYXNlIDB4YzE6XG5cdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncykge1xuXHRcdFx0XHRcdHZhbHVlID0gcmVhZCgpIC8vIGZvbGxvd2VkIGJ5IHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyBpbiBjaGFyYWN0ZXJzIChub3QgYnl0ZXMhKVxuXHRcdFx0XHRcdGlmICh2YWx1ZSA+IDApXG5cdFx0XHRcdFx0XHRyZXR1cm4gYnVuZGxlZFN0cmluZ3NbMV0uc2xpY2UoYnVuZGxlZFN0cmluZ3MucG9zaXRpb24xLCBidW5kbGVkU3RyaW5ncy5wb3NpdGlvbjEgKz0gdmFsdWUpXG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0cmV0dXJuIGJ1bmRsZWRTdHJpbmdzWzBdLnNsaWNlKGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uMCwgYnVuZGxlZFN0cmluZ3MucG9zaXRpb24wIC09IHZhbHVlKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBDMTsgLy8gXCJuZXZlci11c2VkXCIsIHJldHVybiBzcGVjaWFsIG9iamVjdCB0byBkZW5vdGUgdGhhdFxuXHRcdFx0Y2FzZSAweGMyOiByZXR1cm4gZmFsc2Vcblx0XHRcdGNhc2UgMHhjMzogcmV0dXJuIHRydWVcblx0XHRcdGNhc2UgMHhjNDpcblx0XHRcdFx0Ly8gYmluIDhcblx0XHRcdFx0dmFsdWUgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBidWZmZXInKVxuXHRcdFx0XHRyZXR1cm4gcmVhZEJpbih2YWx1ZSlcblx0XHRcdGNhc2UgMHhjNTpcblx0XHRcdFx0Ly8gYmluIDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRcdHJldHVybiByZWFkQmluKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM2OlxuXHRcdFx0XHQvLyBiaW4gMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0cmV0dXJuIHJlYWRCaW4odmFsdWUpXG5cdFx0XHRjYXNlIDB4Yzc6XG5cdFx0XHRcdC8vIGV4dCA4XG5cdFx0XHRcdHJldHVybiByZWFkRXh0KHNyY1twb3NpdGlvbisrXSlcblx0XHRcdGNhc2UgMHhjODpcblx0XHRcdFx0Ly8gZXh0IDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRcdHJldHVybiByZWFkRXh0KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM5OlxuXHRcdFx0XHQvLyBleHQgMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQodmFsdWUpXG5cdFx0XHRjYXNlIDB4Y2E6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihwb3NpdGlvbilcblx0XHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLnVzZUZsb2F0MzIgPiAyKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyBkb2VzIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdGxldCBtdWx0aXBsaWVyID0gbXVsdDEwWygoc3JjW3Bvc2l0aW9uXSAmIDB4N2YpIDw8IDEpIHwgKHNyY1twb3NpdGlvbiArIDFdID4+IDcpXVxuXHRcdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0XHRyZXR1cm4gKChtdWx0aXBsaWVyICogdmFsdWUgKyAodmFsdWUgPiAwID8gMC41IDogLTAuNSkpID4+IDApIC8gbXVsdGlwbGllclxuXHRcdFx0XHR9XG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4Y2I6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQ2NChwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gOFxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdC8vIHVpbnQgaGFuZGxlcnNcblx0XHRcdGNhc2UgMHhjYzpcblx0XHRcdFx0cmV0dXJuIHNyY1twb3NpdGlvbisrXVxuXHRcdFx0Y2FzZSAweGNkOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhjZTpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4Y2Y6XG5cdFx0XHRcdGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbikgKiAweDEwMDAwMDAwMFxuXHRcdFx0XHRcdHZhbHVlICs9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiArIDQpXG5cdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdVaW50NjQocG9zaXRpb24pLnRvU3RyaW5nKClcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdVaW50NjQocG9zaXRpb24pXG5cdFx0XHRcdFx0aWYgKHZhbHVlPD1CaWdJbnQoMik8PEJpZ0ludCg1MikpIHZhbHVlPU51bWJlcih2YWx1ZSlcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdVaW50NjQocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDhcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cblx0XHRcdC8vIGludCBoYW5kbGVyc1xuXHRcdFx0Y2FzZSAweGQwOlxuXHRcdFx0XHRyZXR1cm4gZGF0YVZpZXcuZ2V0SW50OChwb3NpdGlvbisrKVxuXHRcdFx0Y2FzZSAweGQxOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEludDE2KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSAyXG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGQyOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEludDMyKHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA0XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGQzOlxuXHRcdFx0XHRpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQzMihwb3NpdGlvbikgKiAweDEwMDAwMDAwMFxuXHRcdFx0XHRcdHZhbHVlICs9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiArIDQpXG5cdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdJbnQ2NChwb3NpdGlvbikudG9TdHJpbmcoKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnYXV0bycpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ0ludDY0KHBvc2l0aW9uKVxuXHRcdFx0XHRcdGlmICh2YWx1ZT49QmlnSW50KC0yKTw8QmlnSW50KDUyKSYmdmFsdWU8PUJpZ0ludCgyKTw8QmlnSW50KDUyKSkgdmFsdWU9TnVtYmVyKHZhbHVlKVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ0ludDY0KHBvc2l0aW9uKVxuXHRcdFx0XHRwb3NpdGlvbiArPSA4XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXG5cdFx0XHRjYXNlIDB4ZDQ6XG5cdFx0XHRcdC8vIGZpeGV4dCAxXG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICh2YWx1ZSA9PSAweDcyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlY29yZERlZmluaXRpb24oc3JjW3Bvc2l0aW9uKytdICYgMHgzZilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZXQgZXh0ZW5zaW9uID0gY3VycmVudEV4dGVuc2lvbnNbdmFsdWVdXG5cdFx0XHRcdFx0aWYgKGV4dGVuc2lvbikge1xuXHRcdFx0XHRcdFx0aWYgKGV4dGVuc2lvbi5yZWFkKSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uKysgLy8gc2tpcCBmaWxsZXIgYnl0ZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uLnJlYWQocmVhZCgpKVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChleHRlbnNpb24ubm9CdWZmZXIpIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24rKyAvLyBza2lwIGZpbGxlciBieXRlXG5cdFx0XHRcdFx0XHRcdHJldHVybiBleHRlbnNpb24oKVxuXHRcdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRcdHJldHVybiBleHRlbnNpb24oc3JjLnN1YmFycmF5KHBvc2l0aW9uLCArK3Bvc2l0aW9uKSlcblx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBleHRlbnNpb24gJyArIHZhbHVlKVxuXHRcdFx0XHR9XG5cdFx0XHRjYXNlIDB4ZDU6XG5cdFx0XHRcdC8vIGZpeGV4dCAyXG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uXVxuXHRcdFx0XHRpZiAodmFsdWUgPT0gMHg3Mikge1xuXHRcdFx0XHRcdHBvc2l0aW9uKytcblx0XHRcdFx0XHRyZXR1cm4gcmVjb3JkRGVmaW5pdGlvbihzcmNbcG9zaXRpb24rK10gJiAweDNmLCBzcmNbcG9zaXRpb24rK10pXG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHJldHVybiByZWFkRXh0KDIpXG5cdFx0XHRjYXNlIDB4ZDY6XG5cdFx0XHRcdC8vIGZpeGV4dCA0XG5cdFx0XHRcdHJldHVybiByZWFkRXh0KDQpXG5cdFx0XHRjYXNlIDB4ZDc6XG5cdFx0XHRcdC8vIGZpeGV4dCA4XG5cdFx0XHRcdHJldHVybiByZWFkRXh0KDgpXG5cdFx0XHRjYXNlIDB4ZDg6XG5cdFx0XHRcdC8vIGZpeGV4dCAxNlxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCgxNilcblx0XHRcdGNhc2UgMHhkOTpcblx0XHRcdC8vIHN0ciA4XG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24pIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uIC0gc3JjU3RyaW5nU3RhcnQsIChwb3NpdGlvbiArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzgodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGE6XG5cdFx0XHQvLyBzdHIgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDJcblx0XHRcdFx0aWYgKHNyY1N0cmluZ0VuZCA+PSBwb3NpdGlvbikge1xuXHRcdFx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24gLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uICs9IHZhbHVlKSAtIHNyY1N0cmluZ1N0YXJ0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZWFkU3RyaW5nMTYodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGI6XG5cdFx0XHQvLyBzdHIgMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0aWYgKHNyY1N0cmluZ0VuZCA+PSBwb3NpdGlvbikge1xuXHRcdFx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24gLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uICs9IHZhbHVlKSAtIHNyY1N0cmluZ1N0YXJ0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZWFkU3RyaW5nMzIodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGM6XG5cdFx0XHQvLyBhcnJheSAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRyZXR1cm4gcmVhZEFycmF5KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRkOlxuXHRcdFx0Ly8gYXJyYXkgMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pXG5cdFx0XHRcdHBvc2l0aW9uICs9IDRcblx0XHRcdFx0cmV0dXJuIHJlYWRBcnJheSh2YWx1ZSlcblx0XHRcdGNhc2UgMHhkZTpcblx0XHRcdC8vIG1hcCAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRyZXR1cm4gcmVhZE1hcCh2YWx1ZSlcblx0XHRcdGNhc2UgMHhkZjpcblx0XHRcdC8vIG1hcCAzMlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRyZXR1cm4gcmVhZE1hcCh2YWx1ZSlcblx0XHRcdGRlZmF1bHQ6IC8vIG5lZ2F0aXZlIGludFxuXHRcdFx0XHRpZiAodG9rZW4gPj0gMHhlMClcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW4gLSAweDEwMFxuXHRcdFx0XHRpZiAodG9rZW4gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGxldCBlcnJvciA9IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgTWVzc2FnZVBhY2sgZGF0YScpXG5cdFx0XHRcdFx0ZXJyb3IuaW5jb21wbGV0ZSA9IHRydWVcblx0XHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBNZXNzYWdlUGFjayB0b2tlbiAnICsgdG9rZW4pXG5cblx0XHR9XG5cdH1cbn1cbmNvbnN0IHZhbGlkTmFtZSA9IC9eW2EtekEtWl8kXVthLXpBLVpcXGRfJF0qJC9cbmZ1bmN0aW9uIGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUsIGZpcnN0SWQpIHtcblx0ZnVuY3Rpb24gcmVhZE9iamVjdCgpIHtcblx0XHQvLyBUaGlzIGluaXRpYWwgZnVuY3Rpb24gaXMgcXVpY2sgdG8gaW5zdGFudGlhdGUsIGJ1dCBydW5zIHNsb3dlci4gQWZ0ZXIgc2V2ZXJhbCBpdGVyYXRpb25zIHBheSB0aGUgY29zdCB0byBidWlsZCB0aGUgZmFzdGVyIGZ1bmN0aW9uXG5cdFx0aWYgKHJlYWRPYmplY3QuY291bnQrKyA+IGlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQpIHtcblx0XHRcdGxldCByZWFkT2JqZWN0ID0gc3RydWN0dXJlLnJlYWQgPSAobmV3IEZ1bmN0aW9uKCdyJywgJ3JldHVybiBmdW5jdGlvbigpe3JldHVybiAnICsgKGN1cnJlbnRVbnBhY2tyLmZyZWV6ZURhdGEgPyAnT2JqZWN0LmZyZWV6ZScgOiAnJykgK1xuXHRcdFx0XHQnKHsnICsgc3RydWN0dXJlLm1hcChrZXkgPT4ga2V5ID09PSAnX19wcm90b19fJyA/ICdfX3Byb3RvXzpyKCknIDogdmFsaWROYW1lLnRlc3Qoa2V5KSA/IGtleSArICc6cigpJyA6ICgnWycgKyBKU09OLnN0cmluZ2lmeShrZXkpICsgJ106cigpJykpLmpvaW4oJywnKSArICd9KX0nKSkocmVhZClcblx0XHRcdGlmIChzdHJ1Y3R1cmUuaGlnaEJ5dGUgPT09IDApXG5cdFx0XHRcdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU2Vjb25kQnl0ZVJlYWRlcihmaXJzdElkLCBzdHJ1Y3R1cmUucmVhZClcblx0XHRcdHJldHVybiByZWFkT2JqZWN0KCkgLy8gc2Vjb25kIGJ5dGUgaXMgYWxyZWFkeSByZWFkLCBpZiB0aGVyZSBpcyBvbmUgc28gaW1tZWRpYXRlbHkgcmVhZCBvYmplY3Rcblx0XHR9XG5cdFx0bGV0IG9iamVjdCA9IHt9XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzdHJ1Y3R1cmUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsZXQga2V5ID0gc3RydWN0dXJlW2ldXG5cdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJylcblx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJ1xuXHRcdFx0b2JqZWN0W2tleV0gPSByZWFkKClcblx0XHR9XG5cdFx0aWYgKGN1cnJlbnRVbnBhY2tyLmZyZWV6ZURhdGEpXG5cdFx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmplY3QpO1xuXHRcdHJldHVybiBvYmplY3Rcblx0fVxuXHRyZWFkT2JqZWN0LmNvdW50ID0gMFxuXHRpZiAoc3RydWN0dXJlLmhpZ2hCeXRlID09PSAwKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZVNlY29uZEJ5dGVSZWFkZXIoZmlyc3RJZCwgcmVhZE9iamVjdClcblx0fVxuXHRyZXR1cm4gcmVhZE9iamVjdFxufVxuXG5jb25zdCBjcmVhdGVTZWNvbmRCeXRlUmVhZGVyID0gKGZpcnN0SWQsIHJlYWQwKSA9PiB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRsZXQgaGlnaEJ5dGUgPSBzcmNbcG9zaXRpb24rK11cblx0XHRpZiAoaGlnaEJ5dGUgPT09IDApXG5cdFx0XHRyZXR1cm4gcmVhZDAoKVxuXHRcdGxldCBpZCA9IGZpcnN0SWQgPCAzMiA/IC0oZmlyc3RJZCArIChoaWdoQnl0ZSA8PCA1KSkgOiBmaXJzdElkICsgKGhpZ2hCeXRlIDw8IDUpXG5cdFx0bGV0IHN0cnVjdHVyZSA9IGN1cnJlbnRTdHJ1Y3R1cmVzW2lkXSB8fCBsb2FkU3RydWN0dXJlcygpW2lkXVxuXHRcdGlmICghc3RydWN0dXJlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1JlY29yZCBpZCBpcyBub3QgZGVmaW5lZCBmb3IgJyArIGlkKVxuXHRcdH1cblx0XHRpZiAoIXN0cnVjdHVyZS5yZWFkKVxuXHRcdFx0c3RydWN0dXJlLnJlYWQgPSBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlLCBmaXJzdElkKVxuXHRcdHJldHVybiBzdHJ1Y3R1cmUucmVhZCgpXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRTdHJ1Y3R1cmVzKCkge1xuXHRsZXQgbG9hZGVkU3RydWN0dXJlcyA9IHNhdmVTdGF0ZSgoKSA9PiB7XG5cdFx0Ly8gc2F2ZSB0aGUgc3RhdGUgaW4gY2FzZSBnZXRTdHJ1Y3R1cmVzIG1vZGlmaWVzIG91ciBidWZmZXJcblx0XHRzcmMgPSBudWxsXG5cdFx0cmV0dXJuIGN1cnJlbnRVbnBhY2tyLmdldFN0cnVjdHVyZXMoKVxuXHR9KVxuXHRyZXR1cm4gY3VycmVudFN0cnVjdHVyZXMgPSBjdXJyZW50VW5wYWNrci5fbWVyZ2VTdHJ1Y3R1cmVzKGxvYWRlZFN0cnVjdHVyZXMsIGN1cnJlbnRTdHJ1Y3R1cmVzKVxufVxuXG52YXIgcmVhZEZpeGVkU3RyaW5nID0gcmVhZFN0cmluZ0pTXG52YXIgcmVhZFN0cmluZzggPSByZWFkU3RyaW5nSlNcbnZhciByZWFkU3RyaW5nMTYgPSByZWFkU3RyaW5nSlNcbnZhciByZWFkU3RyaW5nMzIgPSByZWFkU3RyaW5nSlNcbmV4cG9ydCBsZXQgaXNOYXRpdmVBY2NlbGVyYXRpb25FbmFibGVkID0gZmFsc2VcblxuZXhwb3J0IGZ1bmN0aW9uIHNldEV4dHJhY3RvcihleHRyYWN0U3RyaW5ncykge1xuXHRpc05hdGl2ZUFjY2VsZXJhdGlvbkVuYWJsZWQgPSB0cnVlXG5cdHJlYWRGaXhlZFN0cmluZyA9IHJlYWRTdHJpbmcoMSlcblx0cmVhZFN0cmluZzggPSByZWFkU3RyaW5nKDIpXG5cdHJlYWRTdHJpbmcxNiA9IHJlYWRTdHJpbmcoMylcblx0cmVhZFN0cmluZzMyID0gcmVhZFN0cmluZyg1KVxuXHRmdW5jdGlvbiByZWFkU3RyaW5nKGhlYWRlckxlbmd0aCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiByZWFkU3RyaW5nKGxlbmd0aCkge1xuXHRcdFx0bGV0IHN0cmluZyA9IHN0cmluZ3Nbc3RyaW5nUG9zaXRpb24rK11cblx0XHRcdGlmIChzdHJpbmcgPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MpXG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmdKUyhsZW5ndGgpXG5cdFx0XHRcdGxldCBieXRlT2Zmc2V0ID0gc3JjLmJ5dGVPZmZzZXRcblx0XHRcdFx0bGV0IGV4dHJhY3Rpb24gPSBleHRyYWN0U3RyaW5ncyhwb3NpdGlvbiAtIGhlYWRlckxlbmd0aCArIGJ5dGVPZmZzZXQsIHNyY0VuZCArIGJ5dGVPZmZzZXQsIHNyYy5idWZmZXIpXG5cdFx0XHRcdGlmICh0eXBlb2YgZXh0cmFjdGlvbiA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHN0cmluZyA9IGV4dHJhY3Rpb25cblx0XHRcdFx0XHRzdHJpbmdzID0gRU1QVFlfQVJSQVlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHJpbmdzID0gZXh0cmFjdGlvblxuXHRcdFx0XHRcdHN0cmluZ1Bvc2l0aW9uID0gMVxuXHRcdFx0XHRcdHNyY1N0cmluZ0VuZCA9IDEgLy8gZXZlbiBpZiBhIHV0Zi04IHN0cmluZyB3YXMgZGVjb2RlZCwgbXVzdCBpbmRpY2F0ZSB3ZSBhcmUgaW4gdGhlIG1pZHN0IG9mIGV4dHJhY3RlZCBzdHJpbmdzIGFuZCBjYW4ndCBza2lwIHN0cmluZ3Ncblx0XHRcdFx0XHRzdHJpbmcgPSBzdHJpbmdzWzBdXG5cdFx0XHRcdFx0aWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBidWZmZXInKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsZXQgc3JjU3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuXHRcdFx0aWYgKHNyY1N0cmluZ0xlbmd0aCA8PSBsZW5ndGgpIHtcblx0XHRcdFx0cG9zaXRpb24gKz0gbGVuZ3RoXG5cdFx0XHRcdHJldHVybiBzdHJpbmdcblx0XHRcdH1cblx0XHRcdHNyY1N0cmluZyA9IHN0cmluZ1xuXHRcdFx0c3JjU3RyaW5nU3RhcnQgPSBwb3NpdGlvblxuXHRcdFx0c3JjU3RyaW5nRW5kID0gcG9zaXRpb24gKyBzcmNTdHJpbmdMZW5ndGhcblx0XHRcdHBvc2l0aW9uICs9IGxlbmd0aFxuXHRcdFx0cmV0dXJuIHN0cmluZy5zbGljZSgwLCBsZW5ndGgpIC8vIHdlIGtub3cgd2UganVzdCB3YW50IHRoZSBiZWdpbm5pbmdcblx0XHR9XG5cdH1cbn1cbmZ1bmN0aW9uIHJlYWRTdHJpbmdKUyhsZW5ndGgpIHtcblx0bGV0IHJlc3VsdFxuXHRpZiAobGVuZ3RoIDwgMTYpIHtcblx0XHRpZiAocmVzdWx0ID0gc2hvcnRTdHJpbmdJbkpTKGxlbmd0aCkpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdH1cblx0aWYgKGxlbmd0aCA+IDY0ICYmIGRlY29kZXIpXG5cdFx0cmV0dXJuIGRlY29kZXIuZGVjb2RlKHNyYy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKz0gbGVuZ3RoKSlcblx0Y29uc3QgZW5kID0gcG9zaXRpb24gKyBsZW5ndGhcblx0Y29uc3QgdW5pdHMgPSBbXVxuXHRyZXN1bHQgPSAnJ1xuXHR3aGlsZSAocG9zaXRpb24gPCBlbmQpIHtcblx0XHRjb25zdCBieXRlMSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PT0gMCkge1xuXHRcdFx0Ly8gMSBieXRlXG5cdFx0XHR1bml0cy5wdXNoKGJ5dGUxKVxuXHRcdH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhlMCkgPT09IDB4YzApIHtcblx0XHRcdC8vIDIgYnl0ZXNcblx0XHRcdGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZlxuXHRcdFx0dW5pdHMucHVzaCgoKGJ5dGUxICYgMHgxZikgPDwgNikgfCBieXRlMilcblx0XHR9IGVsc2UgaWYgKChieXRlMSAmIDB4ZjApID09PSAweGUwKSB7XG5cdFx0XHQvLyAzIGJ5dGVzXG5cdFx0XHRjb25zdCBieXRlMiA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Zcblx0XHRcdGNvbnN0IGJ5dGUzID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZlxuXHRcdFx0dW5pdHMucHVzaCgoKGJ5dGUxICYgMHgxZikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTMpXG5cdFx0fSBlbHNlIGlmICgoYnl0ZTEgJiAweGY4KSA9PT0gMHhmMCkge1xuXHRcdFx0Ly8gNCBieXRlc1xuXHRcdFx0Y29uc3QgYnl0ZTIgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmXG5cdFx0XHRjb25zdCBieXRlMyA9IHNyY1twb3NpdGlvbisrXSAmIDB4M2Zcblx0XHRcdGNvbnN0IGJ5dGU0ID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZlxuXHRcdFx0bGV0IHVuaXQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwYykgfCAoYnl0ZTMgPDwgMHgwNikgfCBieXRlNFxuXHRcdFx0aWYgKHVuaXQgPiAweGZmZmYpIHtcblx0XHRcdFx0dW5pdCAtPSAweDEwMDAwXG5cdFx0XHRcdHVuaXRzLnB1c2goKCh1bml0ID4+PiAxMCkgJiAweDNmZikgfCAweGQ4MDApXG5cdFx0XHRcdHVuaXQgPSAweGRjMDAgfCAodW5pdCAmIDB4M2ZmKVxuXHRcdFx0fVxuXHRcdFx0dW5pdHMucHVzaCh1bml0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1bml0cy5wdXNoKGJ5dGUxKVxuXHRcdH1cblxuXHRcdGlmICh1bml0cy5sZW5ndGggPj0gMHgxMDAwKSB7XG5cdFx0XHRyZXN1bHQgKz0gZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgdW5pdHMpXG5cdFx0XHR1bml0cy5sZW5ndGggPSAwXG5cdFx0fVxuXHR9XG5cblx0aWYgKHVuaXRzLmxlbmd0aCA+IDApIHtcblx0XHRyZXN1bHQgKz0gZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgdW5pdHMpXG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZFN0cmluZyhzb3VyY2UsIHN0YXJ0LCBsZW5ndGgpIHtcblx0bGV0IGV4aXN0aW5nU3JjID0gc3JjO1xuXHRzcmMgPSBzb3VyY2U7XG5cdHBvc2l0aW9uID0gc3RhcnQ7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHJlYWRTdHJpbmdKUyhsZW5ndGgpO1xuXHR9IGZpbmFsbHkge1xuXHRcdHNyYyA9IGV4aXN0aW5nU3JjO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlYWRBcnJheShsZW5ndGgpIHtcblx0bGV0IGFycmF5ID0gbmV3IEFycmF5KGxlbmd0aClcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdGFycmF5W2ldID0gcmVhZCgpXG5cdH1cblx0aWYgKGN1cnJlbnRVbnBhY2tyLmZyZWV6ZURhdGEpXG5cdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoYXJyYXkpXG5cdHJldHVybiBhcnJheVxufVxuXG5mdW5jdGlvbiByZWFkTWFwKGxlbmd0aCkge1xuXHRpZiAoY3VycmVudFVucGFja3IubWFwc0FzT2JqZWN0cykge1xuXHRcdGxldCBvYmplY3QgPSB7fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBrZXkgPSByZWFkS2V5KClcblx0XHRcdGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuXHRcdFx0XHRrZXkgPSAnX19wcm90b18nO1xuXHRcdFx0b2JqZWN0W2tleV0gPSByZWFkKClcblx0XHR9XG5cdFx0cmV0dXJuIG9iamVjdFxuXHR9IGVsc2Uge1xuXHRcdGxldCBtYXAgPSBuZXcgTWFwKClcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtYXAuc2V0KHJlYWQoKSwgcmVhZCgpKVxuXHRcdH1cblx0XHRyZXR1cm4gbWFwXG5cdH1cbn1cblxudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbmZ1bmN0aW9uIGxvbmdTdHJpbmdJbkpTKGxlbmd0aCkge1xuXHRsZXQgc3RhcnQgPSBwb3NpdGlvblxuXHRsZXQgYnl0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKVxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgYnl0ZSA9IHNyY1twb3NpdGlvbisrXTtcblx0XHRpZiAoKGJ5dGUgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0cG9zaXRpb24gPSBzdGFydFxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGJ5dGVzW2ldID0gYnl0ZVxuXHRcdH1cblx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgYnl0ZXMpXG59XG5mdW5jdGlvbiBzaG9ydFN0cmluZ0luSlMobGVuZ3RoKSB7XG5cdGlmIChsZW5ndGggPCA0KSB7XG5cdFx0aWYgKGxlbmd0aCA8IDIpIHtcblx0XHRcdGlmIChsZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiAnJ1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBhID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICgoYSAmIDB4ODApID4gMSkge1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IDFcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEpXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBhID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRsZXQgYiA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0aWYgKChhICYgMHg4MCkgPiAwIHx8IChiICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uIC09IDJcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMylcblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiKVxuXHRcdFx0bGV0IGMgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGlmICgoYyAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiAtPSAzXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjKVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRsZXQgYSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdGxldCBiID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0bGV0IGMgPSBzcmNbcG9zaXRpb24rK11cblx0XHRsZXQgZCA9IHNyY1twb3NpdGlvbisrXVxuXHRcdGlmICgoYSAmIDB4ODApID4gMCB8fCAoYiAmIDB4ODApID4gMCB8fCAoYyAmIDB4ODApID4gMCB8fCAoZCAmIDB4ODApID4gMCkge1xuXHRcdFx0cG9zaXRpb24gLT0gNFxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGlmIChsZW5ndGggPCA2KSB7XG5cdFx0XHRpZiAobGVuZ3RoID09PSA0KVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGV0IGUgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0aWYgKChlICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gNVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSlcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDgpIHtcblx0XHRcdGxldCBlID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRsZXQgZiA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0aWYgKChlICYgMHg4MCkgPiAwIHx8IChmICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uIC09IDZcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgNylcblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmKVxuXHRcdFx0bGV0IGcgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGlmICgoZyAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiAtPSA3XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgZSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0bGV0IGYgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdGxldCBnID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRsZXQgaCA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0aWYgKChlICYgMHg4MCkgPiAwIHx8IChmICYgMHg4MCkgPiAwIHx8IChnICYgMHg4MCkgPiAwIHx8IChoICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uIC09IDhcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMTApIHtcblx0XHRcdFx0aWYgKGxlbmd0aCA9PT0gOClcblx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGxldCBpID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdFx0aWYgKChpICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiAtPSA5XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpKVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDEyKSB7XG5cdFx0XHRcdGxldCBpID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGxldCBqID0gc3JjW3Bvc2l0aW9uKytdXG5cdFx0XHRcdGlmICgoaSAmIDB4ODApID4gMCB8fCAoaiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IDEwXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxlbmd0aCA8IDExKVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgailcblx0XHRcdFx0bGV0IGsgPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0aWYgKChrICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gMTFcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGspXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgaSA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRsZXQgaiA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRsZXQgayA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRsZXQgbCA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRpZiAoKGkgJiAweDgwKSA+IDAgfHwgKGogJiAweDgwKSA+IDAgfHwgKGsgJiAweDgwKSA+IDAgfHwgKGwgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxMlxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsZW5ndGggPCAxNCkge1xuXHRcdFx0XHRcdGlmIChsZW5ndGggPT09IDEyKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsKVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0bGV0IG0gPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0XHRcdGlmICgobSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiAtPSAxM1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IG0gPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0XHRsZXQgbiA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRcdGlmICgobSAmIDB4ODApID4gMCB8fCAobiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gLT0gMTRcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobGVuZ3RoIDwgMTUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4pXG5cdFx0XHRcdFx0bGV0IG8gPSBzcmNbcG9zaXRpb24rK11cblx0XHRcdFx0XHRpZiAoKG8gJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uIC09IDE1XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuLCBvKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlYWRPbmx5SlNTdHJpbmcoKSB7XG5cdGxldCB0b2tlbiA9IHNyY1twb3NpdGlvbisrXVxuXHRsZXQgbGVuZ3RoXG5cdGlmICh0b2tlbiA8IDB4YzApIHtcblx0XHQvLyBmaXhzdHJcblx0XHRsZW5ndGggPSB0b2tlbiAtIDB4YTBcblx0fSBlbHNlIHtcblx0XHRzd2l0Y2godG9rZW4pIHtcblx0XHRcdGNhc2UgMHhkOTpcblx0XHRcdC8vIHN0ciA4XG5cdFx0XHRcdGxlbmd0aCA9IHNyY1twb3NpdGlvbisrXVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAweGRhOlxuXHRcdFx0Ly8gc3RyIDE2XG5cdFx0XHRcdGxlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gMlxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAweGRiOlxuXHRcdFx0Ly8gc3RyIDMyXG5cdFx0XHRcdGxlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbilcblx0XHRcdFx0cG9zaXRpb24gKz0gNFxuXHRcdFx0XHRicmVha1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzdHJpbmcnKVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZFN0cmluZ0pTKGxlbmd0aClcbn1cblxuXG5mdW5jdGlvbiByZWFkQmluKGxlbmd0aCkge1xuXHRyZXR1cm4gY3VycmVudFVucGFja3IuY29weUJ1ZmZlcnMgP1xuXHRcdC8vIHNwZWNpZmljYWxseSB1c2UgdGhlIGNvcHlpbmcgc2xpY2UgKG5vdCB0aGUgbm9kZSBvbmUpXG5cdFx0VWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzcmMsIHBvc2l0aW9uLCBwb3NpdGlvbiArPSBsZW5ndGgpIDpcblx0XHRzcmMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICs9IGxlbmd0aClcbn1cbmZ1bmN0aW9uIHJlYWRFeHQobGVuZ3RoKSB7XG5cdGxldCB0eXBlID0gc3JjW3Bvc2l0aW9uKytdXG5cdGlmIChjdXJyZW50RXh0ZW5zaW9uc1t0eXBlXSkge1xuXHRcdGxldCBlbmRcblx0XHRyZXR1cm4gY3VycmVudEV4dGVuc2lvbnNbdHlwZV0oc3JjLnN1YmFycmF5KHBvc2l0aW9uLCBlbmQgPSAocG9zaXRpb24gKz0gbGVuZ3RoKSksIChyZWFkUG9zaXRpb24pID0+IHtcblx0XHRcdHBvc2l0aW9uID0gcmVhZFBvc2l0aW9uO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIHJlYWQoKTtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gZW5kO1xuXHRcdFx0fVxuXHRcdH0pXG5cdH1cblx0ZWxzZVxuXHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBleHRlbnNpb24gdHlwZSAnICsgdHlwZSlcbn1cblxudmFyIGtleUNhY2hlID0gbmV3IEFycmF5KDQwOTYpXG5mdW5jdGlvbiByZWFkS2V5KCkge1xuXHRsZXQgbGVuZ3RoID0gc3JjW3Bvc2l0aW9uKytdXG5cdGlmIChsZW5ndGggPj0gMHhhMCAmJiBsZW5ndGggPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyLCBwb3RlbnRpYWxseSB1c2Uga2V5IGNhY2hlXG5cdFx0bGVuZ3RoID0gbGVuZ3RoIC0gMHhhMFxuXHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24pIC8vIGlmIGl0IGhhcyBiZWVuIGV4dHJhY3RlZCwgbXVzdCB1c2UgaXQgKGFuZCBmYXN0ZXIgYW55d2F5KVxuXHRcdFx0cmV0dXJuIHNyY1N0cmluZy5zbGljZShwb3NpdGlvbiAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24gKz0gbGVuZ3RoKSAtIHNyY1N0cmluZ1N0YXJ0KVxuXHRcdGVsc2UgaWYgKCEoc3JjU3RyaW5nRW5kID09IDAgJiYgc3JjRW5kIDwgMTgwKSlcblx0XHRcdHJldHVybiByZWFkRml4ZWRTdHJpbmcobGVuZ3RoKVxuXHR9IGVsc2UgeyAvLyBub3QgY2FjaGVhYmxlLCBnbyBiYWNrIGFuZCBkbyBhIHN0YW5kYXJkIHJlYWRcblx0XHRwb3NpdGlvbi0tXG5cdFx0cmV0dXJuIGFzU2FmZVN0cmluZyhyZWFkKCkpXG5cdH1cblx0bGV0IGtleSA9ICgobGVuZ3RoIDw8IDUpIF4gKGxlbmd0aCA+IDEgPyBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pIDogbGVuZ3RoID4gMCA/IHNyY1twb3NpdGlvbl0gOiAwKSkgJiAweGZmZlxuXHRsZXQgZW50cnkgPSBrZXlDYWNoZVtrZXldXG5cdGxldCBjaGVja1Bvc2l0aW9uID0gcG9zaXRpb25cblx0bGV0IGVuZCA9IHBvc2l0aW9uICsgbGVuZ3RoIC0gM1xuXHRsZXQgY2h1bmtcblx0bGV0IGkgPSAwXG5cdGlmIChlbnRyeSAmJiBlbnRyeS5ieXRlcyA9PSBsZW5ndGgpIHtcblx0XHR3aGlsZSAoY2hlY2tQb3NpdGlvbiA8IGVuZCkge1xuXHRcdFx0Y2h1bmsgPSBkYXRhVmlldy5nZXRVaW50MzIoY2hlY2tQb3NpdGlvbilcblx0XHRcdGlmIChjaHVuayAhPSBlbnRyeVtpKytdKSB7XG5cdFx0XHRcdGNoZWNrUG9zaXRpb24gPSAweDcwMDAwMDAwXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRjaGVja1Bvc2l0aW9uICs9IDRcblx0XHR9XG5cdFx0ZW5kICs9IDNcblx0XHR3aGlsZSAoY2hlY2tQb3NpdGlvbiA8IGVuZCkge1xuXHRcdFx0Y2h1bmsgPSBzcmNbY2hlY2tQb3NpdGlvbisrXVxuXHRcdFx0aWYgKGNodW5rICE9IGVudHJ5W2krK10pIHtcblx0XHRcdFx0Y2hlY2tQb3NpdGlvbiA9IDB4NzAwMDAwMDBcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNoZWNrUG9zaXRpb24gPT09IGVuZCkge1xuXHRcdFx0cG9zaXRpb24gPSBjaGVja1Bvc2l0aW9uXG5cdFx0XHRyZXR1cm4gZW50cnkuc3RyaW5nXG5cdFx0fVxuXHRcdGVuZCAtPSAzXG5cdFx0Y2hlY2tQb3NpdGlvbiA9IHBvc2l0aW9uXG5cdH1cblx0ZW50cnkgPSBbXVxuXHRrZXlDYWNoZVtrZXldID0gZW50cnlcblx0ZW50cnkuYnl0ZXMgPSBsZW5ndGhcblx0d2hpbGUgKGNoZWNrUG9zaXRpb24gPCBlbmQpIHtcblx0XHRjaHVuayA9IGRhdGFWaWV3LmdldFVpbnQzMihjaGVja1Bvc2l0aW9uKVxuXHRcdGVudHJ5LnB1c2goY2h1bmspXG5cdFx0Y2hlY2tQb3NpdGlvbiArPSA0XG5cdH1cblx0ZW5kICs9IDNcblx0d2hpbGUgKGNoZWNrUG9zaXRpb24gPCBlbmQpIHtcblx0XHRjaHVuayA9IHNyY1tjaGVja1Bvc2l0aW9uKytdXG5cdFx0ZW50cnkucHVzaChjaHVuaylcblx0fVxuXHQvLyBmb3Igc21hbGwgYmxvY2tzLCBhdm9pZGluZyB0aGUgb3ZlcmhlYWQgb2YgdGhlIGV4dHJhY3QgY2FsbCBpcyBoZWxwZnVsXG5cdGxldCBzdHJpbmcgPSBsZW5ndGggPCAxNiA/IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpIDogbG9uZ1N0cmluZ0luSlMobGVuZ3RoKVxuXHRpZiAoc3RyaW5nICE9IG51bGwpXG5cdFx0cmV0dXJuIGVudHJ5LnN0cmluZyA9IHN0cmluZ1xuXHRyZXR1cm4gZW50cnkuc3RyaW5nID0gcmVhZEZpeGVkU3RyaW5nKGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNTYWZlU3RyaW5nKHByb3BlcnR5KSB7XG5cdC8vIHByb3RlY3QgYWdhaW5zdCBleHBlbnNpdmUgKERvUykgc3RyaW5nIGNvbnZlcnNpb25zXG5cdGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSByZXR1cm4gcHJvcGVydHk7XG5cdGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdudW1iZXInIHx8IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2JpZ2ludCcpIHJldHVybiBwcm9wZXJ0eS50b1N0cmluZygpO1xuXHRpZiAocHJvcGVydHkgPT0gbnVsbCkgcmV0dXJuIHByb3BlcnR5ICsgJyc7XG5cdGlmIChjdXJyZW50VW5wYWNrci5hbGxvd0FycmF5c0luTWFwS2V5cyAmJiBBcnJheS5pc0FycmF5KHByb3BlcnR5KSAmJiBwcm9wZXJ0eS5mbGF0KCkuZXZlcnkoaXRlbSA9PiBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbicsICdiaWdpbnQnXS5pbmNsdWRlcyh0eXBlb2YgaXRlbSkpKSB7XG5cdFx0cmV0dXJuIHByb3BlcnR5LmZsYXQoKS50b1N0cmluZygpO1xuXHR9XG5cdHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcm9wZXJ0eSB0eXBlIGZvciByZWNvcmQ6ICR7dHlwZW9mIHByb3BlcnR5fWApO1xufVxuLy8gdGhlIHJlZ2lzdHJhdGlvbiBvZiB0aGUgcmVjb3JkIGRlZmluaXRpb24gZXh0ZW5zaW9uIChhcyBcInJcIilcbmNvbnN0IHJlY29yZERlZmluaXRpb24gPSAoaWQsIGhpZ2hCeXRlKSA9PiB7XG5cdGxldCBzdHJ1Y3R1cmUgPSByZWFkKCkubWFwKGFzU2FmZVN0cmluZykgLy8gZW5zdXJlIHRoYXQgYWxsIGtleXMgYXJlIHN0cmluZ3MgYW5kXG5cdC8vIHRoYXQgdGhlIGFycmF5IGlzIG11dGFibGVcblx0bGV0IGZpcnN0Qnl0ZSA9IGlkXG5cdGlmIChoaWdoQnl0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWQgPSBpZCA8IDMyID8gLSgoaGlnaEJ5dGUgPDwgNSkgKyBpZCkgOiAoKGhpZ2hCeXRlIDw8IDUpICsgaWQpXG5cdFx0c3RydWN0dXJlLmhpZ2hCeXRlID0gaGlnaEJ5dGVcblx0fVxuXHRsZXQgZXhpc3RpbmdTdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1tpZF1cblx0Ly8gSWYgaXQgaXMgYSBzaGFyZWQgc3RydWN0dXJlLCB3ZSBuZWVkIHRvIHJlc3RvcmUgYW55IGNoYW5nZXMgYWZ0ZXIgcmVhZGluZy5cblx0Ly8gQWxzbyBpbiBzZXF1ZW50aWFsIG1vZGUsIHdlIG1heSBnZXQgaW5jb21wbGV0ZSByZWFkcyBhbmQgdGh1cyBlcnJvcnMsIGFuZCB3ZSBuZWVkIHRvIHJlc3RvcmVcblx0Ly8gdG8gdGhlIHN0YXRlIHByaW9yIHRvIGFuIGluY29tcGxldGUgcmVhZCBpbiBvcmRlciB0byBwcm9wZXJseSByZXN1bWUuXG5cdGlmIChleGlzdGluZ1N0cnVjdHVyZSAmJiAoZXhpc3RpbmdTdHJ1Y3R1cmUuaXNTaGFyZWQgfHwgc2VxdWVudGlhbE1vZGUpKSB7XG5cdFx0KGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzIHx8IChjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyA9IFtdKSlbaWRdID0gZXhpc3RpbmdTdHJ1Y3R1cmVcblx0fVxuXHRjdXJyZW50U3RydWN0dXJlc1tpZF0gPSBzdHJ1Y3R1cmVcblx0c3RydWN0dXJlLnJlYWQgPSBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlLCBmaXJzdEJ5dGUpXG5cdHJldHVybiBzdHJ1Y3R1cmUucmVhZCgpXG59XG5jdXJyZW50RXh0ZW5zaW9uc1swXSA9ICgpID0+IHt9IC8vIG5vdGVwYWNrIGRlZmluZXMgZXh0ZW5zaW9uIDAgdG8gbWVhbiB1bmRlZmluZWQsIHNvIHVzZSB0aGF0IGFzIHRoZSBkZWZhdWx0IGhlcmVcbmN1cnJlbnRFeHRlbnNpb25zWzBdLm5vQnVmZmVyID0gdHJ1ZVxuXG5jdXJyZW50RXh0ZW5zaW9uc1sweDQyXSA9IGRhdGEgPT4ge1xuXHRsZXQgaGVhZExlbmd0aCA9IChkYXRhLmJ5dGVMZW5ndGggJSA4KSB8fCA4XG5cdGxldCBoZWFkID0gQmlnSW50KGRhdGFbMF0gJiAweDgwID8gZGF0YVswXSAtIDB4MTAwIDogZGF0YVswXSlcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBoZWFkTGVuZ3RoOyBpKyspIHtcblx0XHRoZWFkIDw8PSBCaWdJbnQoOClcblx0XHRoZWFkICs9IEJpZ0ludChkYXRhW2ldKVxuXHR9XG5cdGlmIChkYXRhLmJ5dGVMZW5ndGggIT09IGhlYWRMZW5ndGgpIHtcblx0XHRsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpXG5cdFx0bGV0IGRlY29kZSA9IChzdGFydCwgZW5kKSA9PiB7XG5cdFx0XHRsZXQgbGVuZ3RoID0gZW5kIC0gc3RhcnRcblx0XHRcdGlmIChsZW5ndGggPD0gNDApIHtcblx0XHRcdFx0bGV0IG91dCA9IHZpZXcuZ2V0QmlnVWludDY0KHN0YXJ0KVxuXHRcdFx0XHRmb3IgKGxldCBpID0gc3RhcnQgKyA4OyBpIDwgZW5kOyBpICs9IDgpIHtcblx0XHRcdFx0XHRvdXQgPDw9IEJpZ0ludCg2NG4pXG5cdFx0XHRcdFx0b3V0IHw9IHZpZXcuZ2V0QmlnVWludDY0KGkpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG91dFxuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgKGxlbmd0aCA9PT0gOCkgcmV0dXJuIHZpZXcuZ2V0QmlnVWludDY0KHN0YXJ0KVxuXHRcdFx0bGV0IG1pZGRsZSA9IHN0YXJ0ICsgKGxlbmd0aCA+PiA0IDw8IDMpXG5cdFx0XHRsZXQgbGVmdCA9IGRlY29kZShzdGFydCwgbWlkZGxlKVxuXHRcdFx0bGV0IHJpZ2h0ID0gZGVjb2RlKG1pZGRsZSwgZW5kKVxuXHRcdFx0cmV0dXJuIChsZWZ0IDw8IEJpZ0ludCgoZW5kIC0gbWlkZGxlKSAqIDgpKSB8IHJpZ2h0XG5cdFx0fVxuXHRcdGhlYWQgPSAoaGVhZCA8PCBCaWdJbnQoKHZpZXcuYnl0ZUxlbmd0aCAtIGhlYWRMZW5ndGgpICogOCkpIHwgZGVjb2RlKGhlYWRMZW5ndGgsIHZpZXcuYnl0ZUxlbmd0aClcblx0fVxuXHRyZXR1cm4gaGVhZFxufVxuXG5sZXQgZXJyb3JzID0ge1xuXHRFcnJvciwgRXZhbEVycm9yLCBSYW5nZUVycm9yLCBSZWZlcmVuY2VFcnJvciwgU3ludGF4RXJyb3IsIFR5cGVFcnJvciwgVVJJRXJyb3IsIEFnZ3JlZ2F0ZUVycm9yOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICdmdW5jdGlvbicgPyBBZ2dyZWdhdGVFcnJvciA6IG51bGwsXG59XG5jdXJyZW50RXh0ZW5zaW9uc1sweDY1XSA9ICgpID0+IHtcblx0bGV0IGRhdGEgPSByZWFkKClcblx0aWYgKCFlcnJvcnNbZGF0YVswXV0pIHtcblx0XHRsZXQgZXJyb3IgPSBFcnJvcihkYXRhWzFdLCB7IGNhdXNlOiBkYXRhWzJdIH0pXG5cdFx0ZXJyb3IubmFtZSA9IGRhdGFbMF1cblx0XHRyZXR1cm4gZXJyb3Jcblx0fVxuXHRyZXR1cm4gZXJyb3JzW2RhdGFbMF1dKGRhdGFbMV0sIHsgY2F1c2U6IGRhdGFbMl0gfSlcbn1cblxuY3VycmVudEV4dGVuc2lvbnNbMHg2OV0gPSAoZGF0YSkgPT4ge1xuXHQvLyBpZCBleHRlbnNpb24gKGZvciBzdHJ1Y3R1cmVkIGNsb25lcylcblx0aWYgKGN1cnJlbnRVbnBhY2tyLnN0cnVjdHVyZWRDbG9uZSA9PT0gZmFsc2UpIHRocm93IG5ldyBFcnJvcignU3RydWN0dXJlZCBjbG9uZSBleHRlbnNpb24gaXMgZGlzYWJsZWQnKVxuXHRsZXQgaWQgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gLSA0KVxuXHRpZiAoIXJlZmVyZW5jZU1hcClcblx0XHRyZWZlcmVuY2VNYXAgPSBuZXcgTWFwKClcblx0bGV0IHRva2VuID0gc3JjW3Bvc2l0aW9uXVxuXHRsZXQgdGFyZ2V0XG5cdC8vIFRPRE86IGhhbmRsZSBhbnkgb3RoZXIgdHlwZXMgdGhhdCBjYW4gY3ljbGUgYW5kIG1ha2UgdGhlIGNvZGUgbW9yZSByb2J1c3QgaWYgdGhlcmUgYXJlIG90aGVyIGV4dGVuc2lvbnNcblx0aWYgKHRva2VuID49IDB4OTAgJiYgdG9rZW4gPCAweGEwIHx8IHRva2VuID09IDB4ZGMgfHwgdG9rZW4gPT0gMHhkZClcblx0XHR0YXJnZXQgPSBbXVxuXHRlbHNlIGlmICh0b2tlbiA+PSAweDgwICYmIHRva2VuIDwgMHg5MCB8fCB0b2tlbiA9PSAweGRlIHx8IHRva2VuID09IDB4ZGYpXG5cdFx0dGFyZ2V0ID0gbmV3IE1hcCgpXG5cdGVsc2UgaWYgKCh0b2tlbiA+PSAweGM3ICYmIHRva2VuIDw9IDB4YzkgfHwgdG9rZW4gPj0gMHhkNCAmJiB0b2tlbiA8PSAweGQ4KSAmJiBzcmNbcG9zaXRpb24gKyAxXSA9PT0gMHg3Mylcblx0XHR0YXJnZXQgPSBuZXcgU2V0KClcblx0ZWxzZVxuXHRcdHRhcmdldCA9IHt9XG5cblx0bGV0IHJlZkVudHJ5ID0geyB0YXJnZXQgfSAvLyBhIHBsYWNlaG9sZGVyIG9iamVjdFxuXHRyZWZlcmVuY2VNYXAuc2V0KGlkLCByZWZFbnRyeSlcblx0bGV0IHRhcmdldFByb3BlcnRpZXMgPSByZWFkKCkgLy8gcmVhZCB0aGUgbmV4dCB2YWx1ZSBhcyB0aGUgdGFyZ2V0IG9iamVjdCB0byBpZFxuXHRpZiAoIXJlZkVudHJ5LnVzZWQpIHtcblx0XHQvLyBubyBjeWNsZSwgY2FuIGp1c3QgdXNlIHRoZSByZXR1cm5lZCByZWFkIG9iamVjdFxuXHRcdHJldHVybiByZWZFbnRyeS50YXJnZXQgPSB0YXJnZXRQcm9wZXJ0aWVzIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIHdpdGggdGhlIHJlYWwgb25lXG5cdH0gZWxzZSB7XG5cdFx0Ly8gdGhlcmUgaXMgYSBjeWNsZSwgc28gd2UgaGF2ZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBvcmlnaW5hbCB0YXJnZXRcblx0XHRPYmplY3QuYXNzaWduKHRhcmdldCwgdGFyZ2V0UHJvcGVydGllcylcblx0fVxuXG5cdC8vIGNvcHkgb3ZlciBtYXAvc2V0IGVudHJpZXMgaWYgd2UncmUgYWJsZSB0b1xuXHRpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwKVxuXHRcdGZvciAobGV0IFtrLCB2XSBvZiB0YXJnZXRQcm9wZXJ0aWVzLmVudHJpZXMoKSkgdGFyZ2V0LnNldChrLCB2KVxuXHRpZiAodGFyZ2V0IGluc3RhbmNlb2YgU2V0KVxuXHRcdGZvciAobGV0IGkgb2YgQXJyYXkuZnJvbSh0YXJnZXRQcm9wZXJ0aWVzKSkgdGFyZ2V0LmFkZChpKVxuXHRyZXR1cm4gdGFyZ2V0XG59XG5cbmN1cnJlbnRFeHRlbnNpb25zWzB4NzBdID0gKGRhdGEpID0+IHtcblx0Ly8gcG9pbnRlciBleHRlbnNpb24gKGZvciBzdHJ1Y3R1cmVkIGNsb25lcylcblx0aWYgKGN1cnJlbnRVbnBhY2tyLnN0cnVjdHVyZWRDbG9uZSA9PT0gZmFsc2UpIHRocm93IG5ldyBFcnJvcignU3RydWN0dXJlZCBjbG9uZSBleHRlbnNpb24gaXMgZGlzYWJsZWQnKVxuXHRsZXQgaWQgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gLSA0KVxuXHRsZXQgcmVmRW50cnkgPSByZWZlcmVuY2VNYXAuZ2V0KGlkKVxuXHRyZWZFbnRyeS51c2VkID0gdHJ1ZVxuXHRyZXR1cm4gcmVmRW50cnkudGFyZ2V0XG59XG5cbmN1cnJlbnRFeHRlbnNpb25zWzB4NzNdID0gKCkgPT4gbmV3IFNldChyZWFkKCkpXG5cbmV4cG9ydCBjb25zdCB0eXBlZEFycmF5cyA9IFsnSW50OCcsJ1VpbnQ4JywnVWludDhDbGFtcGVkJywnSW50MTYnLCdVaW50MTYnLCdJbnQzMicsJ1VpbnQzMicsJ0Zsb2F0MzInLCdGbG9hdDY0JywnQmlnSW50NjQnLCdCaWdVaW50NjQnXS5tYXAodHlwZSA9PiB0eXBlICsgJ0FycmF5JylcblxubGV0IGdsYmwgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgPyBnbG9iYWxUaGlzIDogd2luZG93O1xuY3VycmVudEV4dGVuc2lvbnNbMHg3NF0gPSAoZGF0YSkgPT4ge1xuXHRsZXQgdHlwZUNvZGUgPSBkYXRhWzBdXG5cdC8vIHdlIGFsd2F5cyBoYXZlIHRvIHNsaWNlIHRvIGdldCBhIG5ldyBBcnJheUJ1ZmZlciB0aGF0IGlzIGFsaWduZWRcblx0bGV0IGJ1ZmZlciA9IFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSwgMSkuYnVmZmVyXG5cblx0bGV0IHR5cGVkQXJyYXlOYW1lID0gdHlwZWRBcnJheXNbdHlwZUNvZGVdXG5cdGlmICghdHlwZWRBcnJheU5hbWUpIHtcblx0XHRpZiAodHlwZUNvZGUgPT09IDE2KSByZXR1cm4gYnVmZmVyXG5cdFx0aWYgKHR5cGVDb2RlID09PSAxNykgcmV0dXJuIG5ldyBEYXRhVmlldyhidWZmZXIpXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0eXBlZCBhcnJheSBmb3IgY29kZSAnICsgdHlwZUNvZGUpXG5cdH1cblx0cmV0dXJuIG5ldyBnbGJsW3R5cGVkQXJyYXlOYW1lXShidWZmZXIpXG59XG5jdXJyZW50RXh0ZW5zaW9uc1sweDc4XSA9ICgpID0+IHtcblx0bGV0IGRhdGEgPSByZWFkKClcblx0cmV0dXJuIG5ldyBSZWdFeHAoZGF0YVswXSwgZGF0YVsxXSlcbn1cbmNvbnN0IFRFTVBfQlVORExFID0gW11cbmN1cnJlbnRFeHRlbnNpb25zWzB4NjJdID0gKGRhdGEpID0+IHtcblx0bGV0IGRhdGFTaXplID0gKGRhdGFbMF0gPDwgMjQpICsgKGRhdGFbMV0gPDwgMTYpICsgKGRhdGFbMl0gPDwgOCkgKyBkYXRhWzNdXG5cdGxldCBkYXRhUG9zaXRpb24gPSBwb3NpdGlvblxuXHRwb3NpdGlvbiArPSBkYXRhU2l6ZSAtIGRhdGEubGVuZ3RoXG5cdGJ1bmRsZWRTdHJpbmdzID0gVEVNUF9CVU5ETEVcblx0YnVuZGxlZFN0cmluZ3MgPSBbcmVhZE9ubHlKU1N0cmluZygpLCByZWFkT25seUpTU3RyaW5nKCldXG5cdGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uMCA9IDBcblx0YnVuZGxlZFN0cmluZ3MucG9zaXRpb24xID0gMFxuXHRidW5kbGVkU3RyaW5ncy5wb3N0QnVuZGxlUG9zaXRpb24gPSBwb3NpdGlvblxuXHRwb3NpdGlvbiA9IGRhdGFQb3NpdGlvblxuXHRyZXR1cm4gcmVhZCgpXG59XG5cbmN1cnJlbnRFeHRlbnNpb25zWzB4ZmZdID0gKGRhdGEpID0+IHtcblx0Ly8gMzItYml0IGRhdGUgZXh0ZW5zaW9uXG5cdGlmIChkYXRhLmxlbmd0aCA9PSA0KVxuXHRcdHJldHVybiBuZXcgRGF0ZSgoZGF0YVswXSAqIDB4MTAwMDAwMCArIChkYXRhWzFdIDw8IDE2KSArIChkYXRhWzJdIDw8IDgpICsgZGF0YVszXSkgKiAxMDAwKVxuXHRlbHNlIGlmIChkYXRhLmxlbmd0aCA9PSA4KVxuXHRcdHJldHVybiBuZXcgRGF0ZShcblx0XHRcdCgoZGF0YVswXSA8PCAyMikgKyAoZGF0YVsxXSA8PCAxNCkgKyAoZGF0YVsyXSA8PCA2KSArIChkYXRhWzNdID4+IDIpKSAvIDEwMDAwMDAgK1xuXHRcdFx0KChkYXRhWzNdICYgMHgzKSAqIDB4MTAwMDAwMDAwICsgZGF0YVs0XSAqIDB4MTAwMDAwMCArIChkYXRhWzVdIDw8IDE2KSArIChkYXRhWzZdIDw8IDgpICsgZGF0YVs3XSkgKiAxMDAwKVxuXHRlbHNlIGlmIChkYXRhLmxlbmd0aCA9PSAxMilcblx0XHRyZXR1cm4gbmV3IERhdGUoXG5cdFx0XHQoKGRhdGFbMF0gPDwgMjQpICsgKGRhdGFbMV0gPDwgMTYpICsgKGRhdGFbMl0gPDwgOCkgKyBkYXRhWzNdKSAvIDEwMDAwMDAgK1xuXHRcdFx0KCgoZGF0YVs0XSAmIDB4ODApID8gLTB4MTAwMDAwMDAwMDAwMCA6IDApICsgZGF0YVs2XSAqIDB4MTAwMDAwMDAwMDAgKyBkYXRhWzddICogMHgxMDAwMDAwMDAgKyBkYXRhWzhdICogMHgxMDAwMDAwICsgKGRhdGFbOV0gPDwgMTYpICsgKGRhdGFbMTBdIDw8IDgpICsgZGF0YVsxMV0pICogMTAwMClcblx0ZWxzZVxuXHRcdHJldHVybiBuZXcgRGF0ZSgnaW52YWxpZCcpXG59XG4vLyByZWdpc3RyYXRpb24gb2YgYnVsayByZWNvcmQgZGVmaW5pdGlvbj9cbi8vIGN1cnJlbnRFeHRlbnNpb25zWzB4NTJdID0gKCkgPT5cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKGNhbGxiYWNrKSB7XG5cdGlmIChvblNhdmVTdGF0ZSlcblx0XHRvblNhdmVTdGF0ZSgpO1xuXHRsZXQgc2F2ZWRTcmNFbmQgPSBzcmNFbmRcblx0bGV0IHNhdmVkUG9zaXRpb24gPSBwb3NpdGlvblxuXHRsZXQgc2F2ZWRTdHJpbmdQb3NpdGlvbiA9IHN0cmluZ1Bvc2l0aW9uXG5cdGxldCBzYXZlZFNyY1N0cmluZ1N0YXJ0ID0gc3JjU3RyaW5nU3RhcnRcblx0bGV0IHNhdmVkU3JjU3RyaW5nRW5kID0gc3JjU3RyaW5nRW5kXG5cdGxldCBzYXZlZFNyY1N0cmluZyA9IHNyY1N0cmluZ1xuXHRsZXQgc2F2ZWRTdHJpbmdzID0gc3RyaW5nc1xuXHRsZXQgc2F2ZWRSZWZlcmVuY2VNYXAgPSByZWZlcmVuY2VNYXBcblx0bGV0IHNhdmVkQnVuZGxlZFN0cmluZ3MgPSBidW5kbGVkU3RyaW5nc1xuXG5cdC8vIFRPRE86IFdlIG1heSBuZWVkIHRvIHJldmlzaXQgdGhpcyBpZiB3ZSBkbyBtb3JlIGV4dGVybmFsIGNhbGxzIHRvIHVzZXIgY29kZSAoc2luY2UgaXQgY291bGQgYmUgc2xvdylcblx0bGV0IHNhdmVkU3JjID0gbmV3IFVpbnQ4QXJyYXkoc3JjLnNsaWNlKDAsIHNyY0VuZCkpIC8vIHdlIGNvcHkgdGhlIGRhdGEgaW4gY2FzZSBpdCBjaGFuZ2VzIHdoaWxlIGV4dGVybmFsIGRhdGEgaXMgcHJvY2Vzc2VkXG5cdGxldCBzYXZlZFN0cnVjdHVyZXMgPSBjdXJyZW50U3RydWN0dXJlc1xuXHRsZXQgc2F2ZWRTdHJ1Y3R1cmVzQ29udGVudHMgPSBjdXJyZW50U3RydWN0dXJlcy5zbGljZSgwLCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGgpXG5cdGxldCBzYXZlZFBhY2tyID0gY3VycmVudFVucGFja3Jcblx0bGV0IHNhdmVkU2VxdWVudGlhbE1vZGUgPSBzZXF1ZW50aWFsTW9kZVxuXHRsZXQgdmFsdWUgPSBjYWxsYmFjaygpXG5cdHNyY0VuZCA9IHNhdmVkU3JjRW5kXG5cdHBvc2l0aW9uID0gc2F2ZWRQb3NpdGlvblxuXHRzdHJpbmdQb3NpdGlvbiA9IHNhdmVkU3RyaW5nUG9zaXRpb25cblx0c3JjU3RyaW5nU3RhcnQgPSBzYXZlZFNyY1N0cmluZ1N0YXJ0XG5cdHNyY1N0cmluZ0VuZCA9IHNhdmVkU3JjU3RyaW5nRW5kXG5cdHNyY1N0cmluZyA9IHNhdmVkU3JjU3RyaW5nXG5cdHN0cmluZ3MgPSBzYXZlZFN0cmluZ3Ncblx0cmVmZXJlbmNlTWFwID0gc2F2ZWRSZWZlcmVuY2VNYXBcblx0YnVuZGxlZFN0cmluZ3MgPSBzYXZlZEJ1bmRsZWRTdHJpbmdzXG5cdHNyYyA9IHNhdmVkU3JjXG5cdHNlcXVlbnRpYWxNb2RlID0gc2F2ZWRTZXF1ZW50aWFsTW9kZVxuXHRjdXJyZW50U3RydWN0dXJlcyA9IHNhdmVkU3RydWN0dXJlc1xuXHRjdXJyZW50U3RydWN0dXJlcy5zcGxpY2UoMCwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoLCAuLi5zYXZlZFN0cnVjdHVyZXNDb250ZW50cylcblx0Y3VycmVudFVucGFja3IgPSBzYXZlZFBhY2tyXG5cdGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aClcblx0cmV0dXJuIHZhbHVlXG59XG5leHBvcnQgZnVuY3Rpb24gY2xlYXJTb3VyY2UoKSB7XG5cdHNyYyA9IG51bGxcblx0cmVmZXJlbmNlTWFwID0gbnVsbFxuXHRjdXJyZW50U3RydWN0dXJlcyA9IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEV4dGVuc2lvbihleHRlbnNpb24pIHtcblx0aWYgKGV4dGVuc2lvbi51bnBhY2spXG5cdFx0Y3VycmVudEV4dGVuc2lvbnNbZXh0ZW5zaW9uLnR5cGVdID0gZXh0ZW5zaW9uLnVucGFja1xuXHRlbHNlXG5cdFx0Y3VycmVudEV4dGVuc2lvbnNbZXh0ZW5zaW9uLnR5cGVdID0gZXh0ZW5zaW9uXG59XG5cbmV4cG9ydCBjb25zdCBtdWx0MTAgPSBuZXcgQXJyYXkoMTQ3KSAvLyB0aGlzIGlzIGEgdGFibGUgbWF0Y2hpbmcgYmluYXJ5IGV4cG9uZW50cyB0byB0aGUgbXVsdGlwbGllciB0byBkZXRlcm1pbmUgc2lnbmlmaWNhbnQgZGlnaXQgcm91bmRpbmdcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0bXVsdDEwW2ldID0gKygnMWUnICsgTWF0aC5mbG9vcig0NS4xNSAtIGkgKiAwLjMwMTAzKSlcbn1cbmV4cG9ydCBjb25zdCBEZWNvZGVyID0gVW5wYWNrclxudmFyIGRlZmF1bHRVbnBhY2tyID0gbmV3IFVucGFja3IoeyB1c2VSZWNvcmRzOiBmYWxzZSB9KVxuZXhwb3J0IGNvbnN0IHVucGFjayA9IGRlZmF1bHRVbnBhY2tyLnVucGFja1xuZXhwb3J0IGNvbnN0IHVucGFja011bHRpcGxlID0gZGVmYXVsdFVucGFja3IudW5wYWNrTXVsdGlwbGVcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSBkZWZhdWx0VW5wYWNrci51bnBhY2tcbmV4cG9ydCBjb25zdCBGTE9BVDMyX09QVElPTlMgPSB7XG5cdE5FVkVSOiAwLFxuXHRBTFdBWVM6IDEsXG5cdERFQ0lNQUxfUk9VTkQ6IDMsXG5cdERFQ0lNQUxfRklUOiA0XG59XG5sZXQgZjMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEpXG5sZXQgdThBcnJheSA9IG5ldyBVaW50OEFycmF5KGYzMkFycmF5LmJ1ZmZlciwgMCwgNClcbmV4cG9ydCBmdW5jdGlvbiByb3VuZEZsb2F0MzIoZmxvYXQzMk51bWJlcikge1xuXHRmMzJBcnJheVswXSA9IGZsb2F0MzJOdW1iZXJcblx0bGV0IG11bHRpcGxpZXIgPSBtdWx0MTBbKCh1OEFycmF5WzNdICYgMHg3ZikgPDwgMSkgfCAodThBcnJheVsyXSA+PiA3KV1cblx0cmV0dXJuICgobXVsdGlwbGllciAqIGZsb2F0MzJOdW1iZXIgKyAoZmxvYXQzMk51bWJlciA+IDAgPyAwLjUgOiAtMC41KSkgPj4gMCkgLyBtdWx0aXBsaWVyXG59XG5leHBvcnQgZnVuY3Rpb24gc2V0UmVhZFN0cnVjdCh1cGRhdGVkUmVhZFN0cnVjdCwgbG9hZGVkU3RydWN0cywgc2F2ZVN0YXRlKSB7XG5cdHJlYWRTdHJ1Y3QgPSB1cGRhdGVkUmVhZFN0cnVjdDtcblx0b25Mb2FkZWRTdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0cztcblx0b25TYXZlU3RhdGUgPSBzYXZlU3RhdGU7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/unpack.js\n");

/***/ })

};
;