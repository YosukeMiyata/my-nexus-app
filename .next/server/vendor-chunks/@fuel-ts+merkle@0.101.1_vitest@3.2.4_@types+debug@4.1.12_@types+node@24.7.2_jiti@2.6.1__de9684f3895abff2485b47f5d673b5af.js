"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@fuel-ts+merkle@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6.1__de9684f3895abff2485b47f5d673b5af";
exports.ids = ["vendor-chunks/@fuel-ts+merkle@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6.1__de9684f3895abff2485b47f5d673b5af"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@fuel-ts+merkle@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6.1__de9684f3895abff2485b47f5d673b5af/node_modules/@fuel-ts/merkle/dist/index.mjs":
/*!*************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@fuel-ts+merkle@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6.1__de9684f3895abff2485b47f5d673b5af/node_modules/@fuel-ts/merkle/dist/index.mjs ***!
  \*************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SparseMerkleTree: () => (/* binding */ SparseMerkleTree),\n/* harmony export */   calcRoot: () => (/* binding */ calcRoot),\n/* harmony export */   constructTree: () => (/* binding */ constructTree),\n/* harmony export */   getProof: () => (/* binding */ getProof),\n/* harmony export */   hashLeaf: () => (/* binding */ hashLeaf),\n/* harmony export */   hashNode: () => (/* binding */ hashNode)\n/* harmony export */ });\n/* harmony import */ var _fuel_ts_hasher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fuel-ts/hasher */ \"(ssr)/./node_modules/.pnpm/@fuel-ts+hasher@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6.1__3de5373ec566d2f8672f34c376d1b1fa/node_modules/@fuel-ts/hasher/dist/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\n// src/binary/binaryMerkleTree.ts\n\n\n// src/common/common.ts\nvar EMPTY = \"0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\";\n\n// src/binary/types/node.ts\nvar Node = class {\n  static {\n    __name(this, \"Node\");\n  }\n  left;\n  right;\n  parent;\n  hash;\n  data;\n  index;\n  constructor(left, right, parent, hash5, data, index = 0) {\n    this.left = left;\n    this.right = right;\n    this.parent = parent;\n    this.hash = hash5;\n    this.data = data;\n    this.index = index;\n  }\n};\nvar node_default = Node;\n\n// src/binary/binaryMerkleTree.ts\nfunction hashLeaf(data) {\n  return (0,_fuel_ts_hasher__WEBPACK_IMPORTED_MODULE_0__.hash)(\"0x00\".concat(data.slice(2)));\n}\n__name(hashLeaf, \"hashLeaf\");\nfunction hashNode(left, right) {\n  return (0,_fuel_ts_hasher__WEBPACK_IMPORTED_MODULE_0__.hash)(\"0x01\".concat(left.slice(2)).concat(right.slice(2)));\n}\n__name(hashNode, \"hashNode\");\nfunction constructTree(data) {\n  const nodes = [];\n  for (let i = 0; i < data.length; i += 1) {\n    const hashed = hashLeaf(data[i]);\n    const leaf = new node_default(-1, -1, -1, hashed, data[i]);\n    leaf.index = i;\n    nodes.push(leaf);\n  }\n  const nodesList = [...nodes];\n  let pNodes = [...nodes];\n  let size = nodes.length + 1 >> 1;\n  let odd = nodes.length & 1;\n  while (true) {\n    let i = 0;\n    for (; i < size - odd; i += 1) {\n      const j = i << 1;\n      const hashed = hashNode(pNodes[j].hash, pNodes[j + 1].hash);\n      nodes[i] = new node_default(pNodes[j].index, pNodes[j + 1].index, -1, hashed, \"\");\n      const nextIndex = nodesList.length;\n      nodes[i].index = nextIndex;\n      nodesList[pNodes[j].index].parent = nextIndex;\n      nodesList[pNodes[j + 1].index].parent = nextIndex;\n      nodesList.push(nodes[i]);\n    }\n    if (size === 1) {\n      break;\n    }\n    if (odd === 1) {\n      nodes[i] = pNodes[i << 1];\n    }\n    odd = size & 1;\n    size = size + 1 >> 1;\n    pNodes = [...nodes];\n  }\n  return nodesList;\n}\n__name(constructTree, \"constructTree\");\nfunction calcRoot(data) {\n  if (!data.length) {\n    return EMPTY;\n  }\n  const nodes = [];\n  for (let i = 0; i < data.length; i += 1) {\n    const hashed = hashLeaf(data[i]);\n    nodes.push(new node_default(-1, -1, -1, hashed, data[i]));\n  }\n  let pNodes = nodes;\n  let size = nodes.length + 1 >> 1;\n  let odd = nodes.length & 1;\n  while (true) {\n    let i = 0;\n    for (; i < size - odd; i += 1) {\n      const j = i << 1;\n      const hashed = hashNode(pNodes[j].hash, pNodes[j + 1].hash);\n      nodes[i] = new node_default(pNodes[j].index, pNodes[j + 1].index, -1, hashed, \"\");\n    }\n    if (odd === 1) {\n      nodes[i] = pNodes[i << 1];\n    }\n    if (size === 1) {\n      break;\n    }\n    odd = size & 1;\n    size = size + 1 >> 1;\n    pNodes = nodes;\n  }\n  return nodes[0].hash;\n}\n__name(calcRoot, \"calcRoot\");\nfunction getProof(nodes, id) {\n  const proof = [];\n  for (let prev = id, cur = nodes[id].parent; cur !== -1; prev = cur, cur = nodes[cur].parent) {\n    if (nodes[cur].left === prev) {\n      proof.push(nodes[nodes[cur].right].hash);\n    } else {\n      proof.push(nodes[nodes[cur].left].hash);\n    }\n  }\n  return proof;\n}\n__name(getProof, \"getProof\");\n\n// src/sparse/sparseMerkleTree.ts\n\n\n// src/sparse/proofs.ts\n\n\n// src/sparse/treeHasher.ts\n\nvar leafPrefix = \"0x00\";\nvar nodePrefix = \"0x01\";\nfunction hashLeaf2(key, data) {\n  const value = \"0x00\".concat(key.slice(2)).concat((0,_fuel_ts_hasher__WEBPACK_IMPORTED_MODULE_0__.hash)(data).slice(2));\n  return [(0,_fuel_ts_hasher__WEBPACK_IMPORTED_MODULE_0__.hash)(value), value];\n}\n__name(hashLeaf2, \"hashLeaf\");\nfunction hashNode2(left, right) {\n  const value = \"0x01\".concat(left.slice(2)).concat(right.slice(2));\n  return [(0,_fuel_ts_hasher__WEBPACK_IMPORTED_MODULE_0__.hash)(value), value];\n}\n__name(hashNode2, \"hashNode\");\nfunction parseLeaf(data) {\n  const len = nodePrefix.length;\n  return [\"0x\".concat(data.slice(len, len + 64)), \"0x\".concat(data.slice(len + 64))];\n}\n__name(parseLeaf, \"parseLeaf\");\nfunction parseNode(data) {\n  const len = nodePrefix.length;\n  return [\"0x\".concat(data.slice(len, len + 64)), \"0x\".concat(data.slice(len + 64))];\n}\n__name(parseNode, \"parseNode\");\nfunction isLeaf(data) {\n  return data.slice(0, 4) === leafPrefix;\n}\n__name(isLeaf, \"isLeaf\");\n\n// src/sparse/types/sparseCompactMerkleProof.ts\nvar SparseCompactMerkleProof = class {\n  static {\n    __name(this, \"SparseCompactMerkleProof\");\n  }\n  SideNodes;\n  NonMembershipLeafData;\n  BitMask;\n  NumSideNodes;\n  SiblingData;\n  constructor(SideNodes, NonMembershipLeafData, Bitmask, NumSideNodes, SiblingData) {\n    this.SideNodes = SideNodes;\n    this.NonMembershipLeafData = NonMembershipLeafData;\n    this.BitMask = Bitmask;\n    this.NumSideNodes = NumSideNodes;\n    this.SiblingData = SiblingData;\n  }\n};\nvar sparseCompactMerkleProof_default = SparseCompactMerkleProof;\n\n// src/sparse/types/sparseMerkleProof.ts\nvar SparseMerkleProof = class {\n  static {\n    __name(this, \"SparseMerkleProof\");\n  }\n  SideNodes;\n  NonMembershipLeafData;\n  SiblingData;\n  constructor(sideNodes, NonMembershipLeafData, SiblingData) {\n    this.SideNodes = sideNodes;\n    this.NonMembershipLeafData = NonMembershipLeafData;\n    this.SiblingData = SiblingData;\n  }\n};\nvar sparseMerkleProof_default = SparseMerkleProof;\n\n// src/sparse/utils.ts\nvar ZERO = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nvar MAX_HEIGHT = 256;\nfunction getBitAtFromMSB(data, position) {\n  const slicedData = data.slice(2);\n  const byte = \"0x\".concat(\n    slicedData.slice(Math.floor(position / 8) * 2, Math.floor(position / 8) * 2 + 2)\n  );\n  const bits = Number(byte) & 1 << 8 - 1 - position % 8;\n  if (bits > 0) {\n    return 1;\n  }\n  return 0;\n}\n__name(getBitAtFromMSB, \"getBitAtFromMSB\");\nfunction reverseSideNodes(sideNodes) {\n  let left = 0;\n  let right = sideNodes.length - 1;\n  const reversedSideNodes = sideNodes;\n  while (left < right) {\n    [reversedSideNodes[left], reversedSideNodes[right]] = [\n      reversedSideNodes[right],\n      reversedSideNodes[left]\n    ];\n    left += 1;\n    right -= 1;\n  }\n  return reversedSideNodes;\n}\n__name(reverseSideNodes, \"reverseSideNodes\");\nfunction countCommonPrefix(data1, data2) {\n  let count = 0;\n  for (let i = 0; i < MAX_HEIGHT; i += 1) {\n    if (getBitAtFromMSB(data1, i) === getBitAtFromMSB(data2, i)) {\n      count += 1;\n    } else {\n      break;\n    }\n  }\n  return count;\n}\n__name(countCommonPrefix, \"countCommonPrefix\");\n\n// src/sparse/proofs.ts\nfunction compactProof(proof) {\n  const bitMask = [];\n  const compactedSideNodes = [];\n  let node;\n  for (let i = 0; i < proof.SideNodes.length; i += 1) {\n    node = proof.SideNodes[i];\n    if (node === ZERO) {\n      bitMask.push(0);\n    } else {\n      compactedSideNodes.push(node);\n      bitMask.push(1);\n    }\n  }\n  const compactedProof = new sparseCompactMerkleProof_default(\n    compactedSideNodes,\n    proof.NonMembershipLeafData,\n    bitMask,\n    proof.SideNodes.length,\n    proof.SiblingData\n  );\n  return compactedProof;\n}\n__name(compactProof, \"compactProof\");\n\n// src/sparse/sparseMerkleTree.ts\nvar SparseMerkleTree = class {\n  static {\n    __name(this, \"SparseMerkleTree\");\n  }\n  ms;\n  root;\n  constructor() {\n    const ms = {};\n    this.ms = ms;\n    this.root = ZERO;\n    this.ms[this.root] = ZERO;\n  }\n  get(key) {\n    return this.ms[key];\n  }\n  set(key, value) {\n    this.ms[key] = value;\n  }\n  setRoot(root) {\n    this.root = root;\n  }\n  sideNodesForRoot(key, root) {\n    const sideNodes = [];\n    if (root === ZERO) {\n      return [sideNodes, ZERO, \"\", \"\"];\n    }\n    let currentData = this.get(root);\n    if (isLeaf(currentData)) {\n      return [sideNodes, root, currentData, \"\"];\n    }\n    let leftNode;\n    let rightNode;\n    let nodeHash = \"\";\n    let sideNode = \"\";\n    for (let i = 0; i < MAX_HEIGHT; i += 1) {\n      [leftNode, rightNode] = parseNode(currentData);\n      if (getBitAtFromMSB(key, i) === 1) {\n        sideNode = leftNode;\n        nodeHash = rightNode;\n      } else {\n        sideNode = rightNode;\n        nodeHash = leftNode;\n      }\n      sideNodes.push(sideNode);\n      if (nodeHash === ZERO) {\n        currentData = \"\";\n        break;\n      }\n      currentData = this.get(nodeHash);\n      if (isLeaf(currentData)) {\n        break;\n      }\n    }\n    const siblingData = this.get(sideNode);\n    return [reverseSideNodes(sideNodes), nodeHash, currentData, siblingData];\n  }\n  deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData) {\n    if (oldLeafHash === ZERO) {\n      return this.root;\n    }\n    const [actualPath] = parseLeaf(oldLeafData);\n    if (actualPath !== key) {\n      return this.root;\n    }\n    let currentHash = \"\";\n    let currentData = \"\";\n    let sideNode = \"\";\n    let sideNodeValue = \"\";\n    let nonPlaceholderReached = false;\n    for (let i = 0; i < sideNodes.length; i += 1) {\n      if (sideNodes[i] === \"\") {\n        continue;\n      }\n      sideNode = sideNodes[i];\n      if (currentData === \"\") {\n        sideNodeValue = this.get(sideNode);\n        if (isLeaf(sideNodeValue)) {\n          currentHash = sideNode;\n          currentData = sideNode;\n          continue;\n        } else {\n          currentData = ZERO;\n          nonPlaceholderReached = true;\n        }\n      }\n      if (!nonPlaceholderReached && sideNode === ZERO) {\n        continue;\n      } else if (!nonPlaceholderReached) {\n        nonPlaceholderReached = true;\n      }\n      if (getBitAtFromMSB(key, sideNodes.length - 1 - i) === 1) {\n        [currentHash, currentData] = hashNode2(sideNode, currentData);\n      } else {\n        [currentHash, currentData] = hashNode2(currentData, sideNode);\n      }\n      this.set(currentHash, currentData);\n      currentData = currentHash;\n    }\n    if (currentHash === \"\") {\n      currentHash = ZERO;\n    }\n    return currentHash;\n  }\n  updateWithSideNodes(key, value, sideNodes, oldLeafHash, oldLeafData) {\n    let currentHash;\n    let currentData;\n    this.set((0,_fuel_ts_hasher__WEBPACK_IMPORTED_MODULE_0__.hash)(value), value);\n    [currentHash, currentData] = hashLeaf2(key, value);\n    this.set(currentHash, currentData);\n    currentData = currentHash;\n    let commonPrefixCount;\n    if (oldLeafHash === ZERO) {\n      commonPrefixCount = MAX_HEIGHT;\n    } else {\n      const [actualPath] = parseLeaf(oldLeafData);\n      commonPrefixCount = countCommonPrefix(key, actualPath);\n    }\n    if (commonPrefixCount !== MAX_HEIGHT) {\n      if (getBitAtFromMSB(key, commonPrefixCount) === 1) {\n        [currentHash, currentData] = hashNode2(oldLeafHash, currentData);\n      } else {\n        [currentHash, currentData] = hashNode2(currentData, oldLeafHash);\n      }\n      this.set(currentHash, currentData);\n      currentData = currentHash;\n    }\n    for (let i = 0; i < MAX_HEIGHT; i += 1) {\n      let sideNode;\n      const offsetOfSideNodes = MAX_HEIGHT - sideNodes.length;\n      if (i - offsetOfSideNodes < 0 || sideNodes[i - offsetOfSideNodes] === \"\") {\n        if (commonPrefixCount !== MAX_HEIGHT && commonPrefixCount > MAX_HEIGHT - 1 - i) {\n          sideNode = ZERO;\n        } else {\n          continue;\n        }\n      } else {\n        sideNode = sideNodes[i - offsetOfSideNodes];\n      }\n      if (getBitAtFromMSB(key, MAX_HEIGHT - 1 - i) === 1) {\n        [currentHash, currentData] = hashNode2(sideNode, currentData);\n      } else {\n        [currentHash, currentData] = hashNode2(currentData, sideNode);\n      }\n      this.set(currentHash, currentData);\n      currentData = currentHash;\n    }\n    return currentHash;\n  }\n  update(key, value) {\n    const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);\n    const newRoot = this.updateWithSideNodes(key, value, sideNodes, oldLeafHash, oldLeafData);\n    this.setRoot(newRoot);\n  }\n  delete(key) {\n    const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);\n    const newRoot = this.deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData);\n    this.setRoot(newRoot);\n  }\n  prove(key) {\n    const [sideNodes, leafHash, leafData, siblingData] = this.sideNodesForRoot(key, this.root);\n    const nonEmptySideNodes = [];\n    for (let i = 0; i < sideNodes.length; i += 1) {\n      if (sideNodes[i] !== \"\") {\n        nonEmptySideNodes.push(sideNodes[i]);\n      }\n    }\n    let nonMembershipLeafData = \"\";\n    if (leafHash !== ZERO) {\n      const [actualPath] = parseLeaf(leafData);\n      if (actualPath !== key) {\n        nonMembershipLeafData = leafData;\n      }\n    }\n    const proof = new sparseMerkleProof_default(nonEmptySideNodes, nonMembershipLeafData, siblingData);\n    return proof;\n  }\n  proveCompacted(key) {\n    const proof = this.prove(key);\n    const compactedProof = compactProof(proof);\n    return compactedProof;\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGZ1ZWwtdHMrbWVya2xlQDAuMTAxLjFfdml0ZXN0QDMuMi40X0B0eXBlcytkZWJ1Z0A0LjEuMTJfQHR5cGVzK25vZGVAMjQuNy4yX2ppdGlAMi42LjFfX2RlOTY4NGYzODk1YWJmZjI0ODViNDdmNWQ2NzNiNWFmL25vZGVfbW9kdWxlcy9AZnVlbC10cy9tZXJrbGUvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0EsNERBQTRELDJCQUEyQjs7QUFFdkY7QUFDdUM7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLHFEQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxREFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNnRDs7QUFFaEQ7QUFDZ0Q7O0FBRWhEO0FBQ2dEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxxREFBSztBQUN4RCxVQUFVLHFEQUFLO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFLO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy95b3VzdWtlL015UHJvamVjdC9teS1uZXh1cy1hcHAvbm9kZV9tb2R1bGVzLy5wbnBtL0BmdWVsLXRzK21lcmtsZUAwLjEwMS4xX3ZpdGVzdEAzLjIuNF9AdHlwZXMrZGVidWdANC4xLjEyX0B0eXBlcytub2RlQDI0LjcuMl9qaXRpQDIuNi4xX19kZTk2ODRmMzg5NWFiZmYyNDg1YjQ3ZjVkNjczYjVhZi9ub2RlX21vZHVsZXMvQGZ1ZWwtdHMvbWVya2xlL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cbi8vIHNyYy9iaW5hcnkvYmluYXJ5TWVya2xlVHJlZS50c1xuaW1wb3J0IHsgaGFzaCB9IGZyb20gXCJAZnVlbC10cy9oYXNoZXJcIjtcblxuLy8gc3JjL2NvbW1vbi9jb21tb24udHNcbnZhciBFTVBUWSA9IFwiMHhlM2IwYzQ0Mjk4ZmMxYzE0OWFmYmY0Yzg5OTZmYjkyNDI3YWU0MWU0NjQ5YjkzNGNhNDk1OTkxYjc4NTJiODU1XCI7XG5cbi8vIHNyYy9iaW5hcnkvdHlwZXMvbm9kZS50c1xudmFyIE5vZGUgPSBjbGFzcyB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiTm9kZVwiKTtcbiAgfVxuICBsZWZ0O1xuICByaWdodDtcbiAgcGFyZW50O1xuICBoYXNoO1xuICBkYXRhO1xuICBpbmRleDtcbiAgY29uc3RydWN0b3IobGVmdCwgcmlnaHQsIHBhcmVudCwgaGFzaDUsIGRhdGEsIGluZGV4ID0gMCkge1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuaGFzaCA9IGhhc2g1O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG59O1xudmFyIG5vZGVfZGVmYXVsdCA9IE5vZGU7XG5cbi8vIHNyYy9iaW5hcnkvYmluYXJ5TWVya2xlVHJlZS50c1xuZnVuY3Rpb24gaGFzaExlYWYoZGF0YSkge1xuICByZXR1cm4gaGFzaChcIjB4MDBcIi5jb25jYXQoZGF0YS5zbGljZSgyKSkpO1xufVxuX19uYW1lKGhhc2hMZWFmLCBcImhhc2hMZWFmXCIpO1xuZnVuY3Rpb24gaGFzaE5vZGUobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIGhhc2goXCIweDAxXCIuY29uY2F0KGxlZnQuc2xpY2UoMikpLmNvbmNhdChyaWdodC5zbGljZSgyKSkpO1xufVxuX19uYW1lKGhhc2hOb2RlLCBcImhhc2hOb2RlXCIpO1xuZnVuY3Rpb24gY29uc3RydWN0VHJlZShkYXRhKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGhhc2hlZCA9IGhhc2hMZWFmKGRhdGFbaV0pO1xuICAgIGNvbnN0IGxlYWYgPSBuZXcgbm9kZV9kZWZhdWx0KC0xLCAtMSwgLTEsIGhhc2hlZCwgZGF0YVtpXSk7XG4gICAgbGVhZi5pbmRleCA9IGk7XG4gICAgbm9kZXMucHVzaChsZWFmKTtcbiAgfVxuICBjb25zdCBub2Rlc0xpc3QgPSBbLi4ubm9kZXNdO1xuICBsZXQgcE5vZGVzID0gWy4uLm5vZGVzXTtcbiAgbGV0IHNpemUgPSBub2Rlcy5sZW5ndGggKyAxID4+IDE7XG4gIGxldCBvZGQgPSBub2Rlcy5sZW5ndGggJiAxO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHNpemUgLSBvZGQ7IGkgKz0gMSkge1xuICAgICAgY29uc3QgaiA9IGkgPDwgMTtcbiAgICAgIGNvbnN0IGhhc2hlZCA9IGhhc2hOb2RlKHBOb2Rlc1tqXS5oYXNoLCBwTm9kZXNbaiArIDFdLmhhc2gpO1xuICAgICAgbm9kZXNbaV0gPSBuZXcgbm9kZV9kZWZhdWx0KHBOb2Rlc1tqXS5pbmRleCwgcE5vZGVzW2ogKyAxXS5pbmRleCwgLTEsIGhhc2hlZCwgXCJcIik7XG4gICAgICBjb25zdCBuZXh0SW5kZXggPSBub2Rlc0xpc3QubGVuZ3RoO1xuICAgICAgbm9kZXNbaV0uaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICBub2Rlc0xpc3RbcE5vZGVzW2pdLmluZGV4XS5wYXJlbnQgPSBuZXh0SW5kZXg7XG4gICAgICBub2Rlc0xpc3RbcE5vZGVzW2ogKyAxXS5pbmRleF0ucGFyZW50ID0gbmV4dEluZGV4O1xuICAgICAgbm9kZXNMaXN0LnB1c2gobm9kZXNbaV0pO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA9PT0gMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChvZGQgPT09IDEpIHtcbiAgICAgIG5vZGVzW2ldID0gcE5vZGVzW2kgPDwgMV07XG4gICAgfVxuICAgIG9kZCA9IHNpemUgJiAxO1xuICAgIHNpemUgPSBzaXplICsgMSA+PiAxO1xuICAgIHBOb2RlcyA9IFsuLi5ub2Rlc107XG4gIH1cbiAgcmV0dXJuIG5vZGVzTGlzdDtcbn1cbl9fbmFtZShjb25zdHJ1Y3RUcmVlLCBcImNvbnN0cnVjdFRyZWVcIik7XG5mdW5jdGlvbiBjYWxjUm9vdChkYXRhKSB7XG4gIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gRU1QVFk7XG4gIH1cbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgaGFzaGVkID0gaGFzaExlYWYoZGF0YVtpXSk7XG4gICAgbm9kZXMucHVzaChuZXcgbm9kZV9kZWZhdWx0KC0xLCAtMSwgLTEsIGhhc2hlZCwgZGF0YVtpXSkpO1xuICB9XG4gIGxldCBwTm9kZXMgPSBub2RlcztcbiAgbGV0IHNpemUgPSBub2Rlcy5sZW5ndGggKyAxID4+IDE7XG4gIGxldCBvZGQgPSBub2Rlcy5sZW5ndGggJiAxO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHNpemUgLSBvZGQ7IGkgKz0gMSkge1xuICAgICAgY29uc3QgaiA9IGkgPDwgMTtcbiAgICAgIGNvbnN0IGhhc2hlZCA9IGhhc2hOb2RlKHBOb2Rlc1tqXS5oYXNoLCBwTm9kZXNbaiArIDFdLmhhc2gpO1xuICAgICAgbm9kZXNbaV0gPSBuZXcgbm9kZV9kZWZhdWx0KHBOb2Rlc1tqXS5pbmRleCwgcE5vZGVzW2ogKyAxXS5pbmRleCwgLTEsIGhhc2hlZCwgXCJcIik7XG4gICAgfVxuICAgIGlmIChvZGQgPT09IDEpIHtcbiAgICAgIG5vZGVzW2ldID0gcE5vZGVzW2kgPDwgMV07XG4gICAgfVxuICAgIGlmIChzaXplID09PSAxKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2RkID0gc2l6ZSAmIDE7XG4gICAgc2l6ZSA9IHNpemUgKyAxID4+IDE7XG4gICAgcE5vZGVzID0gbm9kZXM7XG4gIH1cbiAgcmV0dXJuIG5vZGVzWzBdLmhhc2g7XG59XG5fX25hbWUoY2FsY1Jvb3QsIFwiY2FsY1Jvb3RcIik7XG5mdW5jdGlvbiBnZXRQcm9vZihub2RlcywgaWQpIHtcbiAgY29uc3QgcHJvb2YgPSBbXTtcbiAgZm9yIChsZXQgcHJldiA9IGlkLCBjdXIgPSBub2Rlc1tpZF0ucGFyZW50OyBjdXIgIT09IC0xOyBwcmV2ID0gY3VyLCBjdXIgPSBub2Rlc1tjdXJdLnBhcmVudCkge1xuICAgIGlmIChub2Rlc1tjdXJdLmxlZnQgPT09IHByZXYpIHtcbiAgICAgIHByb29mLnB1c2gobm9kZXNbbm9kZXNbY3VyXS5yaWdodF0uaGFzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb29mLnB1c2gobm9kZXNbbm9kZXNbY3VyXS5sZWZ0XS5oYXNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb29mO1xufVxuX19uYW1lKGdldFByb29mLCBcImdldFByb29mXCIpO1xuXG4vLyBzcmMvc3BhcnNlL3NwYXJzZU1lcmtsZVRyZWUudHNcbmltcG9ydCB7IGhhc2ggYXMgaGFzaDQgfSBmcm9tIFwiQGZ1ZWwtdHMvaGFzaGVyXCI7XG5cbi8vIHNyYy9zcGFyc2UvcHJvb2ZzLnRzXG5pbXBvcnQgeyBoYXNoIGFzIGhhc2gzIH0gZnJvbSBcIkBmdWVsLXRzL2hhc2hlclwiO1xuXG4vLyBzcmMvc3BhcnNlL3RyZWVIYXNoZXIudHNcbmltcG9ydCB7IGhhc2ggYXMgaGFzaDIgfSBmcm9tIFwiQGZ1ZWwtdHMvaGFzaGVyXCI7XG52YXIgbGVhZlByZWZpeCA9IFwiMHgwMFwiO1xudmFyIG5vZGVQcmVmaXggPSBcIjB4MDFcIjtcbmZ1bmN0aW9uIGhhc2hMZWFmMihrZXksIGRhdGEpIHtcbiAgY29uc3QgdmFsdWUgPSBcIjB4MDBcIi5jb25jYXQoa2V5LnNsaWNlKDIpKS5jb25jYXQoaGFzaDIoZGF0YSkuc2xpY2UoMikpO1xuICByZXR1cm4gW2hhc2gyKHZhbHVlKSwgdmFsdWVdO1xufVxuX19uYW1lKGhhc2hMZWFmMiwgXCJoYXNoTGVhZlwiKTtcbmZ1bmN0aW9uIGhhc2hOb2RlMihsZWZ0LCByaWdodCkge1xuICBjb25zdCB2YWx1ZSA9IFwiMHgwMVwiLmNvbmNhdChsZWZ0LnNsaWNlKDIpKS5jb25jYXQocmlnaHQuc2xpY2UoMikpO1xuICByZXR1cm4gW2hhc2gyKHZhbHVlKSwgdmFsdWVdO1xufVxuX19uYW1lKGhhc2hOb2RlMiwgXCJoYXNoTm9kZVwiKTtcbmZ1bmN0aW9uIHBhcnNlTGVhZihkYXRhKSB7XG4gIGNvbnN0IGxlbiA9IG5vZGVQcmVmaXgubGVuZ3RoO1xuICByZXR1cm4gW1wiMHhcIi5jb25jYXQoZGF0YS5zbGljZShsZW4sIGxlbiArIDY0KSksIFwiMHhcIi5jb25jYXQoZGF0YS5zbGljZShsZW4gKyA2NCkpXTtcbn1cbl9fbmFtZShwYXJzZUxlYWYsIFwicGFyc2VMZWFmXCIpO1xuZnVuY3Rpb24gcGFyc2VOb2RlKGRhdGEpIHtcbiAgY29uc3QgbGVuID0gbm9kZVByZWZpeC5sZW5ndGg7XG4gIHJldHVybiBbXCIweFwiLmNvbmNhdChkYXRhLnNsaWNlKGxlbiwgbGVuICsgNjQpKSwgXCIweFwiLmNvbmNhdChkYXRhLnNsaWNlKGxlbiArIDY0KSldO1xufVxuX19uYW1lKHBhcnNlTm9kZSwgXCJwYXJzZU5vZGVcIik7XG5mdW5jdGlvbiBpc0xlYWYoZGF0YSkge1xuICByZXR1cm4gZGF0YS5zbGljZSgwLCA0KSA9PT0gbGVhZlByZWZpeDtcbn1cbl9fbmFtZShpc0xlYWYsIFwiaXNMZWFmXCIpO1xuXG4vLyBzcmMvc3BhcnNlL3R5cGVzL3NwYXJzZUNvbXBhY3RNZXJrbGVQcm9vZi50c1xudmFyIFNwYXJzZUNvbXBhY3RNZXJrbGVQcm9vZiA9IGNsYXNzIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJTcGFyc2VDb21wYWN0TWVya2xlUHJvb2ZcIik7XG4gIH1cbiAgU2lkZU5vZGVzO1xuICBOb25NZW1iZXJzaGlwTGVhZkRhdGE7XG4gIEJpdE1hc2s7XG4gIE51bVNpZGVOb2RlcztcbiAgU2libGluZ0RhdGE7XG4gIGNvbnN0cnVjdG9yKFNpZGVOb2RlcywgTm9uTWVtYmVyc2hpcExlYWZEYXRhLCBCaXRtYXNrLCBOdW1TaWRlTm9kZXMsIFNpYmxpbmdEYXRhKSB7XG4gICAgdGhpcy5TaWRlTm9kZXMgPSBTaWRlTm9kZXM7XG4gICAgdGhpcy5Ob25NZW1iZXJzaGlwTGVhZkRhdGEgPSBOb25NZW1iZXJzaGlwTGVhZkRhdGE7XG4gICAgdGhpcy5CaXRNYXNrID0gQml0bWFzaztcbiAgICB0aGlzLk51bVNpZGVOb2RlcyA9IE51bVNpZGVOb2RlcztcbiAgICB0aGlzLlNpYmxpbmdEYXRhID0gU2libGluZ0RhdGE7XG4gIH1cbn07XG52YXIgc3BhcnNlQ29tcGFjdE1lcmtsZVByb29mX2RlZmF1bHQgPSBTcGFyc2VDb21wYWN0TWVya2xlUHJvb2Y7XG5cbi8vIHNyYy9zcGFyc2UvdHlwZXMvc3BhcnNlTWVya2xlUHJvb2YudHNcbnZhciBTcGFyc2VNZXJrbGVQcm9vZiA9IGNsYXNzIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJTcGFyc2VNZXJrbGVQcm9vZlwiKTtcbiAgfVxuICBTaWRlTm9kZXM7XG4gIE5vbk1lbWJlcnNoaXBMZWFmRGF0YTtcbiAgU2libGluZ0RhdGE7XG4gIGNvbnN0cnVjdG9yKHNpZGVOb2RlcywgTm9uTWVtYmVyc2hpcExlYWZEYXRhLCBTaWJsaW5nRGF0YSkge1xuICAgIHRoaXMuU2lkZU5vZGVzID0gc2lkZU5vZGVzO1xuICAgIHRoaXMuTm9uTWVtYmVyc2hpcExlYWZEYXRhID0gTm9uTWVtYmVyc2hpcExlYWZEYXRhO1xuICAgIHRoaXMuU2libGluZ0RhdGEgPSBTaWJsaW5nRGF0YTtcbiAgfVxufTtcbnZhciBzcGFyc2VNZXJrbGVQcm9vZl9kZWZhdWx0ID0gU3BhcnNlTWVya2xlUHJvb2Y7XG5cbi8vIHNyYy9zcGFyc2UvdXRpbHMudHNcbnZhciBaRVJPID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbnZhciBNQVhfSEVJR0hUID0gMjU2O1xuZnVuY3Rpb24gZ2V0Qml0QXRGcm9tTVNCKGRhdGEsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IHNsaWNlZERhdGEgPSBkYXRhLnNsaWNlKDIpO1xuICBjb25zdCBieXRlID0gXCIweFwiLmNvbmNhdChcbiAgICBzbGljZWREYXRhLnNsaWNlKE1hdGguZmxvb3IocG9zaXRpb24gLyA4KSAqIDIsIE1hdGguZmxvb3IocG9zaXRpb24gLyA4KSAqIDIgKyAyKVxuICApO1xuICBjb25zdCBiaXRzID0gTnVtYmVyKGJ5dGUpICYgMSA8PCA4IC0gMSAtIHBvc2l0aW9uICUgODtcbiAgaWYgKGJpdHMgPiAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5fX25hbWUoZ2V0Qml0QXRGcm9tTVNCLCBcImdldEJpdEF0RnJvbU1TQlwiKTtcbmZ1bmN0aW9uIHJldmVyc2VTaWRlTm9kZXMoc2lkZU5vZGVzKSB7XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gc2lkZU5vZGVzLmxlbmd0aCAtIDE7XG4gIGNvbnN0IHJldmVyc2VkU2lkZU5vZGVzID0gc2lkZU5vZGVzO1xuICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgW3JldmVyc2VkU2lkZU5vZGVzW2xlZnRdLCByZXZlcnNlZFNpZGVOb2Rlc1tyaWdodF1dID0gW1xuICAgICAgcmV2ZXJzZWRTaWRlTm9kZXNbcmlnaHRdLFxuICAgICAgcmV2ZXJzZWRTaWRlTm9kZXNbbGVmdF1cbiAgICBdO1xuICAgIGxlZnQgKz0gMTtcbiAgICByaWdodCAtPSAxO1xuICB9XG4gIHJldHVybiByZXZlcnNlZFNpZGVOb2Rlcztcbn1cbl9fbmFtZShyZXZlcnNlU2lkZU5vZGVzLCBcInJldmVyc2VTaWRlTm9kZXNcIik7XG5mdW5jdGlvbiBjb3VudENvbW1vblByZWZpeChkYXRhMSwgZGF0YTIpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfSEVJR0hUOyBpICs9IDEpIHtcbiAgICBpZiAoZ2V0Qml0QXRGcm9tTVNCKGRhdGExLCBpKSA9PT0gZ2V0Qml0QXRGcm9tTVNCKGRhdGEyLCBpKSkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cbl9fbmFtZShjb3VudENvbW1vblByZWZpeCwgXCJjb3VudENvbW1vblByZWZpeFwiKTtcblxuLy8gc3JjL3NwYXJzZS9wcm9vZnMudHNcbmZ1bmN0aW9uIGNvbXBhY3RQcm9vZihwcm9vZikge1xuICBjb25zdCBiaXRNYXNrID0gW107XG4gIGNvbnN0IGNvbXBhY3RlZFNpZGVOb2RlcyA9IFtdO1xuICBsZXQgbm9kZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9vZi5TaWRlTm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBub2RlID0gcHJvb2YuU2lkZU5vZGVzW2ldO1xuICAgIGlmIChub2RlID09PSBaRVJPKSB7XG4gICAgICBiaXRNYXNrLnB1c2goMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBhY3RlZFNpZGVOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgYml0TWFzay5wdXNoKDEpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb21wYWN0ZWRQcm9vZiA9IG5ldyBzcGFyc2VDb21wYWN0TWVya2xlUHJvb2ZfZGVmYXVsdChcbiAgICBjb21wYWN0ZWRTaWRlTm9kZXMsXG4gICAgcHJvb2YuTm9uTWVtYmVyc2hpcExlYWZEYXRhLFxuICAgIGJpdE1hc2ssXG4gICAgcHJvb2YuU2lkZU5vZGVzLmxlbmd0aCxcbiAgICBwcm9vZi5TaWJsaW5nRGF0YVxuICApO1xuICByZXR1cm4gY29tcGFjdGVkUHJvb2Y7XG59XG5fX25hbWUoY29tcGFjdFByb29mLCBcImNvbXBhY3RQcm9vZlwiKTtcblxuLy8gc3JjL3NwYXJzZS9zcGFyc2VNZXJrbGVUcmVlLnRzXG52YXIgU3BhcnNlTWVya2xlVHJlZSA9IGNsYXNzIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJTcGFyc2VNZXJrbGVUcmVlXCIpO1xuICB9XG4gIG1zO1xuICByb290O1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBtcyA9IHt9O1xuICAgIHRoaXMubXMgPSBtcztcbiAgICB0aGlzLnJvb3QgPSBaRVJPO1xuICAgIHRoaXMubXNbdGhpcy5yb290XSA9IFpFUk87XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLm1zW2tleV07XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLm1zW2tleV0gPSB2YWx1ZTtcbiAgfVxuICBzZXRSb290KHJvb3QpIHtcbiAgICB0aGlzLnJvb3QgPSByb290O1xuICB9XG4gIHNpZGVOb2Rlc0ZvclJvb3Qoa2V5LCByb290KSB7XG4gICAgY29uc3Qgc2lkZU5vZGVzID0gW107XG4gICAgaWYgKHJvb3QgPT09IFpFUk8pIHtcbiAgICAgIHJldHVybiBbc2lkZU5vZGVzLCBaRVJPLCBcIlwiLCBcIlwiXTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXQocm9vdCk7XG4gICAgaWYgKGlzTGVhZihjdXJyZW50RGF0YSkpIHtcbiAgICAgIHJldHVybiBbc2lkZU5vZGVzLCByb290LCBjdXJyZW50RGF0YSwgXCJcIl07XG4gICAgfVxuICAgIGxldCBsZWZ0Tm9kZTtcbiAgICBsZXQgcmlnaHROb2RlO1xuICAgIGxldCBub2RlSGFzaCA9IFwiXCI7XG4gICAgbGV0IHNpZGVOb2RlID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BWF9IRUlHSFQ7IGkgKz0gMSkge1xuICAgICAgW2xlZnROb2RlLCByaWdodE5vZGVdID0gcGFyc2VOb2RlKGN1cnJlbnREYXRhKTtcbiAgICAgIGlmIChnZXRCaXRBdEZyb21NU0Ioa2V5LCBpKSA9PT0gMSkge1xuICAgICAgICBzaWRlTm9kZSA9IGxlZnROb2RlO1xuICAgICAgICBub2RlSGFzaCA9IHJpZ2h0Tm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZGVOb2RlID0gcmlnaHROb2RlO1xuICAgICAgICBub2RlSGFzaCA9IGxlZnROb2RlO1xuICAgICAgfVxuICAgICAgc2lkZU5vZGVzLnB1c2goc2lkZU5vZGUpO1xuICAgICAgaWYgKG5vZGVIYXNoID09PSBaRVJPKSB7XG4gICAgICAgIGN1cnJlbnREYXRhID0gXCJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjdXJyZW50RGF0YSA9IHRoaXMuZ2V0KG5vZGVIYXNoKTtcbiAgICAgIGlmIChpc0xlYWYoY3VycmVudERhdGEpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nRGF0YSA9IHRoaXMuZ2V0KHNpZGVOb2RlKTtcbiAgICByZXR1cm4gW3JldmVyc2VTaWRlTm9kZXMoc2lkZU5vZGVzKSwgbm9kZUhhc2gsIGN1cnJlbnREYXRhLCBzaWJsaW5nRGF0YV07XG4gIH1cbiAgZGVsZXRlV2l0aFNpZGVOb2RlcyhrZXksIHNpZGVOb2Rlcywgb2xkTGVhZkhhc2gsIG9sZExlYWZEYXRhKSB7XG4gICAgaWYgKG9sZExlYWZIYXNoID09PSBaRVJPKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgIH1cbiAgICBjb25zdCBbYWN0dWFsUGF0aF0gPSBwYXJzZUxlYWYob2xkTGVhZkRhdGEpO1xuICAgIGlmIChhY3R1YWxQYXRoICE9PSBrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gICAgfVxuICAgIGxldCBjdXJyZW50SGFzaCA9IFwiXCI7XG4gICAgbGV0IGN1cnJlbnREYXRhID0gXCJcIjtcbiAgICBsZXQgc2lkZU5vZGUgPSBcIlwiO1xuICAgIGxldCBzaWRlTm9kZVZhbHVlID0gXCJcIjtcbiAgICBsZXQgbm9uUGxhY2Vob2xkZXJSZWFjaGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWRlTm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChzaWRlTm9kZXNbaV0gPT09IFwiXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzaWRlTm9kZSA9IHNpZGVOb2Rlc1tpXTtcbiAgICAgIGlmIChjdXJyZW50RGF0YSA9PT0gXCJcIikge1xuICAgICAgICBzaWRlTm9kZVZhbHVlID0gdGhpcy5nZXQoc2lkZU5vZGUpO1xuICAgICAgICBpZiAoaXNMZWFmKHNpZGVOb2RlVmFsdWUpKSB7XG4gICAgICAgICAgY3VycmVudEhhc2ggPSBzaWRlTm9kZTtcbiAgICAgICAgICBjdXJyZW50RGF0YSA9IHNpZGVOb2RlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnREYXRhID0gWkVSTztcbiAgICAgICAgICBub25QbGFjZWhvbGRlclJlYWNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW5vblBsYWNlaG9sZGVyUmVhY2hlZCAmJiBzaWRlTm9kZSA9PT0gWkVSTykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoIW5vblBsYWNlaG9sZGVyUmVhY2hlZCkge1xuICAgICAgICBub25QbGFjZWhvbGRlclJlYWNoZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGdldEJpdEF0RnJvbU1TQihrZXksIHNpZGVOb2Rlcy5sZW5ndGggLSAxIC0gaSkgPT09IDEpIHtcbiAgICAgICAgW2N1cnJlbnRIYXNoLCBjdXJyZW50RGF0YV0gPSBoYXNoTm9kZTIoc2lkZU5vZGUsIGN1cnJlbnREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFtjdXJyZW50SGFzaCwgY3VycmVudERhdGFdID0gaGFzaE5vZGUyKGN1cnJlbnREYXRhLCBzaWRlTm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldChjdXJyZW50SGFzaCwgY3VycmVudERhdGEpO1xuICAgICAgY3VycmVudERhdGEgPSBjdXJyZW50SGFzaDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRIYXNoID09PSBcIlwiKSB7XG4gICAgICBjdXJyZW50SGFzaCA9IFpFUk87XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50SGFzaDtcbiAgfVxuICB1cGRhdGVXaXRoU2lkZU5vZGVzKGtleSwgdmFsdWUsIHNpZGVOb2Rlcywgb2xkTGVhZkhhc2gsIG9sZExlYWZEYXRhKSB7XG4gICAgbGV0IGN1cnJlbnRIYXNoO1xuICAgIGxldCBjdXJyZW50RGF0YTtcbiAgICB0aGlzLnNldChoYXNoNCh2YWx1ZSksIHZhbHVlKTtcbiAgICBbY3VycmVudEhhc2gsIGN1cnJlbnREYXRhXSA9IGhhc2hMZWFmMihrZXksIHZhbHVlKTtcbiAgICB0aGlzLnNldChjdXJyZW50SGFzaCwgY3VycmVudERhdGEpO1xuICAgIGN1cnJlbnREYXRhID0gY3VycmVudEhhc2g7XG4gICAgbGV0IGNvbW1vblByZWZpeENvdW50O1xuICAgIGlmIChvbGRMZWFmSGFzaCA9PT0gWkVSTykge1xuICAgICAgY29tbW9uUHJlZml4Q291bnQgPSBNQVhfSEVJR0hUO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbYWN0dWFsUGF0aF0gPSBwYXJzZUxlYWYob2xkTGVhZkRhdGEpO1xuICAgICAgY29tbW9uUHJlZml4Q291bnQgPSBjb3VudENvbW1vblByZWZpeChrZXksIGFjdHVhbFBhdGgpO1xuICAgIH1cbiAgICBpZiAoY29tbW9uUHJlZml4Q291bnQgIT09IE1BWF9IRUlHSFQpIHtcbiAgICAgIGlmIChnZXRCaXRBdEZyb21NU0Ioa2V5LCBjb21tb25QcmVmaXhDb3VudCkgPT09IDEpIHtcbiAgICAgICAgW2N1cnJlbnRIYXNoLCBjdXJyZW50RGF0YV0gPSBoYXNoTm9kZTIob2xkTGVhZkhhc2gsIGN1cnJlbnREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFtjdXJyZW50SGFzaCwgY3VycmVudERhdGFdID0gaGFzaE5vZGUyKGN1cnJlbnREYXRhLCBvbGRMZWFmSGFzaCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldChjdXJyZW50SGFzaCwgY3VycmVudERhdGEpO1xuICAgICAgY3VycmVudERhdGEgPSBjdXJyZW50SGFzaDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfSEVJR0hUOyBpICs9IDEpIHtcbiAgICAgIGxldCBzaWRlTm9kZTtcbiAgICAgIGNvbnN0IG9mZnNldE9mU2lkZU5vZGVzID0gTUFYX0hFSUdIVCAtIHNpZGVOb2Rlcy5sZW5ndGg7XG4gICAgICBpZiAoaSAtIG9mZnNldE9mU2lkZU5vZGVzIDwgMCB8fCBzaWRlTm9kZXNbaSAtIG9mZnNldE9mU2lkZU5vZGVzXSA9PT0gXCJcIikge1xuICAgICAgICBpZiAoY29tbW9uUHJlZml4Q291bnQgIT09IE1BWF9IRUlHSFQgJiYgY29tbW9uUHJlZml4Q291bnQgPiBNQVhfSEVJR0hUIC0gMSAtIGkpIHtcbiAgICAgICAgICBzaWRlTm9kZSA9IFpFUk87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZGVOb2RlID0gc2lkZU5vZGVzW2kgLSBvZmZzZXRPZlNpZGVOb2Rlc107XG4gICAgICB9XG4gICAgICBpZiAoZ2V0Qml0QXRGcm9tTVNCKGtleSwgTUFYX0hFSUdIVCAtIDEgLSBpKSA9PT0gMSkge1xuICAgICAgICBbY3VycmVudEhhc2gsIGN1cnJlbnREYXRhXSA9IGhhc2hOb2RlMihzaWRlTm9kZSwgY3VycmVudERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgW2N1cnJlbnRIYXNoLCBjdXJyZW50RGF0YV0gPSBoYXNoTm9kZTIoY3VycmVudERhdGEsIHNpZGVOb2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0KGN1cnJlbnRIYXNoLCBjdXJyZW50RGF0YSk7XG4gICAgICBjdXJyZW50RGF0YSA9IGN1cnJlbnRIYXNoO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudEhhc2g7XG4gIH1cbiAgdXBkYXRlKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBbc2lkZU5vZGVzLCBvbGRMZWFmSGFzaCwgb2xkTGVhZkRhdGFdID0gdGhpcy5zaWRlTm9kZXNGb3JSb290KGtleSwgdGhpcy5yb290KTtcbiAgICBjb25zdCBuZXdSb290ID0gdGhpcy51cGRhdGVXaXRoU2lkZU5vZGVzKGtleSwgdmFsdWUsIHNpZGVOb2Rlcywgb2xkTGVhZkhhc2gsIG9sZExlYWZEYXRhKTtcbiAgICB0aGlzLnNldFJvb3QobmV3Um9vdCk7XG4gIH1cbiAgZGVsZXRlKGtleSkge1xuICAgIGNvbnN0IFtzaWRlTm9kZXMsIG9sZExlYWZIYXNoLCBvbGRMZWFmRGF0YV0gPSB0aGlzLnNpZGVOb2Rlc0ZvclJvb3Qoa2V5LCB0aGlzLnJvb3QpO1xuICAgIGNvbnN0IG5ld1Jvb3QgPSB0aGlzLmRlbGV0ZVdpdGhTaWRlTm9kZXMoa2V5LCBzaWRlTm9kZXMsIG9sZExlYWZIYXNoLCBvbGRMZWFmRGF0YSk7XG4gICAgdGhpcy5zZXRSb290KG5ld1Jvb3QpO1xuICB9XG4gIHByb3ZlKGtleSkge1xuICAgIGNvbnN0IFtzaWRlTm9kZXMsIGxlYWZIYXNoLCBsZWFmRGF0YSwgc2libGluZ0RhdGFdID0gdGhpcy5zaWRlTm9kZXNGb3JSb290KGtleSwgdGhpcy5yb290KTtcbiAgICBjb25zdCBub25FbXB0eVNpZGVOb2RlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lkZU5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoc2lkZU5vZGVzW2ldICE9PSBcIlwiKSB7XG4gICAgICAgIG5vbkVtcHR5U2lkZU5vZGVzLnB1c2goc2lkZU5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5vbk1lbWJlcnNoaXBMZWFmRGF0YSA9IFwiXCI7XG4gICAgaWYgKGxlYWZIYXNoICE9PSBaRVJPKSB7XG4gICAgICBjb25zdCBbYWN0dWFsUGF0aF0gPSBwYXJzZUxlYWYobGVhZkRhdGEpO1xuICAgICAgaWYgKGFjdHVhbFBhdGggIT09IGtleSkge1xuICAgICAgICBub25NZW1iZXJzaGlwTGVhZkRhdGEgPSBsZWFmRGF0YTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvb2YgPSBuZXcgc3BhcnNlTWVya2xlUHJvb2ZfZGVmYXVsdChub25FbXB0eVNpZGVOb2Rlcywgbm9uTWVtYmVyc2hpcExlYWZEYXRhLCBzaWJsaW5nRGF0YSk7XG4gICAgcmV0dXJuIHByb29mO1xuICB9XG4gIHByb3ZlQ29tcGFjdGVkKGtleSkge1xuICAgIGNvbnN0IHByb29mID0gdGhpcy5wcm92ZShrZXkpO1xuICAgIGNvbnN0IGNvbXBhY3RlZFByb29mID0gY29tcGFjdFByb29mKHByb29mKTtcbiAgICByZXR1cm4gY29tcGFjdGVkUHJvb2Y7XG4gIH1cbn07XG5leHBvcnQge1xuICBTcGFyc2VNZXJrbGVUcmVlLFxuICBjYWxjUm9vdCxcbiAgY29uc3RydWN0VHJlZSxcbiAgZ2V0UHJvb2YsXG4gIGhhc2hMZWFmLFxuICBoYXNoTm9kZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@fuel-ts+merkle@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6.1__de9684f3895abff2485b47f5d673b5af/node_modules/@fuel-ts/merkle/dist/index.mjs\n");

/***/ })

};
;