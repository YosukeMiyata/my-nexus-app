"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@avail-project+nexus-core@0.0.1-beta.0_bufferutil@4.0.9_google-protobuf@3.21.4_utf-8-va_56dd550c8b9e0639694cd9176377fa72";
exports.ids = ["vendor-chunks/@avail-project+nexus-core@0.0.1-beta.0_bufferutil@4.0.9_google-protobuf@3.21.4_utf-8-va_56dd550c8b9e0639694cd9176377fa72"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@avail-project+nexus-core@0.0.1-beta.0_bufferutil@4.0.9_google-protobuf@3.21.4_utf-8-va_56dd550c8b9e0639694cd9176377fa72/node_modules/@avail-project/nexus-core/dist/commons/index.js":
/*!******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@avail-project+nexus-core@0.0.1-beta.0_bufferutil@4.0.9_google-protobuf@3.21.4_utf-8-va_56dd550c8b9e0639694cd9176377fa72/node_modules/@avail-project/nexus-core/dist/commons/index.js ***!
  \******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar Decimal = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/.pnpm/decimal.js@10.6.0/node_modules/decimal.js/decimal.js\");\nvar viem = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_cjs/index.js\");\nvar chains = __webpack_require__(/*! viem/chains */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_cjs/chains/index.js\");\n\nexports.SwapMode = void 0;\n(function (SwapMode) {\n    SwapMode[SwapMode[\"EXACT_IN\"] = 0] = \"EXACT_IN\";\n    SwapMode[SwapMode[\"EXACT_OUT\"] = 1] = \"EXACT_OUT\";\n})(exports.SwapMode || (exports.SwapMode = {}));\nconst CaliburSBCTypes = {\n    BatchedCall: [\n        { name: 'calls', type: 'Call[]' },\n        { name: 'revertOnFailure', type: 'bool' },\n    ],\n    Call: [\n        { name: 'to', type: 'address' },\n        { name: 'value', type: 'uint256' },\n        { name: 'data', type: 'bytes' },\n    ],\n    SignedBatchedCall: [\n        { name: 'batchedCall', type: 'BatchedCall' },\n        { name: 'nonce', type: 'uint256' },\n        { name: 'keyHash', type: 'bytes32' },\n        { name: 'executor', type: 'address' },\n        { name: 'deadline', type: 'uint256' },\n    ],\n};\n\nconst SUPPORTED_CHAINS = {\n    // Mainnet chains\n    ETHEREUM: 1,\n    BASE: 8453,\n    ARBITRUM: 42161,\n    OPTIMISM: 10,\n    POLYGON: 137,\n    AVALANCHE: 43114,\n    SCROLL: 534352,\n    SOPHON: 50104,\n    KAIA: 8217,\n    BNB: 56,\n    HYPEREVM: 999,\n    // Testnet chains\n    SEPOLIA: 11155111,\n    BASE_SEPOLIA: 84532,\n    ARBITRUM_SEPOLIA: 421614,\n    OPTIMISM_SEPOLIA: 11155420,\n    POLYGON_AMOY: 80002,\n    MONAD_TESTNET: 10143,\n};\nconst BASE_TOKEN_METADATA = {\n    ETH: {\n        symbol: 'ETH',\n        name: 'Ethereum',\n        decimals: 18,\n        icon: 'https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628',\n        coingeckoId: 'ethereum',\n        isNative: true,\n    },\n    USDT: {\n        symbol: 'USDT',\n        name: 'Tether USD',\n        decimals: 6,\n        icon: 'https://coin-images.coingecko.com/coins/images/35023/large/USDT.png',\n        coingeckoId: 'tether',\n    },\n    USDC: {\n        symbol: 'USDC',\n        name: 'USD Coin',\n        decimals: 6,\n        icon: 'https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694',\n        coingeckoId: 'usd-coin',\n    },\n};\nconst TOKEN_METADATA = BASE_TOKEN_METADATA;\nconst TESTNET_TOKEN_METADATA = {\n    ETH: { ...BASE_TOKEN_METADATA.ETH, name: 'Test Ethereum' },\n    USDT: { ...BASE_TOKEN_METADATA.USDT, name: 'Test Tether USD' },\n    USDC: { ...BASE_TOKEN_METADATA.USDC, name: 'Test USD Coin' },\n};\nconst CHAIN_METADATA = {\n    // Mainnet chains\n    [SUPPORTED_CHAINS.ETHEREUM]: {\n        id: 1,\n        name: 'Ethereum',\n        shortName: 'eth',\n        logo: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png',\n        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n        rpcUrls: ['https://eth.merkle.io'],\n        blockExplorerUrls: ['https://etherscan.io'],\n    },\n    [SUPPORTED_CHAINS.BASE]: {\n        id: 8453,\n        name: 'Base',\n        shortName: 'base',\n        logo: 'https://pbs.twimg.com/profile_images/1945608199500910592/rnk6ixxH_400x400.jpg',\n        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n        rpcUrls: ['https://mainnet.base.org'],\n        blockExplorerUrls: ['https://basescan.org'],\n    },\n    [SUPPORTED_CHAINS.ARBITRUM]: {\n        id: 42161,\n        name: 'Arbitrum One',\n        shortName: 'arb1',\n        logo: 'https://assets.coingecko.com/coins/images/16547/small/photo_2023-03-29_21.47.00.jpeg',\n        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n        rpcUrls: [\n            'https://arb-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n            'https://arbitrum.blockpi.network/v1/rpc/a8ccd43cdc840c2b2d20c24a058514a21302376d',\n        ],\n        blockExplorerUrls: ['https://arbiscan.io'],\n    },\n    [SUPPORTED_CHAINS.OPTIMISM]: {\n        id: 10,\n        name: 'Optimism',\n        shortName: 'oeth',\n        logo: 'https://assets.coingecko.com/coins/images/25244/small/Optimism.png',\n        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n        rpcUrls: ['https://mainnet.optimism.io'],\n        blockExplorerUrls: ['https://optimistic.etherscan.io'],\n    },\n    [SUPPORTED_CHAINS.POLYGON]: {\n        id: 137,\n        name: 'Polygon',\n        shortName: 'matic',\n        logo: 'https://assets.coingecko.com/coins/images/4713/small/polygon.png',\n        nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },\n        rpcUrls: ['https://polygon-rpc.com'],\n        blockExplorerUrls: ['https://polygonscan.com'],\n    },\n    [SUPPORTED_CHAINS.AVALANCHE]: {\n        id: 43114,\n        name: 'Avalanche',\n        shortName: 'avax',\n        logo: 'https://assets.coingecko.com/coins/images/12559/small/Avalanche_Circle_RedWhite_Trans.png',\n        nativeCurrency: { name: 'Avalanche', symbol: 'AVAX', decimals: 18 },\n        rpcUrls: ['https://api.avax.network/ext/bc/C/rpc'],\n        blockExplorerUrls: ['https://snowtrace.io'],\n    },\n    [SUPPORTED_CHAINS.SCROLL]: {\n        id: 534352,\n        name: 'Scroll',\n        shortName: 'scroll',\n        logo: 'https://assets.coingecko.com/coins/images/50571/standard/scroll.jpg?1728376125',\n        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n        rpcUrls: ['https://rpc.scroll.io'],\n        blockExplorerUrls: ['https://scrollscan.com'],\n    },\n    [SUPPORTED_CHAINS.SOPHON]: {\n        id: 50104,\n        name: 'Sophon',\n        shortName: 'sophon',\n        logo: 'https://assets.coingecko.com/coins/images/38680/large/sophon_logo_200.png',\n        nativeCurrency: { name: 'Sophon', symbol: 'SOPH', decimals: 18 },\n        rpcUrls: ['https://rpc.sophon.xyz'],\n        blockExplorerUrls: ['https://explorer.sophon.xyz'],\n    },\n    [SUPPORTED_CHAINS.KAIA]: {\n        id: 8217,\n        name: 'Kaia Mainnet',\n        shortName: 'kaia',\n        logo: 'https://assets.coingecko.com/asset_platforms/images/9672/large/kaia.png',\n        nativeCurrency: { name: 'Kaia', symbol: 'KAIA', decimals: 18 },\n        rpcUrls: ['https://public-en.node.kaia.io'],\n        blockExplorerUrls: ['https://kaiascan.io'],\n    },\n    [SUPPORTED_CHAINS.BNB]: {\n        id: 56,\n        name: 'BNB Smart Chain',\n        shortName: 'bnb',\n        logo: 'https://assets.coingecko.com/asset_platforms/images/1/large/bnb_smart_chain.png',\n        nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },\n        rpcUrls: ['https://bsc-pokt.nodies.app'],\n        blockExplorerUrls: ['https://bscscan.com'],\n    },\n    [SUPPORTED_CHAINS.HYPEREVM]: {\n        id: 999,\n        name: 'Hyperliquid EVM',\n        shortName: 'hyperliquid',\n        logo: 'https://assets.coingecko.com/asset_platforms/images/243/large/hyperliquid.png',\n        nativeCurrency: { name: 'HYPE', symbol: 'HYPE', decimals: 18 },\n        rpcUrls: ['https://rpc.hyperliquid.xyz/evm'],\n        blockExplorerUrls: ['https://hyperevmscan.io/'],\n    },\n    // Testnet chains\n    [SUPPORTED_CHAINS.SEPOLIA]: {\n        id: 11155111,\n        name: 'Sepolia',\n        shortName: 'sepolia',\n        logo: 'https://assets.coingecko.com/coins/images/13383/large/ethereum.png',\n        nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },\n        rpcUrls: ['https://sepolia.drpc.org'],\n        blockExplorerUrls: ['https://sepolia.etherscan.io'],\n    },\n    [SUPPORTED_CHAINS.BASE_SEPOLIA]: {\n        id: 84532,\n        name: 'Base Sepolia',\n        shortName: 'base-sepolia',\n        logo: 'https://pbs.twimg.com/profile_images/1945608199500910592/rnk6ixxH_400x400.jpg',\n        nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },\n        rpcUrls: ['https://sepolia.base.org'],\n        blockExplorerUrls: ['https://sepolia.basescan.org'],\n    },\n    [SUPPORTED_CHAINS.MONAD_TESTNET]: {\n        id: 10143,\n        name: 'Monad Testnet',\n        shortName: 'monad-testnet',\n        logo: 'https://assets.coingecko.com/coins/images/38927/standard/monad.jpg',\n        nativeCurrency: { name: 'Testnet MON Token', symbol: 'MON', decimals: 18 },\n        rpcUrls: ['https://testnet-rpc.monad.xyz/'],\n        blockExplorerUrls: ['https://testnet.monadexplorer.com/'],\n    },\n    [SUPPORTED_CHAINS.ARBITRUM_SEPOLIA]: {\n        id: 421614,\n        name: 'Arbitrum Sepolia',\n        shortName: 'arb-sepolia',\n        logo: 'https://assets.coingecko.com/coins/images/16547/small/photo_2023-03-29_21.47.00.jpeg',\n        nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },\n        rpcUrls: ['https://sepolia-rollup.arbitrum.io/rpc'],\n        blockExplorerUrls: ['https://sepolia.arbiscan.io'],\n    },\n    [SUPPORTED_CHAINS.OPTIMISM_SEPOLIA]: {\n        id: 11155420,\n        name: 'Optimism Sepolia',\n        shortName: 'op-sepolia',\n        logo: 'https://assets.coingecko.com/coins/images/25244/small/Optimism.png',\n        nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },\n        rpcUrls: ['https://sepolia.optimism.io'],\n        blockExplorerUrls: ['https://sepolia-optimism.etherscan.io'],\n    },\n    [SUPPORTED_CHAINS.POLYGON_AMOY]: {\n        id: 80002,\n        name: 'Polygon Amoy',\n        shortName: 'amoy',\n        logo: 'https://assets.coingecko.com/coins/images/4713/small/polygon.png',\n        nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },\n        rpcUrls: ['https://rpc-amoy.polygon.technology'],\n        blockExplorerUrls: ['https://amoy.polygonscan.com'],\n    },\n};\n// Event name constants to prevent typos\nconst NEXUS_EVENTS = {\n    STEP_COMPLETE: 'step_complete',\n    EXPECTED_STEPS: 'expected_steps',\n    SWAP_STEPS: 'swap_step',\n    // Modular event names\n    BRIDGE_EXECUTE_EXPECTED_STEPS: 'bridge_execute_expected_steps',\n    BRIDGE_EXECUTE_COMPLETED_STEPS: 'bridge_execute_completed_steps',\n};\n// Helper constants for mainnet and testnet chain categorization\nconst MAINNET_CHAINS = [\n    SUPPORTED_CHAINS.ETHEREUM,\n    SUPPORTED_CHAINS.BASE,\n    SUPPORTED_CHAINS.ARBITRUM,\n    SUPPORTED_CHAINS.OPTIMISM,\n    SUPPORTED_CHAINS.POLYGON,\n    SUPPORTED_CHAINS.AVALANCHE,\n    SUPPORTED_CHAINS.SCROLL,\n    SUPPORTED_CHAINS.SOPHON,\n    SUPPORTED_CHAINS.KAIA,\n    SUPPORTED_CHAINS.BNB,\n    SUPPORTED_CHAINS.HYPEREVM,\n];\nconst TESTNET_CHAINS = [\n    SUPPORTED_CHAINS.SEPOLIA,\n    SUPPORTED_CHAINS.BASE_SEPOLIA,\n    SUPPORTED_CHAINS.ARBITRUM_SEPOLIA,\n    SUPPORTED_CHAINS.OPTIMISM_SEPOLIA,\n    SUPPORTED_CHAINS.POLYGON_AMOY,\n    SUPPORTED_CHAINS.MONAD_TESTNET,\n];\n/**\n * Token contract addresses per chain\n * This registry contains the contract addresses for supported tokens across different chains\n */\nconst TOKEN_CONTRACT_ADDRESSES = {\n    USDC: {\n        [SUPPORTED_CHAINS.ETHEREUM]: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n        [SUPPORTED_CHAINS.BASE]: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\n        [SUPPORTED_CHAINS.POLYGON]: '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359',\n        [SUPPORTED_CHAINS.ARBITRUM]: '0xaf88d065e77c8cc2239327c5edb3a432268e5831',\n        [SUPPORTED_CHAINS.SOPHON]: '0x9aa0f72392b5784ad86c6f3e899bcc053d00db4f',\n        [SUPPORTED_CHAINS.OPTIMISM]: '0x0b2c639c533813f4aa9d7837caf62653d097ff85',\n        [SUPPORTED_CHAINS.SCROLL]: '0x06efdbff2a14a7c8e15944d1f4a48f9f95f663a4',\n        [SUPPORTED_CHAINS.AVALANCHE]: '0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e',\n        [SUPPORTED_CHAINS.BNB]: '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d',\n        // testnet chains\n        [SUPPORTED_CHAINS.SEPOLIA]: '0xf08A50178dfcDe18524640EA6618a1f965821715',\n        [SUPPORTED_CHAINS.BASE_SEPOLIA]: '0x036CbD53842c5426634e7929541eC2318f3dCF7e',\n        [SUPPORTED_CHAINS.ARBITRUM_SEPOLIA]: '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d',\n        [SUPPORTED_CHAINS.OPTIMISM_SEPOLIA]: '0x5fd84259d66Cd46123540766Be93DFE6D43130D7',\n        [SUPPORTED_CHAINS.POLYGON_AMOY]: '0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582',\n        [SUPPORTED_CHAINS.MONAD_TESTNET]: '0xf817257fed379853cDe0fa4F97AB987181B1E5Ea',\n    },\n    USDT: {\n        [SUPPORTED_CHAINS.ETHEREUM]: '0xdac17f958d2ee523a2206206994597c13d831ec7',\n        [SUPPORTED_CHAINS.POLYGON]: '0xc2132d05d31c914a87c6611c10748aeb04b58e8f',\n        [SUPPORTED_CHAINS.ARBITRUM]: '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9',\n        [SUPPORTED_CHAINS.SOPHON]: '0x6386da73545ae4e2b2e0393688fa8b65bb9a7169',\n        [SUPPORTED_CHAINS.KAIA]: '0xd077a400968890eacc75cdc901f0356c943e4fdb',\n        [SUPPORTED_CHAINS.OPTIMISM]: '0x94b008aa00579c1307b0ef2c499ad98a8ce58e58',\n        [SUPPORTED_CHAINS.SCROLL]: '0xf55bec9cafdbe8730f096aa55dad6d22d44099df',\n        [SUPPORTED_CHAINS.AVALANCHE]: '0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7',\n        [SUPPORTED_CHAINS.BNB]: '0x55d398326f99059fF775485246999027B3197955',\n        [SUPPORTED_CHAINS.HYPEREVM]: '0xB8CE59FC3717ada4C02eaDF9682A9e934F625ebb',\n        // testnet chains\n        [SUPPORTED_CHAINS.SEPOLIA]: '0xaA8E23Fb1079EA71e0a56F48a2aA51851D8433D0',\n        [SUPPORTED_CHAINS.BASE_SEPOLIA]: '0xf7e53b20f39a5f8c35005fEf37eef03A7b0d0B5a',\n        [SUPPORTED_CHAINS.ARBITRUM_SEPOLIA]: '0xb9a4873d8d2C22e56b8574e8605644d08E047434',\n        [SUPPORTED_CHAINS.OPTIMISM_SEPOLIA]: '0x7F5c764cBc14f9669B88837ca1490cCa17c31607',\n        [SUPPORTED_CHAINS.POLYGON_AMOY]: '0x2c852e740B62308c46DD29B982FBb650D063Bd07',\n        [SUPPORTED_CHAINS.MONAD_TESTNET]: '0x88b8E2161DEDC77EF4ab7585569D2415a1C1055D',\n    },\n    // ETH is native on all supported chains, no contract address needed\n};\nconst DESTINATION_SWAP_TOKENS = new Map([\n    [\n        SUPPORTED_CHAINS.OPTIMISM,\n        [\n            {\n                decimals: 18,\n                logo: 'https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628',\n                name: 'Ether',\n                symbol: 'ETH',\n                tokenAddress: '0x0000000000000000000000000000000000000000',\n            },\n            {\n                decimals: 6,\n                logo: 'https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694',\n                name: 'USD Coin',\n                symbol: 'USDC',\n                tokenAddress: '0x0b2c639c533813f4aa9d7837caf62653d097ff85',\n            },\n            {\n                decimals: 18,\n                logo: 'https://coin-images.coingecko.com/coins/images/25244/large/Optimism.png?1696524385',\n                name: 'Optimism',\n                symbol: 'OP',\n                tokenAddress: '0x4200000000000000000000000000000000000042',\n            },\n            {\n                decimals: 18,\n                logo: 'https://coin-images.coingecko.com/coins/images/12645/large/AAVE.png?1696512452',\n                name: 'Aave Token',\n                symbol: 'AAVE',\n                tokenAddress: '0x76fb31fb4af56892a25e32cfc43de717950c9278',\n            },\n            {\n                decimals: 18,\n                logo: 'https://coin-images.coingecko.com/coins/images/12504/large/uni.jpg?1696512319',\n                name: 'Uniswap',\n                symbol: 'UNI',\n                tokenAddress: '0x6fd9d7ad17242c41f7131d257212c54a0e816691',\n            },\n        ],\n    ],\n    [\n        SUPPORTED_CHAINS.ARBITRUM,\n        [\n            {\n                decimals: 18,\n                logo: 'https://coin-images.coingecko.com/coins/images/29850/large/pepe-token.jpeg?1696528776',\n                name: 'Pepe',\n                symbol: 'PEPE',\n                tokenAddress: '0x25d887ce7a35172c62febfd67a1856f20faebb00',\n            },\n            {\n                decimals: 18,\n                logo: 'https://coin-images.coingecko.com/coins/images/13573/large/Lido_DAO.png?1696513326',\n                name: 'Lido DAO Token',\n                symbol: 'LDO',\n                tokenAddress: '0x13ad51ed4f1b7e9dc168d8a00cb3f4ddd85efa60',\n            },\n        ],\n    ],\n    [\n        SUPPORTED_CHAINS.SCROLL,\n        [\n            {\n                decimals: 18,\n                logo: 'https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628',\n                name: 'Ether',\n                symbol: 'ETH',\n                tokenAddress: '0x0000000000000000000000000000000000000000',\n            },\n        ],\n    ],\n    [\n        SUPPORTED_CHAINS.BASE,\n        [\n            {\n                decimals: 18,\n                logo: 'https://coin-images.coingecko.com/coins/images/9956/large/Badge_Dai.png?1696509996',\n                name: 'Dai Stablecoin',\n                symbol: 'DAI',\n                tokenAddress: '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb',\n            },\n            {\n                decimals: 18,\n                logo: 'https://coin-images.coingecko.com/coins/images/28206/large/ftxG9_TJ_400x400.jpeg?1696527208',\n                name: 'LayerZero',\n                symbol: 'ZRO',\n                tokenAddress: '0x6985884c4392d348587b19cb9eaaf157f13271cd',\n            },\n            {\n                decimals: 18,\n                logo: 'https://assets.coingecko.com/coins/images/12151/standard/OM_Token.png?1696511991',\n                name: 'MANTRA',\n                symbol: 'OM',\n                tokenAddress: '0x3992b27da26848c2b19cea6fd25ad5568b68ab98',\n            },\n            {\n                decimals: 18,\n                logo: 'https://assets.coingecko.com/coins/images/54411/standard/Qm4DW488_400x400.jpg',\n                name: 'KAITO',\n                symbol: 'KAITO',\n                tokenAddress: '0x98d0baa52b2d063e780de12f615f963fe8537553',\n            },\n        ],\n    ],\n]);\n\nconst LOG_LEVEL = {\n    DEBUG: 1,\n    ERROR: 4,\n    INFO: 2,\n    NOLOGS: 5,\n    WARNING: 3,\n};\nconst setExceptionReporter = (reporter) => {\n    state.exceptionReporter = reporter;\n};\nconst sendException = (msg) => {\n    if (!state.exceptionReporter)\n        return;\n    try {\n        state.exceptionReporter(msg);\n    }\n    catch (reportErr) {\n        console.error('[LOGGER] Exception reporter threw:', reportErr);\n    }\n};\nconst setLogLevel = (level) => {\n    state.logLevel = level;\n};\nconst getLogger = () => {\n    return state.logger;\n};\nclass Logger {\n    constructor() {\n        this.prefix = 'NEXUS_SDK';\n    }\n    consoleLog(level, message, params) {\n        if (level < state.logLevel) {\n            return;\n        }\n        switch (level) {\n            case LOG_LEVEL.DEBUG:\n                console.debug(`[DEBUG]`, message, params);\n                break;\n            case LOG_LEVEL.ERROR:\n                console.error(`[ERROR]`, message, params);\n                break;\n            case LOG_LEVEL.INFO:\n                console.info(`[INFO]`, message, params);\n                break;\n            case LOG_LEVEL.WARNING:\n                console.warn(`[WARN]`, message, params);\n                break;\n            default:\n                console.log(`[LOG]`, message, params);\n        }\n    }\n    debug(message, params = {}) {\n        this.internalLog(LOG_LEVEL.DEBUG, message, params);\n    }\n    error(message, err) {\n        if (err instanceof Error) {\n            this.internalLog(LOG_LEVEL.ERROR, message, err.message);\n            sendException(JSON.stringify({ error: err.message, message }));\n            return;\n        }\n        if (typeof err === 'string') {\n            this.internalLog(LOG_LEVEL.ERROR, message, err);\n            sendException(JSON.stringify({ error: err, message }));\n        }\n        else {\n            this.internalLog(LOG_LEVEL.ERROR, message, undefined);\n            sendException(JSON.stringify({ message }));\n        }\n    }\n    info(message, params = {}) {\n        this.internalLog(LOG_LEVEL.INFO, message, params);\n    }\n    internalLog(level, message, params) {\n        const logMessage = `[${this.prefix}] Msg: ${message}\\n`;\n        this.consoleLog(level, logMessage, params);\n    }\n    warn(message, params = {}) {\n        this.internalLog(LOG_LEVEL.WARNING, message, params);\n    }\n}\nconst state = {\n    exceptionReporter: null,\n    logger: new Logger(),\n    logLevel: LOG_LEVEL.NOLOGS,\n};\n// Export a default logger instance for convenience\nconst logger = getLogger();\n\n/**\n * Shared utility for standardized error message extraction\n */\nfunction extractErrorMessage(error, fallbackContext) {\n    return error instanceof Error ? error.message : `Unknown ${fallbackContext} error`;\n}\nfunction wait(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n/**\n * Get Viem chain configuration for supported chains\n */\nfunction getViemChain(chainId) {\n    switch (chainId) {\n        case 1:\n            return chains.mainnet;\n        case 137:\n            return chains.polygon;\n        case 42161:\n            return chains.arbitrum;\n        case 10:\n            return chains.optimism;\n        case 8453:\n            return chains.base;\n        default:\n            // Return a basic chain config for unsupported chains\n            return {\n                id: chainId,\n                name: `Chain ${chainId}`,\n                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },\n                rpcUrls: {\n                    default: { http: [] },\n                    public: { http: [] },\n                },\n            };\n    }\n}\n/**\n * Format a balance string to a human-readable format using Decimal.js\n */\nfunction formatBalance(balance, decimals, precision = 4) {\n    const balanceDecimal = new Decimal(balance);\n    const divisor = new Decimal(10).pow(decimals);\n    const formatted = balanceDecimal.div(divisor);\n    if (formatted.isZero())\n        return '0';\n    if (formatted.lt(0.0001))\n        return '< 0.0001';\n    return formatted.toFixed(precision).replace(/\\.?0+$/, '');\n}\n/**\n * Parse units from a human-readable string to wei/smallest unit using Decimal.js\n */\nfunction parseUnits(value, decimals) {\n    const valueDecimal = new Decimal(value);\n    const multiplier = new Decimal(10).pow(decimals);\n    const result = valueDecimal.mul(multiplier);\n    return BigInt(result.toFixed(0));\n}\n/**\n * Format units from wei/smallest unit to human-readable string using Decimal.js\n */\nfunction formatUnits(value, decimals) {\n    const valueDecimal = new Decimal(value.toString());\n    const divisor = new Decimal(10).pow(decimals);\n    const result = valueDecimal.div(divisor);\n    return result.toFixed();\n}\n/**\n * Validate if a string is a valid Ethereum address using viem\n */\nfunction isValidAddress(address) {\n    return viem.isAddress(address);\n}\n/**\n * Get mainnet token metadata by symbol\n */\nconst getMainnetTokenMetadata = (symbol) => {\n    return TOKEN_METADATA[symbol];\n};\n/**\n * Get testnet token metadata by symbol\n */\nconst getTestnetTokenMetadata = (symbol) => {\n    return TESTNET_TOKEN_METADATA[symbol];\n};\n/**\n * Get token metadata by symbol (defaults to mainnet, kept for backward compatibility)\n */\nconst getTokenMetadata = (symbol) => {\n    return TOKEN_METADATA[symbol];\n};\n/**\n * Get chain metadata by chain ID\n */\nfunction getChainMetadata(chainId) {\n    return CHAIN_METADATA[chainId];\n}\n/**\n * Format a mainnet token amount with proper decimals and symbol\n */\nfunction formatTokenAmount(amount, tokenSymbol, precision = 4) {\n    const metadata = getMainnetTokenMetadata(tokenSymbol);\n    if (!metadata)\n        return `${amount} ${tokenSymbol}`;\n    const amountStr = typeof amount === 'bigint' ? amount.toString() : amount;\n    const formatted = formatBalance(amountStr, metadata.decimals, precision);\n    return `${formatted} ${metadata.symbol}`;\n}\n/**\n * Format a testnet token amount with proper decimals and symbol\n */\nfunction formatTestnetTokenAmount(amount, tokenSymbol, precision = 4) {\n    const metadata = getTestnetTokenMetadata(tokenSymbol);\n    if (!metadata)\n        return `${amount} ${tokenSymbol}`;\n    const amountStr = typeof amount === 'bigint' ? amount.toString() : amount;\n    const formatted = formatBalance(amountStr, metadata.decimals, precision);\n    return `${formatted} ${metadata.symbol}`;\n}\n/**\n * Truncate an address for display purposes\n */\nfunction truncateAddress(address, startLength = 6, endLength = 4) {\n    if (!isValidAddress(address))\n        return address;\n    if (address.length <= startLength + endLength + 2)\n        return address;\n    return `${address.slice(0, startLength)}...${address.slice(-endLength)}`;\n}\n/**\n * Convert chain ID to hex format\n */\nfunction chainIdToHex(chainId) {\n    return `0x${chainId.toString(16)}`;\n}\n/**\n * Convert hex chain ID to number\n */\nfunction hexToChainId(hex) {\n    return parseInt(hex, 16);\n}\nconst isMainnetChain = (chainId) => {\n    return MAINNET_CHAINS.includes(chainId);\n};\nconst isTestnetChain = (chainId) => {\n    return TESTNET_CHAINS.includes(chainId);\n};\n/**\n * Enhanced contract parameter validation with detailed error messages\n */\nfunction validateContractParams(params) {\n    const { contractAddress, contractAbi, functionName, functionParams, chainId } = params;\n    // Validate contract address\n    if (!contractAddress || typeof contractAddress !== 'string') {\n        return { isValid: false, error: 'Contract address is required and must be a string' };\n    }\n    if (!viem.isAddress(contractAddress)) {\n        return { isValid: false, error: 'Contract address must be a checksummed Ethereum address' };\n    }\n    // Validate ABI\n    if (!Array.isArray(contractAbi) || contractAbi.length === 0) {\n        return { isValid: false, error: 'Contract ABI is required and must be a non-empty array' };\n    }\n    // Validate function name\n    if (!functionName || typeof functionName !== 'string') {\n        return { isValid: false, error: 'Function name is required and must be a string' };\n    }\n    // Find function in ABI\n    const functionAbi = contractAbi.find((item) => item.type === 'function' && item.name === functionName);\n    if (!functionAbi) {\n        return { isValid: false, error: `Function '${functionName}' not found in contract ABI` };\n    }\n    // Validate parameters count\n    const expectedParamsCount = functionAbi.inputs?.length ?? 0;\n    const providedParamsCount = functionParams?.length || 0;\n    if (expectedParamsCount !== providedParamsCount) {\n        return {\n            isValid: false,\n            error: `Function '${functionName}' expects ${expectedParamsCount} parameters, but ${providedParamsCount} were provided`,\n        };\n    }\n    // Validate chain ID\n    if (!chainId || !CHAIN_METADATA[chainId]) {\n        return { isValid: false, error: `Unsupported chain ID: ${chainId}` };\n    }\n    return { isValid: true };\n}\n/**\n * Enhanced contract call encoding with comprehensive error handling\n */\nfunction encodeContractCall(params) {\n    try {\n        const { contractAbi, functionName, functionParams } = params;\n        const data = viem.encodeFunctionData({\n            abi: contractAbi,\n            functionName,\n            args: functionParams,\n        });\n        return { success: true, data };\n    }\n    catch (error) {\n        return {\n            success: false,\n            error: `Failed to encode contract call: ${extractErrorMessage(error, 'encoding')}`,\n        };\n    }\n}\n/**\n * Validate and ensure a value is a valid transaction hash\n */\nfunction validateTransactionHash(value) {\n    if (typeof value !== 'string')\n        return false;\n    return viem.isHash(value);\n}\n/**\n * Validate hex response from RPC calls\n */\nfunction validateHexResponse(value, fieldName) {\n    if (typeof value !== 'string') {\n        return { isValid: false, error: `${fieldName} must be a string, got ${typeof value}` };\n    }\n    if (!value.startsWith('0x')) {\n        return { isValid: false, error: `${fieldName} must be a hex string starting with 0x` };\n    }\n    return { isValid: true };\n}\n/**\n * Enhanced block explorer URL generation with fallback support\n */\nfunction getBlockExplorerUrl(chainId, txHash) {\n    const chainMetadata = CHAIN_METADATA[chainId];\n    if (!chainMetadata?.blockExplorerUrls?.[0]) {\n        logger.warn(`No block explorer URL found for chain ${chainId}`);\n        return '';\n    }\n    const baseUrl = chainMetadata.blockExplorerUrls[0];\n    return `${baseUrl}/tx/${txHash}`;\n}\n/**\n * Search for transaction hash in block transactions\n */\nasync function searchTransactionInBlock(provider, fromAddress) {\n    const latestBlock = (await provider.request({\n        method: 'eth_getBlockByNumber',\n        params: ['latest', true],\n    }));\n    if (!latestBlock?.transactions)\n        return null;\n    for (const tx of latestBlock.transactions) {\n        if (tx.from?.toLowerCase() === fromAddress.toLowerCase()) {\n            if (validateTransactionHash(tx.hash)) {\n                return tx.hash;\n            }\n        }\n    }\n    return null;\n}\n/**\n * Poll for transaction hash with timeout\n */\nasync function pollForTransactionHash(provider, fromAddress, timeout) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < timeout) {\n        const hash = await searchTransactionInBlock(provider, fromAddress);\n        if (hash) {\n            return { success: true, hash };\n        }\n        await wait(2000);\n    }\n    return { success: false, error: 'Transaction hash not found within timeout period' };\n}\n/**\n * Get transaction hash with multiple fallback strategies\n */\nasync function getTransactionHashWithFallback(provider, response, options = {}) {\n    const { enablePolling = false, timeout = 30000, fromAddress } = options;\n    // Strategy 1: Direct response validation\n    if (validateTransactionHash(response)) {\n        return { success: true, hash: response };\n    }\n    // Strategy 2: Transaction polling (if enabled)\n    if (enablePolling && fromAddress) {\n        try {\n            return await pollForTransactionHash(provider, fromAddress, timeout);\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Transaction polling failed: ${extractErrorMessage(error, 'polling')}`,\n            };\n        }\n    }\n    return {\n        success: false,\n        error: `Invalid transaction hash response: ${typeof response}${enablePolling ? ' (polling disabled)' : ''}`,\n    };\n}\n/**\n * Enhanced transaction receipt waiting using Viem\n */\nasync function waitForTransactionReceipt(provider, txHash, options = {}, chainId = 1) {\n    const { timeout = 300000, // 5 minutes default\n    requiredConfirmations = 1, pollingInterval = 2000, } = options;\n    try {\n        const client = viem.createPublicClient({\n            chain: getViemChain(chainId),\n            transport: viem.custom(provider),\n        });\n        // Use Viem's waitForTransactionReceipt with timeout\n        const receipt = await client.waitForTransactionReceipt({\n            hash: txHash,\n            timeout,\n            pollingInterval,\n        });\n        // Check transaction status\n        if (receipt.status === 'reverted') {\n            return {\n                success: false,\n                error: 'Transaction failed (reverted)',\n                receipt,\n            };\n        }\n        // Get current block number for confirmation count\n        const currentBlock = await client.getBlockNumber();\n        const confirmations = Number(currentBlock - receipt.blockNumber) + 1;\n        // Check if we have enough confirmations\n        if (confirmations >= requiredConfirmations) {\n            return {\n                success: true,\n                receipt,\n                confirmations,\n            };\n        }\n        const confirmationStartTime = Date.now();\n        const confirmationTimeout = timeout || 300000;\n        // Wait for additional confirmations if needed\n        while (true) {\n            await wait(pollingInterval);\n            if (Date.now() - confirmationStartTime > confirmationTimeout) {\n                return {\n                    success: false,\n                    error: `Confirmation timeout: only ${confirmations} of ${requiredConfirmations} confirmations received`,\n                    receipt,\n                    confirmations,\n                };\n            }\n            const latestBlock = await client.getBlockNumber();\n            const currentConfirmations = Number(latestBlock - receipt.blockNumber) + 1;\n            if (currentConfirmations >= requiredConfirmations) {\n                return {\n                    success: true,\n                    receipt,\n                    confirmations: currentConfirmations,\n                };\n            }\n        }\n    }\n    catch (error) {\n        const errorMessage = error instanceof Error\n            ? error.message\n            : error?.shortMessage ||\n                error?.message ||\n                'Transaction receipt timeout';\n        return {\n            success: false,\n            error: errorMessage,\n        };\n    }\n}\n/**\n * Utility function to get token contract address for a specific token and chain\n * @param token Token symbol (e.g., 'USDC', 'USDT')\n * @param chainId Chain ID\n * @param isTestnet Whether to use testnet addresses\n * @returns Contract address or undefined if not found\n */\nfunction getTokenContractAddress(token, chainId) {\n    const registry = TOKEN_CONTRACT_ADDRESSES;\n    const address = registry[token]?.[chainId];\n    return address || undefined;\n}\n\nexports.CHAIN_METADATA = CHAIN_METADATA;\nexports.CaliburSBCTypes = CaliburSBCTypes;\nexports.DESTINATION_SWAP_TOKENS = DESTINATION_SWAP_TOKENS;\nexports.LOG_LEVEL = LOG_LEVEL;\nexports.MAINNET_CHAINS = MAINNET_CHAINS;\nexports.NEXUS_EVENTS = NEXUS_EVENTS;\nexports.SUPPORTED_CHAINS = SUPPORTED_CHAINS;\nexports.TESTNET_CHAINS = TESTNET_CHAINS;\nexports.TESTNET_TOKEN_METADATA = TESTNET_TOKEN_METADATA;\nexports.TOKEN_CONTRACT_ADDRESSES = TOKEN_CONTRACT_ADDRESSES;\nexports.TOKEN_METADATA = TOKEN_METADATA;\nexports.chainIdToHex = chainIdToHex;\nexports.encodeContractCall = encodeContractCall;\nexports.extractErrorMessage = extractErrorMessage;\nexports.formatBalance = formatBalance;\nexports.formatTestnetTokenAmount = formatTestnetTokenAmount;\nexports.formatTokenAmount = formatTokenAmount;\nexports.formatUnits = formatUnits;\nexports.getBlockExplorerUrl = getBlockExplorerUrl;\nexports.getChainMetadata = getChainMetadata;\nexports.getLogger = getLogger;\nexports.getMainnetTokenMetadata = getMainnetTokenMetadata;\nexports.getTestnetTokenMetadata = getTestnetTokenMetadata;\nexports.getTokenContractAddress = getTokenContractAddress;\nexports.getTokenMetadata = getTokenMetadata;\nexports.getTransactionHashWithFallback = getTransactionHashWithFallback;\nexports.getViemChain = getViemChain;\nexports.hexToChainId = hexToChainId;\nexports.isMainnetChain = isMainnetChain;\nexports.isTestnetChain = isTestnetChain;\nexports.isValidAddress = isValidAddress;\nexports.logger = logger;\nexports.parseUnits = parseUnits;\nexports.setExceptionReporter = setExceptionReporter;\nexports.setLogLevel = setLogLevel;\nexports.truncateAddress = truncateAddress;\nexports.validateContractParams = validateContractParams;\nexports.validateHexResponse = validateHexResponse;\nexports.validateTransactionHash = validateTransactionHash;\nexports.wait = wait;\nexports.waitForTransactionReceipt = waitForTransactionReceipt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGF2YWlsLXByb2plY3QrbmV4dXMtY29yZUAwLjAuMS1iZXRhLjBfYnVmZmVydXRpbEA0LjAuOV9nb29nbGUtcHJvdG9idWZAMy4yMS40X3V0Zi04LXZhXzU2ZGQ1NTBjOGI5ZTA2Mzk2OTRjZDkxNzYzNzdmYTcyL25vZGVfbW9kdWxlcy9AYXZhaWwtcHJvamVjdC9uZXh1cy1jb3JlL2Rpc3QvY29tbW9ucy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsbUdBQVk7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLHVKQUFNO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxxS0FBYTs7QUFFbEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCLGdCQUFnQixLQUFLO0FBQzdDO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QyxVQUFVLHVDQUF1QztBQUNqRDtBQUNBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkMsVUFBVSxnQ0FBZ0M7QUFDMUMsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BELFVBQVUsZ0NBQWdDO0FBQzFDLFVBQVUsa0NBQWtDO0FBQzVDLFVBQVUsbUNBQW1DO0FBQzdDLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQW1EO0FBQzlELFlBQVksc0RBQXNEO0FBQ2xFLFlBQVksb0RBQW9EO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQTRDO0FBQ3RFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBNEM7QUFDdEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUE0QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQTRDO0FBQ3RFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlEQUFpRDtBQUMzRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQTRDO0FBQ3RFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUE0QztBQUN0RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMENBQTBDO0FBQ3BFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBNEM7QUFDdEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQW9EO0FBQzlFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvREFBb0Q7QUFDOUU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUF3RDtBQUNsRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQW9EO0FBQzlFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvREFBb0Q7QUFDOUU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUE4QztBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QWdDO0FBQ2hDLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QixpQkFBaUI7QUFDakIsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0Isd0JBQXdCO0FBQ3hCLHNDQUFzQztBQUN0QyxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIsNEJBQTRCO0FBQzVCLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQiwrQkFBK0I7QUFDL0IsWUFBWTtBQUNaLGlDQUFpQyIsInNvdXJjZXMiOlsiL1VzZXJzL3lvdXN1a2UvTXlQcm9qZWN0L215LW5leHVzLWFwcC9ub2RlX21vZHVsZXMvLnBucG0vQGF2YWlsLXByb2plY3QrbmV4dXMtY29yZUAwLjAuMS1iZXRhLjBfYnVmZmVydXRpbEA0LjAuOV9nb29nbGUtcHJvdG9idWZAMy4yMS40X3V0Zi04LXZhXzU2ZGQ1NTBjOGI5ZTA2Mzk2OTRjZDkxNzYzNzdmYTcyL25vZGVfbW9kdWxlcy9AYXZhaWwtcHJvamVjdC9uZXh1cy1jb3JlL2Rpc3QvY29tbW9ucy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBEZWNpbWFsID0gcmVxdWlyZSgnZGVjaW1hbC5qcycpO1xudmFyIHZpZW0gPSByZXF1aXJlKCd2aWVtJyk7XG52YXIgY2hhaW5zID0gcmVxdWlyZSgndmllbS9jaGFpbnMnKTtcblxuZXhwb3J0cy5Td2FwTW9kZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoU3dhcE1vZGUpIHtcbiAgICBTd2FwTW9kZVtTd2FwTW9kZVtcIkVYQUNUX0lOXCJdID0gMF0gPSBcIkVYQUNUX0lOXCI7XG4gICAgU3dhcE1vZGVbU3dhcE1vZGVbXCJFWEFDVF9PVVRcIl0gPSAxXSA9IFwiRVhBQ1RfT1VUXCI7XG59KShleHBvcnRzLlN3YXBNb2RlIHx8IChleHBvcnRzLlN3YXBNb2RlID0ge30pKTtcbmNvbnN0IENhbGlidXJTQkNUeXBlcyA9IHtcbiAgICBCYXRjaGVkQ2FsbDogW1xuICAgICAgICB7IG5hbWU6ICdjYWxscycsIHR5cGU6ICdDYWxsW10nIH0sXG4gICAgICAgIHsgbmFtZTogJ3JldmVydE9uRmFpbHVyZScsIHR5cGU6ICdib29sJyB9LFxuICAgIF0sXG4gICAgQ2FsbDogW1xuICAgICAgICB7IG5hbWU6ICd0bycsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgICAgICB7IG5hbWU6ICd2YWx1ZScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgICAgICB7IG5hbWU6ICdkYXRhJywgdHlwZTogJ2J5dGVzJyB9LFxuICAgIF0sXG4gICAgU2lnbmVkQmF0Y2hlZENhbGw6IFtcbiAgICAgICAgeyBuYW1lOiAnYmF0Y2hlZENhbGwnLCB0eXBlOiAnQmF0Y2hlZENhbGwnIH0sXG4gICAgICAgIHsgbmFtZTogJ25vbmNlJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgIHsgbmFtZTogJ2tleUhhc2gnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgICAgeyBuYW1lOiAnZXhlY3V0b3InLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICAgICAgeyBuYW1lOiAnZGVhZGxpbmUnLCB0eXBlOiAndWludDI1NicgfSxcbiAgICBdLFxufTtcblxuY29uc3QgU1VQUE9SVEVEX0NIQUlOUyA9IHtcbiAgICAvLyBNYWlubmV0IGNoYWluc1xuICAgIEVUSEVSRVVNOiAxLFxuICAgIEJBU0U6IDg0NTMsXG4gICAgQVJCSVRSVU06IDQyMTYxLFxuICAgIE9QVElNSVNNOiAxMCxcbiAgICBQT0xZR09OOiAxMzcsXG4gICAgQVZBTEFOQ0hFOiA0MzExNCxcbiAgICBTQ1JPTEw6IDUzNDM1MixcbiAgICBTT1BIT046IDUwMTA0LFxuICAgIEtBSUE6IDgyMTcsXG4gICAgQk5COiA1NixcbiAgICBIWVBFUkVWTTogOTk5LFxuICAgIC8vIFRlc3RuZXQgY2hhaW5zXG4gICAgU0VQT0xJQTogMTExNTUxMTEsXG4gICAgQkFTRV9TRVBPTElBOiA4NDUzMixcbiAgICBBUkJJVFJVTV9TRVBPTElBOiA0MjE2MTQsXG4gICAgT1BUSU1JU01fU0VQT0xJQTogMTExNTU0MjAsXG4gICAgUE9MWUdPTl9BTU9ZOiA4MDAwMixcbiAgICBNT05BRF9URVNUTkVUOiAxMDE0Myxcbn07XG5jb25zdCBCQVNFX1RPS0VOX01FVEFEQVRBID0ge1xuICAgIEVUSDoge1xuICAgICAgICBzeW1ib2w6ICdFVEgnLFxuICAgICAgICBuYW1lOiAnRXRoZXJldW0nLFxuICAgICAgICBkZWNpbWFsczogMTgsXG4gICAgICAgIGljb246ICdodHRwczovL2NvaW4taW1hZ2VzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzI3OS9sYXJnZS9ldGhlcmV1bS5wbmc/MTY5NjUwMTYyOCcsXG4gICAgICAgIGNvaW5nZWNrb0lkOiAnZXRoZXJldW0nLFxuICAgICAgICBpc05hdGl2ZTogdHJ1ZSxcbiAgICB9LFxuICAgIFVTRFQ6IHtcbiAgICAgICAgc3ltYm9sOiAnVVNEVCcsXG4gICAgICAgIG5hbWU6ICdUZXRoZXIgVVNEJyxcbiAgICAgICAgZGVjaW1hbHM6IDYsXG4gICAgICAgIGljb246ICdodHRwczovL2NvaW4taW1hZ2VzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzM1MDIzL2xhcmdlL1VTRFQucG5nJyxcbiAgICAgICAgY29pbmdlY2tvSWQ6ICd0ZXRoZXInLFxuICAgIH0sXG4gICAgVVNEQzoge1xuICAgICAgICBzeW1ib2w6ICdVU0RDJyxcbiAgICAgICAgbmFtZTogJ1VTRCBDb2luJyxcbiAgICAgICAgZGVjaW1hbHM6IDYsXG4gICAgICAgIGljb246ICdodHRwczovL2NvaW4taW1hZ2VzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzYzMTkvbGFyZ2UvdXNkYy5wbmc/MTY5NjUwNjY5NCcsXG4gICAgICAgIGNvaW5nZWNrb0lkOiAndXNkLWNvaW4nLFxuICAgIH0sXG59O1xuY29uc3QgVE9LRU5fTUVUQURBVEEgPSBCQVNFX1RPS0VOX01FVEFEQVRBO1xuY29uc3QgVEVTVE5FVF9UT0tFTl9NRVRBREFUQSA9IHtcbiAgICBFVEg6IHsgLi4uQkFTRV9UT0tFTl9NRVRBREFUQS5FVEgsIG5hbWU6ICdUZXN0IEV0aGVyZXVtJyB9LFxuICAgIFVTRFQ6IHsgLi4uQkFTRV9UT0tFTl9NRVRBREFUQS5VU0RULCBuYW1lOiAnVGVzdCBUZXRoZXIgVVNEJyB9LFxuICAgIFVTREM6IHsgLi4uQkFTRV9UT0tFTl9NRVRBREFUQS5VU0RDLCBuYW1lOiAnVGVzdCBVU0QgQ29pbicgfSxcbn07XG5jb25zdCBDSEFJTl9NRVRBREFUQSA9IHtcbiAgICAvLyBNYWlubmV0IGNoYWluc1xuICAgIFtTVVBQT1JURURfQ0hBSU5TLkVUSEVSRVVNXToge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgbmFtZTogJ0V0aGVyZXVtJyxcbiAgICAgICAgc2hvcnROYW1lOiAnZXRoJyxcbiAgICAgICAgbG9nbzogJ2h0dHBzOi8vYXNzZXRzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzI3OS9zbWFsbC9ldGhlcmV1bS5wbmcnLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeTogeyBuYW1lOiAnRXRoZXInLCBzeW1ib2w6ICdFVEgnLCBkZWNpbWFsczogMTggfSxcbiAgICAgICAgcnBjVXJsczogWydodHRwczovL2V0aC5tZXJrbGUuaW8nXSxcbiAgICAgICAgYmxvY2tFeHBsb3JlclVybHM6IFsnaHR0cHM6Ly9ldGhlcnNjYW4uaW8nXSxcbiAgICB9LFxuICAgIFtTVVBQT1JURURfQ0hBSU5TLkJBU0VdOiB7XG4gICAgICAgIGlkOiA4NDUzLFxuICAgICAgICBuYW1lOiAnQmFzZScsXG4gICAgICAgIHNob3J0TmFtZTogJ2Jhc2UnLFxuICAgICAgICBsb2dvOiAnaHR0cHM6Ly9wYnMudHdpbWcuY29tL3Byb2ZpbGVfaW1hZ2VzLzE5NDU2MDgxOTk1MDA5MTA1OTIvcm5rNml4eEhfNDAweDQwMC5qcGcnLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeTogeyBuYW1lOiAnRXRoZXInLCBzeW1ib2w6ICdFVEgnLCBkZWNpbWFsczogMTggfSxcbiAgICAgICAgcnBjVXJsczogWydodHRwczovL21haW5uZXQuYmFzZS5vcmcnXSxcbiAgICAgICAgYmxvY2tFeHBsb3JlclVybHM6IFsnaHR0cHM6Ly9iYXNlc2Nhbi5vcmcnXSxcbiAgICB9LFxuICAgIFtTVVBQT1JURURfQ0hBSU5TLkFSQklUUlVNXToge1xuICAgICAgICBpZDogNDIxNjEsXG4gICAgICAgIG5hbWU6ICdBcmJpdHJ1bSBPbmUnLFxuICAgICAgICBzaG9ydE5hbWU6ICdhcmIxJyxcbiAgICAgICAgbG9nbzogJ2h0dHBzOi8vYXNzZXRzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzE2NTQ3L3NtYWxsL3Bob3RvXzIwMjMtMDMtMjlfMjEuNDcuMDAuanBlZycsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6ICdFdGhlcicsIHN5bWJvbDogJ0VUSCcsIGRlY2ltYWxzOiAxOCB9LFxuICAgICAgICBycGNVcmxzOiBbXG4gICAgICAgICAgICAnaHR0cHM6Ly9hcmItbWFpbm5ldC5nLmFsY2hlbXkuY29tL3YyL1BmYXN3cktxMHJqT3JmWVdIZkU5dUxRS2hpRDRKQ2RxJyxcbiAgICAgICAgICAgICdodHRwczovL2FyYml0cnVtLmJsb2NrcGkubmV0d29yay92MS9ycGMvYThjY2Q0M2NkYzg0MGMyYjJkMjBjMjRhMDU4NTE0YTIxMzAyMzc2ZCcsXG4gICAgICAgIF0sXG4gICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzOiBbJ2h0dHBzOi8vYXJiaXNjYW4uaW8nXSxcbiAgICB9LFxuICAgIFtTVVBQT1JURURfQ0hBSU5TLk9QVElNSVNNXToge1xuICAgICAgICBpZDogMTAsXG4gICAgICAgIG5hbWU6ICdPcHRpbWlzbScsXG4gICAgICAgIHNob3J0TmFtZTogJ29ldGgnLFxuICAgICAgICBsb2dvOiAnaHR0cHM6Ly9hc3NldHMuY29pbmdlY2tvLmNvbS9jb2lucy9pbWFnZXMvMjUyNDQvc21hbGwvT3B0aW1pc20ucG5nJyxcbiAgICAgICAgbmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogJ0V0aGVyJywgc3ltYm9sOiAnRVRIJywgZGVjaW1hbHM6IDE4IH0sXG4gICAgICAgIHJwY1VybHM6IFsnaHR0cHM6Ly9tYWlubmV0Lm9wdGltaXNtLmlvJ10sXG4gICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzOiBbJ2h0dHBzOi8vb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW8nXSxcbiAgICB9LFxuICAgIFtTVVBQT1JURURfQ0hBSU5TLlBPTFlHT05dOiB7XG4gICAgICAgIGlkOiAxMzcsXG4gICAgICAgIG5hbWU6ICdQb2x5Z29uJyxcbiAgICAgICAgc2hvcnROYW1lOiAnbWF0aWMnLFxuICAgICAgICBsb2dvOiAnaHR0cHM6Ly9hc3NldHMuY29pbmdlY2tvLmNvbS9jb2lucy9pbWFnZXMvNDcxMy9zbWFsbC9wb2x5Z29uLnBuZycsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6ICdNQVRJQycsIHN5bWJvbDogJ01BVElDJywgZGVjaW1hbHM6IDE4IH0sXG4gICAgICAgIHJwY1VybHM6IFsnaHR0cHM6Ly9wb2x5Z29uLXJwYy5jb20nXSxcbiAgICAgICAgYmxvY2tFeHBsb3JlclVybHM6IFsnaHR0cHM6Ly9wb2x5Z29uc2Nhbi5jb20nXSxcbiAgICB9LFxuICAgIFtTVVBQT1JURURfQ0hBSU5TLkFWQUxBTkNIRV06IHtcbiAgICAgICAgaWQ6IDQzMTE0LFxuICAgICAgICBuYW1lOiAnQXZhbGFuY2hlJyxcbiAgICAgICAgc2hvcnROYW1lOiAnYXZheCcsXG4gICAgICAgIGxvZ286ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8xMjU1OS9zbWFsbC9BdmFsYW5jaGVfQ2lyY2xlX1JlZFdoaXRlX1RyYW5zLnBuZycsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6ICdBdmFsYW5jaGUnLCBzeW1ib2w6ICdBVkFYJywgZGVjaW1hbHM6IDE4IH0sXG4gICAgICAgIHJwY1VybHM6IFsnaHR0cHM6Ly9hcGkuYXZheC5uZXR3b3JrL2V4dC9iYy9DL3JwYyddLFxuICAgICAgICBibG9ja0V4cGxvcmVyVXJsczogWydodHRwczovL3Nub3d0cmFjZS5pbyddLFxuICAgIH0sXG4gICAgW1NVUFBPUlRFRF9DSEFJTlMuU0NST0xMXToge1xuICAgICAgICBpZDogNTM0MzUyLFxuICAgICAgICBuYW1lOiAnU2Nyb2xsJyxcbiAgICAgICAgc2hvcnROYW1lOiAnc2Nyb2xsJyxcbiAgICAgICAgbG9nbzogJ2h0dHBzOi8vYXNzZXRzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzUwNTcxL3N0YW5kYXJkL3Njcm9sbC5qcGc/MTcyODM3NjEyNScsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6ICdFdGhlcicsIHN5bWJvbDogJ0VUSCcsIGRlY2ltYWxzOiAxOCB9LFxuICAgICAgICBycGNVcmxzOiBbJ2h0dHBzOi8vcnBjLnNjcm9sbC5pbyddLFxuICAgICAgICBibG9ja0V4cGxvcmVyVXJsczogWydodHRwczovL3Njcm9sbHNjYW4uY29tJ10sXG4gICAgfSxcbiAgICBbU1VQUE9SVEVEX0NIQUlOUy5TT1BIT05dOiB7XG4gICAgICAgIGlkOiA1MDEwNCxcbiAgICAgICAgbmFtZTogJ1NvcGhvbicsXG4gICAgICAgIHNob3J0TmFtZTogJ3NvcGhvbicsXG4gICAgICAgIGxvZ286ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8zODY4MC9sYXJnZS9zb3Bob25fbG9nb18yMDAucG5nJyxcbiAgICAgICAgbmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogJ1NvcGhvbicsIHN5bWJvbDogJ1NPUEgnLCBkZWNpbWFsczogMTggfSxcbiAgICAgICAgcnBjVXJsczogWydodHRwczovL3JwYy5zb3Bob24ueHl6J10sXG4gICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzOiBbJ2h0dHBzOi8vZXhwbG9yZXIuc29waG9uLnh5eiddLFxuICAgIH0sXG4gICAgW1NVUFBPUlRFRF9DSEFJTlMuS0FJQV06IHtcbiAgICAgICAgaWQ6IDgyMTcsXG4gICAgICAgIG5hbWU6ICdLYWlhIE1haW5uZXQnLFxuICAgICAgICBzaG9ydE5hbWU6ICdrYWlhJyxcbiAgICAgICAgbG9nbzogJ2h0dHBzOi8vYXNzZXRzLmNvaW5nZWNrby5jb20vYXNzZXRfcGxhdGZvcm1zL2ltYWdlcy85NjcyL2xhcmdlL2thaWEucG5nJyxcbiAgICAgICAgbmF0aXZlQ3VycmVuY3k6IHsgbmFtZTogJ0thaWEnLCBzeW1ib2w6ICdLQUlBJywgZGVjaW1hbHM6IDE4IH0sXG4gICAgICAgIHJwY1VybHM6IFsnaHR0cHM6Ly9wdWJsaWMtZW4ubm9kZS5rYWlhLmlvJ10sXG4gICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzOiBbJ2h0dHBzOi8va2FpYXNjYW4uaW8nXSxcbiAgICB9LFxuICAgIFtTVVBQT1JURURfQ0hBSU5TLkJOQl06IHtcbiAgICAgICAgaWQ6IDU2LFxuICAgICAgICBuYW1lOiAnQk5CIFNtYXJ0IENoYWluJyxcbiAgICAgICAgc2hvcnROYW1lOiAnYm5iJyxcbiAgICAgICAgbG9nbzogJ2h0dHBzOi8vYXNzZXRzLmNvaW5nZWNrby5jb20vYXNzZXRfcGxhdGZvcm1zL2ltYWdlcy8xL2xhcmdlL2JuYl9zbWFydF9jaGFpbi5wbmcnLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeTogeyBuYW1lOiAnQk5CJywgc3ltYm9sOiAnQk5CJywgZGVjaW1hbHM6IDE4IH0sXG4gICAgICAgIHJwY1VybHM6IFsnaHR0cHM6Ly9ic2MtcG9rdC5ub2RpZXMuYXBwJ10sXG4gICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzOiBbJ2h0dHBzOi8vYnNjc2Nhbi5jb20nXSxcbiAgICB9LFxuICAgIFtTVVBQT1JURURfQ0hBSU5TLkhZUEVSRVZNXToge1xuICAgICAgICBpZDogOTk5LFxuICAgICAgICBuYW1lOiAnSHlwZXJsaXF1aWQgRVZNJyxcbiAgICAgICAgc2hvcnROYW1lOiAnaHlwZXJsaXF1aWQnLFxuICAgICAgICBsb2dvOiAnaHR0cHM6Ly9hc3NldHMuY29pbmdlY2tvLmNvbS9hc3NldF9wbGF0Zm9ybXMvaW1hZ2VzLzI0My9sYXJnZS9oeXBlcmxpcXVpZC5wbmcnLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeTogeyBuYW1lOiAnSFlQRScsIHN5bWJvbDogJ0hZUEUnLCBkZWNpbWFsczogMTggfSxcbiAgICAgICAgcnBjVXJsczogWydodHRwczovL3JwYy5oeXBlcmxpcXVpZC54eXovZXZtJ10sXG4gICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzOiBbJ2h0dHBzOi8vaHlwZXJldm1zY2FuLmlvLyddLFxuICAgIH0sXG4gICAgLy8gVGVzdG5ldCBjaGFpbnNcbiAgICBbU1VQUE9SVEVEX0NIQUlOUy5TRVBPTElBXToge1xuICAgICAgICBpZDogMTExNTUxMTEsXG4gICAgICAgIG5hbWU6ICdTZXBvbGlhJyxcbiAgICAgICAgc2hvcnROYW1lOiAnc2Vwb2xpYScsXG4gICAgICAgIGxvZ286ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8xMzM4My9sYXJnZS9ldGhlcmV1bS5wbmcnLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeTogeyBuYW1lOiAnU2Vwb2xpYSBFdGhlcicsIHN5bWJvbDogJ0VUSCcsIGRlY2ltYWxzOiAxOCB9LFxuICAgICAgICBycGNVcmxzOiBbJ2h0dHBzOi8vc2Vwb2xpYS5kcnBjLm9yZyddLFxuICAgICAgICBibG9ja0V4cGxvcmVyVXJsczogWydodHRwczovL3NlcG9saWEuZXRoZXJzY2FuLmlvJ10sXG4gICAgfSxcbiAgICBbU1VQUE9SVEVEX0NIQUlOUy5CQVNFX1NFUE9MSUFdOiB7XG4gICAgICAgIGlkOiA4NDUzMixcbiAgICAgICAgbmFtZTogJ0Jhc2UgU2Vwb2xpYScsXG4gICAgICAgIHNob3J0TmFtZTogJ2Jhc2Utc2Vwb2xpYScsXG4gICAgICAgIGxvZ286ICdodHRwczovL3Bicy50d2ltZy5jb20vcHJvZmlsZV9pbWFnZXMvMTk0NTYwODE5OTUwMDkxMDU5Mi9ybms2aXh4SF80MDB4NDAwLmpwZycsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6ICdTZXBvbGlhIEV0aGVyJywgc3ltYm9sOiAnRVRIJywgZGVjaW1hbHM6IDE4IH0sXG4gICAgICAgIHJwY1VybHM6IFsnaHR0cHM6Ly9zZXBvbGlhLmJhc2Uub3JnJ10sXG4gICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzOiBbJ2h0dHBzOi8vc2Vwb2xpYS5iYXNlc2Nhbi5vcmcnXSxcbiAgICB9LFxuICAgIFtTVVBQT1JURURfQ0hBSU5TLk1PTkFEX1RFU1RORVRdOiB7XG4gICAgICAgIGlkOiAxMDE0MyxcbiAgICAgICAgbmFtZTogJ01vbmFkIFRlc3RuZXQnLFxuICAgICAgICBzaG9ydE5hbWU6ICdtb25hZC10ZXN0bmV0JyxcbiAgICAgICAgbG9nbzogJ2h0dHBzOi8vYXNzZXRzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzM4OTI3L3N0YW5kYXJkL21vbmFkLmpwZycsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6ICdUZXN0bmV0IE1PTiBUb2tlbicsIHN5bWJvbDogJ01PTicsIGRlY2ltYWxzOiAxOCB9LFxuICAgICAgICBycGNVcmxzOiBbJ2h0dHBzOi8vdGVzdG5ldC1ycGMubW9uYWQueHl6LyddLFxuICAgICAgICBibG9ja0V4cGxvcmVyVXJsczogWydodHRwczovL3Rlc3RuZXQubW9uYWRleHBsb3Jlci5jb20vJ10sXG4gICAgfSxcbiAgICBbU1VQUE9SVEVEX0NIQUlOUy5BUkJJVFJVTV9TRVBPTElBXToge1xuICAgICAgICBpZDogNDIxNjE0LFxuICAgICAgICBuYW1lOiAnQXJiaXRydW0gU2Vwb2xpYScsXG4gICAgICAgIHNob3J0TmFtZTogJ2FyYi1zZXBvbGlhJyxcbiAgICAgICAgbG9nbzogJ2h0dHBzOi8vYXNzZXRzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzE2NTQ3L3NtYWxsL3Bob3RvXzIwMjMtMDMtMjlfMjEuNDcuMDAuanBlZycsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6ICdTZXBvbGlhIEV0aGVyJywgc3ltYm9sOiAnRVRIJywgZGVjaW1hbHM6IDE4IH0sXG4gICAgICAgIHJwY1VybHM6IFsnaHR0cHM6Ly9zZXBvbGlhLXJvbGx1cC5hcmJpdHJ1bS5pby9ycGMnXSxcbiAgICAgICAgYmxvY2tFeHBsb3JlclVybHM6IFsnaHR0cHM6Ly9zZXBvbGlhLmFyYmlzY2FuLmlvJ10sXG4gICAgfSxcbiAgICBbU1VQUE9SVEVEX0NIQUlOUy5PUFRJTUlTTV9TRVBPTElBXToge1xuICAgICAgICBpZDogMTExNTU0MjAsXG4gICAgICAgIG5hbWU6ICdPcHRpbWlzbSBTZXBvbGlhJyxcbiAgICAgICAgc2hvcnROYW1lOiAnb3Atc2Vwb2xpYScsXG4gICAgICAgIGxvZ286ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8yNTI0NC9zbWFsbC9PcHRpbWlzbS5wbmcnLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeTogeyBuYW1lOiAnU2Vwb2xpYSBFdGhlcicsIHN5bWJvbDogJ0VUSCcsIGRlY2ltYWxzOiAxOCB9LFxuICAgICAgICBycGNVcmxzOiBbJ2h0dHBzOi8vc2Vwb2xpYS5vcHRpbWlzbS5pbyddLFxuICAgICAgICBibG9ja0V4cGxvcmVyVXJsczogWydodHRwczovL3NlcG9saWEtb3B0aW1pc20uZXRoZXJzY2FuLmlvJ10sXG4gICAgfSxcbiAgICBbU1VQUE9SVEVEX0NIQUlOUy5QT0xZR09OX0FNT1ldOiB7XG4gICAgICAgIGlkOiA4MDAwMixcbiAgICAgICAgbmFtZTogJ1BvbHlnb24gQW1veScsXG4gICAgICAgIHNob3J0TmFtZTogJ2Ftb3knLFxuICAgICAgICBsb2dvOiAnaHR0cHM6Ly9hc3NldHMuY29pbmdlY2tvLmNvbS9jb2lucy9pbWFnZXMvNDcxMy9zbWFsbC9wb2x5Z29uLnBuZycsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6ICdNQVRJQycsIHN5bWJvbDogJ01BVElDJywgZGVjaW1hbHM6IDE4IH0sXG4gICAgICAgIHJwY1VybHM6IFsnaHR0cHM6Ly9ycGMtYW1veS5wb2x5Z29uLnRlY2hub2xvZ3knXSxcbiAgICAgICAgYmxvY2tFeHBsb3JlclVybHM6IFsnaHR0cHM6Ly9hbW95LnBvbHlnb25zY2FuLmNvbSddLFxuICAgIH0sXG59O1xuLy8gRXZlbnQgbmFtZSBjb25zdGFudHMgdG8gcHJldmVudCB0eXBvc1xuY29uc3QgTkVYVVNfRVZFTlRTID0ge1xuICAgIFNURVBfQ09NUExFVEU6ICdzdGVwX2NvbXBsZXRlJyxcbiAgICBFWFBFQ1RFRF9TVEVQUzogJ2V4cGVjdGVkX3N0ZXBzJyxcbiAgICBTV0FQX1NURVBTOiAnc3dhcF9zdGVwJyxcbiAgICAvLyBNb2R1bGFyIGV2ZW50IG5hbWVzXG4gICAgQlJJREdFX0VYRUNVVEVfRVhQRUNURURfU1RFUFM6ICdicmlkZ2VfZXhlY3V0ZV9leHBlY3RlZF9zdGVwcycsXG4gICAgQlJJREdFX0VYRUNVVEVfQ09NUExFVEVEX1NURVBTOiAnYnJpZGdlX2V4ZWN1dGVfY29tcGxldGVkX3N0ZXBzJyxcbn07XG4vLyBIZWxwZXIgY29uc3RhbnRzIGZvciBtYWlubmV0IGFuZCB0ZXN0bmV0IGNoYWluIGNhdGVnb3JpemF0aW9uXG5jb25zdCBNQUlOTkVUX0NIQUlOUyA9IFtcbiAgICBTVVBQT1JURURfQ0hBSU5TLkVUSEVSRVVNLFxuICAgIFNVUFBPUlRFRF9DSEFJTlMuQkFTRSxcbiAgICBTVVBQT1JURURfQ0hBSU5TLkFSQklUUlVNLFxuICAgIFNVUFBPUlRFRF9DSEFJTlMuT1BUSU1JU00sXG4gICAgU1VQUE9SVEVEX0NIQUlOUy5QT0xZR09OLFxuICAgIFNVUFBPUlRFRF9DSEFJTlMuQVZBTEFOQ0hFLFxuICAgIFNVUFBPUlRFRF9DSEFJTlMuU0NST0xMLFxuICAgIFNVUFBPUlRFRF9DSEFJTlMuU09QSE9OLFxuICAgIFNVUFBPUlRFRF9DSEFJTlMuS0FJQSxcbiAgICBTVVBQT1JURURfQ0hBSU5TLkJOQixcbiAgICBTVVBQT1JURURfQ0hBSU5TLkhZUEVSRVZNLFxuXTtcbmNvbnN0IFRFU1RORVRfQ0hBSU5TID0gW1xuICAgIFNVUFBPUlRFRF9DSEFJTlMuU0VQT0xJQSxcbiAgICBTVVBQT1JURURfQ0hBSU5TLkJBU0VfU0VQT0xJQSxcbiAgICBTVVBQT1JURURfQ0hBSU5TLkFSQklUUlVNX1NFUE9MSUEsXG4gICAgU1VQUE9SVEVEX0NIQUlOUy5PUFRJTUlTTV9TRVBPTElBLFxuICAgIFNVUFBPUlRFRF9DSEFJTlMuUE9MWUdPTl9BTU9ZLFxuICAgIFNVUFBPUlRFRF9DSEFJTlMuTU9OQURfVEVTVE5FVCxcbl07XG4vKipcbiAqIFRva2VuIGNvbnRyYWN0IGFkZHJlc3NlcyBwZXIgY2hhaW5cbiAqIFRoaXMgcmVnaXN0cnkgY29udGFpbnMgdGhlIGNvbnRyYWN0IGFkZHJlc3NlcyBmb3Igc3VwcG9ydGVkIHRva2VucyBhY3Jvc3MgZGlmZmVyZW50IGNoYWluc1xuICovXG5jb25zdCBUT0tFTl9DT05UUkFDVF9BRERSRVNTRVMgPSB7XG4gICAgVVNEQzoge1xuICAgICAgICBbU1VQUE9SVEVEX0NIQUlOUy5FVEhFUkVVTV06ICcweGEwYjg2OTkxYzYyMThiMzZjMWQxOWQ0YTJlOWViMGNlMzYwNmViNDgnLFxuICAgICAgICBbU1VQUE9SVEVEX0NIQUlOUy5CQVNFXTogJzB4ODMzNTg5ZkNENmVEYjZFMDhmNGM3QzMyRDRmNzFiNTRiZEEwMjkxMycsXG4gICAgICAgIFtTVVBQT1JURURfQ0hBSU5TLlBPTFlHT05dOiAnMHgzYzQ5OWM1NDJjZWY1ZTM4MTFlMTE5MmNlNzBkOGNjMDNkNWMzMzU5JyxcbiAgICAgICAgW1NVUFBPUlRFRF9DSEFJTlMuQVJCSVRSVU1dOiAnMHhhZjg4ZDA2NWU3N2M4Y2MyMjM5MzI3YzVlZGIzYTQzMjI2OGU1ODMxJyxcbiAgICAgICAgW1NVUFBPUlRFRF9DSEFJTlMuU09QSE9OXTogJzB4OWFhMGY3MjM5MmI1Nzg0YWQ4NmM2ZjNlODk5YmNjMDUzZDAwZGI0ZicsXG4gICAgICAgIFtTVVBQT1JURURfQ0hBSU5TLk9QVElNSVNNXTogJzB4MGIyYzYzOWM1MzM4MTNmNGFhOWQ3ODM3Y2FmNjI2NTNkMDk3ZmY4NScsXG4gICAgICAgIFtTVVBQT1JURURfQ0hBSU5TLlNDUk9MTF06ICcweDA2ZWZkYmZmMmExNGE3YzhlMTU5NDRkMWY0YTQ4ZjlmOTVmNjYzYTQnLFxuICAgICAgICBbU1VQUE9SVEVEX0NIQUlOUy5BVkFMQU5DSEVdOiAnMHhiOTdlZjllZjg3MzRjNzE5MDRkODAwMmY4YjZiYzY2ZGQ5YzQ4YTZlJyxcbiAgICAgICAgW1NVUFBPUlRFRF9DSEFJTlMuQk5CXTogJzB4OEFDNzZhNTFjYzk1MGQ5ODIyRDY4YjgzZkUxQWQ5N0IzMkNkNTgwZCcsXG4gICAgICAgIC8vIHRlc3RuZXQgY2hhaW5zXG4gICAgICAgIFtTVVBQT1JURURfQ0hBSU5TLlNFUE9MSUFdOiAnMHhmMDhBNTAxNzhkZmNEZTE4NTI0NjQwRUE2NjE4YTFmOTY1ODIxNzE1JyxcbiAgICAgICAgW1NVUFBPUlRFRF9DSEFJTlMuQkFTRV9TRVBPTElBXTogJzB4MDM2Q2JENTM4NDJjNTQyNjYzNGU3OTI5NTQxZUMyMzE4ZjNkQ0Y3ZScsXG4gICAgICAgIFtTVVBQT1JURURfQ0hBSU5TLkFSQklUUlVNX1NFUE9MSUFdOiAnMHg3NWZhZjExNGVhZmIxQkRiZTJGMDMxNkRGODkzZmQ1OENFNDZBQTRkJyxcbiAgICAgICAgW1NVUFBPUlRFRF9DSEFJTlMuT1BUSU1JU01fU0VQT0xJQV06ICcweDVmZDg0MjU5ZDY2Q2Q0NjEyMzU0MDc2NkJlOTNERkU2RDQzMTMwRDcnLFxuICAgICAgICBbU1VQUE9SVEVEX0NIQUlOUy5QT0xZR09OX0FNT1ldOiAnMHg0MUU5NEViMDE5QzA3NjJmOUJmY2Y5RmIxRTU4NzI1QmZCMGU3NTgyJyxcbiAgICAgICAgW1NVUFBPUlRFRF9DSEFJTlMuTU9OQURfVEVTVE5FVF06ICcweGY4MTcyNTdmZWQzNzk4NTNjRGUwZmE0Rjk3QUI5ODcxODFCMUU1RWEnLFxuICAgIH0sXG4gICAgVVNEVDoge1xuICAgICAgICBbU1VQUE9SVEVEX0NIQUlOUy5FVEhFUkVVTV06ICcweGRhYzE3Zjk1OGQyZWU1MjNhMjIwNjIwNjk5NDU5N2MxM2Q4MzFlYzcnLFxuICAgICAgICBbU1VQUE9SVEVEX0NIQUlOUy5QT0xZR09OXTogJzB4YzIxMzJkMDVkMzFjOTE0YTg3YzY2MTFjMTA3NDhhZWIwNGI1OGU4ZicsXG4gICAgICAgIFtTVVBQT1JURURfQ0hBSU5TLkFSQklUUlVNXTogJzB4ZmQwODZiYzdjZDVjNDgxZGNjOWM4NWViZTQ3OGExYzBiNjlmY2JiOScsXG4gICAgICAgIFtTVVBQT1JURURfQ0hBSU5TLlNPUEhPTl06ICcweDYzODZkYTczNTQ1YWU0ZTJiMmUwMzkzNjg4ZmE4YjY1YmI5YTcxNjknLFxuICAgICAgICBbU1VQUE9SVEVEX0NIQUlOUy5LQUlBXTogJzB4ZDA3N2E0MDA5Njg4OTBlYWNjNzVjZGM5MDFmMDM1NmM5NDNlNGZkYicsXG4gICAgICAgIFtTVVBQT1JURURfQ0hBSU5TLk9QVElNSVNNXTogJzB4OTRiMDA4YWEwMDU3OWMxMzA3YjBlZjJjNDk5YWQ5OGE4Y2U1OGU1OCcsXG4gICAgICAgIFtTVVBQT1JURURfQ0hBSU5TLlNDUk9MTF06ICcweGY1NWJlYzljYWZkYmU4NzMwZjA5NmFhNTVkYWQ2ZDIyZDQ0MDk5ZGYnLFxuICAgICAgICBbU1VQUE9SVEVEX0NIQUlOUy5BVkFMQU5DSEVdOiAnMHg5NzAyMjMwYThlYTUzNjAxZjVjZDJkYzAwZmRiYzEzZDRkZjRhOGM3JyxcbiAgICAgICAgW1NVUFBPUlRFRF9DSEFJTlMuQk5CXTogJzB4NTVkMzk4MzI2Zjk5MDU5ZkY3NzU0ODUyNDY5OTkwMjdCMzE5Nzk1NScsXG4gICAgICAgIFtTVVBQT1JURURfQ0hBSU5TLkhZUEVSRVZNXTogJzB4QjhDRTU5RkMzNzE3YWRhNEMwMmVhREY5NjgyQTllOTM0RjYyNWViYicsXG4gICAgICAgIC8vIHRlc3RuZXQgY2hhaW5zXG4gICAgICAgIFtTVVBQT1JURURfQ0hBSU5TLlNFUE9MSUFdOiAnMHhhQThFMjNGYjEwNzlFQTcxZTBhNTZGNDhhMmFBNTE4NTFEODQzM0QwJyxcbiAgICAgICAgW1NVUFBPUlRFRF9DSEFJTlMuQkFTRV9TRVBPTElBXTogJzB4ZjdlNTNiMjBmMzlhNWY4YzM1MDA1ZkVmMzdlZWYwM0E3YjBkMEI1YScsXG4gICAgICAgIFtTVVBQT1JURURfQ0hBSU5TLkFSQklUUlVNX1NFUE9MSUFdOiAnMHhiOWE0ODczZDhkMkMyMmU1NmI4NTc0ZTg2MDU2NDRkMDhFMDQ3NDM0JyxcbiAgICAgICAgW1NVUFBPUlRFRF9DSEFJTlMuT1BUSU1JU01fU0VQT0xJQV06ICcweDdGNWM3NjRjQmMxNGY5NjY5Qjg4ODM3Y2ExNDkwY0NhMTdjMzE2MDcnLFxuICAgICAgICBbU1VQUE9SVEVEX0NIQUlOUy5QT0xZR09OX0FNT1ldOiAnMHgyYzg1MmU3NDBCNjIzMDhjNDZERDI5Qjk4MkZCYjY1MEQwNjNCZDA3JyxcbiAgICAgICAgW1NVUFBPUlRFRF9DSEFJTlMuTU9OQURfVEVTVE5FVF06ICcweDg4YjhFMjE2MURFREM3N0VGNGFiNzU4NTU2OUQyNDE1YTFDMTA1NUQnLFxuICAgIH0sXG4gICAgLy8gRVRIIGlzIG5hdGl2ZSBvbiBhbGwgc3VwcG9ydGVkIGNoYWlucywgbm8gY29udHJhY3QgYWRkcmVzcyBuZWVkZWRcbn07XG5jb25zdCBERVNUSU5BVElPTl9TV0FQX1RPS0VOUyA9IG5ldyBNYXAoW1xuICAgIFtcbiAgICAgICAgU1VQUE9SVEVEX0NIQUlOUy5PUFRJTUlTTSxcbiAgICAgICAgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgICAgICBsb2dvOiAnaHR0cHM6Ly9jb2luLWltYWdlcy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8yNzkvbGFyZ2UvZXRoZXJldW0ucG5nPzE2OTY1MDE2MjgnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdFdGhlcicsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiAnRVRIJyxcbiAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogNixcbiAgICAgICAgICAgICAgICBsb2dvOiAnaHR0cHM6Ly9jb2luLWltYWdlcy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy82MzE5L2xhcmdlL3VzZGMucG5nPzE2OTY1MDY2OTQnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdVU0QgQ29pbicsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiAnVVNEQycsXG4gICAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiAnMHgwYjJjNjM5YzUzMzgxM2Y0YWE5ZDc4MzdjYWY2MjY1M2QwOTdmZjg1JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgICAgIGxvZ286ICdodHRwczovL2NvaW4taW1hZ2VzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzI1MjQ0L2xhcmdlL09wdGltaXNtLnBuZz8xNjk2NTI0Mzg1JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnT3B0aW1pc20nLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogJ09QJyxcbiAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3M6ICcweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogMTgsXG4gICAgICAgICAgICAgICAgbG9nbzogJ2h0dHBzOi8vY29pbi1pbWFnZXMuY29pbmdlY2tvLmNvbS9jb2lucy9pbWFnZXMvMTI2NDUvbGFyZ2UvQUFWRS5wbmc/MTY5NjUxMjQ1MicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0FhdmUgVG9rZW4nLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogJ0FBVkUnLFxuICAgICAgICAgICAgICAgIHRva2VuQWRkcmVzczogJzB4NzZmYjMxZmI0YWY1Njg5MmEyNWUzMmNmYzQzZGU3MTc5NTBjOTI3OCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgICAgICBsb2dvOiAnaHR0cHM6Ly9jb2luLWltYWdlcy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8xMjUwNC9sYXJnZS91bmkuanBnPzE2OTY1MTIzMTknLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdVbmlzd2FwJyxcbiAgICAgICAgICAgICAgICBzeW1ib2w6ICdVTkknLFxuICAgICAgICAgICAgICAgIHRva2VuQWRkcmVzczogJzB4NmZkOWQ3YWQxNzI0MmM0MWY3MTMxZDI1NzIxMmM1NGEwZTgxNjY5MScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBTVVBQT1JURURfQ0hBSU5TLkFSQklUUlVNLFxuICAgICAgICBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgICAgIGxvZ286ICdodHRwczovL2NvaW4taW1hZ2VzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzI5ODUwL2xhcmdlL3BlcGUtdG9rZW4uanBlZz8xNjk2NTI4Nzc2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnUGVwZScsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiAnUEVQRScsXG4gICAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiAnMHgyNWQ4ODdjZTdhMzUxNzJjNjJmZWJmZDY3YTE4NTZmMjBmYWViYjAwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgICAgIGxvZ286ICdodHRwczovL2NvaW4taW1hZ2VzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzEzNTczL2xhcmdlL0xpZG9fREFPLnBuZz8xNjk2NTEzMzI2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTGlkbyBEQU8gVG9rZW4nLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogJ0xETycsXG4gICAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiAnMHgxM2FkNTFlZDRmMWI3ZTlkYzE2OGQ4YTAwY2IzZjRkZGQ4NWVmYTYwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgXSxcbiAgICBbXG4gICAgICAgIFNVUFBPUlRFRF9DSEFJTlMuU0NST0xMLFxuICAgICAgICBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgICAgIGxvZ286ICdodHRwczovL2NvaW4taW1hZ2VzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzI3OS9sYXJnZS9ldGhlcmV1bS5wbmc/MTY5NjUwMTYyOCcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0V0aGVyJyxcbiAgICAgICAgICAgICAgICBzeW1ib2w6ICdFVEgnLFxuICAgICAgICAgICAgICAgIHRva2VuQWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBTVVBQT1JURURfQ0hBSU5TLkJBU0UsXG4gICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogMTgsXG4gICAgICAgICAgICAgICAgbG9nbzogJ2h0dHBzOi8vY29pbi1pbWFnZXMuY29pbmdlY2tvLmNvbS9jb2lucy9pbWFnZXMvOTk1Ni9sYXJnZS9CYWRnZV9EYWkucG5nPzE2OTY1MDk5OTYnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdEYWkgU3RhYmxlY29pbicsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiAnREFJJyxcbiAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3M6ICcweDUwYzU3MjU5NDlBNkYwYzcyRTZDNGE2NDFGMjQwNDlBOTE3REIwQ2InLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogMTgsXG4gICAgICAgICAgICAgICAgbG9nbzogJ2h0dHBzOi8vY29pbi1pbWFnZXMuY29pbmdlY2tvLmNvbS9jb2lucy9pbWFnZXMvMjgyMDYvbGFyZ2UvZnR4RzlfVEpfNDAweDQwMC5qcGVnPzE2OTY1MjcyMDgnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdMYXllclplcm8nLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogJ1pSTycsXG4gICAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiAnMHg2OTg1ODg0YzQzOTJkMzQ4NTg3YjE5Y2I5ZWFhZjE1N2YxMzI3MWNkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgICAgIGxvZ286ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8xMjE1MS9zdGFuZGFyZC9PTV9Ub2tlbi5wbmc/MTY5NjUxMTk5MScsXG4gICAgICAgICAgICAgICAgbmFtZTogJ01BTlRSQScsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiAnT00nLFxuICAgICAgICAgICAgICAgIHRva2VuQWRkcmVzczogJzB4Mzk5MmIyN2RhMjY4NDhjMmIxOWNlYTZmZDI1YWQ1NTY4YjY4YWI5OCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgICAgICBsb2dvOiAnaHR0cHM6Ly9hc3NldHMuY29pbmdlY2tvLmNvbS9jb2lucy9pbWFnZXMvNTQ0MTEvc3RhbmRhcmQvUW00RFc0ODhfNDAweDQwMC5qcGcnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdLQUlUTycsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiAnS0FJVE8nLFxuICAgICAgICAgICAgICAgIHRva2VuQWRkcmVzczogJzB4OThkMGJhYTUyYjJkMDYzZTc4MGRlMTJmNjE1Zjk2M2ZlODUzNzU1MycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIF0sXG5dKTtcblxuY29uc3QgTE9HX0xFVkVMID0ge1xuICAgIERFQlVHOiAxLFxuICAgIEVSUk9SOiA0LFxuICAgIElORk86IDIsXG4gICAgTk9MT0dTOiA1LFxuICAgIFdBUk5JTkc6IDMsXG59O1xuY29uc3Qgc2V0RXhjZXB0aW9uUmVwb3J0ZXIgPSAocmVwb3J0ZXIpID0+IHtcbiAgICBzdGF0ZS5leGNlcHRpb25SZXBvcnRlciA9IHJlcG9ydGVyO1xufTtcbmNvbnN0IHNlbmRFeGNlcHRpb24gPSAobXNnKSA9PiB7XG4gICAgaWYgKCFzdGF0ZS5leGNlcHRpb25SZXBvcnRlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICAgIHN0YXRlLmV4Y2VwdGlvblJlcG9ydGVyKG1zZyk7XG4gICAgfVxuICAgIGNhdGNoIChyZXBvcnRFcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW0xPR0dFUl0gRXhjZXB0aW9uIHJlcG9ydGVyIHRocmV3OicsIHJlcG9ydEVycik7XG4gICAgfVxufTtcbmNvbnN0IHNldExvZ0xldmVsID0gKGxldmVsKSA9PiB7XG4gICAgc3RhdGUubG9nTGV2ZWwgPSBsZXZlbDtcbn07XG5jb25zdCBnZXRMb2dnZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlLmxvZ2dlcjtcbn07XG5jbGFzcyBMb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByZWZpeCA9ICdORVhVU19TREsnO1xuICAgIH1cbiAgICBjb25zb2xlTG9nKGxldmVsLCBtZXNzYWdlLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGxldmVsIDwgc3RhdGUubG9nTGV2ZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgICAgICBjYXNlIExPR19MRVZFTC5ERUJVRzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBbREVCVUddYCwgbWVzc2FnZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTE9HX0xFVkVMLkVSUk9SOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtFUlJPUl1gLCBtZXNzYWdlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMT0dfTEVWRUwuSU5GTzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oYFtJTkZPXWAsIG1lc3NhZ2UsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExPR19MRVZFTC5XQVJOSU5HOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW1dBUk5dYCwgbWVzc2FnZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtMT0ddYCwgbWVzc2FnZSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWJ1ZyhtZXNzYWdlLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aGlzLmludGVybmFsTG9nKExPR19MRVZFTC5ERUJVRywgbWVzc2FnZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgZXJyb3IobWVzc2FnZSwgZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbExvZyhMT0dfTEVWRUwuRVJST1IsIG1lc3NhZ2UsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHNlbmRFeGNlcHRpb24oSlNPTi5zdHJpbmdpZnkoeyBlcnJvcjogZXJyLm1lc3NhZ2UsIG1lc3NhZ2UgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXJyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbExvZyhMT0dfTEVWRUwuRVJST1IsIG1lc3NhZ2UsIGVycik7XG4gICAgICAgICAgICBzZW5kRXhjZXB0aW9uKEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6IGVyciwgbWVzc2FnZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsTG9nKExPR19MRVZFTC5FUlJPUiwgbWVzc2FnZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHNlbmRFeGNlcHRpb24oSlNPTi5zdHJpbmdpZnkoeyBtZXNzYWdlIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmZvKG1lc3NhZ2UsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxMb2coTE9HX0xFVkVMLklORk8sIG1lc3NhZ2UsIHBhcmFtcyk7XG4gICAgfVxuICAgIGludGVybmFsTG9nKGxldmVsLCBtZXNzYWdlLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgbG9nTWVzc2FnZSA9IGBbJHt0aGlzLnByZWZpeH1dIE1zZzogJHttZXNzYWdlfVxcbmA7XG4gICAgICAgIHRoaXMuY29uc29sZUxvZyhsZXZlbCwgbG9nTWVzc2FnZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgd2FybihtZXNzYWdlLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aGlzLmludGVybmFsTG9nKExPR19MRVZFTC5XQVJOSU5HLCBtZXNzYWdlLCBwYXJhbXMpO1xuICAgIH1cbn1cbmNvbnN0IHN0YXRlID0ge1xuICAgIGV4Y2VwdGlvblJlcG9ydGVyOiBudWxsLFxuICAgIGxvZ2dlcjogbmV3IExvZ2dlcigpLFxuICAgIGxvZ0xldmVsOiBMT0dfTEVWRUwuTk9MT0dTLFxufTtcbi8vIEV4cG9ydCBhIGRlZmF1bHQgbG9nZ2VyIGluc3RhbmNlIGZvciBjb252ZW5pZW5jZVxuY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKCk7XG5cbi8qKlxuICogU2hhcmVkIHV0aWxpdHkgZm9yIHN0YW5kYXJkaXplZCBlcnJvciBtZXNzYWdlIGV4dHJhY3Rpb25cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEVycm9yTWVzc2FnZShlcnJvciwgZmFsbGJhY2tDb250ZXh0KSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogYFVua25vd24gJHtmYWxsYmFja0NvbnRleHR9IGVycm9yYDtcbn1cbmZ1bmN0aW9uIHdhaXQobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbi8qKlxuICogR2V0IFZpZW0gY2hhaW4gY29uZmlndXJhdGlvbiBmb3Igc3VwcG9ydGVkIGNoYWluc1xuICovXG5mdW5jdGlvbiBnZXRWaWVtQ2hhaW4oY2hhaW5JZCkge1xuICAgIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gY2hhaW5zLm1haW5uZXQ7XG4gICAgICAgIGNhc2UgMTM3OlxuICAgICAgICAgICAgcmV0dXJuIGNoYWlucy5wb2x5Z29uO1xuICAgICAgICBjYXNlIDQyMTYxOlxuICAgICAgICAgICAgcmV0dXJuIGNoYWlucy5hcmJpdHJ1bTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBjaGFpbnMub3B0aW1pc207XG4gICAgICAgIGNhc2UgODQ1MzpcbiAgICAgICAgICAgIHJldHVybiBjaGFpbnMuYmFzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFJldHVybiBhIGJhc2ljIGNoYWluIGNvbmZpZyBmb3IgdW5zdXBwb3J0ZWQgY2hhaW5zXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBjaGFpbklkLFxuICAgICAgICAgICAgICAgIG5hbWU6IGBDaGFpbiAke2NoYWluSWR9YCxcbiAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeTogeyBuYW1lOiAnRVRIJywgc3ltYm9sOiAnRVRIJywgZGVjaW1hbHM6IDE4IH0sXG4gICAgICAgICAgICAgICAgcnBjVXJsczoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7IGh0dHA6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgIHB1YmxpYzogeyBodHRwOiBbXSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogRm9ybWF0IGEgYmFsYW5jZSBzdHJpbmcgdG8gYSBodW1hbi1yZWFkYWJsZSBmb3JtYXQgdXNpbmcgRGVjaW1hbC5qc1xuICovXG5mdW5jdGlvbiBmb3JtYXRCYWxhbmNlKGJhbGFuY2UsIGRlY2ltYWxzLCBwcmVjaXNpb24gPSA0KSB7XG4gICAgY29uc3QgYmFsYW5jZURlY2ltYWwgPSBuZXcgRGVjaW1hbChiYWxhbmNlKTtcbiAgICBjb25zdCBkaXZpc29yID0gbmV3IERlY2ltYWwoMTApLnBvdyhkZWNpbWFscyk7XG4gICAgY29uc3QgZm9ybWF0dGVkID0gYmFsYW5jZURlY2ltYWwuZGl2KGRpdmlzb3IpO1xuICAgIGlmIChmb3JtYXR0ZWQuaXNaZXJvKCkpXG4gICAgICAgIHJldHVybiAnMCc7XG4gICAgaWYgKGZvcm1hdHRlZC5sdCgwLjAwMDEpKVxuICAgICAgICByZXR1cm4gJzwgMC4wMDAxJztcbiAgICByZXR1cm4gZm9ybWF0dGVkLnRvRml4ZWQocHJlY2lzaW9uKS5yZXBsYWNlKC9cXC4/MCskLywgJycpO1xufVxuLyoqXG4gKiBQYXJzZSB1bml0cyBmcm9tIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIHRvIHdlaS9zbWFsbGVzdCB1bml0IHVzaW5nIERlY2ltYWwuanNcbiAqL1xuZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgICBjb25zdCB2YWx1ZURlY2ltYWwgPSBuZXcgRGVjaW1hbCh2YWx1ZSk7XG4gICAgY29uc3QgbXVsdGlwbGllciA9IG5ldyBEZWNpbWFsKDEwKS5wb3coZGVjaW1hbHMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlRGVjaW1hbC5tdWwobXVsdGlwbGllcik7XG4gICAgcmV0dXJuIEJpZ0ludChyZXN1bHQudG9GaXhlZCgwKSk7XG59XG4vKipcbiAqIEZvcm1hdCB1bml0cyBmcm9tIHdlaS9zbWFsbGVzdCB1bml0IHRvIGh1bWFuLXJlYWRhYmxlIHN0cmluZyB1c2luZyBEZWNpbWFsLmpzXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFVuaXRzKHZhbHVlLCBkZWNpbWFscykge1xuICAgIGNvbnN0IHZhbHVlRGVjaW1hbCA9IG5ldyBEZWNpbWFsKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IGRpdmlzb3IgPSBuZXcgRGVjaW1hbCgxMCkucG93KGRlY2ltYWxzKTtcbiAgICBjb25zdCByZXN1bHQgPSB2YWx1ZURlY2ltYWwuZGl2KGRpdmlzb3IpO1xuICAgIHJldHVybiByZXN1bHQudG9GaXhlZCgpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZSBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIEV0aGVyZXVtIGFkZHJlc3MgdXNpbmcgdmllbVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgcmV0dXJuIHZpZW0uaXNBZGRyZXNzKGFkZHJlc3MpO1xufVxuLyoqXG4gKiBHZXQgbWFpbm5ldCB0b2tlbiBtZXRhZGF0YSBieSBzeW1ib2xcbiAqL1xuY29uc3QgZ2V0TWFpbm5ldFRva2VuTWV0YWRhdGEgPSAoc3ltYm9sKSA9PiB7XG4gICAgcmV0dXJuIFRPS0VOX01FVEFEQVRBW3N5bWJvbF07XG59O1xuLyoqXG4gKiBHZXQgdGVzdG5ldCB0b2tlbiBtZXRhZGF0YSBieSBzeW1ib2xcbiAqL1xuY29uc3QgZ2V0VGVzdG5ldFRva2VuTWV0YWRhdGEgPSAoc3ltYm9sKSA9PiB7XG4gICAgcmV0dXJuIFRFU1RORVRfVE9LRU5fTUVUQURBVEFbc3ltYm9sXTtcbn07XG4vKipcbiAqIEdldCB0b2tlbiBtZXRhZGF0YSBieSBzeW1ib2wgKGRlZmF1bHRzIHRvIG1haW5uZXQsIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gKi9cbmNvbnN0IGdldFRva2VuTWV0YWRhdGEgPSAoc3ltYm9sKSA9PiB7XG4gICAgcmV0dXJuIFRPS0VOX01FVEFEQVRBW3N5bWJvbF07XG59O1xuLyoqXG4gKiBHZXQgY2hhaW4gbWV0YWRhdGEgYnkgY2hhaW4gSURcbiAqL1xuZnVuY3Rpb24gZ2V0Q2hhaW5NZXRhZGF0YShjaGFpbklkKSB7XG4gICAgcmV0dXJuIENIQUlOX01FVEFEQVRBW2NoYWluSWRdO1xufVxuLyoqXG4gKiBGb3JtYXQgYSBtYWlubmV0IHRva2VuIGFtb3VudCB3aXRoIHByb3BlciBkZWNpbWFscyBhbmQgc3ltYm9sXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFRva2VuQW1vdW50KGFtb3VudCwgdG9rZW5TeW1ib2wsIHByZWNpc2lvbiA9IDQpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGdldE1haW5uZXRUb2tlbk1ldGFkYXRhKHRva2VuU3ltYm9sKTtcbiAgICBpZiAoIW1ldGFkYXRhKVxuICAgICAgICByZXR1cm4gYCR7YW1vdW50fSAke3Rva2VuU3ltYm9sfWA7XG4gICAgY29uc3QgYW1vdW50U3RyID0gdHlwZW9mIGFtb3VudCA9PT0gJ2JpZ2ludCcgPyBhbW91bnQudG9TdHJpbmcoKSA6IGFtb3VudDtcbiAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRCYWxhbmNlKGFtb3VudFN0ciwgbWV0YWRhdGEuZGVjaW1hbHMsIHByZWNpc2lvbik7XG4gICAgcmV0dXJuIGAke2Zvcm1hdHRlZH0gJHttZXRhZGF0YS5zeW1ib2x9YDtcbn1cbi8qKlxuICogRm9ybWF0IGEgdGVzdG5ldCB0b2tlbiBhbW91bnQgd2l0aCBwcm9wZXIgZGVjaW1hbHMgYW5kIHN5bWJvbFxuICovXG5mdW5jdGlvbiBmb3JtYXRUZXN0bmV0VG9rZW5BbW91bnQoYW1vdW50LCB0b2tlblN5bWJvbCwgcHJlY2lzaW9uID0gNCkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0VGVzdG5ldFRva2VuTWV0YWRhdGEodG9rZW5TeW1ib2wpO1xuICAgIGlmICghbWV0YWRhdGEpXG4gICAgICAgIHJldHVybiBgJHthbW91bnR9ICR7dG9rZW5TeW1ib2x9YDtcbiAgICBjb25zdCBhbW91bnRTdHIgPSB0eXBlb2YgYW1vdW50ID09PSAnYmlnaW50JyA/IGFtb3VudC50b1N0cmluZygpIDogYW1vdW50O1xuICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdEJhbGFuY2UoYW1vdW50U3RyLCBtZXRhZGF0YS5kZWNpbWFscywgcHJlY2lzaW9uKTtcbiAgICByZXR1cm4gYCR7Zm9ybWF0dGVkfSAke21ldGFkYXRhLnN5bWJvbH1gO1xufVxuLyoqXG4gKiBUcnVuY2F0ZSBhbiBhZGRyZXNzIGZvciBkaXNwbGF5IHB1cnBvc2VzXG4gKi9cbmZ1bmN0aW9uIHRydW5jYXRlQWRkcmVzcyhhZGRyZXNzLCBzdGFydExlbmd0aCA9IDYsIGVuZExlbmd0aCA9IDQpIHtcbiAgICBpZiAoIWlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKVxuICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICBpZiAoYWRkcmVzcy5sZW5ndGggPD0gc3RhcnRMZW5ndGggKyBlbmRMZW5ndGggKyAyKVxuICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICByZXR1cm4gYCR7YWRkcmVzcy5zbGljZSgwLCBzdGFydExlbmd0aCl9Li4uJHthZGRyZXNzLnNsaWNlKC1lbmRMZW5ndGgpfWA7XG59XG4vKipcbiAqIENvbnZlcnQgY2hhaW4gSUQgdG8gaGV4IGZvcm1hdFxuICovXG5mdW5jdGlvbiBjaGFpbklkVG9IZXgoY2hhaW5JZCkge1xuICAgIHJldHVybiBgMHgke2NoYWluSWQudG9TdHJpbmcoMTYpfWA7XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IGNoYWluIElEIHRvIG51bWJlclxuICovXG5mdW5jdGlvbiBoZXhUb0NoYWluSWQoaGV4KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGhleCwgMTYpO1xufVxuY29uc3QgaXNNYWlubmV0Q2hhaW4gPSAoY2hhaW5JZCkgPT4ge1xuICAgIHJldHVybiBNQUlOTkVUX0NIQUlOUy5pbmNsdWRlcyhjaGFpbklkKTtcbn07XG5jb25zdCBpc1Rlc3RuZXRDaGFpbiA9IChjaGFpbklkKSA9PiB7XG4gICAgcmV0dXJuIFRFU1RORVRfQ0hBSU5TLmluY2x1ZGVzKGNoYWluSWQpO1xufTtcbi8qKlxuICogRW5oYW5jZWQgY29udHJhY3QgcGFyYW1ldGVyIHZhbGlkYXRpb24gd2l0aCBkZXRhaWxlZCBlcnJvciBtZXNzYWdlc1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRyYWN0UGFyYW1zKHBhcmFtcykge1xuICAgIGNvbnN0IHsgY29udHJhY3RBZGRyZXNzLCBjb250cmFjdEFiaSwgZnVuY3Rpb25OYW1lLCBmdW5jdGlvblBhcmFtcywgY2hhaW5JZCB9ID0gcGFyYW1zO1xuICAgIC8vIFZhbGlkYXRlIGNvbnRyYWN0IGFkZHJlc3NcbiAgICBpZiAoIWNvbnRyYWN0QWRkcmVzcyB8fCB0eXBlb2YgY29udHJhY3RBZGRyZXNzICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6ICdDb250cmFjdCBhZGRyZXNzIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgc3RyaW5nJyB9O1xuICAgIH1cbiAgICBpZiAoIXZpZW0uaXNBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiAnQ29udHJhY3QgYWRkcmVzcyBtdXN0IGJlIGEgY2hlY2tzdW1tZWQgRXRoZXJldW0gYWRkcmVzcycgfTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgQUJJXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRyYWN0QWJpKSB8fCBjb250cmFjdEFiaS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiAnQ29udHJhY3QgQUJJIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5JyB9O1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSBmdW5jdGlvbiBuYW1lXG4gICAgaWYgKCFmdW5jdGlvbk5hbWUgfHwgdHlwZW9mIGZ1bmN0aW9uTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiAnRnVuY3Rpb24gbmFtZSBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHN0cmluZycgfTtcbiAgICB9XG4gICAgLy8gRmluZCBmdW5jdGlvbiBpbiBBQklcbiAgICBjb25zdCBmdW5jdGlvbkFiaSA9IGNvbnRyYWN0QWJpLmZpbmQoKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpdGVtLm5hbWUgPT09IGZ1bmN0aW9uTmFtZSk7XG4gICAgaWYgKCFmdW5jdGlvbkFiaSkge1xuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3I6IGBGdW5jdGlvbiAnJHtmdW5jdGlvbk5hbWV9JyBub3QgZm91bmQgaW4gY29udHJhY3QgQUJJYCB9O1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSBwYXJhbWV0ZXJzIGNvdW50XG4gICAgY29uc3QgZXhwZWN0ZWRQYXJhbXNDb3VudCA9IGZ1bmN0aW9uQWJpLmlucHV0cz8ubGVuZ3RoID8/IDA7XG4gICAgY29uc3QgcHJvdmlkZWRQYXJhbXNDb3VudCA9IGZ1bmN0aW9uUGFyYW1zPy5sZW5ndGggfHwgMDtcbiAgICBpZiAoZXhwZWN0ZWRQYXJhbXNDb3VudCAhPT0gcHJvdmlkZWRQYXJhbXNDb3VudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogYEZ1bmN0aW9uICcke2Z1bmN0aW9uTmFtZX0nIGV4cGVjdHMgJHtleHBlY3RlZFBhcmFtc0NvdW50fSBwYXJhbWV0ZXJzLCBidXQgJHtwcm92aWRlZFBhcmFtc0NvdW50fSB3ZXJlIHByb3ZpZGVkYCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgY2hhaW4gSURcbiAgICBpZiAoIWNoYWluSWQgfHwgIUNIQUlOX01FVEFEQVRBW2NoYWluSWRdKSB7XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogYFVuc3VwcG9ydGVkIGNoYWluIElEOiAke2NoYWluSWR9YCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG59XG4vKipcbiAqIEVuaGFuY2VkIGNvbnRyYWN0IGNhbGwgZW5jb2Rpbmcgd2l0aCBjb21wcmVoZW5zaXZlIGVycm9yIGhhbmRsaW5nXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUNvbnRyYWN0Q2FsbChwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGNvbnRyYWN0QWJpLCBmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB2aWVtLmVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0QWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgYXJnczogZnVuY3Rpb25QYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogYEZhaWxlZCB0byBlbmNvZGUgY29udHJhY3QgY2FsbDogJHtleHRyYWN0RXJyb3JNZXNzYWdlKGVycm9yLCAnZW5jb2RpbmcnKX1gLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGUgYW5kIGVuc3VyZSBhIHZhbHVlIGlzIGEgdmFsaWQgdHJhbnNhY3Rpb24gaGFzaFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVRyYW5zYWN0aW9uSGFzaCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHZpZW0uaXNIYXNoKHZhbHVlKTtcbn1cbi8qKlxuICogVmFsaWRhdGUgaGV4IHJlc3BvbnNlIGZyb20gUlBDIGNhbGxzXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSGV4UmVzcG9uc2UodmFsdWUsIGZpZWxkTmFtZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcjogYCR7ZmllbGROYW1lfSBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgJHt0eXBlb2YgdmFsdWV9YCB9O1xuICAgIH1cbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGVycm9yOiBgJHtmaWVsZE5hbWV9IG11c3QgYmUgYSBoZXggc3RyaW5nIHN0YXJ0aW5nIHdpdGggMHhgIH07XG4gICAgfVxuICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUgfTtcbn1cbi8qKlxuICogRW5oYW5jZWQgYmxvY2sgZXhwbG9yZXIgVVJMIGdlbmVyYXRpb24gd2l0aCBmYWxsYmFjayBzdXBwb3J0XG4gKi9cbmZ1bmN0aW9uIGdldEJsb2NrRXhwbG9yZXJVcmwoY2hhaW5JZCwgdHhIYXNoKSB7XG4gICAgY29uc3QgY2hhaW5NZXRhZGF0YSA9IENIQUlOX01FVEFEQVRBW2NoYWluSWRdO1xuICAgIGlmICghY2hhaW5NZXRhZGF0YT8uYmxvY2tFeHBsb3JlclVybHM/LlswXSkge1xuICAgICAgICBsb2dnZXIud2FybihgTm8gYmxvY2sgZXhwbG9yZXIgVVJMIGZvdW5kIGZvciBjaGFpbiAke2NoYWluSWR9YCk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgYmFzZVVybCA9IGNoYWluTWV0YWRhdGEuYmxvY2tFeHBsb3JlclVybHNbMF07XG4gICAgcmV0dXJuIGAke2Jhc2VVcmx9L3R4LyR7dHhIYXNofWA7XG59XG4vKipcbiAqIFNlYXJjaCBmb3IgdHJhbnNhY3Rpb24gaGFzaCBpbiBibG9jayB0cmFuc2FjdGlvbnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VhcmNoVHJhbnNhY3Rpb25JbkJsb2NrKHByb3ZpZGVyLCBmcm9tQWRkcmVzcykge1xuICAgIGNvbnN0IGxhdGVzdEJsb2NrID0gKGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsXG4gICAgICAgIHBhcmFtczogWydsYXRlc3QnLCB0cnVlXSxcbiAgICB9KSk7XG4gICAgaWYgKCFsYXRlc3RCbG9jaz8udHJhbnNhY3Rpb25zKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHR4IG9mIGxhdGVzdEJsb2NrLnRyYW5zYWN0aW9ucykge1xuICAgICAgICBpZiAodHguZnJvbT8udG9Mb3dlckNhc2UoKSA9PT0gZnJvbUFkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlVHJhbnNhY3Rpb25IYXNoKHR4Lmhhc2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4Lmhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFBvbGwgZm9yIHRyYW5zYWN0aW9uIGhhc2ggd2l0aCB0aW1lb3V0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBvbGxGb3JUcmFuc2FjdGlvbkhhc2gocHJvdmlkZXIsIGZyb21BZGRyZXNzLCB0aW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHNlYXJjaFRyYW5zYWN0aW9uSW5CbG9jayhwcm92aWRlciwgZnJvbUFkZHJlc3MpO1xuICAgICAgICBpZiAoaGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgaGFzaCB9O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHdhaXQoMjAwMCk7XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1RyYW5zYWN0aW9uIGhhc2ggbm90IGZvdW5kIHdpdGhpbiB0aW1lb3V0IHBlcmlvZCcgfTtcbn1cbi8qKlxuICogR2V0IHRyYW5zYWN0aW9uIGhhc2ggd2l0aCBtdWx0aXBsZSBmYWxsYmFjayBzdHJhdGVnaWVzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uSGFzaFdpdGhGYWxsYmFjayhwcm92aWRlciwgcmVzcG9uc2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZW5hYmxlUG9sbGluZyA9IGZhbHNlLCB0aW1lb3V0ID0gMzAwMDAsIGZyb21BZGRyZXNzIH0gPSBvcHRpb25zO1xuICAgIC8vIFN0cmF0ZWd5IDE6IERpcmVjdCByZXNwb25zZSB2YWxpZGF0aW9uXG4gICAgaWYgKHZhbGlkYXRlVHJhbnNhY3Rpb25IYXNoKHJlc3BvbnNlKSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBoYXNoOiByZXNwb25zZSB9O1xuICAgIH1cbiAgICAvLyBTdHJhdGVneSAyOiBUcmFuc2FjdGlvbiBwb2xsaW5nIChpZiBlbmFibGVkKVxuICAgIGlmIChlbmFibGVQb2xsaW5nICYmIGZyb21BZGRyZXNzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcG9sbEZvclRyYW5zYWN0aW9uSGFzaChwcm92aWRlciwgZnJvbUFkZHJlc3MsIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogYFRyYW5zYWN0aW9uIHBvbGxpbmcgZmFpbGVkOiAke2V4dHJhY3RFcnJvck1lc3NhZ2UoZXJyb3IsICdwb2xsaW5nJyl9YCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBgSW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoIHJlc3BvbnNlOiAke3R5cGVvZiByZXNwb25zZX0ke2VuYWJsZVBvbGxpbmcgPyAnIChwb2xsaW5nIGRpc2FibGVkKScgOiAnJ31gLFxuICAgIH07XG59XG4vKipcbiAqIEVuaGFuY2VkIHRyYW5zYWN0aW9uIHJlY2VpcHQgd2FpdGluZyB1c2luZyBWaWVtXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQocHJvdmlkZXIsIHR4SGFzaCwgb3B0aW9ucyA9IHt9LCBjaGFpbklkID0gMSkge1xuICAgIGNvbnN0IHsgdGltZW91dCA9IDMwMDAwMCwgLy8gNSBtaW51dGVzIGRlZmF1bHRcbiAgICByZXF1aXJlZENvbmZpcm1hdGlvbnMgPSAxLCBwb2xsaW5nSW50ZXJ2YWwgPSAyMDAwLCB9ID0gb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB2aWVtLmNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgICAgICBjaGFpbjogZ2V0VmllbUNoYWluKGNoYWluSWQpLFxuICAgICAgICAgICAgdHJhbnNwb3J0OiB2aWVtLmN1c3RvbShwcm92aWRlciksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBVc2UgVmllbSdzIHdhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQgd2l0aCB0aW1lb3V0XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBjbGllbnQud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh7XG4gICAgICAgICAgICBoYXNoOiB0eEhhc2gsXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgcG9sbGluZ0ludGVydmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2hlY2sgdHJhbnNhY3Rpb24gc3RhdHVzXG4gICAgICAgIGlmIChyZWNlaXB0LnN0YXR1cyA9PT0gJ3JldmVydGVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ1RyYW5zYWN0aW9uIGZhaWxlZCAocmV2ZXJ0ZWQpJyxcbiAgICAgICAgICAgICAgICByZWNlaXB0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgY3VycmVudCBibG9jayBudW1iZXIgZm9yIGNvbmZpcm1hdGlvbiBjb3VudFxuICAgICAgICBjb25zdCBjdXJyZW50QmxvY2sgPSBhd2FpdCBjbGllbnQuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgY29uc3QgY29uZmlybWF0aW9ucyA9IE51bWJlcihjdXJyZW50QmxvY2sgLSByZWNlaXB0LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgZW5vdWdoIGNvbmZpcm1hdGlvbnNcbiAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPj0gcmVxdWlyZWRDb25maXJtYXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVjZWlwdCxcbiAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maXJtYXRpb25TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBjb25maXJtYXRpb25UaW1lb3V0ID0gdGltZW91dCB8fCAzMDAwMDA7XG4gICAgICAgIC8vIFdhaXQgZm9yIGFkZGl0aW9uYWwgY29uZmlybWF0aW9ucyBpZiBuZWVkZWRcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGF3YWl0IHdhaXQocG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gY29uZmlybWF0aW9uU3RhcnRUaW1lID4gY29uZmlybWF0aW9uVGltZW91dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYENvbmZpcm1hdGlvbiB0aW1lb3V0OiBvbmx5ICR7Y29uZmlybWF0aW9uc30gb2YgJHtyZXF1aXJlZENvbmZpcm1hdGlvbnN9IGNvbmZpcm1hdGlvbnMgcmVjZWl2ZWRgLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXB0LFxuICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsYXRlc3RCbG9jayA9IGF3YWl0IGNsaWVudC5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbmZpcm1hdGlvbnMgPSBOdW1iZXIobGF0ZXN0QmxvY2sgLSByZWNlaXB0LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgICAgICBpZiAoY3VycmVudENvbmZpcm1hdGlvbnMgPj0gcmVxdWlyZWRDb25maXJtYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9uczogY3VycmVudENvbmZpcm1hdGlvbnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgICAgPyBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICA6IGVycm9yPy5zaG9ydE1lc3NhZ2UgfHxcbiAgICAgICAgICAgICAgICBlcnJvcj8ubWVzc2FnZSB8fFxuICAgICAgICAgICAgICAgICdUcmFuc2FjdGlvbiByZWNlaXB0IHRpbWVvdXQnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBnZXQgdG9rZW4gY29udHJhY3QgYWRkcmVzcyBmb3IgYSBzcGVjaWZpYyB0b2tlbiBhbmQgY2hhaW5cbiAqIEBwYXJhbSB0b2tlbiBUb2tlbiBzeW1ib2wgKGUuZy4sICdVU0RDJywgJ1VTRFQnKVxuICogQHBhcmFtIGNoYWluSWQgQ2hhaW4gSURcbiAqIEBwYXJhbSBpc1Rlc3RuZXQgV2hldGhlciB0byB1c2UgdGVzdG5ldCBhZGRyZXNzZXNcbiAqIEByZXR1cm5zIENvbnRyYWN0IGFkZHJlc3Mgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICovXG5mdW5jdGlvbiBnZXRUb2tlbkNvbnRyYWN0QWRkcmVzcyh0b2tlbiwgY2hhaW5JZCkge1xuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gVE9LRU5fQ09OVFJBQ1RfQUREUkVTU0VTO1xuICAgIGNvbnN0IGFkZHJlc3MgPSByZWdpc3RyeVt0b2tlbl0/LltjaGFpbklkXTtcbiAgICByZXR1cm4gYWRkcmVzcyB8fCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydHMuQ0hBSU5fTUVUQURBVEEgPSBDSEFJTl9NRVRBREFUQTtcbmV4cG9ydHMuQ2FsaWJ1clNCQ1R5cGVzID0gQ2FsaWJ1clNCQ1R5cGVzO1xuZXhwb3J0cy5ERVNUSU5BVElPTl9TV0FQX1RPS0VOUyA9IERFU1RJTkFUSU9OX1NXQVBfVE9LRU5TO1xuZXhwb3J0cy5MT0dfTEVWRUwgPSBMT0dfTEVWRUw7XG5leHBvcnRzLk1BSU5ORVRfQ0hBSU5TID0gTUFJTk5FVF9DSEFJTlM7XG5leHBvcnRzLk5FWFVTX0VWRU5UUyA9IE5FWFVTX0VWRU5UUztcbmV4cG9ydHMuU1VQUE9SVEVEX0NIQUlOUyA9IFNVUFBPUlRFRF9DSEFJTlM7XG5leHBvcnRzLlRFU1RORVRfQ0hBSU5TID0gVEVTVE5FVF9DSEFJTlM7XG5leHBvcnRzLlRFU1RORVRfVE9LRU5fTUVUQURBVEEgPSBURVNUTkVUX1RPS0VOX01FVEFEQVRBO1xuZXhwb3J0cy5UT0tFTl9DT05UUkFDVF9BRERSRVNTRVMgPSBUT0tFTl9DT05UUkFDVF9BRERSRVNTRVM7XG5leHBvcnRzLlRPS0VOX01FVEFEQVRBID0gVE9LRU5fTUVUQURBVEE7XG5leHBvcnRzLmNoYWluSWRUb0hleCA9IGNoYWluSWRUb0hleDtcbmV4cG9ydHMuZW5jb2RlQ29udHJhY3RDYWxsID0gZW5jb2RlQ29udHJhY3RDYWxsO1xuZXhwb3J0cy5leHRyYWN0RXJyb3JNZXNzYWdlID0gZXh0cmFjdEVycm9yTWVzc2FnZTtcbmV4cG9ydHMuZm9ybWF0QmFsYW5jZSA9IGZvcm1hdEJhbGFuY2U7XG5leHBvcnRzLmZvcm1hdFRlc3RuZXRUb2tlbkFtb3VudCA9IGZvcm1hdFRlc3RuZXRUb2tlbkFtb3VudDtcbmV4cG9ydHMuZm9ybWF0VG9rZW5BbW91bnQgPSBmb3JtYXRUb2tlbkFtb3VudDtcbmV4cG9ydHMuZm9ybWF0VW5pdHMgPSBmb3JtYXRVbml0cztcbmV4cG9ydHMuZ2V0QmxvY2tFeHBsb3JlclVybCA9IGdldEJsb2NrRXhwbG9yZXJVcmw7XG5leHBvcnRzLmdldENoYWluTWV0YWRhdGEgPSBnZXRDaGFpbk1ldGFkYXRhO1xuZXhwb3J0cy5nZXRMb2dnZXIgPSBnZXRMb2dnZXI7XG5leHBvcnRzLmdldE1haW5uZXRUb2tlbk1ldGFkYXRhID0gZ2V0TWFpbm5ldFRva2VuTWV0YWRhdGE7XG5leHBvcnRzLmdldFRlc3RuZXRUb2tlbk1ldGFkYXRhID0gZ2V0VGVzdG5ldFRva2VuTWV0YWRhdGE7XG5leHBvcnRzLmdldFRva2VuQ29udHJhY3RBZGRyZXNzID0gZ2V0VG9rZW5Db250cmFjdEFkZHJlc3M7XG5leHBvcnRzLmdldFRva2VuTWV0YWRhdGEgPSBnZXRUb2tlbk1ldGFkYXRhO1xuZXhwb3J0cy5nZXRUcmFuc2FjdGlvbkhhc2hXaXRoRmFsbGJhY2sgPSBnZXRUcmFuc2FjdGlvbkhhc2hXaXRoRmFsbGJhY2s7XG5leHBvcnRzLmdldFZpZW1DaGFpbiA9IGdldFZpZW1DaGFpbjtcbmV4cG9ydHMuaGV4VG9DaGFpbklkID0gaGV4VG9DaGFpbklkO1xuZXhwb3J0cy5pc01haW5uZXRDaGFpbiA9IGlzTWFpbm5ldENoYWluO1xuZXhwb3J0cy5pc1Rlc3RuZXRDaGFpbiA9IGlzVGVzdG5ldENoYWluO1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGlzVmFsaWRBZGRyZXNzO1xuZXhwb3J0cy5sb2dnZXIgPSBsb2dnZXI7XG5leHBvcnRzLnBhcnNlVW5pdHMgPSBwYXJzZVVuaXRzO1xuZXhwb3J0cy5zZXRFeGNlcHRpb25SZXBvcnRlciA9IHNldEV4Y2VwdGlvblJlcG9ydGVyO1xuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IHNldExvZ0xldmVsO1xuZXhwb3J0cy50cnVuY2F0ZUFkZHJlc3MgPSB0cnVuY2F0ZUFkZHJlc3M7XG5leHBvcnRzLnZhbGlkYXRlQ29udHJhY3RQYXJhbXMgPSB2YWxpZGF0ZUNvbnRyYWN0UGFyYW1zO1xuZXhwb3J0cy52YWxpZGF0ZUhleFJlc3BvbnNlID0gdmFsaWRhdGVIZXhSZXNwb25zZTtcbmV4cG9ydHMudmFsaWRhdGVUcmFuc2FjdGlvbkhhc2ggPSB2YWxpZGF0ZVRyYW5zYWN0aW9uSGFzaDtcbmV4cG9ydHMud2FpdCA9IHdhaXQ7XG5leHBvcnRzLndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQgPSB3YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@avail-project+nexus-core@0.0.1-beta.0_bufferutil@4.0.9_google-protobuf@3.21.4_utf-8-va_56dd550c8b9e0639694cd9176377fa72/node_modules/@avail-project/nexus-core/dist/commons/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@avail-project+nexus-core@0.0.1-beta.0_bufferutil@4.0.9_google-protobuf@3.21.4_utf-8-va_56dd550c8b9e0639694cd9176377fa72/node_modules/@avail-project/nexus-core/dist/index.esm.js":
/*!**************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@avail-project+nexus-core@0.0.1-beta.0_bufferutil@4.0.9_google-protobuf@3.21.4_utf-8-va_56dd550c8b9e0639694cd9176377fa72/node_modules/@avail-project/nexus-core/dist/index.esm.js ***!
  \**************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHAIN_METADATA: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.CHAIN_METADATA),\n/* harmony export */   CaliburSBCTypes: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.CaliburSBCTypes),\n/* harmony export */   DESTINATION_SWAP_TOKENS: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.DESTINATION_SWAP_TOKENS),\n/* harmony export */   LOG_LEVEL: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.LOG_LEVEL),\n/* harmony export */   MAINNET_CHAINS: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.MAINNET_CHAINS),\n/* harmony export */   NEXUS_EVENTS: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS),\n/* harmony export */   NexusSDK: () => (/* binding */ NexusSDK),\n/* harmony export */   SUPPORTED_CHAINS: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.SUPPORTED_CHAINS),\n/* harmony export */   SwapMode: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.SwapMode),\n/* harmony export */   TESTNET_CHAINS: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.TESTNET_CHAINS),\n/* harmony export */   TESTNET_TOKEN_METADATA: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.TESTNET_TOKEN_METADATA),\n/* harmony export */   TOKEN_CONTRACT_ADDRESSES: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.TOKEN_CONTRACT_ADDRESSES),\n/* harmony export */   TOKEN_METADATA: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.TOKEN_METADATA),\n/* harmony export */   chainIdToHex: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.chainIdToHex),\n/* harmony export */   encodeContractCall: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.encodeContractCall),\n/* harmony export */   extractErrorMessage: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage),\n/* harmony export */   formatBalance: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.formatBalance),\n/* harmony export */   formatTestnetTokenAmount: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.formatTestnetTokenAmount),\n/* harmony export */   formatTokenAmount: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.formatTokenAmount),\n/* harmony export */   formatUnits: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.formatUnits),\n/* harmony export */   getBlockExplorerUrl: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.getBlockExplorerUrl),\n/* harmony export */   getChainMetadata: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.getChainMetadata),\n/* harmony export */   getLogger: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.getLogger),\n/* harmony export */   getMainnetTokenMetadata: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.getMainnetTokenMetadata),\n/* harmony export */   getTestnetTokenMetadata: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.getTestnetTokenMetadata),\n/* harmony export */   getTokenContractAddress: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.getTokenContractAddress),\n/* harmony export */   getTokenMetadata: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.getTokenMetadata),\n/* harmony export */   getTransactionHashWithFallback: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.getTransactionHashWithFallback),\n/* harmony export */   getViemChain: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.getViemChain),\n/* harmony export */   hexToChainId: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.hexToChainId),\n/* harmony export */   isMainnetChain: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.isMainnetChain),\n/* harmony export */   isTestnetChain: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.isTestnetChain),\n/* harmony export */   isValidAddress: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.isValidAddress),\n/* harmony export */   logger: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.logger),\n/* harmony export */   parseUnits: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.parseUnits),\n/* harmony export */   setExceptionReporter: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.setExceptionReporter),\n/* harmony export */   setLogLevel: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.setLogLevel),\n/* harmony export */   truncateAddress: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.truncateAddress),\n/* harmony export */   validateContractParams: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.validateContractParams),\n/* harmony export */   validateHexResponse: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.validateHexResponse),\n/* harmony export */   validateTransactionHash: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.validateTransactionHash),\n/* harmony export */   wait: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.wait),\n/* harmony export */   waitForTransactionReceipt: () => (/* reexport safe */ _commons__WEBPACK_IMPORTED_MODULE_0__.waitForTransactionReceipt)\n/* harmony export */ });\n/* harmony import */ var _commons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commons */ \"(ssr)/./node_modules/.pnpm/@avail-project+nexus-core@0.0.1-beta.0_bufferutil@4.0.9_google-protobuf@3.21.4_utf-8-va_56dd550c8b9e0639694cd9176377fa72/node_modules/@avail-project/nexus-core/dist/commons/index.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/encoding/fromHex.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/unit/formatEther.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/errors/rpc.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/constants/number.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/abi/decodeFunctionData.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/encoding/toBytes.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/data/pad.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/signature/parseSignature.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/actions/getContract.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! viem/utils */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/clients/transports/fallback.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/abi/getAbiItem.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/abi/encodeAbiParameters.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/hash/keccak256.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/signature/hashMessage.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/encoding/fromBytes.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/data/concat.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/clients/transports/webSocket.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/transaction/serializeTransaction.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/clients/transports/custom.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/clients/decorators/public.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/unit/parseUnits.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/constants/abis.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/unit/formatUnits.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/abi/encodePacked.js\");\n/* harmony import */ var _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @arcana/ca-common */ \"(ssr)/./node_modules/.pnpm/@arcana+ca-common@1.0.1-alpha.6_@cosmjs+proto-signing@0.34.0_@cosmjs+stargate@0.34.0_bu_f223cc0ff9f86444de0877e59a78e7ca/node_modules/@arcana/ca-common/dist/esm/index.js\");\n/* harmony import */ var decimal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/.pnpm/decimal.js@10.6.0/node_modules/decimal.js/decimal.mjs\");\n/* harmony import */ var fuels__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fuels */ \"(ssr)/./node_modules/.pnpm/fuels@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6.1_jsdom@26.1_b20937e3f604b46d6217e388b4bd6dee/node_modules/fuels/dist/index.mjs\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/.pnpm/axios@1.12.2/node_modules/axios/lib/axios.js\");\n/* harmony import */ var it_ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! it-ws */ \"(ssr)/./node_modules/.pnpm/it-ws@6.1.5_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/it-ws/dist/src/index.js\");\n/* harmony import */ var msgpackr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! msgpackr */ \"(ssr)/./node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/node-index.js\");\n/* harmony import */ var _cosmjs_stargate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @cosmjs/stargate */ \"(ssr)/./node_modules/.pnpm/@cosmjs+stargate@0.34.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/index.js\");\n/* harmony import */ var _cosmjs_stargate__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_cosmjs_stargate__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _metamask_safe_event_emitter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @metamask/safe-event-emitter */ \"(ssr)/./node_modules/.pnpm/@metamask+safe-event-emitter@3.1.2/node_modules/@metamask/safe-event-emitter/dist/esm/index.mjs\");\n/* harmony import */ var _starkware_industries_starkware_crypto_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @starkware-industries/starkware-crypto-utils */ \"(ssr)/./node_modules/.pnpm/@starkware-industries+starkware-crypto-utils@0.2.1/node_modules/@starkware-industries/starkware-crypto-utils/dist/index.es.js\");\n/* harmony import */ var viem_accounts__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! viem/accounts */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/accounts/privateKeyToAccount.js\");\n/* harmony import */ var viem_siwe__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! viem/siwe */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/utils/siwe/createSiweMessage.js\");\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! long */ \"(ssr)/./node_modules/.pnpm/long@5.3.2/node_modules/long/index.js\");\n/* harmony import */ var es_toolkit__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! es-toolkit */ \"(ssr)/./node_modules/.pnpm/es-toolkit@1.40.0/node_modules/es-toolkit/dist/function/retry.mjs\");\n/* harmony import */ var es_toolkit__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! es-toolkit */ \"(ssr)/./node_modules/.pnpm/es-toolkit@1.40.0/node_modules/es-toolkit/dist/array/orderBy.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass NexusUtils {\n    constructor(adapter, isReady) {\n        this.adapter = adapter;\n        this.isReady = isReady;\n        // Pure utility functions (no adapter dependency)\n        this.formatBalance = _commons__WEBPACK_IMPORTED_MODULE_0__.formatBalance;\n        this.parseUnits = _commons__WEBPACK_IMPORTED_MODULE_0__.parseUnits;\n        this.formatUnits = _commons__WEBPACK_IMPORTED_MODULE_0__.formatUnits;\n        this.isValidAddress = _commons__WEBPACK_IMPORTED_MODULE_0__.isValidAddress;\n        this.truncateAddress = _commons__WEBPACK_IMPORTED_MODULE_0__.truncateAddress;\n        this.chainIdToHex = _commons__WEBPACK_IMPORTED_MODULE_0__.chainIdToHex;\n        this.hexToChainId = _commons__WEBPACK_IMPORTED_MODULE_0__.hexToChainId;\n        this.getMainnetTokenMetadata = _commons__WEBPACK_IMPORTED_MODULE_0__.getMainnetTokenMetadata;\n        this.getTestnetTokenMetadata = _commons__WEBPACK_IMPORTED_MODULE_0__.getTestnetTokenMetadata;\n        this.getTokenMetadata = _commons__WEBPACK_IMPORTED_MODULE_0__.getTokenMetadata;\n        this.getChainMetadata = _commons__WEBPACK_IMPORTED_MODULE_0__.getChainMetadata;\n        this.formatTokenAmount = _commons__WEBPACK_IMPORTED_MODULE_0__.formatTokenAmount;\n        this.formatTestnetTokenAmount = _commons__WEBPACK_IMPORTED_MODULE_0__.formatTestnetTokenAmount;\n    }\n    ensureInitialized() {\n        if (!this.isReady()) {\n            throw new Error('NexusSDK must be initialized before using utils methods that require adapter access. Call sdk.initialize() first.');\n        }\n    }\n    getSupportedChains() {\n        this.ensureInitialized();\n        return this.adapter.getSupportedChains();\n    }\n    getSwapSupportedChainsAndTokens() {\n        this.ensureInitialized();\n        return this.adapter.nexusSDK.getSwapSupportedChainsAndTokens();\n    }\n    /* Same for isSupportedChain / isSupportedToken */\n    isSupportedChain(chainId) {\n        this.ensureInitialized();\n        return this.adapter.isSupportedChain(chainId);\n    }\n    isSupportedToken(token) {\n        this.ensureInitialized();\n        return this.adapter.isSupportedToken(token);\n    }\n}\n\nconst BACKEND_URL = 'https://nexus-backend.avail.so';\n/**\n * Backend client for gas estimation using new API\n */\nclass BackendSimulationClient {\n    constructor(config) {\n        this.baseUrl = config.baseUrl;\n    }\n    /**\n     * Check if a specific chain is supported\n     */\n    async isChainSupported(chainId) {\n        try {\n            const response = await fetch(`${this.baseUrl}/api/gas-estimation/check-chain/${chainId}`);\n            if (!response.ok)\n                return false;\n            const result = await response.json();\n            return result.success && result.data?.supported === true;\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Error checking chain support for ${chainId}:`, error);\n            return false;\n        }\n    }\n    /**\n     * Get all supported chains\n     */\n    async getSupportedChains() {\n        try {\n            const response = await fetch(`${this.baseUrl}/api/gas-estimation/supported-chains`);\n            if (!response.ok)\n                return null;\n            const result = await response.json();\n            return result.success ? result.data || null : null;\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('Error fetching supported chains:', error);\n            return null;\n        }\n    }\n    /**\n     * Get service status\n     */\n    async getServiceStatus() {\n        try {\n            const response = await fetch(`${this.baseUrl}/api/gas-estimation/status`);\n            if (!response.ok)\n                return null;\n            const result = await response.json();\n            return result.success ? result.data || null : null;\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('Error fetching service status:', error);\n            return null;\n        }\n    }\n    /**\n     * Health check\n     */\n    async healthCheck() {\n        try {\n            const response = await fetch(`${this.baseUrl}/api/health`);\n            if (!response.ok)\n                return null;\n            const result = await response.json();\n            return result.success ? result.data || null : null;\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('Error performing health check:', error);\n            return null;\n        }\n    }\n    /**\n     * Test connectivity and service health\n     */\n    async testConnection() {\n        try {\n            const health = await this.healthCheck();\n            return health?.status === 'ok';\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('Connection test failed:', error);\n            return false;\n        }\n    }\n    /**\n     * Get detailed service information\n     */\n    async getServiceInfo() {\n        try {\n            const [health, status] = await Promise.all([this.healthCheck(), this.getServiceStatus()]);\n            return {\n                healthy: health?.status === 'ok',\n                configured: status?.configured || false,\n                supportedChains: status?.supportedChainsCount || 0,\n                version: health?.version,\n                uptime: health?.uptime,\n            };\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('Error getting service info:', error);\n            return {\n                healthy: false,\n                configured: false,\n                supportedChains: 0,\n            };\n        }\n    }\n    /**\n     * Simulate transaction using Tenderly's Gateway RPC with state overrides\n     * This provides more accurate simulation results than basic gas estimation\n     */\n    async simulate(request) {\n        try {\n            const response = await fetch(`${this.baseUrl}/api/gas-estimation/simulate`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(request),\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`Simulation API error: ${response.status} - ${errorText}`);\n            }\n            const result = await response.json();\n            if (!result.success || !result.data) {\n                throw new Error(result.error || result.message || 'Simulation failed');\n            }\n            const gasData = result.data;\n            return {\n                gasUsed: gasData.gasUsed,\n                gasPrice: gasData.gasPrice || '0x0',\n                maxFeePerGas: gasData.maxFeePerGas,\n                maxPriorityFeePerGas: gasData.maxPriorityFeePerGas,\n                success: true,\n                estimatedCost: {\n                    totalFee: gasData?.gasUsed || '0',\n                },\n            };\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('Simulation API error:', error);\n            return {\n                gasUsed: '0x0',\n                gasPrice: '0x0',\n                success: false,\n                errorMessage: error instanceof Error ? error.message : 'Unknown error',\n                estimatedCost: {\n                    totalFee: '0',\n                },\n            };\n        }\n    }\n    /**\n     * Fetch current gas price via RPC\n     */\n    async getCurrentGasPrice(chainId) {\n        try {\n            const rpcUrl = this.getRpcUrl(chainId);\n            const response = await fetch(rpcUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    jsonrpc: '2.0',\n                    method: 'eth_gasPrice',\n                    params: [],\n                    id: 1,\n                }),\n            });\n            if (!response.ok) {\n                throw new Error(`RPC request failed: ${response.status}`);\n            }\n            const result = await response.json();\n            if (result.error) {\n                throw new Error(`RPC error: ${result.error.message}`);\n            }\n            // Convert hex gas price to bigint\n            return (0,viem__WEBPACK_IMPORTED_MODULE_10__.hexToBigInt)(result.result);\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('Failed to fetch current gas price, using fallback:', error);\n            // Fallback to 20 gwei if RPC call fails\n            return BigInt('20000000000'); // 20 gwei in wei\n        }\n    }\n    /**\n     * Get RPC URL for a given chain ID using CHAIN_METADATA\n     */\n    getRpcUrl(chainId) {\n        const chainIdNum = parseInt(chainId, 10);\n        const chainMetadata = _commons__WEBPACK_IMPORTED_MODULE_0__.CHAIN_METADATA[chainIdNum];\n        if (!chainMetadata || !chainMetadata.rpcUrls || chainMetadata.rpcUrls.length === 0) {\n            throw new Error(`No RPC URL available for chain ${chainId}`);\n        }\n        // Use the first RPC URL from the metadata\n        return chainMetadata.rpcUrls[0];\n    }\n    async simulateBundle(request) {\n        try {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG simulateBundle - request:', JSON.stringify(request, null, 2));\n            const response = await fetch(`${this.baseUrl}/api/gas-estimation/bundle`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(request),\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`Bundle simulation API error: ${response.status} - ${errorText}`);\n            }\n            const result = await response.json();\n            if (!result.success || !result.data) {\n                throw new Error(result.message || 'Bundle simulation failed');\n            }\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG simulateBundle - backend response:', result);\n            // Fetch current gas price via RPC\n            const currentGasPrice = await this.getCurrentGasPrice(request.chainId);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG - Raw gas price from RPC (wei):', currentGasPrice.toString());\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG - Gas price in gwei:', (Number(currentGasPrice) / 1e9).toFixed(2));\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG - Chain ID:', request.chainId);\n            // Transform backend response to human-readable format\n            const transformedResults = result.data.map((item, index) => {\n                const gasUsed = (0,viem__WEBPACK_IMPORTED_MODULE_10__.hexToBigInt)(item.gasUsed);\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG - Gas used (units):', gasUsed.toString());\n                const gasCostWei = gasUsed * currentGasPrice;\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG - Gas cost (wei):', gasCostWei.toString());\n                const gasCostEther = (0,viem__WEBPACK_IMPORTED_MODULE_11__.formatEther)(gasCostWei);\n                return {\n                    stepId: request.simulations[index]?.stepId || `step-${index}`,\n                    gasUsed: gasCostEther, // Human-readable cost like \"0.004205\"\n                    success: true,\n                    error: undefined,\n                };\n            });\n            // Calculate total cost\n            const totalGasCostWei = result.data.reduce((sum, item) => {\n                const gasUsed = (0,viem__WEBPACK_IMPORTED_MODULE_10__.hexToBigInt)(item.gasUsed);\n                return sum + gasUsed * currentGasPrice;\n            }, BigInt(0));\n            const totalGasCostEther = (0,viem__WEBPACK_IMPORTED_MODULE_11__.formatEther)(totalGasCostWei);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG simulateBundle - transformed response:', {\n                results: transformedResults,\n                totalGasUsed: totalGasCostEther,\n                gasPriceUsed: (0,viem__WEBPACK_IMPORTED_MODULE_11__.formatEther)(currentGasPrice * BigInt(1000000000)) + ' gwei',\n            });\n            return {\n                success: true,\n                results: transformedResults,\n                totalGasUsed: totalGasCostEther,\n            };\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('Bundle simulation API error:', error);\n            return {\n                success: false,\n                results: request.simulations.map((sim) => ({\n                    stepId: sim.stepId,\n                    gasUsed: '0.0',\n                    success: false,\n                    error: error instanceof Error ? error.message : 'Unknown error',\n                })),\n                totalGasUsed: '0.0',\n            };\n        }\n    }\n}\n/**\n * Default backend simulation client instance\n */\nlet defaultSimulationClient = null;\n/**\n * Configure the default simulation client\n */\nfunction configureSimulationBackend(config) {\n    defaultSimulationClient = new BackendSimulationClient(config);\n}\n/**\n * Get the default simulation client\n */\nfunction getSimulationClient() {\n    return defaultSimulationClient;\n}\n/**\n * Initialize simulation client with health check\n */\nasync function initializeSimulationClient(baseUrl = BACKEND_URL) {\n    try {\n        const client = new BackendSimulationClient({ baseUrl });\n        // Test the connection\n        const isHealthy = await client.testConnection();\n        if (!isHealthy) {\n            return {\n                success: false,\n                error: `Backend service at ${baseUrl} is not responding or unhealthy`,\n            };\n        }\n        // Configure as default client\n        defaultSimulationClient = client;\n        return {\n            success: true,\n        };\n    }\n    catch (error) {\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Unknown initialization error',\n        };\n    }\n}\n// Initialize with BACKEND_URL by default\nconfigureSimulationBackend({ baseUrl: BACKEND_URL });\n\nconst LOG_LEVEL = {\n    DEBUG: 1,\n    ERROR: 4,\n    INFO: 2,\n    NOLOGS: 5,\n    WARNING: 3,\n};\nconst sendException = (msg) => {\n};\nconst setLogLevel = (level) => {\n    state.logLevel = level;\n};\nconst getLogger = () => {\n    return state.logger;\n};\nclass Logger {\n    constructor() {\n        this.prefix = \"XAR_CA_SDK\";\n    }\n    consoleLog(level, message, params) {\n        if (level < state.logLevel) {\n            return;\n        }\n        switch (level) {\n            case LOG_LEVEL.DEBUG:\n                console.debug(`[DEBUG]`, message, params);\n                break;\n            case LOG_LEVEL.ERROR:\n                console.error(`[ERROR]`, message, params);\n                break;\n            case LOG_LEVEL.INFO:\n                console.info(`[INFO]`, message, params);\n                break;\n            case LOG_LEVEL.WARNING:\n                console.warn(`[WARN]`, message, params);\n                break;\n            default:\n                console.log(`[LOG]`, message, params);\n        }\n    }\n    debug(message, params = {}) {\n        this.internalLog(LOG_LEVEL.DEBUG, message, params);\n    }\n    error(message, err) {\n        if (err instanceof Error) {\n            this.internalLog(LOG_LEVEL.ERROR, message, err.message);\n            sendException(JSON.stringify({ error: err.message, message }));\n            return;\n        }\n        if (typeof err == \"string\") {\n            this.internalLog(LOG_LEVEL.ERROR, message, err);\n            sendException(JSON.stringify({ error: err, message }));\n        }\n    }\n    info(message, params = {}) {\n        this.internalLog(LOG_LEVEL.INFO, message, params);\n    }\n    internalLog(level, message, params) {\n        const logMessage = `[${this.prefix}] Msg: ${message}\\n`;\n        this.consoleLog(level, logMessage, params);\n    }\n    warn(message, params = {}) {\n        this.internalLog(LOG_LEVEL.WARNING, message, params);\n    }\n}\nconst state = {\n    logger: new Logger(),\n    logLevel: LOG_LEVEL.NOLOGS,\n};\n\nconst INTENT_ACCEPTED = {\n    type: 'INTENT_ACCEPTED',\n    typeID: 'IA',\n};\nconst INTENT_HASH_SIGNED = {\n    type: 'INTENT_HASH_SIGNED',\n    typeID: 'IHS',\n};\nconst INTENT_SUBMITTED = {\n    type: 'INTENT_SUBMITTED',\n    typeID: 'IS',\n};\nconst INTENT_INIT_STEPS = [\n    INTENT_HASH_SIGNED,\n    {\n        ...INTENT_SUBMITTED,\n        data: {\n            explorerURL: '',\n            intentID: 0,\n        },\n    },\n];\nconst INTENT_FULFILLED = {\n    type: 'INTENT_FULFILLED',\n    typeID: 'IF',\n};\nconst ALLOWANCE_APPROVAL_REQ = (chainID) => ({\n    type: 'ALLOWANCE_USER_APPROVAL',\n    typeID: `AUA_${chainID}`,\n});\nconst ALLOWANCE_APPROVAL_MINED = (chainID) => ({\n    type: 'ALLOWANCE_APPROVAL_MINED',\n    typeID: `AAM_${chainID}`,\n});\nconst ALLOWANCE_COMPLETE = {\n    type: 'ALLOWANCE_ALL_DONE',\n    typeID: 'AAD',\n};\nconst INTENT_DEPOSIT_REQ = (id) => ({\n    type: 'INTENT_DEPOSIT',\n    typeID: `ID_${id}`,\n});\nconst INTENT_DEPOSITS_CONFIRMED = {\n    type: 'INTENT_DEPOSITS_CONFIRMED',\n    typeID: 'UIDC',\n};\nconst INTENT_COLLECTION_COMPLETE = {\n    type: 'INTENT_COLLECTION_COMPLETE',\n    typeID: 'ICC',\n};\nconst INTENT_COLLECTION = (id) => ({\n    type: 'INTENT_COLLECTION',\n    typeID: `IC_${id}`,\n});\nconst INTENT_FINISH_STEPS = [INTENT_FULFILLED];\nconst createSteps = (intent, chainList, unallowedSources) => {\n    const steps = [];\n    steps.push(INTENT_ACCEPTED);\n    if (unallowedSources && unallowedSources?.length > 0) {\n        for (const source of unallowedSources) {\n            steps.push({\n                ...ALLOWANCE_APPROVAL_REQ(source.chain.id),\n                data: {\n                    chainID: source.chain.id,\n                    chainName: source.chain.name,\n                },\n            }, {\n                ...ALLOWANCE_APPROVAL_MINED(source.chain.id),\n                data: {\n                    chainID: source.chain.id,\n                    chainName: source.chain.name,\n                },\n            });\n        }\n        steps.push(ALLOWANCE_COMPLETE);\n    }\n    steps.push(...INTENT_INIT_STEPS);\n    const sources = intent.sources.filter((s) => s.chainID !== intent.destination.chainID);\n    let collections = 0, deposits = 0;\n    for (const [i, s] of sources.entries()) {\n        const isNative = isNativeAddress$1(s.universe, s.tokenContract);\n        if (isNative) {\n            deposits++;\n            const chain = chainList.getChainByID(s.chainID);\n            if (!chain) {\n                throw new Error(`Unknown chain ID ${s.chainID} while building steps`);\n            }\n            steps.push({\n                ...INTENT_DEPOSIT_REQ(i + 1),\n                data: {\n                    amount: s.amount.toString(),\n                    chainID: chain.id,\n                    chainName: chain.name,\n                    symbol: chain.nativeCurrency.symbol,\n                },\n            });\n        }\n        else {\n            collections++;\n            steps.push({\n                ...INTENT_COLLECTION(i + 1),\n                data: {\n                    confirmed: i + 1,\n                    total: sources.length,\n                },\n            });\n        }\n    }\n    if (collections > 0) {\n        steps.push(INTENT_COLLECTION_COMPLETE);\n    }\n    if (deposits > 0) {\n        steps.push(INTENT_DEPOSITS_CONFIRMED);\n    }\n    steps.push(...INTENT_FINISH_STEPS);\n    return steps;\n};\n\nconst ERC20TransferABI = {\n    constant: false,\n    inputs: [\n        {\n            name: '_to',\n            type: 'address',\n        },\n        {\n            name: '_value',\n            type: 'uint256',\n        },\n    ],\n    name: 'transfer',\n    outputs: [\n        {\n            name: '',\n            type: 'bool',\n        },\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function',\n};\nconst ERC20AllowanceABI = {\n    constant: true,\n    inputs: [\n        {\n            name: '_owner',\n            type: 'address',\n        },\n        {\n            name: '_spender',\n            type: 'address',\n        },\n    ],\n    name: 'allowance',\n    outputs: [\n        {\n            name: '',\n            type: 'uint256',\n        },\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function',\n};\nconst ABI = [\n    {\n        constant: true,\n        inputs: [],\n        name: 'name',\n        outputs: [\n            {\n                name: '',\n                type: 'string',\n            },\n        ],\n        payable: false,\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        constant: false,\n        inputs: [\n            {\n                name: '_spender',\n                type: 'address',\n            },\n            {\n                name: '_value',\n                type: 'uint256',\n            },\n        ],\n        name: 'approve',\n        outputs: [\n            {\n                name: '',\n                type: 'bool',\n            },\n        ],\n        payable: false,\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        constant: true,\n        inputs: [],\n        name: 'totalSupply',\n        outputs: [\n            {\n                name: '',\n                type: 'uint256',\n            },\n        ],\n        payable: false,\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        constant: false,\n        inputs: [\n            {\n                name: '_from',\n                type: 'address',\n            },\n            {\n                name: '_to',\n                type: 'address',\n            },\n            {\n                name: '_value',\n                type: 'uint256',\n            },\n        ],\n        name: 'transferFrom',\n        outputs: [\n            {\n                name: '',\n                type: 'bool',\n            },\n        ],\n        payable: false,\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        constant: true,\n        inputs: [],\n        name: 'decimals',\n        outputs: [\n            {\n                name: '',\n                type: 'uint8',\n            },\n        ],\n        payable: false,\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        constant: true,\n        inputs: [\n            {\n                name: '_owner',\n                type: 'address',\n            },\n        ],\n        name: 'balanceOf',\n        outputs: [\n            {\n                name: 'balance',\n                type: 'uint256',\n            },\n        ],\n        payable: false,\n        stateMutability: 'view',\n        type: 'function',\n    },\n    {\n        constant: true,\n        inputs: [],\n        name: 'symbol',\n        outputs: [\n            {\n                name: '',\n                type: 'string',\n            },\n        ],\n        payable: false,\n        stateMutability: 'view',\n        type: 'function',\n    },\n    ERC20TransferABI,\n    ERC20AllowanceABI,\n    {\n        payable: true,\n        stateMutability: 'payable',\n        type: 'fallback',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                name: 'owner',\n                type: 'address',\n            },\n            {\n                indexed: true,\n                name: 'spender',\n                type: 'address',\n            },\n            {\n                indexed: false,\n                name: 'value',\n                type: 'uint256',\n            },\n        ],\n        name: 'Approval',\n        type: 'event',\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                name: 'from',\n                type: 'address',\n            },\n            {\n                indexed: true,\n                name: 'to',\n                type: 'address',\n            },\n            {\n                indexed: false,\n                name: 'value',\n                type: 'uint256',\n            },\n        ],\n        name: 'Transfer',\n        type: 'event',\n    },\n];\nconst ERC20PermitABI = [\n    {\n        comment: 'From the EIP-2612 spec.',\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'owner',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'spender',\n                type: 'address',\n            },\n            {\n                internalType: 'uint256',\n                name: 'value',\n                type: 'uint256',\n            },\n            {\n                internalType: 'uint256',\n                name: 'deadline',\n                type: 'uint256',\n            },\n            {\n                internalType: 'uint8',\n                name: 'v',\n                type: 'uint8',\n            },\n            {\n                internalType: 'bytes32',\n                name: 'r',\n                type: 'bytes32',\n            },\n            {\n                internalType: 'bytes32',\n                name: 's',\n                type: 'bytes32',\n            },\n        ],\n        name: 'permit',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        comment: 'Available on bridged tokens on Polygon.',\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'userAddress',\n                type: 'address',\n            },\n            {\n                internalType: 'bytes',\n                name: 'functionSignature',\n                type: 'bytes',\n            },\n            {\n                internalType: 'bytes32',\n                name: 'sigR',\n                type: 'bytes32',\n            },\n            {\n                internalType: 'bytes32',\n                name: 'sigS',\n                type: 'bytes32',\n            },\n            {\n                internalType: 'uint8',\n                name: 'sigV',\n                type: 'uint8',\n            },\n        ],\n        name: 'executeMetaTransaction',\n        outputs: [\n            {\n                internalType: 'bytes',\n                name: '',\n                type: 'bytes',\n            },\n        ],\n        stateMutability: 'payable',\n        type: 'function',\n    },\n];\nconst ERC20PermitEIP712Type = {\n    EIP712Domain: [\n        { name: 'name', type: 'string' },\n        { name: 'version', type: 'string' },\n        { name: 'chainId', type: 'uint256' },\n        { name: 'verifyingContract', type: 'address' },\n    ],\n    Permit: [\n        { name: 'owner', type: 'address' },\n        { name: 'spender', type: 'address' },\n        { name: 'value', type: 'uint256' },\n        { name: 'nonce', type: 'uint256' },\n        { name: 'deadline', type: 'uint256' },\n    ],\n};\nconst ERC20PermitEIP2612PolygonType = {\n    EIP712Domain: [\n        { name: 'name', type: 'string' },\n        { name: 'version', type: 'string' },\n        { name: 'verifyingContract', type: 'address' },\n        { name: 'salt', type: 'bytes32' },\n    ],\n    MetaTransaction: [\n        { name: 'nonce', type: 'uint256' },\n        { name: 'from', type: 'address' },\n        { name: 'functionSignature', type: 'bytes' },\n    ],\n};\n\nvar gasOracleABI = [\n    { inputs: [], stateMutability: \"nonpayable\", type: \"constructor\" },\n    {\n        inputs: [],\n        name: \"DECIMALS\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"baseFee\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"decimals\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"pure\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"gasPrice\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"bytes\", name: \"_data\", type: \"bytes\" }],\n        name: \"getL1Fee\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"bytes\", name: \"_data\", type: \"bytes\" }],\n        name: \"getL1GasUsed\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"l1BaseFee\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"overhead\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"scalar\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"version\",\n        outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n];\n\nconst FillEvent = {\n    anonymous: false,\n    inputs: [\n        {\n            indexed: true,\n            internalType: \"bytes32\",\n            name: \"requestHash\",\n            type: \"bytes32\",\n        },\n        {\n            indexed: false,\n            internalType: \"address\",\n            name: \"from\",\n            type: \"address\",\n        },\n        {\n            indexed: false,\n            internalType: \"address\",\n            name: \"solver\",\n            type: \"address\",\n        },\n    ],\n    name: \"Fill\",\n    type: \"event\",\n};\n\nconst ErrorUserDeniedIntent$1 = new viem__WEBPACK_IMPORTED_MODULE_12__.UserRejectedRequestError(new Error(\"User denied intent.\"));\nconst ErrorUserDeniedAllowance = new viem__WEBPACK_IMPORTED_MODULE_12__.UserRejectedRequestError(new Error(\"User denied allowance.\"));\nconst ErrorInsufficientBalance$1 = new viem__WEBPACK_IMPORTED_MODULE_12__.InternalRpcError(new Error(\"Insufficient balance.\"));\nnew viem__WEBPACK_IMPORTED_MODULE_12__.InternalRpcError(new Error(\"Error while building intent.\"));\nconst ErrorLiquidityTimeout = new viem__WEBPACK_IMPORTED_MODULE_12__.InternalRpcError(new Error(\"Timed out waiting for liquidity.\"));\n\nconst logger$l = getLogger();\nconst isEVMTx = (tx) => {\n    logger$l.debug('isEVMTx', tx);\n    if (typeof tx !== 'object') {\n        return false;\n    }\n    if (!tx) {\n        return false;\n    }\n    if (!('to' in tx)) {\n        return false;\n    }\n    if (!('data' in tx || 'value' in tx)) {\n        return false;\n    }\n    return true;\n};\nconst getAllowance = (chain, address, tokenContract, chainList) => {\n    logger$l.debug('getAllowance', {\n        tokenContract,\n        ZERO_ADDRESS,\n    });\n    if (equalFold(ZERO_ADDRESS, tokenContract)) {\n        return Promise.resolve(viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256);\n    }\n    const publicClient = createPublicClientWithFallback(chain);\n    return publicClient.readContract({\n        abi: ABI,\n        address: tokenContract,\n        args: [address, chainList.getVaultContractAddress(chain.id)],\n        functionName: 'allowance',\n    });\n};\nconst getAllowances = async (input, address, chainList) => {\n    const values = {};\n    const promises = [];\n    for (const i of input) {\n        if (i.chainID === fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet) {\n            promises.push(Promise.resolve(0n));\n        }\n        else {\n            const chain = chainList.getChainByID(i.chainID);\n            if (!chain) {\n                throw new Error('chain not found');\n            }\n            promises.push(getAllowance(chain, address, i.tokenContract, chainList));\n        }\n    }\n    const result = await Promise.all(promises);\n    for (const i in result) {\n        values[input[i].chainID] = result[i];\n    }\n    return values;\n};\nconst waitForIntentFulfilment = async (publicClient, vaultContractAddr, requestHash, ac) => {\n    return new Promise((resolve) => {\n        const unwatch = publicClient.watchContractEvent({\n            abi: [FillEvent],\n            address: vaultContractAddr,\n            args: { requestHash },\n            eventName: 'Fill',\n            onLogs: (logs) => {\n                logger$l.debug('waitForIntentFulfilment', { logs });\n                ac.abort();\n                return resolve('ok');\n            },\n            poll: false,\n        });\n        ac.signal.addEventListener('abort', () => {\n            unwatch();\n            return resolve('ok from outside');\n        }, { once: true });\n    });\n};\nconst requestTimeout = (timeout, ac) => {\n    return new Promise((_, reject) => {\n        const t = window.setTimeout(() => {\n            ac.abort();\n            return reject(ErrorLiquidityTimeout);\n        }, minutesToMs(timeout));\n        ac.signal.addEventListener('abort', () => {\n            window.clearTimeout(t);\n        }, { once: true });\n    });\n};\nconst getTokenTxFunction = (data) => {\n    try {\n        const { args, functionName } = (0,viem__WEBPACK_IMPORTED_MODULE_14__.decodeFunctionData)({\n            abi: ABI,\n            data,\n        });\n        return { args, functionName };\n    }\n    catch (e) {\n        logger$l.debug('getTokenTxFunction', e);\n        return { args: [], functionName: 'unknown' };\n    }\n};\nconst setAllowances = async (tokenContractAddresses, client, networkConfig, chainList, chain, amount) => {\n    const vaultAddr = chainList.getVaultContractAddress(chain.id);\n    const p = [];\n    const address = (await client.getAddresses())[0];\n    const chainId = new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.OmniversalChainID(_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM, chain.id);\n    const chainDatum = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ChaindataMap.get(chainId);\n    if (!chainDatum) {\n        throw new Error('Chain data not found');\n    }\n    const account = {\n        address,\n        type: 'json-rpc',\n    };\n    const publicClient = createPublicClientWithFallback(chain);\n    const sponsoredApprovalParams = {\n        address: (0,viem__WEBPACK_IMPORTED_MODULE_15__.hexToBytes)((0,viem__WEBPACK_IMPORTED_MODULE_16__.pad)(address, {\n            dir: 'left',\n            size: 32,\n        })),\n        chain_id: chainDatum.ChainID32,\n        operations: [],\n        universe: chainDatum.Universe,\n    };\n    for (const addr of tokenContractAddresses) {\n        const currency = chainDatum.CurrencyMap.get(convertTo32Bytes$1(addr));\n        if (!currency) {\n            throw new Error('Currency not found');\n        }\n        if (currency.permitVariant === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported) {\n            const hash = await client.writeContract({\n                abi: ABI,\n                account: address,\n                address: addr,\n                args: [vaultAddr, amount],\n                chain,\n                functionName: 'approve',\n            });\n            p.push((async function () {\n                const result = await publicClient.waitForTransactionReceipt({\n                    confirmations: 2,\n                    hash,\n                });\n                if (result.status === 'reverted') {\n                    throw new Error('setAllowance failed with tx revert');\n                }\n            })());\n        }\n        else {\n            const signed = (0,viem__WEBPACK_IMPORTED_MODULE_17__.parseSignature)(await signPermitForAddressAndValue(currency, client, publicClient, account, vaultAddr, amount));\n            sponsoredApprovalParams.operations.push({\n                sig_r: (0,viem__WEBPACK_IMPORTED_MODULE_15__.hexToBytes)(signed.r),\n                sig_s: (0,viem__WEBPACK_IMPORTED_MODULE_15__.hexToBytes)(signed.s),\n                sig_v: signed.yParity < 27 ? signed.yParity + 27 : signed.yParity,\n                token_address: currency.tokenAddress,\n                value: convertTo32Bytes$1(amount),\n                variant: currency.permitVariant === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.PolygonEMT ? 2 : 1,\n            });\n        }\n    }\n    if (p.length) {\n        await Promise.all(p);\n    }\n    if (sponsoredApprovalParams.operations.length) {\n        await vscCreateSponsoredApprovals(networkConfig.VSC_DOMAIN, [sponsoredApprovalParams]);\n    }\n    return;\n};\nconst DEFAULT_GAS_ORACLE_ADDRESS = '0x420000000000000000000000000000000000000F';\nconst L1_GAS_ORACLES = {\n    10: DEFAULT_GAS_ORACLE_ADDRESS,\n    11155420: DEFAULT_GAS_ORACLE_ADDRESS,\n    534352: '0x5300000000000000000000000000000000000002',\n    8453: DEFAULT_GAS_ORACLE_ADDRESS,\n    84532: DEFAULT_GAS_ORACLE_ADDRESS,\n};\nconst chainsWithGasOracles = Object.keys(L1_GAS_ORACLES).map(Number);\nconst getL1Fee = async (chain, input = '0x') => {\n    let fee = 0n;\n    if (chainsWithGasOracles.includes(chain.id)) {\n        fee = await fetchL1Fee(chain, input);\n    }\n    return fee;\n};\nconst fetchL1Fee = (chain, input) => {\n    const pc = createPublicClientWithFallback(chain);\n    return pc.readContract({\n        abi: gasOracleABI,\n        address: L1_GAS_ORACLES[chain.id],\n        args: [input],\n        functionName: 'getL1Fee',\n    });\n};\nconst waitForTxReceipt = async (hash, publicClient, confirmations = 1) => {\n    const r = await publicClient.waitForTransactionReceipt({\n        confirmations,\n        hash,\n    });\n    if (r.status === 'reverted') {\n        throw new Error(`Transaction reverted: ${hash}`);\n    }\n};\nconst switchChain = async (client, chain) => {\n    try {\n        await client.switchChain({ id: chain.id });\n    }\n    catch (e) {\n        if (e instanceof viem__WEBPACK_IMPORTED_MODULE_12__.SwitchChainError && e.code === viem__WEBPACK_IMPORTED_MODULE_12__.SwitchChainError.code) {\n            await client.addChain({\n                chain,\n            });\n            await client.switchChain({ id: chain.id });\n            return;\n        }\n        throw e;\n    }\n};\nconst EIP712Domain = [\n    { name: 'name', type: 'string' },\n    { name: 'version', type: 'string' },\n    { name: 'chainId', type: 'uint256' },\n    { name: 'verifyingContract', type: 'address' },\n];\nconst PolygonDomain = [\n    { name: 'name', type: 'string' },\n    { name: 'version', type: 'string' },\n    { name: 'verifyingContract', type: 'address' },\n    { name: 'salt', type: 'bytes32' },\n];\nasync function signPermitForAddressAndValue(cur, client, publicClient, account, spender, value, deadline) {\n    const contract = (0,viem__WEBPACK_IMPORTED_MODULE_18__.getContract)({\n        abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ERC20ABI,\n        address: (0,viem__WEBPACK_IMPORTED_MODULE_19__.bytesToHex)(cur.tokenAddress.subarray(12)),\n        client: { public: publicClient },\n    });\n    const walletAddress = account.address;\n    deadline = deadline ?? 2n ** 256n - 1n;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const requestsToBeMade = [\n        (() => {\n            // Hack for sophon ETH\n            return contract.read.name().catch(() => {\n                return '';\n            });\n        })(),\n        client.request({ method: 'eth_chainId' }, { dedupe: true }),\n    ];\n    switch (cur.permitVariant) {\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported:\n        default: {\n            throw new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitCreationError('Permits are unsupported on this currency');\n        }\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.DAI:\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical:\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Polygon2612: {\n            requestsToBeMade[2] = contract.read.nonces([walletAddress]);\n            break;\n        }\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.PolygonEMT: {\n            requestsToBeMade[2] = contract.read.getNonce([walletAddress]);\n        }\n    }\n    const [name, chainID, nonce] = await Promise.all(requestsToBeMade);\n    switch (cur.permitVariant) {\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.DAI: {\n            return client.signTypedData({\n                account,\n                domain: {\n                    chainId: (0,viem__WEBPACK_IMPORTED_MODULE_10__.hexToBigInt)(chainID),\n                    name,\n                    verifyingContract: contract.address,\n                    version: cur.permitContractVersion.toString(10),\n                },\n                message: {\n                    allowed: true,\n                    expiry: deadline,\n                    holder: walletAddress,\n                    nonce,\n                    spender: spender,\n                },\n                primaryType: 'Permit',\n                types: {\n                    EIP712Domain,\n                    Permit: [\n                        { name: 'holder', type: 'address' },\n                        { name: 'spender', type: 'address' },\n                        { name: 'nonce', type: 'uint256' },\n                        { name: 'expiry', type: 'uint256' },\n                        { name: 'allowed', type: 'bool' },\n                    ],\n                },\n            });\n        }\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical: {\n            return client.signTypedData({\n                account,\n                domain: {\n                    chainId: (0,viem__WEBPACK_IMPORTED_MODULE_10__.hexToBigInt)(chainID),\n                    name,\n                    verifyingContract: contract.address,\n                    version: cur.permitContractVersion.toString(10),\n                },\n                message: {\n                    deadline,\n                    nonce,\n                    owner: walletAddress,\n                    spender,\n                    value,\n                },\n                primaryType: 'Permit',\n                types: {\n                    EIP712Domain,\n                    Permit: [\n                        { name: 'owner', type: 'address' },\n                        { name: 'spender', type: 'address' },\n                        { name: 'value', type: 'uint256' },\n                        { name: 'nonce', type: 'uint256' },\n                        { name: 'deadline', type: 'uint256' },\n                    ],\n                },\n            });\n        }\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Polygon2612: {\n            return client.signTypedData({\n                account,\n                domain: {\n                    name,\n                    salt: (0,viem__WEBPACK_IMPORTED_MODULE_16__.pad)(chainID, {\n                        dir: 'left',\n                        size: 32,\n                    }),\n                    verifyingContract: contract.address,\n                    version: cur.permitContractVersion.toString(10),\n                },\n                message: {\n                    allowed: true,\n                    expiry: deadline,\n                    holder: walletAddress,\n                    nonce,\n                    spender: spender,\n                },\n                primaryType: 'Permit',\n                types: {\n                    EIP712Domain: PolygonDomain,\n                    Permit: [\n                        { name: 'holder', type: 'address' },\n                        { name: 'spender', type: 'address' },\n                        { name: 'nonce', type: 'uint256' },\n                        { name: 'expiry', type: 'uint256' },\n                        { name: 'allowed', type: 'bool' },\n                    ],\n                },\n            });\n        }\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.PolygonEMT: {\n            const funcSig = (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n                abi: ABI,\n                args: [spender, value],\n                functionName: 'approve',\n            });\n            return client.signTypedData({\n                account,\n                domain: {\n                    name,\n                    salt: (0,viem__WEBPACK_IMPORTED_MODULE_16__.pad)(chainID, {\n                        dir: 'left',\n                        size: 32,\n                    }),\n                    verifyingContract: contract.address,\n                    version: cur.permitContractVersion.toString(10),\n                },\n                message: {\n                    from: walletAddress,\n                    functionSignature: funcSig,\n                    nonce,\n                },\n                primaryType: 'MetaTransaction',\n                types: {\n                    EIP712Domain: PolygonDomain,\n                    MetaTransaction: [\n                        { name: 'nonce', type: 'uint256' },\n                        { name: 'from', type: 'address' },\n                        { name: 'functionSignature', type: 'bytes' },\n                    ],\n                },\n            });\n        }\n    }\n}\nconst createPublicClientWithFallback = (chain) => {\n    if (chain.rpcUrls.default.http.length === 1) {\n        return (0,viem__WEBPACK_IMPORTED_MODULE_21__.createPublicClient)({\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_22__.http)(chain.rpcUrls.default.http[0]),\n        });\n    }\n    return (0,viem__WEBPACK_IMPORTED_MODULE_21__.createPublicClient)({\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_23__.fallback)(chain.rpcUrls.default.http.map((s) => (0,viem__WEBPACK_IMPORTED_MODULE_22__.http)(s))),\n    });\n};\n\nconst logger$k = getLogger();\nconst getCosmosURL = (cosmosURL, kind) => {\n    const u = new URL(cosmosURL);\n    if (kind === 'rpc') {\n        // FIXME: don't hardcode port here\n        u.port = '26650';\n    }\n    return u.toString();\n};\nconst cosmosFeeGrant = async (cosmosURL, vscDomain, address) => {\n    try {\n        await axios__WEBPACK_IMPORTED_MODULE_24__[\"default\"].get(`/cosmos/auth/v1beta1/accounts/${address}`, {\n            baseURL: getCosmosURL(cosmosURL, 'rest'),\n        });\n    }\n    catch (e) {\n        logger$k.error('Requesting a fee grant', e);\n        const response = await vscCreateFeeGrant(vscDomain, address);\n        logger$k.debug('Fee grant response', response.data);\n        return;\n    }\n};\nconst cosmosCreateRFF$1 = async ({ address, cosmosURL, msg, wallet, }) => {\n    const client = await (0,_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.createCosmosClient)(wallet, getCosmosURL(cosmosURL, 'rpc'), {\n        broadcastPollIntervalMs: 250,\n    });\n    try {\n        const res = await client.signAndBroadcast(address, [\n            {\n                typeUrl: '/xarchain.chainabstraction.MsgCreateRequestForFunds',\n                value: msg,\n            },\n        ], {\n            amount: [],\n            gas: 100000n.toString(10),\n        });\n        if ((0,_cosmjs_stargate__WEBPACK_IMPORTED_MODULE_6__.isDeliverTxFailure)(res)) {\n            throw new Error(`Error creating RFF – code=${res.code} log=${res.rawLog ?? 'n/a'}`);\n        }\n        const decoded = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.MsgCreateRequestForFundsResponse.decode(res.msgResponses[0].value);\n        return decoded.id;\n    }\n    finally {\n        client.disconnect();\n    }\n};\nconst cosmosRefundIntent = async (cosmosURL, intentID, wallet) => {\n    const address = (await wallet.getAccounts())[0].address;\n    const client = await (0,_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.createCosmosClient)(wallet, getCosmosURL(cosmosURL, 'rpc'), {\n        broadcastPollIntervalMs: 250,\n    });\n    try {\n        const resp = await client.signAndBroadcast(address, [\n            {\n                typeUrl: '/xarchain.chainabstraction.MsgRefundReq',\n                value: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.MsgRefundReq.create({\n                    creator: address,\n                    rffID: intentID,\n                }),\n            },\n        ], {\n            amount: [],\n            gas: 100000n.toString(10),\n        });\n        logger$k.debug('Refund response', { resp });\n        try {\n            if ((0,_cosmjs_stargate__WEBPACK_IMPORTED_MODULE_6__.isDeliverTxSuccess)(resp)) {\n                const decoded = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.MsgRefundReqResponse.decode(resp.msgResponses[0].value);\n                logger$k.debug('Refund success', { decoded, resp });\n                return resp;\n            }\n            else if (resp.code === 18) {\n                if (resp.rawLog?.includes('RFF already refunded') ||\n                    resp.rawLog?.includes('RFF already filled')) {\n                    return resp;\n                }\n                throw new Error('RFF is not expired yet.');\n            }\n            else {\n                throw new Error('unknown error');\n            }\n        }\n        catch (e) {\n            logger$k.error('Refund failed', e);\n            throw e;\n        }\n    }\n    finally {\n        client.disconnect();\n    }\n};\nconst cosmosCreateDoubleCheckTx$1 = async ({ address, cosmosURL, msg, wallet, }) => {\n    const client = await (0,_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.createCosmosClient)(wallet, getCosmosURL(cosmosURL, 'rpc'), {\n        broadcastPollIntervalMs: 250,\n    });\n    try {\n        logger$k.debug('cosmosCreateDoubleCheckTx', { doubleCheckMsg: msg });\n        const res = await client.signAndBroadcast(address, [\n            {\n                typeUrl: '/xarchain.chainabstraction.MsgDoubleCheckTx',\n                value: msg,\n            },\n        ], {\n            amount: [],\n            gas: 100000n.toString(10),\n        });\n        if ((0,_cosmjs_stargate__WEBPACK_IMPORTED_MODULE_6__.isDeliverTxFailure)(res)) {\n            throw new Error('Error creating MsgDoubleCheckTx');\n        }\n        logger$k.debug('double check response', { doubleCheckTx: res });\n    }\n    finally {\n        client.disconnect();\n    }\n};\nconst decoder = new TextDecoder('utf-8');\nconst cosmosFillCheck = async (intentID, grpcURL, cosmosURL, ac) => {\n    return Promise.any([\n        waitForCosmosFillEvent(intentID, cosmosURL, ac),\n        checkIntentFilled(intentID, grpcURL),\n    ]);\n};\nconst waitForCosmosFillEvent = async (intentID, cosmosURL, ac) => {\n    const u = new URL('/websocket', cosmosURL);\n    u.protocol = 'wss';\n    u.port = '26650';\n    const connection = (0,it_ws__WEBPACK_IMPORTED_MODULE_4__.connect)(u.toString());\n    await connection.connected();\n    ac.signal.addEventListener('abort', () => {\n        connection.close();\n        return Promise.resolve('ok from outside');\n    }, { once: true });\n    const EVENT = 'xarchain.chainabstraction.RFFFulfilledEvent.id';\n    try {\n        connection.socket.send(JSON.stringify({\n            id: '0',\n            jsonrpc: '2.0',\n            method: 'subscribe',\n            params: {\n                query: `${EVENT}='\"${intentID}\"'`,\n            },\n        }));\n        for await (const resp of connection.source) {\n            const decodedResponse = JSON.parse(decoder.decode(resp));\n            if (decodedResponse.result.events &&\n                EVENT in decodedResponse.result.events &&\n                decodedResponse.result.events[EVENT].includes(`\"${intentID}\"`)) {\n                ac.abort();\n                return 'ok';\n            }\n        }\n        throw new Error('waitForCosmosFillEvent: out of loop but no events');\n    }\n    finally {\n        connection.close();\n    }\n};\n\nconst logger$j = getLogger();\nfunction convertAddressByUniverse(input, universe) {\n    const inputIsString = typeof input === 'string';\n    const bytes = inputIsString ? (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(input) : input;\n    if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM) {\n        if (bytes.length === 20) {\n            return inputIsString ? input : bytes;\n        }\n        if (bytes.length === 32) {\n            return inputIsString ? (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(bytes.subarray(12)) : bytes.subarray(12);\n        }\n        throw new Error('invalid length of input');\n    }\n    if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL) {\n        if (bytes.length === 32) {\n            return inputIsString ? input : bytes;\n        }\n        if (bytes.length === 20) {\n            const padded = (0,viem__WEBPACK_IMPORTED_MODULE_16__.pad)(bytes, {\n                dir: 'left',\n                size: 32,\n            });\n            return inputIsString ? (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(padded) : padded;\n        }\n        throw new Error('invalid length of input');\n    }\n    throw new Error('universe is not supported');\n}\nconst minutesToMs = (min) => min * 60 * 1000;\nconst INTENT_KEY = 'xar-sdk-intents';\nconst getIntentKey = (address) => {\n    return `${INTENT_KEY}-${address}`;\n};\nconst storeIntentHashToStore = (address, id, createdAt = Date.now()) => {\n    let intents = [];\n    const fetchedIntents = localStorage.getItem(getIntentKey(address));\n    if (fetchedIntents) {\n        intents = JSON.parse(fetchedIntents) ?? [];\n    }\n    intents.push({ createdAt, id });\n    localStorage.setItem(getIntentKey(address), JSON.stringify(intents));\n};\nconst removeIntentHashFromStore = (address, id) => {\n    let intents = [];\n    const fetchedIntents = localStorage.getItem(getIntentKey(address));\n    if (fetchedIntents) {\n        intents = JSON.parse(fetchedIntents) ?? [];\n    }\n    const oLen = intents.length;\n    intents = intents.filter((h) => h.id !== id.toNumber());\n    if (oLen !== intents.length) {\n        localStorage.setItem(getIntentKey(address), JSON.stringify(intents));\n    }\n};\nconst getExpiredIntents = (address) => {\n    let intents = [];\n    const fetchedIntents = localStorage.getItem(getIntentKey(address));\n    if (fetchedIntents) {\n        intents = JSON.parse(fetchedIntents) ?? [];\n    }\n    logger$j.debug('getExpiredIntents', { intents });\n    const expiredIntents = [];\n    const nonExpiredIntents = [];\n    const TEN_MINUTES_BEFORE = Date.now() - 600000;\n    for (const intent of intents) {\n        if (intent.createdAt < TEN_MINUTES_BEFORE) {\n            expiredIntents.push(intent);\n        }\n        else {\n            nonExpiredIntents.push(intent);\n        }\n    }\n    localStorage.setItem(getIntentKey(address), JSON.stringify(nonExpiredIntents));\n    return expiredIntents;\n};\nconst refundExpiredIntents = async (address, cosmosURL, wallet) => {\n    logger$j.debug('Starting check for expired intents at ', new Date());\n    const expIntents = getExpiredIntents(address);\n    const failedRefunds = [];\n    for (const intent of expIntents) {\n        logger$j.debug(`Starting refund for: ${intent.id}`);\n        try {\n            await cosmosRefundIntent(cosmosURL, intent.id, wallet);\n        }\n        catch (e) {\n            logger$j.debug('Refund failed', e);\n            failedRefunds.push({\n                createdAt: intent.createdAt,\n                id: intent.id,\n            });\n        }\n    }\n    if (failedRefunds.length > 0) {\n        for (const failed of failedRefunds) {\n            storeIntentHashToStore(address, failed.id, failed.createdAt);\n        }\n    }\n};\nconst equalFold = (a, b) => {\n    if (!a || !b) {\n        return false;\n    }\n    return a.toLowerCase() === b.toLowerCase();\n};\nconst createRequestFuelSignature = async (fuelVaultAddress, provider, connector, fuelRFF) => {\n    const account = await connector.currentAccount();\n    if (!account) {\n        throw new Error('Fuel connector is not connected.');\n    }\n    const vault = new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ArcanaVault((0,fuels__WEBPACK_IMPORTED_MODULE_3__.hexlify)(fuelVaultAddress), provider);\n    const { value: hash } = await vault.functions.hash_request(fuelRFF).get();\n    const signature = await connector.signMessage(account, {\n        personalSign: (0,fuels__WEBPACK_IMPORTED_MODULE_3__.arrayify)(hash),\n    });\n    return { requestHash: hash, signature: (0,fuels__WEBPACK_IMPORTED_MODULE_3__.arrayify)(signature) };\n};\nconst getExplorerURL = (baseURL, id) => {\n    return new URL(`/intent/${id.toNumber()}`, baseURL).toString();\n};\n/**\n * @param input\n * @param decimals\n * @returns input / (10**decimals)\n */\nconst divDecimals = (input, decimals) => {\n    return new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](input.toString()).div(decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].pow(10, decimals));\n};\n/**\n * @param input\n * @param decimals\n * @returns BigInt(input * (10**decimals))\n */\nconst mulDecimals = (input, decimals) => {\n    return BigInt(new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](input).mul(decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].pow(10, decimals)).toFixed(0, decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ROUND_CEIL));\n};\nconst convertIntent = (intent, token, chainList) => {\n    console.time('convertIntent');\n    const sources = [];\n    let sourcesTotal = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n    for (const s of intent.sources) {\n        const chainInfo = chainList.getChainByID(s.chainID);\n        if (!chainInfo) {\n            throw new Error('chain not supported');\n        }\n        sources.push({\n            amount: s.amount.toFixed(),\n            chainID: chainInfo.id,\n            chainLogo: chainInfo.custom.icon,\n            chainName: chainInfo.name,\n            contractAddress: s.tokenContract,\n        });\n        sourcesTotal = sourcesTotal.plus(s.amount);\n    }\n    const allSources = [];\n    for (const s of intent.allSources) {\n        const chainInfo = chainList.getChainByID(s.chainID);\n        if (!chainInfo) {\n            throw new Error('chain not supported');\n        }\n        allSources.push({\n            amount: s.amount.toFixed(),\n            chainID: chainInfo.id,\n            chainLogo: chainInfo.custom.icon,\n            chainName: chainInfo.name,\n            contractAddress: s.tokenContract,\n        });\n    }\n    const destinationChainInfo = chainList.getChainByID(intent.destination.chainID);\n    if (!destinationChainInfo) {\n        throw new Error('chain not supported');\n    }\n    const destination = {\n        amount: intent.destination.amount.toFixed(),\n        chainID: intent.destination.chainID,\n        chainLogo: destinationChainInfo?.custom.icon,\n        chainName: destinationChainInfo?.name,\n    };\n    console.timeEnd('convertIntent');\n    return {\n        allSources,\n        destination,\n        fees: {\n            caGas: decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sum(intent.fees.collection, intent.fees.fulfilment).toFixed(token.decimals),\n            gasSupplied: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](intent.fees.gasSupplied).toFixed(),\n            protocol: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](intent.fees.protocol).toFixed(),\n            solver: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](intent.fees.solver).toFixed(),\n            total: decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sum(intent.fees.collection, intent.fees.solver, intent.fees.protocol, intent.fees.fulfilment, intent.fees.gasSupplied).toFixed(token.decimals),\n        },\n        sources,\n        sourcesTotal: sourcesTotal.toFixed(token.decimals),\n        token: {\n            decimals: token.decimals,\n            logo: token.logo,\n            name: token.name,\n            symbol: token.symbol.toUpperCase(),\n        },\n    };\n};\nconst getSupportedChains = (env = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.CORAL) => {\n    const chainList = new ChainList(env);\n    return chainList.chains.map((chain) => {\n        return {\n            id: chain.id,\n            logo: chain.custom.icon,\n            name: chain.name,\n            tokens: [...chain.custom.knownTokens],\n        };\n    });\n};\nconst isArcanaWallet = (p) => {\n    if ('isArcana' in p && p.isArcana) {\n        return true;\n    }\n    return false;\n};\nconst createRequestEVMSignature = async (evmRFF, evmAddress, client) => {\n    logger$j.debug('createReqEVMSignature', { evmRFF });\n    const abi = (0,viem__WEBPACK_IMPORTED_MODULE_25__.getAbiItem)({ abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.EVMVaultABI, name: 'deposit' });\n    const msg = (0,viem__WEBPACK_IMPORTED_MODULE_26__.encodeAbiParameters)(abi.inputs[0].components, [\n        evmRFF.sources,\n        evmRFF.destinationUniverse,\n        evmRFF.destinationChainID,\n        evmRFF.destinations,\n        evmRFF.nonce,\n        evmRFF.expiry,\n        evmRFF.parties,\n    ]);\n    const hash = (0,viem__WEBPACK_IMPORTED_MODULE_27__.keccak256)(msg, 'bytes');\n    const signature = (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(await client.signMessage({\n        account: evmAddress,\n        message: { raw: hash },\n    }));\n    return { requestHash: (0,viem__WEBPACK_IMPORTED_MODULE_28__.hashMessage)({ raw: hash }), signature };\n};\nconst convertGasToToken = (token, oraclePrices, destinationChainID, destinationUniverse, gas) => {\n    if (isNativeAddress$1(destinationUniverse, token.contractAddress)) {\n        return gas;\n    }\n    const gasTokenInUSD = oraclePrices\n        .find((rate) => rate.chainId === destinationChainID &&\n        (equalFold(rate.tokenAddress, ZERO_ADDRESS) ||\n            equalFold(rate.tokenAddress, FUEL_BASE_ASSET_ID)))\n        ?.priceUsd.toFixed() ?? '0';\n    const transferTokenInUSD = oraclePrices\n        .find((rate) => rate.chainId === destinationChainID && equalFold(rate.tokenAddress, token.contractAddress))\n        ?.priceUsd.toFixed();\n    if (!transferTokenInUSD) {\n        throw new Error('could not find token in price oracle');\n    }\n    const usdValue = gas.mul(gasTokenInUSD);\n    const tokenEquivalent = usdValue.div(transferTokenInUSD);\n    return tokenEquivalent.toDP(token.decimals, decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ROUND_CEIL);\n};\nconst evmWaitForFill = async (vaultContractAddress, publicClient, requestHash, intentID, grpcURL, cosmosURL) => {\n    const ac = new AbortController();\n    await Promise.race([\n        waitForIntentFulfilment(publicClient, vaultContractAddress, requestHash, ac),\n        requestTimeout(3, ac),\n        cosmosFillCheck(intentID, grpcURL, cosmosURL, ac),\n    ]);\n};\nconst convertTo32Bytes$1 = (value) => {\n    if (typeof value == 'bigint' || typeof value === 'number') {\n        return (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(value, {\n            size: 32,\n        });\n    }\n    if (typeof value === 'string') {\n        return (0,viem__WEBPACK_IMPORTED_MODULE_16__.pad)((0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(value), {\n            dir: 'left',\n            size: 32,\n        });\n    }\n    throw new Error('invalid type');\n};\nconst convertTo32BytesHex = (value) => {\n    const bytes = convertTo32Bytes$1(value);\n    return (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(bytes);\n};\nconst convertToHexAddressByUniverse = (address, universe) => {\n    if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL) {\n        if (address.length === 32) {\n            return (0,viem__WEBPACK_IMPORTED_MODULE_19__.bytesToHex)(address);\n        }\n        else {\n            throw new Error('fuel: invalid address length');\n        }\n    }\n    else if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM) {\n        if (address.length === 20) {\n            return (0,viem__WEBPACK_IMPORTED_MODULE_19__.bytesToHex)(address);\n        }\n        else if (address.length === 32) {\n            if (!address.subarray(0, 12).every((b) => b === 0)) {\n                throw new Error('evm: non-zero-padded 32-byte address');\n            }\n            return (0,viem__WEBPACK_IMPORTED_MODULE_19__.bytesToHex)(address.subarray(12));\n        }\n        else {\n            throw new Error('evm: invalid address length');\n        }\n    }\n    else {\n        throw new Error('unsupported universe');\n    }\n};\nconst createDepositDoubleCheckTx = (chainID, cosmos, intentID, network) => {\n    const msg = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.MsgDoubleCheckTx.create({\n        creator: cosmos.address,\n        packet: {\n            $case: 'depositPacket',\n            value: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.DepositVEPacket.create({\n                gasRefunded: false,\n                id: intentID,\n            }),\n        },\n        txChainID: chainID,\n        txUniverse: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    });\n    return () => {\n        return cosmosCreateDoubleCheckTx$1({\n            address: cosmos.address,\n            cosmosURL: network.COSMOS_URL,\n            msg,\n            wallet: cosmos.wallet,\n        });\n    };\n};\nconst getSDKConfig = (c) => {\n    const config = {\n        debug: c.debug ?? false,\n        network: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.CORAL,\n    };\n    switch (c.network) {\n        case 'testnet': {\n            config.network = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.FOLLY;\n            break;\n        }\n        case 'mainnet': {\n            config.network = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.CORAL;\n            break;\n        }\n    }\n    return config;\n};\nconst getTxOptions = (options) => {\n    const defaultOptions = {\n        bridge: false,\n        gas: 0n,\n        skipTx: false,\n        sourceChains: [],\n    };\n    if (options?.bridge !== undefined) {\n        defaultOptions.bridge = options.bridge;\n    }\n    if (options?.gas !== undefined) {\n        defaultOptions.gas = options.gas;\n    }\n    if (options?.skipTx !== undefined) {\n        defaultOptions.skipTx = options.skipTx;\n    }\n    if (options?.sourceChains !== undefined) {\n        defaultOptions.sourceChains = options.sourceChains;\n    }\n    return defaultOptions;\n};\nclass UserAsset {\n    get balance() {\n        return this.value.balance;\n    }\n    constructor(value) {\n        this.value = value;\n    }\n    getBalanceOnChain(chainID, tokenAddress) {\n        return (this.value.breakdown.find((b) => {\n            if (tokenAddress) {\n                return b.chain.id === chainID && equalFold(b.contractAddress, tokenAddress);\n            }\n            return b.chain.id === chainID;\n        })?.balance ?? '0');\n    }\n    isDeposit(tokenAddress, universe) {\n        if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM) {\n            return equalFold(tokenAddress, ZERO_ADDRESS);\n        }\n        if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL) {\n            return true;\n        }\n        return false;\n    }\n    iterate(feeStore) {\n        return this.value.breakdown\n            .filter((b) => new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](b.balance).gt(0))\n            .sort((a, b) => {\n            if (a.chain.id === 1) {\n                return 1;\n            }\n            if (b.chain.id === 1) {\n                return -1;\n            }\n            return decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sub(b.balance, a.balance).toNumber();\n        })\n            .map((b) => {\n            let balance = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](b.balance);\n            if (this.isDeposit(b.contractAddress, b.universe)) {\n                const collectionFee = feeStore.calculateCollectionFee({\n                    decimals: b.decimals,\n                    sourceChainID: b.chain.id,\n                    sourceTokenAddress: b.contractAddress,\n                });\n                let estimatedGasForDeposit = collectionFee.mul(b.chain.id === 1 ? 2 : 4);\n                if (b.contractAddress === FUEL_BASE_ASSET_ID && b.chain.id === fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet) {\n                    // Estimating this amount of gas is required for fuel -> vault\n                    estimatedGasForDeposit = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]('0.000_003');\n                }\n                if (new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](b.balance).lessThan(estimatedGasForDeposit)) {\n                    balance = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n                }\n                else {\n                    balance = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](b.balance).minus(estimatedGasForDeposit);\n                }\n            }\n            return {\n                balance,\n                chainID: b.chain.id,\n                decimals: b.decimals,\n                tokenContract: b.contractAddress,\n                universe: b.universe,\n            };\n        });\n    }\n}\nclass UserAssets {\n    constructor(data) {\n        this.data = data;\n    }\n    add(asset) {\n        this.data.push(asset);\n    }\n    find(symbol) {\n        for (const asset of this.data) {\n            if (equalFold(asset.symbol, symbol)) {\n                return new UserAsset(asset);\n            }\n        }\n        throw new Error('Asset is not supported.');\n    }\n    findOnChain(chainID, address) {\n        return this.data.find((asset) => {\n            const index = asset.breakdown.findIndex((b) => b.chain.id === chainID && equalFold(b.contractAddress, address));\n            if (index > -1) {\n                return asset;\n            }\n            return null;\n        });\n    }\n    getAssetDetails(chain, address) {\n        let asset = this.findOnChain(chain.id, address);\n        getLogger().debug('getAssetDetails', {\n            asset,\n            assets: this.data,\n        });\n        const destinationGasBalance = this.getNativeBalance(chain);\n        const chainsWithBalance = this.getChainCountWithBalance(asset);\n        const destinationAssetBalance = asset?.breakdown.find((b) => b.chain.id === chain.id)?.balance ?? '0';\n        return {\n            chainsWithBalance,\n            destinationAssetBalance,\n            destinationGasBalance,\n        };\n    }\n    getBalanceInFiat() {\n        return this.data\n            .reduce((total, asset) => {\n            return total.add(asset.balanceInFiat);\n        }, new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0))\n            .toDecimalPlaces(2)\n            .toNumber();\n    }\n    getChainCountWithBalance(asset) {\n        return asset?.breakdown.filter((b) => new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](b.balance).gt(0)).length ?? 0;\n    }\n    getNativeBalance(chain) {\n        const asset = this.data.find((a) => equalFold(a.symbol, chain.nativeCurrency.symbol));\n        if (asset) {\n            return asset.breakdown.find((b) => b.chain.id === chain.id)?.balance ?? '0';\n        }\n        return '0';\n    }\n    sort() {\n        this.data.forEach((asset) => {\n            asset.breakdown.sort((a, b) => b.balanceInFiat - a.balanceInFiat);\n        });\n        this.data.sort((a, b) => b.balanceInFiat - a.balanceInFiat);\n    }\n    [Symbol.iterator]() {\n        return this.data.values();\n    }\n}\n\nconst logger$i = getLogger();\nlet cosmosQueryClient = null;\nconst getCosmosQueryClient = (grpcURL) => {\n    if (!cosmosQueryClient) {\n        const rpc = new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.GrpcWebImpl(grpcURL, {});\n        cosmosQueryClient = new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.QueryClientImpl(rpc);\n    }\n    return cosmosQueryClient;\n};\nconst PAGE_LIMIT = 100;\nasync function fetchMyIntents(address, grpcURL, page = 1) {\n    try {\n        const response = await getCosmosQueryClient(grpcURL).RequestForFundsByAddress({\n            account: address,\n            pagination: {\n                limit: PAGE_LIMIT,\n                offset: (page - 1) * PAGE_LIMIT,\n                reverse: true,\n            },\n        });\n        return intentTransform(response.requestForFunds);\n    }\n    catch (error) {\n        logger$i.error('Failed to fetch intents', error);\n        throw new Error('Failed to fetch intents');\n    }\n}\nconst intentTransform = (input) => {\n    return input.map((rff) => ({\n        deposited: rff.deposited,\n        destinationChainID: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(rff.destinationChainID),\n        destinations: rff.destinations.map((d) => ({\n            tokenAddress: convertToHexAddressByUniverse(d.tokenAddress, rff.destinationUniverse),\n            value: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToBigInt)(d.value),\n        })),\n        destinationUniverse: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe[rff.destinationUniverse],\n        expiry: rff.expiry.toNumber(),\n        fulfilled: rff.fulfilled,\n        id: rff.id.toNumber(),\n        refunded: rff.refunded,\n        sources: rff.sources.map((s) => ({\n            chainID: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(s.chainID),\n            tokenAddress: convertToHexAddressByUniverse(s.tokenAddress, s.universe),\n            universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe[s.universe],\n            value: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToBigInt)(s.value),\n        })),\n    }));\n};\nasync function fetchProtocolFees(grpcURL) {\n    try {\n        const response = await getCosmosQueryClient(grpcURL).ProtocolFees({\n            Universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL,\n        });\n        return response;\n    }\n    catch (error) {\n        logger$i.error('Failed to fetch protocol fees', error);\n        throw new Error('Failed to fetch protocol fees');\n    }\n}\nasync function fetchSolverData(grpcURL) {\n    try {\n        const response = await getCosmosQueryClient(grpcURL).SolverDataAll({});\n        return response;\n    }\n    catch (error) {\n        logger$i.error('Failed to fetch solver data', error);\n        throw new Error('Failed to fetch solver data');\n    }\n}\nconst fetchPriceOracle = async (grpcURL) => {\n    const data = await getCosmosQueryClient(grpcURL).PriceOracleData({});\n    if (data.PriceOracleData?.priceData?.length) {\n        const oracleRates = data.PriceOracleData?.priceData.map((data) => ({\n            chainId: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(data.chainID),\n            priceUsd: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]((0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(data.price)).div(decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].pow(10, data.decimals)),\n            tokenAddress: convertAddressByUniverse((0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(data.tokenAddress), data.universe),\n            tokensPerUsd: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](1).div(new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]((0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(data.price)).div(decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].pow(10, data.decimals))),\n        }));\n        return oracleRates;\n    }\n    throw new Error('InternalError: No price data found.');\n};\nclass FeeStore {\n    constructor(data) {\n        this.data = data;\n    }\n    calculateCollectionFee({ decimals, sourceChainID, sourceTokenAddress, }) {\n        const collectionFee = this.data.fee.collection.find((f) => {\n            return Number(f.chainID) === sourceChainID && equalFold(f.tokenAddress, sourceTokenAddress);\n        });\n        if (!collectionFee) {\n            return new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n        }\n        return divDecimals(collectionFee.fee ?? 0, decimals);\n    }\n    calculateFulfilmentFee({ decimals, destinationChainID, destinationTokenAddress, }) {\n        const fulfilmentFeeBasis = this.data.fee.fulfilment.find((f) => {\n            return (Number(f.chainID) === destinationChainID &&\n                equalFold(f.tokenAddress, destinationTokenAddress));\n        });\n        if (!fulfilmentFeeBasis) {\n            return new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n        }\n        return new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](fulfilmentFeeBasis.fee ?? 0).div(decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].pow(10, decimals));\n    }\n    calculateProtocolFee(borrow) {\n        const protocolFeeBasis = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.data.fee.protocol.feeBP ?? 0).div(decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].pow(10, 4));\n        return borrow.mul(protocolFeeBasis);\n    }\n    calculateSolverFee({ borrowAmount, decimals, destinationChainID, destinationTokenAddress, sourceChainID, sourceTokenAddress, }) {\n        const solverFeeBP = this.data.solverRoutes.find((f) => {\n            return (Number(f.sourceChainID) === sourceChainID &&\n                Number(f.destinationChainID) === destinationChainID &&\n                equalFold(f.sourceTokenAddress, sourceTokenAddress) &&\n                equalFold(f.destinationTokenAddress, destinationTokenAddress));\n        })?.feeBP ?? 0;\n        return new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](solverFeeBP ?? 0)\n            .div(decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].pow(10, 4))\n            .mul(borrowAmount)\n            .toDP(decimals, decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ROUND_CEIL);\n    }\n}\nconst getFeeStore = async (grpcURL) => {\n    const feeData = {\n        fee: {\n            collection: [],\n            fulfilment: [],\n            protocol: {\n                feeBP: '0',\n            },\n        },\n        solverRoutes: [],\n    };\n    const [p, s] = await Promise.allSettled([fetchProtocolFees(grpcURL), fetchSolverData(grpcURL)]);\n    if (p.status === 'fulfilled') {\n        logger$i.debug('getFeeStore', {\n            collection: p.value.ProtocolFees?.collectionFees,\n            fulfilment: p.value.ProtocolFees?.fulfilmentFees,\n            protocol: p.value.ProtocolFees?.feeBP,\n        });\n        feeData.fee.protocol.feeBP = p.value.ProtocolFees?.feeBP.toString(10) ?? '0';\n        feeData.fee.collection =\n            p.value.ProtocolFees?.collectionFees.map((fee) => {\n                return {\n                    chainID: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(fee.chainID),\n                    fee: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(fee.fee),\n                    tokenAddress: convertAddressByUniverse((0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(fee.tokenAddress), fee.universe),\n                    universe: fee.universe,\n                };\n            }) ?? [];\n        feeData.fee.fulfilment =\n            p.value.ProtocolFees?.fulfilmentFees.map((fee) => {\n                return {\n                    chainID: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(fee.chainID),\n                    fee: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(fee.fee),\n                    tokenAddress: convertAddressByUniverse((0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(fee.tokenAddress), fee.universe),\n                    universe: fee.universe,\n                };\n            }) ?? [];\n    }\n    if (s.status === 'fulfilled') {\n        feeData.solverRoutes =\n            s.value.solverData[0]?.advertisedFees.map((s) => {\n                return {\n                    destinationChainID: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(s.destinationChainID),\n                    destinationTokenAddress: convertAddressByUniverse((0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(s.destinationTokenAddress), s.destinationUniverse),\n                    destinationUniverse: s.destinationUniverse,\n                    feeBP: s.feeBP,\n                    sourceChainID: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(s.sourceChainID),\n                    sourceTokenAddress: convertAddressByUniverse((0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(s.sourceTokenAddress), s.sourceUniverse),\n                    sourceUniverse: s.sourceUniverse,\n                };\n            }) || [];\n    }\n    return new FeeStore(feeData);\n};\nconst getVSCURL = (vscDomain, protocol) => {\n    return `${protocol}://${vscDomain}`;\n};\nlet vscReq = null;\nconst getVscReq = (vscDomain) => {\n    if (!vscReq) {\n        vscReq = axios__WEBPACK_IMPORTED_MODULE_24__[\"default\"].create({\n            baseURL: new URL('/api/v1', getVSCURL(vscDomain, 'https')).toString(),\n            headers: {\n                Accept: 'application/msgpack',\n            },\n            responseType: 'arraybuffer',\n            transformRequest: [\n                function (data, headers) {\n                    if (['get', 'head'].includes(this.method.toLowerCase()))\n                        return;\n                    headers['Content-Type'] = 'application/msgpack';\n                    return (0,msgpackr__WEBPACK_IMPORTED_MODULE_5__.pack)(data);\n                },\n            ],\n            transformResponse: [(data) => (0,msgpackr__WEBPACK_IMPORTED_MODULE_5__.unpack)(data)],\n        });\n    }\n    return vscReq;\n};\nconst getBalancesFromVSC = async (vscDomain, address, namespace = 'ETHEREUM') => {\n    const response = await getVscReq(vscDomain).get(`/get-balance/${namespace}/${address}`);\n    return response.data.balances;\n};\nconst getEVMBalancesForAddress = async (vscDomain, address) => {\n    return getBalancesFromVSC(vscDomain, address);\n};\nconst getFuelBalancesForAddress = async (vscDomain, address) => {\n    return getBalancesFromVSC(vscDomain, address, 'FUEL');\n};\nconst vscCreateFeeGrant = async (vscDomain, address) => {\n    const response = await getVscReq(vscDomain).post(`/create-feegrant`, {\n        cosmos_address: address,\n    });\n    return response;\n};\nconst vscPublishRFF = async (vscDomain, id) => {\n    const response = await getVscReq(vscDomain).post('/publish-rff', {\n        id: id.toNumber(),\n    });\n    logger$i.debug('publishRFF', { response });\n    return { id };\n};\nconst vscCreateSponsoredApprovals = async (vscDomain, input, msd) => {\n    const connection = (0,it_ws__WEBPACK_IMPORTED_MODULE_4__.connect)(new URL('/api/v1/create-sponsored-approvals', getVSCURL(vscDomain, 'wss')).toString());\n    await connection.connected();\n    try {\n        connection.socket.send((0,msgpackr__WEBPACK_IMPORTED_MODULE_5__.pack)(input));\n        let count = 0;\n        for await (const resp of connection.source) {\n            const data = (0,msgpackr__WEBPACK_IMPORTED_MODULE_5__.unpack)(resp);\n            logger$i.debug('vscCreateSponsoredApprovals', { data });\n            if ('errored' in data && data.errored) {\n                throw new Error(data.error);\n            }\n            if ('error' in data && data.error) {\n                throw new Error(data.msg);\n            }\n            if (msd) {\n                msd(ALLOWANCE_APPROVAL_MINED((0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(input[data.part_idx].chain_id)));\n            }\n            count += 1;\n            if (count == input.length) {\n                break;\n            }\n        }\n        return 'ok';\n    }\n    finally {\n        connection.close();\n    }\n};\nconst vscCreateRFF = async (vscDomain, id, msd, expectedCollectionIndexes) => {\n    const receivedCollectionsACKs = [];\n    const connection = (0,it_ws__WEBPACK_IMPORTED_MODULE_4__.connect)(new URL('/api/v1/create-rff', getVSCURL(vscDomain, 'wss')).toString());\n    await connection.connected();\n    logger$i.debug('vscCreateRFF', {\n        expectedCollectionIndexes,\n    });\n    try {\n        connection.socket.send((0,msgpackr__WEBPACK_IMPORTED_MODULE_5__.pack)({ id: id.toNumber() }));\n        for await (const resp of connection.source) {\n            const data = (0,msgpackr__WEBPACK_IMPORTED_MODULE_5__.unpack)(resp);\n            logger$i.debug('vscCreateRFF:response', { data });\n            if (data.status === 255) {\n                if (expectedCollectionIndexes.length === receivedCollectionsACKs.length) {\n                    msd(INTENT_COLLECTION_COMPLETE);\n                    break;\n                }\n                else {\n                    logger$i.debug('(vsc)create-rff:collections failed', {\n                        expectedCollectionIndexes,\n                        receivedCollectionsACKs,\n                    });\n                    throw new Error('(vsc)create-rff: collections failed');\n                }\n            }\n            else if (data.status === 16) {\n                if (expectedCollectionIndexes.includes(data.idx)) {\n                    receivedCollectionsACKs.push(data.idx);\n                }\n                msd(INTENT_COLLECTION(receivedCollectionsACKs.length), {\n                    confirmed: receivedCollectionsACKs.length,\n                    total: expectedCollectionIndexes.length,\n                });\n            }\n            else {\n                if (expectedCollectionIndexes.includes(data.idx)) {\n                    throw new Error(`(vsc)create-rff: ${data.error}`);\n                }\n                else {\n                    logger$i.debug('vscCreateRFF:ExpectedError:ignore', { data });\n                }\n            }\n        }\n    }\n    finally {\n        connection.close();\n    }\n};\nconst checkIntentFilled = async (intentID, grpcURL) => {\n    const response = await getCosmosQueryClient(grpcURL).RequestForFunds({\n        id: intentID,\n    });\n    if (response.requestForFunds?.fulfilled) {\n        return 'ok';\n    }\n    throw new Error('not filled yet');\n};\n\nconst logger$h = getLogger();\nconst getSourcesAndDestinationsForRFF = (intent, chainList, destinationUniverse) => {\n    const sources = [];\n    const universes = new Set();\n    const sourceCounts = {\n        [_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM]: 0,\n        [_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL]: 0,\n        [_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.SOLANA]: 0,\n        [_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.UNRECOGNIZED]: 0,\n    };\n    for (const source of intent.sources) {\n        if (source.chainID == intent.destination.chainID) {\n            continue;\n        }\n        const token = chainList.getTokenByAddress(source.chainID, source.tokenContract);\n        if (!token) {\n            logger$h.error('Token not found', { source });\n            throw new Error('token not found');\n        }\n        sourceCounts[source.universe] += 1;\n        universes.add(source.universe);\n        sources.push({\n            chainID: BigInt(source.chainID),\n            tokenAddress: convertTo32BytesHex(source.tokenContract),\n            universe: source.universe,\n            value: mulDecimals(source.amount, token.decimals),\n        });\n    }\n    universes.add(intent.destination.universe);\n    const destinations = [\n        {\n            tokenAddress: convertTo32BytesHex(intent.destination.tokenContract),\n            universe: intent.destination.universe,\n            value: BigInt(intent.destination.amount\n                .mul(decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].pow(10, intent.destination.decimals))\n                .toFixed(0, decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ROUND_FLOOR)),\n        },\n    ];\n    if (intent.destination.gas != 0n) {\n        if (isNativeAddress$1(intent.destination.universe, intent.destination.tokenContract)) {\n            destinations[0].value = destinations[0].value + intent.destination.gas;\n        }\n        else {\n            destinations.push({\n                tokenAddress: convertTo32BytesHex(destinationUniverse === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL ? FUEL_BASE_ASSET_ID : ZERO_ADDRESS),\n                universe: intent.destination.universe,\n                value: intent.destination.gas,\n            });\n        }\n    }\n    return { destinations, sourceCounts, sources, universes };\n};\nconst createRFFromIntent = async (intent, options, destinationUniverse) => {\n    const { destinations, sources, universes } = getSourcesAndDestinationsForRFF(intent, options.chainList, destinationUniverse);\n    const parties = [];\n    for (const universe of universes) {\n        if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM) {\n            parties.push({\n                address: convertTo32BytesHex(options.evm.address),\n                universe: universe,\n            });\n        }\n        if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL) {\n            parties.push({\n                address: convertTo32BytesHex(options.fuel.address),\n                universe,\n            });\n        }\n    }\n    logger$h.debug('processRFF:1', {\n        destinations,\n        parties,\n        sources,\n        universes,\n    });\n    const omniversalRFF = new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.OmniversalRFF({\n        destinationChainID: convertTo32Bytes$1(intent.destination.chainID),\n        destinations: destinations.map((dest) => ({\n            tokenAddress: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(dest.tokenAddress),\n            value: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(dest.value),\n        })),\n        destinationUniverse: intent.destination.universe,\n        expiry: long__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fromString((BigInt(Date.now() + INTENT_EXPIRY) / 1000n).toString()),\n        nonce: window.crypto.getRandomValues(new Uint8Array(32)),\n        // @ts-ignore\n        signatureData: parties.map((p) => ({\n            address: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(p.address),\n            universe: p.universe,\n        })),\n        // @ts-ignore\n        sources: sources.map((source) => ({\n            chainID: convertTo32Bytes$1(source.chainID),\n            tokenAddress: convertTo32Bytes$1(source.tokenAddress),\n            universe: source.universe,\n            value: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(source.value),\n        })),\n    });\n    const signatureData = [];\n    for (const universe of universes) {\n        if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM) {\n            const { requestHash, signature } = await createRequestEVMSignature(omniversalRFF.asEVMRFF(), options.evm.address, options.evm.client);\n            signatureData.push({\n                address: convertTo32Bytes$1(options.evm.address),\n                requestHash,\n                signature,\n                universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n            });\n        }\n        if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL) {\n            if (!options.fuel?.address || !options.fuel?.provider || !options.fuel?.connector) {\n                logger$h.error('universe has fuel but not expected input', {\n                    fuelInput: options.fuel,\n                });\n                throw new Error('universe has fuel but not expected input');\n            }\n            const { requestHash, signature } = await createRequestFuelSignature(options.chainList.getVaultContractAddress(fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet), options.fuel.provider, options.fuel.connector, omniversalRFF.asFuelRFF());\n            signatureData.push({\n                address: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(options.fuel.address),\n                requestHash,\n                signature,\n                universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL,\n            });\n        }\n    }\n    const msgBasicCosmos = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.MsgCreateRequestForFunds.create({\n        destinationChainID: omniversalRFF.protobufRFF.destinationChainID,\n        destinations: omniversalRFF.protobufRFF.destinations,\n        destinationUniverse: omniversalRFF.protobufRFF.destinationUniverse,\n        expiry: omniversalRFF.protobufRFF.expiry,\n        nonce: omniversalRFF.protobufRFF.nonce,\n        signatureData: signatureData.map((s) => ({\n            address: s.address,\n            signature: s.signature,\n            universe: s.universe,\n        })),\n        sources: omniversalRFF.protobufRFF.sources,\n        user: options.cosmos.address,\n    });\n    logger$h.debug('processRFF:2', {\n        msgBasicCosmos,\n        omniversalRFF,\n        signatureData,\n    });\n    return {\n        msgBasicCosmos,\n        omniversalRFF,\n        signatureData,\n        sources,\n        universes,\n    };\n};\n\nconst KAIA_CHAIN_ID = 8217;\nconst SOPHON_CHAIN_ID = 50104;\nconst HYPEREVM_CHAIN_ID = 0x3e7;\nconst MONAD_TESTNET_CHAIN_ID = 10143;\nconst FUEL_NETWORK_URL = 'https://mainnet.fuel.network/v1/graphql';\nconst SymbolToLogo = {\n    BNB: 'https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png',\n    AVAX: 'https://assets.coingecko.com/coins/images/12559/standard/Avalanche_Circle_RedWhite_Trans.png',\n    ETH: 'https://coin-images.coingecko.com/coins/images/279/large/ethereum.png',\n    KAIA: 'https://assets.coingecko.com/coins/images/39901/large/KAIA.png',\n    MATIC: 'https://coin-images.coingecko.com/coins/images/32440/standard/polygon.png',\n    MON: 'https://assets.coingecko.com/coins/images/38927/large/monad.jpg',\n    POL: 'https://coin-images.coingecko.com/coins/images/32440/standard/polygon.png',\n    SOPH: 'https://assets.coingecko.com/coins/images/38680/large/sophon_logo_200.png',\n    USDC: 'https://coin-images.coingecko.com/coins/images/6319/large/usdc.png',\n    USDT: 'https://coin-images.coingecko.com/coins/images/35023/large/USDT.png',\n    WETH: 'https://coin-images.coingecko.com/coins/images/2518/standard/weth.png',\n    HYPE: 'https://assets.coingecko.com/coins/images/50882/large/hyperliquid.jpg',\n};\nconst FUEL_BASE_ASSET_ID = '0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07';\nconst getLogoFromSymbol = (symbol) => {\n    const logo = SymbolToLogo[symbol];\n    if (!logo) {\n        return '';\n    }\n    return logo;\n};\nconst isNativeAddress$1 = (universe, address) => {\n    if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM) {\n        return address === ZERO_ADDRESS || address === ZERO_ADDRESS_FUEL;\n    }\n    if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL) {\n        return address === FUEL_BASE_ASSET_ID;\n    }\n    // Handle other universes or return false by default\n    return false;\n};\nconst INTENT_EXPIRY = 15 * 60 * 1000;\nconst AaveTokenContracts = {\n    1: {\n        USDC: '0x98C23E9d8f34FEFb1B7BD6a91B7FF122F4e16F5c',\n        USDT: '0x23878914EFE38d27C4D67Ab83ed1b93A74D4086a',\n        WETH: '0x4d5F47FA6A74757f35C14fD3a6Ef8E3C9BC514E8',\n    },\n    10: {\n        USDC: '0x38d693cE1dF5AaDF7bC62595A37D667aD57922e5',\n        USDT: '0x6ab707Aca953eDAeFBc4fD23bA73294241490620',\n        WETH: '0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8',\n    },\n    11155420: {\n        USDC: '0xa818F1B57c201E092C4A2017A91815034326Efd1',\n    },\n    137: {\n        USDC: '0xA4D94019934D8333Ef880ABFFbF2FDd611C762BD',\n        USDT: '0x6ab707Aca953eDAeFBc4fD23bA73294241490620',\n        WETH: '0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8',\n    },\n    42161: {\n        USDC: '0x724dc807b04555b71ed48a6896b6F41593b8C637',\n        USDT: '0x6ab707Aca953eDAeFBc4fD23bA73294241490620',\n        WETH: '0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8',\n    },\n    // Testnet chains\n    421614: {\n        USDC: '0x460b97BD498E1157530AEb3086301d5225b91216',\n    },\n    43114: {\n        USDC: '0x625E7708f30cA75bfd92586e17077590C60eb4cD',\n        USDT: '0x6ab707Aca953eDAeFBc4fD23bA73294241490620',\n        WETH: '0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8',\n    },\n    534352: {\n        USDC: '0x1D738a3436A8C49CefFbaB7fbF04B660fb528CbD',\n        WETH: '0xf301805bE1Df81102C957f6d4Ce29d2B8c056B2a',\n    },\n    56: {\n        USDC: '0x00901a076785e0906d1028c7d6372d247bec7d61',\n        USDT: '0xa9251ca9DE909CB71783723713B21E4233fbf1B1',\n    },\n    59144: {\n        USDC: '0x374D7860c4f2f604De0191298dD393703Cce84f3',\n        USDT: '0x88231dfEC71D4FF5c1e466D08C321944A7adC673',\n        WETH: '0x787897dF92703BB3Fc4d9Ee98e15C0b8130Bf163',\n    },\n    8453: {\n        USDC: '0x4e65fE4DbA92790696d040ac24Aa414708F5c0AB',\n        WETH: '0x7C307e128efA31F540F2E2d976C995E0B65F51F6',\n    },\n    84532: {\n        USDC: '0x10F1A9D11CDf50041f3f8cB7191CBE2f31750ACC',\n        USDT: '0xcE3CAae5Ed17A7AafCEEbc897DE843fA6CC0c018',\n    },\n};\nconst TOKEN_MINTER_CONTRACTS = {\n    534352: {\n        USDT: '0xe2b4795039517653c5ae8c2a9bfdd783b48f447a',\n    },\n    59144: {\n        USDC: '0xA2Ee6Fce4ACB62D95448729cDb781e3BEb62504A',\n        USDT: '0x353012dc4a9A6cF55c941bADC267f82004A8ceB9',\n    },\n    8453: {\n        USDT: '0x4200000000000000000000000000000000000010',\n    },\n};\nconst TOP_OWNER = {\n    [SOPHON_CHAIN_ID]: {\n        ETH: '0x353B35a3362Dff8174cd9679BC4a46365CcD4dA7',\n        USDC: '0x61a87fa6Dd89a23c78F0754EF3372d35ccde5935',\n        USDT: '0x61a87fa6Dd89a23c78F0754EF3372d35ccde5935',\n    },\n};\nconst ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\nconst ZERO_ADDRESS_FUEL = convertTo32BytesHex(ZERO_ADDRESS);\n\nclass ChainList {\n    constructor(env) {\n        switch (env) {\n            case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.CERISE:\n            case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.CORAL:\n                this.chains = MAINNET_CHAINS;\n                break;\n            case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.FOLLY:\n                this.chains = TESTNET_CHAINS;\n                break;\n            case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.JADE:\n                throw new Error('Jade environment not supported yet');\n            default:\n                throw new Error('Unknown environment');\n        }\n        this.vcm = (0,_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.getVaultContractMap)(env);\n    }\n    getChainByID(id) {\n        return this.chains.find((c) => c.id === id);\n    }\n    getNativeToken(chainID) {\n        const chain = this.getChainByID(chainID);\n        if (!chain) {\n            throw new Error('chain not found');\n        }\n        return {\n            contractAddress: ZERO_ADDRESS,\n            decimals: chain.nativeCurrency.decimals,\n            logo: chain.custom.icon,\n            name: chain.nativeCurrency.name,\n            symbol: chain.nativeCurrency.symbol,\n        };\n    }\n    getTokenByAddress(chainID, address) {\n        const chain = this.getChainByID(chainID);\n        if (!chain) {\n            return undefined;\n        }\n        const token = chain.custom.knownTokens.find((t) => equalFold(t.contractAddress, address));\n        if (!token) {\n            if (equalFold(address, ZERO_ADDRESS)) {\n                return this.getNativeToken(chainID);\n            }\n        }\n        return token;\n    }\n    getTokenInfoBySymbol(chainID, symbol) {\n        const chain = this.getChainByID(chainID);\n        if (!chain) {\n            return undefined;\n        }\n        const token = chain.custom.knownTokens.find((t) => equalFold(t.symbol, symbol));\n        if (!token) {\n            if (equalFold(chain.nativeCurrency.symbol, symbol)) {\n                return {\n                    contractAddress: ZERO_ADDRESS,\n                    decimals: chain.nativeCurrency.decimals,\n                    logo: chain.custom.icon,\n                    name: chain.nativeCurrency.name,\n                    symbol: chain.nativeCurrency.symbol,\n                };\n            }\n        }\n        return token;\n    }\n    getVaultContractAddress(chainID) {\n        const chain = this.getChainByID(chainID);\n        if (!chain) {\n            throw new Error('chain not supported');\n        }\n        const omniversalChainID = new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.OmniversalChainID(chain.universe, chainID);\n        const vc = this.vcm.get(omniversalChainID);\n        if (!vc) {\n            throw new Error('vault contract not found');\n        }\n        return convertToHexAddressByUniverse(vc, chain.universe);\n    }\n    getAnkrNameList() {\n        return this.chains.map((c) => c.ankrName).filter((n) => n !== '');\n    }\n}\nconst TESTNET_CHAINS = [\n    {\n        blockExplorers: {\n            default: {\n                name: 'Arbitrum Sepolia Explorer',\n                url: 'https://sepolia.arbiscan.io/',\n            },\n        },\n        custom: {\n            icon: '/images/logos/arbitrum.svg',\n            knownTokens: [\n                {\n                    contractAddress: '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n                {\n                    contractAddress: '0xF954d4A5859b37De88a91bdbb8Ad309056FB04B1',\n                    decimals: 18,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Testing USD',\n                    symbol: 'USDT',\n                },\n            ],\n        },\n        id: 421614,\n        name: 'Arbitrum Sepolia',\n        ankrName: '',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'Ether',\n            symbol: 'ETH',\n        },\n        rpcUrls: {\n            default: {\n                http: ['https://arb-sepolia.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],\n                publicHttp: [\n                    'https://public.stackup.sh/api/v1/node/arbitrum-sepolia',\n                    'https://endpoints.omniatech.io/v1/arbitrum/sepolia/public',\n                    'https://arbitrum-sepolia.gateway.tenderly.co',\n                    'https://api.zan.top/arb-sepolia',\n                ],\n                webSocket: ['wss://arb-sepolia.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'OP Sepolia Explorer',\n                url: 'https://sepolia-optimism.etherscan.io/',\n            },\n        },\n        custom: {\n            icon: '/images/logos/optimism.svg',\n            knownTokens: [\n                {\n                    contractAddress: '0x5fd84259d66Cd46123540766Be93DFE6D43130D7',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n                {\n                    contractAddress: '0x6462693c2F21AC0E517f12641D404895030F7426',\n                    decimals: 18,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Testing USD',\n                    symbol: 'USDT',\n                },\n            ],\n        },\n        id: 11155420,\n        name: 'OP Sepolia',\n        ankrName: '',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'Ether',\n            symbol: 'ETH',\n        },\n        rpcUrls: {\n            default: {\n                http: ['https://opt-sepolia.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],\n                publicHttp: [\n                    'https://api.zan.top/opt-sepolia',\n                    'https://endpoints.omniatech.io/v1/op/sepolia/public',\n                    'https://optimism-sepolia.gateway.tenderly.co',\n                    'https://optimism-sepolia.api.onfinality.io/public',\n                ],\n                webSocket: ['wss://opt-sepolia.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Amoy Polygon Explorer',\n                url: 'https://amoy.polygonscan.com/',\n            },\n        },\n        custom: {\n            icon: '/images/logos/polygon.svg',\n            knownTokens: [\n                {\n                    contractAddress: '0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n            ],\n        },\n        id: 80002,\n        name: 'Amoy',\n        ankrName: '',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'POL',\n            symbol: 'POL',\n        },\n        rpcUrls: {\n            default: {\n                http: ['https://polygon-amoy.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],\n                publicHttp: [\n                    'https://polygon-amoy-bor-rpc.publicnode.com',\n                    'https://rpc-amoy.polygon.technology',\n                    'https://polygon-amoy.gateway.tenderly.co',\n                    'https://polygon-amoy.drpc.org',\n                ],\n                webSocket: ['wss://polygon-amoy.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Basescan',\n                url: 'https://sepolia.basescan.org/',\n            },\n        },\n        custom: {\n            icon: '/images/logos/base.svg',\n            knownTokens: [\n                {\n                    contractAddress: '0x036CbD53842c5426634e7929541eC2318f3dCF7e',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n            ],\n        },\n        id: 84532,\n        name: 'Base Sepolia',\n        ankrName: '',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'Ether',\n            symbol: 'ETH',\n        },\n        rpcUrls: {\n            default: {\n                http: ['https://base-sepolia.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],\n                publicHttp: [\n                    'https://rpc.notadegen.com/base/sepolia',\n                    'https://public.stackup.sh/api/v1/node/base-sepolia',\n                    'https://base-sepolia.gateway.tenderly.co',\n                    'https://base-sepolia.drpc.org',\n                ],\n                webSocket: ['wss://base-sepolia.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Monad Testnet Explorer',\n                url: 'https://testnet.monadexplorer.com',\n            },\n        },\n        custom: {\n            icon: '/images/logos/base.svg',\n            knownTokens: [\n                {\n                    contractAddress: '0xf817257fed379853cDe0fa4F97AB987181B1E5Ea',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n                {\n                    contractAddress: '0x1c56F176D6735888fbB6f8bD9ADAd8Ad7a023a0b',\n                    decimals: 18,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Testing USDT',\n                    symbol: 'USDT',\n                },\n            ],\n        },\n        id: MONAD_TESTNET_CHAIN_ID,\n        name: 'Monad Testnet',\n        ankrName: '',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'Monad',\n            symbol: 'MON',\n        },\n        rpcUrls: {\n            default: {\n                http: ['https://lb.drpc.org/monad-testnet/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE'],\n                publicHttp: ['https://monad-testnet.drpc.org', 'https://rpc.ankr.com/monad_testnet'],\n                webSocket: ['wss://lb.drpc.org/monad-testnet/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE'],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Etherscan Sepolia',\n                url: 'https://sepolia.etherscan.io/',\n            },\n        },\n        custom: {\n            icon: '/images/logos/base.svg',\n            knownTokens: [\n                {\n                    contractAddress: '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n            ],\n        },\n        id: 11155111,\n        name: 'Ethereum Sepolia',\n        ankrName: '',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'Ether',\n            symbol: 'ETH',\n        },\n        rpcUrls: {\n            default: {\n                http: ['https://sepolia.drpc.org'],\n                publicHttp: [\n                    'https://api.zan.top/eth-sepolia',\n                    'https://ethereum-sepolia-public.nodies.app',\n                ],\n                webSocket: ['wss://sepolia.drpc.org'],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n];\nconst MAINNET_CHAINS = [\n    {\n        blockExplorers: {\n            default: {\n                name: 'Fuel Network Explorer',\n                url: 'https://app.fuel.network/',\n            },\n        },\n        custom: {\n            icon: 'https://avatars.githubusercontent.com/u/55993183',\n            knownTokens: [\n                {\n                    contractAddress: FUEL_BASE_ASSET_ID,\n                    decimals: 9,\n                    logo: getLogoFromSymbol('ETH'),\n                    name: 'Ether',\n                    symbol: 'ETH',\n                },\n                {\n                    contractAddress: '0x286c479da40dc953bddc3bb4c453b608bba2e0ac483b077bd475174115395e6b',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n                {\n                    contractAddress: '0xa0265fb5c32f6e8db3197af3c7eb05c48ae373605b8165b6f4a51c5b0ba4812e',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Tether USD',\n                    symbol: 'USDT',\n                },\n            ],\n        },\n        id: fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet,\n        name: 'Fuel Network',\n        ankrName: '',\n        nativeCurrency: {\n            decimals: 9,\n            name: 'Ether',\n            symbol: 'ETH',\n        },\n        rpcUrls: {\n            default: {\n                http: [FUEL_NETWORK_URL],\n                webSocket: [],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Sophscan',\n                url: 'https://sophscan.xyz',\n            },\n        },\n        custom: {\n            icon: 'https://assets.coingecko.com/coins/images/38680/large/sophon_logo_200.png',\n            knownTokens: [\n                {\n                    contractAddress: '0x6386da73545ae4e2b2e0393688fa8b65bb9a7169',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Tether USD',\n                    symbol: 'USDT',\n                },\n                {\n                    contractAddress: '0x9aa0f72392b5784ad86c6f3e899bcc053d00db4f',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n                {\n                    contractAddress: '0x72af9f169b619d85a47dfa8fefbcd39de55c567d',\n                    decimals: 18,\n                    logo: getLogoFromSymbol('ETH'),\n                    name: 'Ether',\n                    symbol: 'ETH',\n                },\n            ],\n        },\n        id: SOPHON_CHAIN_ID,\n        name: 'Sophon',\n        ankrName: '',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'Sophon',\n            symbol: 'SOPH',\n        },\n        rpcUrls: {\n            default: {\n                http: ['https://sophon.gateway.tenderly.co/1d4STFT7zmG0vM5QowibCw'],\n                publicHttp: ['https://rpc-quicknode.sophon.xyz'],\n                webSocket: ['wss://sophon.gateway.tenderly.co/1d4STFT7zmG0vM5QowibCw'],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'KaiaScan',\n                url: 'https://kaiascan.io',\n            },\n        },\n        custom: {\n            icon: 'https://assets.coingecko.com/asset_platforms/images/9672/large/kaia.png',\n            knownTokens: [\n                {\n                    contractAddress: '0xd077a400968890eacc75cdc901f0356c943e4fdb',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Tether USD',\n                    symbol: 'USDT',\n                },\n            ],\n        },\n        id: KAIA_CHAIN_ID,\n        name: 'Kaia Mainnet',\n        ankrName: '',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'Kaia',\n            symbol: 'KAIA',\n        },\n        rpcUrls: {\n            default: {\n                http: [\n                    'https://lb.drpc.org/klaytn/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'https://go.getblock.io/d7094dbd80ab474ba7042603fe912332',\n                ],\n                publicHttp: ['https://go.getblock.io/d7094dbd80ab474ba7042603fe912332'],\n                webSocket: [\n                    'wss://lb.drpc.org/klaytn/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'wss://go.getblock.io/92d6e31d6a47427d9337753b3d48b93e',\n                ],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Etherscan',\n                url: 'https://etherscan.io',\n            },\n        },\n        custom: {\n            icon: 'https://assets.coingecko.com/asset_platforms/images/279/large/ethereum.png?1706606803',\n            knownTokens: [\n                {\n                    contractAddress: '0xdac17f958d2ee523a2206206994597c13d831ec7',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Tether USD',\n                    symbol: 'USDT',\n                },\n                {\n                    contractAddress: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n            ],\n        },\n        id: 1,\n        name: 'Ethereum Mainnet',\n        ankrName: 'eth',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'Ether',\n            symbol: 'ETH',\n        },\n        rpcUrls: {\n            default: {\n                http: [\n                    'https://lb.drpc.org/ethereum/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'https://ethereum.blockpi.network/v1/rpc/743f126e1720d79033ba70a92c9ea3724380d6bd',\n                ],\n                publicHttp: [\n                    'https://cloudflare-eth.com',\n                    'https://1rpc.io/eth',\n                    'https://ethereum-rpc.publicnode.com',\n                    'https://rpc.ankr.com/eth',\n                    'https://ethereum.blockpi.network/v1/rpc/public',\n                    'https://rpc.mevblocker.io',\n                    'https://rpc.mevblocker.io/fast',\n                ],\n                webSocket: [\n                    'wss://lb.drpc.org/ethereum/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'wss://eth.llamarpc.com',\n                ],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Optimism Etherscan',\n                url: 'https://optimistic.etherscan.io',\n            },\n        },\n        custom: {\n            icon: 'https://assets.coingecko.com/coins/images/25244/large/Optimism.png?1696524385',\n            knownTokens: [\n                {\n                    contractAddress: '0x94b008aa00579c1307b0ef2c499ad98a8ce58e58',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Tether USD',\n                    symbol: 'USDT',\n                },\n                {\n                    contractAddress: '0x0b2c639c533813f4aa9d7837caf62653d097ff85',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n            ],\n        },\n        id: 10,\n        name: 'OP Mainnet',\n        ankrName: 'optimism',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'Ether',\n            symbol: 'ETH',\n        },\n        rpcUrls: {\n            default: {\n                http: [\n                    'https://lb.drpc.org/optimism/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'https://opt-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                ],\n                publicHttp: [\n                    'https://mainnet.optimism.io',\n                    'https://1rpc.io/op',\n                    'https://optimism-rpc.publicnode.com',\n                    'https://rpc.ankr.com/optimism',\n                    'https://optimism.blockpi.network/v1/rpc/public',\n                    'https://optimism.llamarpc.com',\n                ],\n                webSocket: [\n                    'wss://lb.drpc.org/optimism/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'wss://opt-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                ],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Polygonscan',\n                url: 'https://polygonscan.com',\n            },\n        },\n        custom: {\n            icon: 'https://assets.coingecko.com/asset_platforms/images/15/large/polygon_pos.png?1706606645',\n            knownTokens: [\n                {\n                    contractAddress: '0xc2132d05d31c914a87c6611c10748aeb04b58e8f',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Tether USD',\n                    symbol: 'USDT',\n                },\n                {\n                    contractAddress: '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n            ],\n        },\n        id: 137,\n        name: 'Polygon PoS',\n        ankrName: 'polygon',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'POL',\n            symbol: 'POL',\n        },\n        rpcUrls: {\n            default: {\n                http: [\n                    'https://lb.drpc.org/polygon/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'https://polygon-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                    'https://polygon.blockpi.network/v1/rpc/07fef5146d885cc0fe07ae6760d486b31e45dcc7',\n                ],\n                publicHttp: [\n                    'https://polygon-rpc.com',\n                    'https://1rpc.io/matic',\n                    'https://polygon-bor-rpc.publicnode.com',\n                    'https://rpc.ankr.com/polygon',\n                    'https://polygon.blockpi.network/v1/rpc/public',\n                    'https://polygon.llamarpc.com',\n                ],\n                webSocket: [\n                    'wss://lb.drpc.org/polygon/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'wss://polygon-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                ],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Basescan',\n                url: 'https://basescan.org',\n            },\n        },\n        custom: {\n            icon: 'https://assets.coingecko.com/asset_platforms/images/131/large/base-network.png?1720533039',\n            knownTokens: [\n                {\n                    contractAddress: '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n            ],\n        },\n        id: 8453,\n        name: 'Base',\n        ankrName: 'base',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'Ether',\n            symbol: 'ETH',\n        },\n        rpcUrls: {\n            default: {\n                http: [\n                    'https://lb.drpc.org/base/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'https://base-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                    'https://base.blockpi.network/v1/rpc/dec2a84b57c7779c8b092a7ca9817e6855aa08c6',\n                ],\n                publicHttp: [\n                    'https://mainnet.base.org',\n                    'https://1rpc.io/base',\n                    'https://base-rpc.publicnode.com',\n                    'https://rpc.ankr.com/base',\n                    'https://base.blockpi.network/v1/rpc/public',\n                    'https://base.llamarpc.com',\n                ],\n                webSocket: [\n                    'wss://lb.drpc.org/base/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'wss://base-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                ],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Arbiscan',\n                url: 'https://arbiscan.io',\n            },\n        },\n        custom: {\n            icon: 'https://assets.coingecko.com/coins/images/16547/large/arb.jpg?1721358242',\n            knownTokens: [\n                {\n                    contractAddress: '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Tether USD',\n                    symbol: 'USDT',\n                },\n                {\n                    contractAddress: '0xaf88d065e77c8cc2239327c5edb3a432268e5831',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n            ],\n        },\n        id: 42161,\n        name: 'Arbitrum One',\n        ankrName: 'arbitrum',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'ETH',\n            symbol: 'ETH',\n        },\n        rpcUrls: {\n            default: {\n                http: [\n                    'https://lb.drpc.org/arbitrum/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'https://arb-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                    'https://arbitrum.blockpi.network/v1/rpc/a8ccd43cdc840c2b2d20c24a058514a21302376d',\n                ],\n                publicHttp: [\n                    'https://arb1.arbitrum.io/rpc',\n                    'https://1rpc.io/arb',\n                    'https://arbitrum-one-rpc.publicnode.com',\n                    'https://rpc.ankr.com/arbitrum',\n                    'https://arbitrum.blockpi.network/v1/rpc/public',\n                ],\n                webSocket: [\n                    'wss://lb.drpc.org/arbitrum/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'wss://arb-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                ],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Scrollscan',\n                url: 'https://scrollscan.com',\n            },\n        },\n        custom: {\n            icon: 'https://assets.coingecko.com/asset_platforms/images/153/large/scroll.jpeg?1706606782',\n            knownTokens: [\n                {\n                    contractAddress: '0xf55bec9cafdbe8730f096aa55dad6d22d44099df',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Tether USD',\n                    symbol: 'USDT',\n                },\n                {\n                    contractAddress: '0x06efdbff2a14a7c8e15944d1f4a48f9f95f663a4',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n            ],\n        },\n        id: 534352,\n        name: 'Scroll',\n        ankrName: 'scroll',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'Ether',\n            symbol: 'ETH',\n        },\n        rpcUrls: {\n            default: {\n                http: [\n                    'https://lb.drpc.org/scroll/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'https://scroll-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                ],\n                publicHttp: [\n                    'https://rpc.scroll.io',\n                    'https://1rpc.io/scroll',\n                    'https://rpc.ankr.com/scroll',\n                    'https://scroll-mainnet.public.blastapi.io',\n                    // \"https://scroll.blockpi.network/v1/rpc/public\",\n                    'https://scroll-rpc.publicnode.com',\n                ],\n                webSocket: [\n                    'wss://lb.drpc.org/scroll/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'wss://scroll-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                ],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Snowscan',\n                url: 'https://snowscan.xyz',\n            },\n        },\n        custom: {\n            icon: 'https://assets.coingecko.com/asset_platforms/images/12/large/avalanche.png',\n            knownTokens: [\n                {\n                    contractAddress: '0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n                {\n                    contractAddress: '0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Tether USD',\n                    symbol: 'USDT',\n                },\n            ],\n        },\n        id: 43114,\n        ankrName: 'avalanche',\n        name: 'Avalanche C-Chain',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'AVAX',\n            symbol: 'AVAX',\n        },\n        rpcUrls: {\n            default: {\n                http: [\n                    'https://lb.drpc.org/avalanche/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'https://avax-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                ],\n                publicHttp: [\n                    'https://1rpc.io/avax/c',\n                    'https://avalanche-c-chain-rpc.publicnode.com',\n                    'https://ava-mainnet.public.blastapi.io/ext/bc/C/rpc',\n                    'https://rpc.ankr.com/avalanche',\n                    'https://avalanche-mainnet.gateway.tenderly.co',\n                ],\n                webSocket: [\n                    'wss://lb.drpc.org/avalanche/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'wss://avax-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                ],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'BscScan',\n                url: 'https://bscscan.com',\n            },\n        },\n        custom: {\n            icon: 'https://assets.coingecko.com/asset_platforms/images/1/large/bnb_smart_chain.png',\n            knownTokens: [\n                {\n                    contractAddress: '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d',\n                    decimals: 18,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n                {\n                    contractAddress: '0x55d398326f99059fF775485246999027B3197955',\n                    decimals: 18,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Tether USD',\n                    symbol: 'USDT',\n                },\n                {\n                    contractAddress: '0x2170Ed0880ac9A755fd29B2688956BD959F933F8',\n                    decimals: 18,\n                    logo: getLogoFromSymbol('ETH'),\n                    name: 'Ether',\n                    symbol: 'ETH',\n                },\n            ],\n        },\n        id: 0x38,\n        name: 'BNB Smart Chain',\n        ankrName: 'bsc',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'BNB',\n            symbol: 'BNB',\n        },\n        rpcUrls: {\n            default: {\n                http: [\n                    'https://lb.drpc.org/bsc/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'https://bnb-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                ],\n                publicHttp: [\n                    'https://1rpc.io/bnb',\n                    'https://bsc-rpc.publicnode.com',\n                    'https://bsc-mainnet.public.blastapi.io',\n                    'https://bsc.drpc.org',\n                    'https://bsc.blockrazor.xyz',\n                ],\n                webSocket: [\n                    'wss://lb.drpc.org/bsc/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                    'wss://bnb-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',\n                ],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    {\n        blockExplorers: {\n            default: {\n                name: 'Hyperscan',\n                url: 'https://hyperscan.com',\n            },\n        },\n        custom: {\n            icon: 'https://assets.coingecko.com/asset_platforms/images/243/large/hyperliquid.png',\n            knownTokens: [\n                {\n                    contractAddress: '0xB8CE59FC3717ada4C02eaDF9682A9e934F625ebb',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDT'),\n                    name: 'Tether USD',\n                    symbol: 'USDT',\n                },\n                {\n                    contractAddress: '0xb88339CB7199b77E23DB6E890353E22632Ba630f',\n                    decimals: 6,\n                    logo: getLogoFromSymbol('USDC'),\n                    name: 'USD Coin',\n                    symbol: 'USDC',\n                },\n            ],\n        },\n        id: HYPEREVM_CHAIN_ID,\n        ankrName: '',\n        name: 'HyperEVM',\n        nativeCurrency: {\n            decimals: 18,\n            name: 'HYPE',\n            symbol: 'HYPE',\n        },\n        rpcUrls: {\n            default: {\n                http: [\n                    // Not supported by Alchemy\n                    'https://hyperliquid.drpc.org',\n                    'https://lb.drpc.org/hyperliquid/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',\n                ],\n                publicHttp: [\n                    'https://hyperliquid-json-rpc.stakely.io',\n                    'https://rpc.hyperlend.finance',\n                    'https://rpc.hypurrscan.io',\n                ],\n                webSocket: ['wss://hyperliquid.drpc.org'],\n            },\n        },\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n];\n\n// Testnet with mainnet tokens\nconst CORAL_CONFIG = {\n    COSMOS_URL: 'https://cosmos01-testnet.arcana.network',\n    EXPLORER_URL: 'https://explorer.nexus.availproject.org',\n    FAUCET_URL: 'https://gateway001-testnet.arcana.network/api/v1/faucet',\n    GRPC_URL: 'https://grpcproxy-testnet.arcana.network',\n    NETWORK_HINT: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.CORAL,\n    SIMULATION_URL: 'https://ca-sim-testnet.arcana.network',\n    VSC_DOMAIN: 'vsc1-testnet.arcana.network',\n};\n// Dev with mainnet tokens\nconst CERISE_CONFIG = {\n    COSMOS_URL: 'https://cosmos01-dev.arcana.network',\n    EXPLORER_URL: 'https://explorer.nexus-cerise.availproject.org',\n    FAUCET_URL: 'https://gateway-dev.arcana.network/api/v1/faucet',\n    GRPC_URL: 'https://mimosa-dash-grpc.arcana.network',\n    NETWORK_HINT: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.CERISE,\n    SIMULATION_URL: 'https://ca-sim-dev.arcana.network',\n    VSC_DOMAIN: 'mimosa-dash-vsc.arcana.network',\n};\n// Dev with testnet tokens\nconst FOLLY_CONFIG = {\n    COSMOS_URL: 'https://cosmos04-dev.arcana.network',\n    EXPLORER_URL: 'https://explorer.nexus-folly.availproject.org',\n    FAUCET_URL: 'https://gateway-dev.arcana.network/api/v1/faucet',\n    GRPC_URL: 'https://grpc-folly.arcana.network',\n    NETWORK_HINT: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.FOLLY,\n    SIMULATION_URL: 'https://ca-sim-dev.arcana.network',\n    VSC_DOMAIN: 'vsc1-folly.arcana.network',\n};\nconst isNetworkConfig = (config) => {\n    if (typeof config !== 'object') {\n        return false;\n    }\n    if (!(config.VSC_DOMAIN &&\n        config.COSMOS_URL &&\n        config.SIMULATION_URL &&\n        config.FAUCET_URL &&\n        config.EXPLORER_URL &&\n        config.GRPC_URL)) {\n        return false;\n    }\n    if (config.NETWORK_HINT === undefined) {\n        return false;\n    }\n    return true;\n};\nconst getNetworkConfig = (network) => {\n    if (isNetworkConfig(network)) {\n        return network;\n    }\n    switch (network) {\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.CERISE:\n            return CERISE_CONFIG;\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.FOLLY:\n            return FOLLY_CONFIG;\n        default:\n            return CORAL_CONFIG;\n    }\n};\n\nclass AllowanceQuery {\n    constructor(walletClient, networkConfig, chainList) {\n        this.walletClient = walletClient;\n        this.networkConfig = networkConfig;\n        this.chainList = chainList;\n    }\n    async get(input) {\n        const addresses = await this.walletClient.getAddresses();\n        if (!addresses.length) {\n            throw new Error('No account connected with wallet client');\n        }\n        const address = addresses[0];\n        const tokens = input.tokens ?? ['USDT', 'USDC'];\n        const chainID = input.chainID ? [input.chainID] : this.chainList.chains.map((c) => c.id);\n        const inp = [];\n        const out = [];\n        for (const c of chainID) {\n            for (const t of tokens) {\n                const token = this.chainList.getTokenInfoBySymbol(c, t);\n                if (token) {\n                    const chain = this.chainList.getChainByID(c);\n                    if (!chain) {\n                        throw new Error('chain not supported');\n                    }\n                    inp.push(getAllowance(chain, address, token.contractAddress, this.chainList).then((val) => {\n                        out.push({\n                            allowance: val,\n                            chainID: c,\n                            token: t,\n                        });\n                    }));\n                }\n            }\n        }\n        return Promise.all(inp).then(() => out);\n    }\n    async revoke(input) {\n        await this.set({ ...input, amount: 0n });\n    }\n    async set(input) {\n        if (input.tokens == null) {\n            throw new Error('missing token param');\n        }\n        if (input.amount == null) {\n            throw new Error('missing amount param');\n        }\n        if (input.chainID == null) {\n            throw new Error('missing chainID param');\n        }\n        const chain = this.chainList.getChainByID(input.chainID);\n        if (!chain) {\n            throw new Error('chain not supported');\n        }\n        let chainID = await this.walletClient.getChainId();\n        if (input.chainID && input.chainID !== chainID) {\n            await switchChain(this.walletClient, chain);\n            chainID = input.chainID;\n        }\n        const tokenAddresses = [];\n        for (const t of input.tokens) {\n            const token = chain.custom.knownTokens.find((kt) => equalFold(kt.symbol, t));\n            if (token) {\n                tokenAddresses.push(token.contractAddress);\n            }\n        }\n        if (!tokenAddresses.length) {\n            throw new Error('None of the supplied token symbols are recognised on this chain');\n        }\n        await setAllowances(tokenAddresses, this.walletClient, this.networkConfig, this.chainList, chain, input.amount);\n    }\n}\n\nclass BridgeQuery {\n    constructor(input, init, switchChain, createEVMHandler, createFuelHandler, address, chainList, fuelAccount) {\n        this.input = input;\n        this.init = init;\n        this.switchChain = switchChain;\n        this.createEVMHandler = createEVMHandler;\n        this.createFuelHandler = createFuelHandler;\n        this.address = address;\n        this.chainList = chainList;\n        this.fuelAccount = fuelAccount;\n        this.handler = null;\n        this.exec = () => {\n            if (!this.handler) {\n                throw new Error('ca not applicable');\n            }\n            return this.handler.process();\n        };\n        this.simulate = async () => {\n            if (!this.handler) {\n                throw new Error('ca not applicable');\n            }\n            const response = await this.handler.buildIntent(this.input.sourceChains ?? []);\n            if (!response) {\n                throw new Error('ca not applicable');\n            }\n            return {\n                intent: convertIntent(response.intent, response.token, this.chainList),\n                token: response.token,\n            };\n        };\n    }\n    async initHandler() {\n        if (!this.handler) {\n            const input = this.input;\n            await this.init();\n            if (input.token && input.amount && input.chainId) {\n                const token = this.chainList.getTokenInfoBySymbol(input.chainId, input.token);\n                if (!token) {\n                    throw new Error('Token not supported on this chain.');\n                }\n                const bridgeAmount = mulDecimals(input.amount, token.decimals);\n                if (input.chainId === fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet) {\n                    if (this.fuelAccount) {\n                        const tx = await this.fuelAccount.createTransfer(\n                        // Random address, since bridge won't call the final tx\n                        '0xE78655DfAd552fc3658c01bfb427b9EAb0c628F54e60b54fDA16c95aaAdE797A', (0,fuels__WEBPACK_IMPORTED_MODULE_3__.bn)(bridgeAmount.toString()), token.contractAddress);\n                        const handlerResponse = await this.createFuelHandler(tx, {\n                            bridge: true,\n                            gas: input.gas ?? 0n,\n                            skipTx: true,\n                        });\n                        this.handler = handlerResponse?.handler;\n                    }\n                    else {\n                        throw new Error('Fuel connector is not set');\n                    }\n                }\n                else {\n                    await this.switchChain(input.chainId);\n                    const p = {\n                        from: this.address,\n                        to: this.address,\n                    };\n                    const isNative = equalFold(token.contractAddress, ZERO_ADDRESS);\n                    if (isNative) {\n                        p.value = (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(bridgeAmount);\n                        input.gas = 0n;\n                    }\n                    else {\n                        p.to = token.contractAddress;\n                        p.data = (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n                            abi: ABI,\n                            args: [this.address, BigInt(bridgeAmount.toString())],\n                            functionName: 'transfer',\n                        });\n                    }\n                    const handlerResponse = await this.createEVMHandler(p, {\n                        bridge: true,\n                        gas: input.gas ?? 0n,\n                        skipTx: true,\n                        sourceChains: input.sourceChains,\n                    });\n                    this.handler = handlerResponse?.handler;\n                }\n                return;\n            }\n            throw new Error('bridge: missing params');\n        }\n    }\n}\n\nconst logger$g = getLogger();\nclass TransferQuery {\n    constructor(input, init, switchChain, createEVMHandler, createFuelHandler, evmAddress, chainList, fuelAccount) {\n        this.input = input;\n        this.init = init;\n        this.switchChain = switchChain;\n        this.createEVMHandler = createEVMHandler;\n        this.createFuelHandler = createFuelHandler;\n        this.evmAddress = evmAddress;\n        this.chainList = chainList;\n        this.fuelAccount = fuelAccount;\n        this.handlerResponse = null;\n        this.exec = async () => {\n            if (!this.handlerResponse?.handler) {\n                throw new Error('ca not applicable');\n            }\n            let explorerURL = '';\n            const result = await this.handlerResponse.handler.process();\n            if (result) {\n                explorerURL = result.explorerURL;\n            }\n            logger$g.debug('TransferQuery:Exec', {\n                state: 'processing completed, going to processTx()',\n            });\n            const hash = (await this.handlerResponse.processTx());\n            return {\n                hash,\n                explorerURL,\n            };\n        };\n        this.simulate = async () => {\n            if (!this.handlerResponse?.handler) {\n                throw new Error('ca not applicable');\n            }\n            const response = await this.handlerResponse.handler.buildIntent(this.input.sourceChains ?? []);\n            if (!response) {\n                throw new Error('ca not applicable');\n            }\n            return {\n                intent: convertIntent(response.intent, response.token, this.chainList),\n                token: response.token,\n            };\n        };\n    }\n    async initHandler() {\n        if (!this.handlerResponse) {\n            const input = this.input;\n            await this.init();\n            logger$g.debug('SendQueryBuilder.exec', {\n                c: input.chainId,\n                p: input,\n            });\n            if (input.to && input.amount !== undefined && input.token && input.chainId) {\n                const tokenInfo = this.chainList.getTokenInfoBySymbol(input.chainId, input.token);\n                if (!tokenInfo) {\n                    throw new Error('Token not supported on this chain.');\n                }\n                const amount = mulDecimals(input.amount, tokenInfo.decimals);\n                logger$g.debug('transfer:2', { amount, tokenInfo });\n                if (input.chainId === fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet) {\n                    if (this.fuelAccount) {\n                        const tx = await this.fuelAccount.createTransfer(input.to, (0,fuels__WEBPACK_IMPORTED_MODULE_3__.bn)(amount.toString()), tokenInfo.contractAddress);\n                        this.handlerResponse = await this.createFuelHandler(tx, {\n                            bridge: false,\n                            gas: 0n,\n                            skipTx: false,\n                        });\n                    }\n                    else {\n                        throw new Error('Fuel connector is not set');\n                    }\n                }\n                else {\n                    await this.switchChain(input.chainId);\n                    const isNative = equalFold(tokenInfo.contractAddress, ZERO_ADDRESS);\n                    const p = {\n                        from: this.evmAddress,\n                        to: input.to,\n                    };\n                    if (isNative) {\n                        p.value = `0x${amount.toString(16)}`;\n                    }\n                    else {\n                        p.to = tokenInfo.contractAddress;\n                        p.data = (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n                            abi: ABI,\n                            args: [input.to, amount],\n                            functionName: 'transfer',\n                        });\n                    }\n                    this.handlerResponse = await this.createEVMHandler(p, {\n                        bridge: false,\n                        gas: 0n,\n                        skipTx: false,\n                        sourceChains: input.sourceChains,\n                    });\n                }\n                return;\n            }\n            throw new Error('transfer: missing params');\n        }\n    }\n}\n\nconst logger$f = getLogger();\nconst simulate = async (tx, address, provider, chainList) => {\n    const outputs = tx.outputs?.filter((o) => o.type === fuels__WEBPACK_IMPORTED_MODULE_3__.OutputType.Coin) ?? [];\n    const tokens = outputs\n        .map((o) => {\n        const token = chainList.getTokenByAddress(fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet, o.assetId);\n        if (!token)\n            return null;\n        return {\n            from: (0,fuels__WEBPACK_IMPORTED_MODULE_3__.hexlify)(address).toLowerCase(),\n            to: (0,fuels__WEBPACK_IMPORTED_MODULE_3__.hexlify)(o.to).toLowerCase(),\n            token: {\n                address: (0,fuels__WEBPACK_IMPORTED_MODULE_3__.hexlify)(o.assetId),\n                amount: divDecimals(o.amount.toString(), token.decimals),\n                decimals: token.decimals,\n                logo: token.logo,\n                name: token.name,\n                symbol: token.symbol,\n            },\n        };\n    })\n        .filter((o) => !!o)\n        .reduce((acc, o) => {\n        const existingCoin = acc.find((a) => o.from === a.from && o.token.address === a.token.contractAddress);\n        if (existingCoin) {\n            existingCoin.token.amount = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](existingCoin.token.amount).plus(o.token.amount);\n            return acc;\n        }\n        acc.push({\n            from: o.from,\n            to: o.to,\n            token: {\n                amount: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](o.token.amount),\n                contractAddress: o.token.address,\n                decimals: o.token.decimals,\n                logo: o.token.logo,\n                name: o.token.name,\n                symbol: o.token.symbol,\n            },\n        });\n        return acc;\n    }, [])\n        .sort((a, b) => (new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](a.token.amount).lessThan(b.token.amount) ? 1 : -1));\n    const { assembledRequest } = await provider.assembleTx({\n        feePayerAccount: new fuels__WEBPACK_IMPORTED_MODULE_3__.Account(address),\n        request: tx,\n    });\n    logger$f.debug('Fuel Simulate: mappedOutputsToInputs', {\n        assembledRequest,\n    });\n    const coin = tokens?.length ? tokens[0] : null;\n    if (!coin) {\n        return;\n    }\n    logger$f.debug('FuelSimulate', {\n        amount: coin.token.amount.toFixed(),\n        coin: coin,\n    });\n    const { amount, ...token } = coin.token;\n    return {\n        amount: amount,\n        gas: BigInt(0),\n        gasFee: divDecimals(BigInt(assembledRequest.maxFee.toString()) * 2n, 9),\n        token: { ...token, type: 'src20' },\n    };\n};\nconst fixTx = async (address, tx, provider) => {\n    delete tx.inputs;\n    const outputQuantities = tx.outputs\n        ?.filter((o) => o.type === fuels__WEBPACK_IMPORTED_MODULE_3__.OutputType.Coin)\n        .map(({ amount, assetId }) => ({\n        amount: (0,fuels__WEBPACK_IMPORTED_MODULE_3__.bn)(amount),\n        assetId: String(assetId),\n    }));\n    const aResponse = await provider.assembleTx({\n        accountCoinQuantities: outputQuantities,\n        estimatePredicates: true,\n        feePayerAccount: new fuels__WEBPACK_IMPORTED_MODULE_3__.Account(address),\n        // @ts-ignore\n        request: tx,\n    });\n    logger$f.debug('fixTx:sendTransaction:3', {\n        assembleTxResponse: aResponse,\n        request: tx,\n    });\n    return aResponse.assembledRequest;\n};\nconst isFuelNativeTransfer = (tx) => {\n    return tx.outputs?.every((o) => {\n        return 'assetId' in o && o.assetId === FUEL_BASE_ASSET_ID;\n    });\n};\n\nconst logger$e = getLogger();\nconst getFuelProvider = (getBalances, address, chain) => {\n    return new (class Provider$1 extends fuels__WEBPACK_IMPORTED_MODULE_3__.Provider {\n        constructor(url, options) {\n            super(url, { ...options, resourceCacheTTL: -1 });\n        }\n        async assembleTx(params) {\n            const { request } = params;\n            logger$e.debug('ffProvider', {\n                request,\n            });\n            const addr = new fuels__WEBPACK_IMPORTED_MODULE_3__.Address(address);\n            const balances = await getBalances();\n            const assetIdsOnFuel = chain.custom.knownTokens.map((c) => c.contractAddress);\n            const outputAssetList = request.outputs.filter((o) => o.type === fuels__WEBPACK_IMPORTED_MODULE_3__.OutputType.Coin);\n            const allAssetSupported = outputAssetList.every((a) => assetIdsOnFuel.includes((0,fuels__WEBPACK_IMPORTED_MODULE_3__.hexlify)(a.assetId)));\n            logger$e.debug('FuelProvide:1', {\n                allAssetSupported,\n                assetIdsOnFuel,\n                outputAssetList,\n            });\n            if (!allAssetSupported) {\n                return super.assembleTx({\n                    ...params,\n                    feePayerAccount: new fuels__WEBPACK_IMPORTED_MODULE_3__.Account(addr),\n                    request,\n                });\n            }\n            const al = [];\n            for (const a of assetIdsOnFuel) {\n                if (!outputAssetList.map((al) => al.assetId).includes(a) && a !== FUEL_BASE_ASSET_ID) {\n                    continue;\n                }\n                const asset = balances.find((asset) => asset.breakdown.find((b) => equalFold(b.contractAddress, (0,fuels__WEBPACK_IMPORTED_MODULE_3__.hexlify)(a)) && b.universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL));\n                const chainAsset = asset?.breakdown.find((b) => equalFold(b.contractAddress, (0,fuels__WEBPACK_IMPORTED_MODULE_3__.hexlify)(a)) && b.universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL);\n                logger$e.debug('FuelProvider:2', {\n                    asset,\n                    chainAsset,\n                });\n                if (asset && chainAsset) {\n                    const decimals = equalFold(FUEL_BASE_ASSET_ID, chainAsset.contractAddress)\n                        ? 9\n                        : asset.decimals;\n                    const amount = new fuels__WEBPACK_IMPORTED_MODULE_3__.BN(mulDecimals(asset.balance, decimals).toString());\n                    logger$e.debug('FuelProvider:3', {\n                        amount,\n                        assetId: (0,fuels__WEBPACK_IMPORTED_MODULE_3__.hexlify)(a),\n                    });\n                    al.push({\n                        amount,\n                        assetId: (0,fuels__WEBPACK_IMPORTED_MODULE_3__.hexlify)(a),\n                    });\n                }\n            }\n            request.addResources(generateFakeResources(al, new fuels__WEBPACK_IMPORTED_MODULE_3__.Address(address)));\n            const { accountCoinQuantities, ...rest } = params;\n            logger$e.debug('FuelProvider:4', {\n                accountCoinQuantities,\n                params: { ...params },\n                request,\n                rest,\n            });\n            const response = await super.assembleTx({\n                ...rest,\n                request,\n            });\n            logger$e.debug('FuelProvider:4', {\n                accountCoinQuantities,\n                params: { ...params },\n                request,\n                response,\n            });\n            return response;\n        }\n    })(FUEL_NETWORK_URL);\n};\nconst generateFakeResources = (coins, address) => {\n    return coins.map((coin) => ({\n        blockCreated: (0,fuels__WEBPACK_IMPORTED_MODULE_3__.bn)(1),\n        id: (0,fuels__WEBPACK_IMPORTED_MODULE_3__.hexlify)((0,fuels__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(fuels__WEBPACK_IMPORTED_MODULE_3__.UTXO_ID_LEN)),\n        owner: address,\n        txCreatedIdx: (0,fuels__WEBPACK_IMPORTED_MODULE_3__.bn)(1),\n        ...coin,\n    }));\n};\n\nconst isERC20TokenTransfer = (input) => {\n    if (input.evm.tx) {\n        const { data, to } = input.evm.tx;\n        if (!data) {\n            return false;\n        }\n        const token = input.chainList.getTokenByAddress(input.chain.id, to);\n        const isTokenSupported = !!token;\n        if (isTokenSupported && data) {\n            const { functionName } = getTokenTxFunction(data);\n            if (functionName === 'transfer') {\n                return true;\n            }\n        }\n    }\n    return false;\n};\nconst isNativeTokenTransfer = (input) => {\n    if (input.evm.tx) {\n        const { value } = input.evm.tx;\n        if (!value)\n            return false;\n        try {\n            return BigInt(value) > 0n;\n        }\n        catch {\n            return false;\n        }\n    }\n    return false;\n};\n\nconst simulateTransaction = async (chainID, simulations, baseURL) => {\n    const url = new URL(\"/simulate\", baseURL).toString();\n    return await axios__WEBPACK_IMPORTED_MODULE_24__[\"default\"].post(url, {\n        chainID,\n        simulations,\n    }, {\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n    });\n};\n\nconst EADDRESS = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';\nconst SWEEPER_ADDRESS = '0x0000000000296e7a886f40f7bc60D2E3653216a6';\nconst ZERO_BYTES_32 = new Uint8Array(32);\nconst ZERO_BYTES_20 = new Uint8Array(20);\nconst CALIBUR_ADDRESS = '0x00000000557A0daF2659cbb6A45f2beB6081e6AE';\nconst CALIBUR_EIP712 = {\n    name: 'Calibur',\n    salt: convertTo32BytesHex(CALIBUR_ADDRESS),\n    version: '1.0.0',\n};\nconst LIFI_API_KEY = 'bcb7981d-ea26-4adf-8926-95d3adf4c001.23bcc0d7-7df7-4c86-bb37-ae9ffc25bb95';\nconst BEBOP_API_KEY = 'ae262dbf-e4d0-4b66-aaec-57a1b4581440';\n\nvar CaliburABI = [\n    {\n        inputs: [\n            {\n                components: [\n                    {\n                        components: [\n                            {\n                                components: [\n                                    {\n                                        internalType: 'address',\n                                        name: 'to',\n                                        type: 'address',\n                                    },\n                                    {\n                                        internalType: 'uint256',\n                                        name: 'value',\n                                        type: 'uint256',\n                                    },\n                                    {\n                                        internalType: 'bytes',\n                                        name: 'data',\n                                        type: 'bytes',\n                                    },\n                                ],\n                                internalType: 'struct Call[]',\n                                name: 'calls',\n                                type: 'tuple[]',\n                            },\n                            {\n                                internalType: 'bool',\n                                name: 'revertOnFailure',\n                                type: 'bool',\n                            },\n                        ],\n                        internalType: 'struct BatchedCall',\n                        name: 'batchedCall',\n                        type: 'tuple',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'nonce',\n                        type: 'uint256',\n                    },\n                    {\n                        internalType: 'bytes32',\n                        name: 'keyHash',\n                        type: 'bytes32',\n                    },\n                    {\n                        internalType: 'address',\n                        name: 'executor',\n                        type: 'address',\n                    },\n                    {\n                        internalType: 'uint256',\n                        name: 'deadline',\n                        type: 'uint256',\n                    },\n                ],\n                internalType: 'struct SignedBatchedCall',\n                name: 'signedBatchedCall',\n                type: 'tuple',\n            },\n            {\n                internalType: 'bytes',\n                name: 'wrappedSignature',\n                type: 'bytes',\n            },\n        ],\n        name: 'execute',\n        outputs: [],\n        stateMutability: 'payable',\n        type: 'function',\n    },\n    {\n        type: 'function',\n        name: 'approveNative',\n        inputs: [\n            {\n                name: 'spender',\n                type: 'address',\n                internalType: 'address',\n            },\n            {\n                name: 'amount',\n                type: 'uint256',\n                internalType: 'uint256',\n            },\n        ],\n        outputs: [\n            {\n                name: '',\n                type: 'bool',\n                internalType: 'bool',\n            },\n        ],\n        stateMutability: 'nonpayable',\n    },\n    {\n        type: 'function',\n        name: 'nativeAllowance',\n        inputs: [\n            {\n                name: 'spender',\n                type: 'address',\n                internalType: 'address',\n            },\n        ],\n        outputs: [\n            {\n                name: 'allowance',\n                type: 'uint256',\n                internalType: 'uint256',\n            },\n        ],\n        stateMutability: 'view',\n    },\n];\n\nconst SWEEP_ABI = [\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'token',\n                type: 'address',\n            },\n        ],\n        name: 'SafeERC20FailedOperation',\n        type: 'error',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'contract IERC20',\n                name: 'token',\n                type: 'address',\n            },\n            {\n                internalType: 'address',\n                name: 'to',\n                type: 'address',\n            },\n        ],\n        name: 'sweepERC20',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'to',\n                type: 'address',\n            },\n        ],\n        name: 'sweepERC7914',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function',\n    },\n];\n\nconst logger$d = getLogger();\nconst createBatchedCallSignature = (batchedCalls, nonce, chain, address, account) => {\n    return account.signTypedData({\n        domain: {\n            chainId: chain,\n            name: CALIBUR_EIP712.name,\n            salt: CALIBUR_EIP712.salt,\n            verifyingContract: address,\n            version: CALIBUR_EIP712.version,\n        },\n        message: {\n            batchedCall: {\n                calls: batchedCalls,\n                revertOnFailure: true,\n            },\n            deadline: viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256,\n            executor: (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(ZERO_BYTES_20),\n            keyHash: (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(ZERO_BYTES_32),\n            nonce,\n        },\n        primaryType: 'SignedBatchedCall',\n        types: _commons__WEBPACK_IMPORTED_MODULE_0__.CaliburSBCTypes,\n    });\n};\nconst waitForSBCTxReceipt = (ops, chainList, publicClientList) => {\n    return Promise.all(ops.map((op) => {\n        const chain = chainList.getChainByID(Number(op[0]));\n        const explorerURL = new URL(`/tx/${op[1]}`, chain.blockExplorers?.default.url);\n        console.log({ explorerURL: explorerURL.toString() });\n        return waitForTxReceipt(op[1], publicClientList.get(chain.id), 2);\n    }));\n};\nconst checkAuthCodeSet = async (chainID, address, cache) => {\n    return isAuthorizationCodeSet(chainID, address, cache);\n};\nconst createSBCTxFromCalls = async ({ cache, calls, chainID, ephemeralAddress, ephemeralWallet, publicClient, }) => {\n    const nonce = (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToBigInt)(window.crypto.getRandomValues(new Uint8Array(24))) << 64n;\n    const signature = await createBatchedCallSignature(calls, nonce, BigInt(chainID), ephemeralAddress, ephemeralWallet);\n    let authorization = null;\n    if (!(await isAuthorizationCodeSet(chainID, ephemeralAddress, cache))) {\n        const nonce = await publicClient.getTransactionCount({\n            address: ephemeralAddress,\n            blockTag: 'pending',\n        });\n        // create authorization for calibur\n        authorization = await ephemeralWallet.signAuthorization({\n            chainId: Number(chainID),\n            contractAddress: CALIBUR_ADDRESS,\n            nonce,\n        });\n    }\n    const request = {\n        address: convertTo32Bytes(ephemeralAddress),\n        authorization_list: [],\n        calls: calls.map((c) => ({\n            data: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(c.data),\n            to_addr: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(c.to),\n            value: convertTo32Bytes(c.value),\n        })),\n        chain_id: convertTo32Bytes(chainID),\n        deadline: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256),\n        key_hash: ZERO_BYTES_32,\n        nonce: convertTo32Bytes(nonce),\n        revert_on_failure: true,\n        signature: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(packSignatureAndHookData(signature)),\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    };\n    if (authorization) {\n        request.authorization_list.push({\n            address: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(CALIBUR_ADDRESS),\n            chain_id: convertTo32Bytes(authorization.chainId),\n            nonce: authorization.nonce,\n            sig_r: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(authorization.r),\n            sig_s: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(authorization.s),\n            sig_v: Number(authorization.yParity),\n        });\n    }\n    logger$d.debug('createSBCTxFromCalls', {\n        request,\n    });\n    return request;\n};\nconst caliburExecute = async ({ actualAddress, actualWallet, calls, chain, ephemeralAddress, ephemeralWallet, value, }) => {\n    const nonce = (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToBigInt)(window.crypto.getRandomValues(new Uint8Array(24))) << 64n;\n    const signature = await createBatchedCallSignature(calls, nonce, BigInt(chain.id), ephemeralAddress, ephemeralWallet);\n    return actualWallet.writeContract({\n        abi: CaliburABI,\n        account: actualAddress,\n        address: ephemeralAddress,\n        args: [\n            {\n                batchedCall: {\n                    calls,\n                    revertOnFailure: true,\n                },\n                deadline: viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256,\n                executor: (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(ZERO_BYTES_20),\n                keyHash: (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(ZERO_BYTES_32),\n                nonce,\n            },\n            packSignatureAndHookData(signature),\n        ],\n        chain,\n        functionName: 'execute',\n        value,\n    });\n};\nconst packSignatureAndHookData = (signature, hookData = '0x') => {\n    return (0,viem__WEBPACK_IMPORTED_MODULE_26__.encodeAbiParameters)([\n        { name: 'signature', type: 'bytes' },\n        { name: 'hookData', type: 'bytes' },\n    ], [signature, hookData]);\n};\n\nconst SWAP_START = {\n    completed: true,\n    type: 'SWAP_START',\n    typeID: 'SWAP_START',\n};\nconst DETERMINING_SWAP = (completed = false) => ({\n    completed,\n    type: 'DETERMINING_SWAP',\n    typeID: DETERMINING_SWAP,\n});\nconst CREATE_PERMIT_FOR_SOURCE_SWAP = (completed, symbol, chain) => ({\n    chain: {\n        id: chain.id,\n        name: chain.name,\n    },\n    completed,\n    symbol,\n    type: 'CREATE_PERMIT_FOR_SOURCE_SWAP',\n    typeID: `CREATE_PERMIT_FOR_SOURCE_SWAP_${chain.id}_${symbol}`,\n});\nconst SOURCE_SWAP_HASH = (ops, chainList) => {\n    const chainID = ops[0];\n    const chain = chainList.getChainByID(Number(ops[0]));\n    if (!chain) {\n        throw new Error(`Unknown chain: ${ops[0]}`);\n    }\n    return {\n        chain: {\n            id: chain.id,\n            name: chain.name,\n        },\n        completed: true,\n        explorerURL: new URL(`/tx/${ops[1]}`, chain.blockExplorers?.default.url).toString(),\n        type: 'SOURCE_SWAP_HASH',\n        typeID: `SOURCE_SWAP_HASH_${chainID}`,\n    };\n};\nconst RFF_ID = (id) => ({\n    completed: true,\n    data: id,\n    type: 'RFF_ID',\n    typeID: 'RFF_ID',\n});\nconst DESTINATION_SWAP_BATCH_TX = (completed) => ({\n    completed,\n    type: 'DESTINATION_SWAP_BATCH_TX',\n    typeID: 'DESTINATION_SWAP_BATCH_TX',\n});\nconst SWAP_COMPLETE = {\n    completed: true,\n    type: 'SWAP_COMPLETE',\n    typeID: 'SWAP_COMPLETE',\n};\nconst DESTINATION_SWAP_HASH = (op, chainList) => {\n    const chain = chainList.getChainByID(Number(op[0]));\n    if (!chain) {\n        throw new Error(`Unknown chain: ${op[0]}`);\n    }\n    return {\n        chain: {\n            id: chain.id,\n            name: chain.name,\n        },\n        completed: true,\n        explorerURL: new URL(`/tx/${op[1]}`, chain.blockExplorers?.default.url).toString(),\n        type: 'DESTINATION_SWAP_HASH',\n        typeID: `DESTINATION_SWAP_HASH_${chain.id}`,\n    };\n};\n\nconst logger$c = getLogger();\nconst convertTo32Bytes = (input) => {\n    if (typeof input === 'string') {\n        return (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)((0,viem__WEBPACK_IMPORTED_MODULE_16__.pad)(input, { dir: 'left', size: 32 }));\n    }\n    if (typeof input === 'bigint' || typeof input === 'number') {\n        return (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(input, {\n            size: 32,\n        });\n    }\n    return (0,viem__WEBPACK_IMPORTED_MODULE_16__.pad)(input, { dir: 'left', size: 32 });\n};\nconst EADDRESS_32_BYTES = convertTo32Bytes(EADDRESS);\nconst convertToEVMAddress = (address) => {\n    if (typeof address === 'string') {\n        address = (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(address);\n    }\n    if (address.length === 20) {\n        return (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(address);\n    }\n    if (address.length == 32) {\n        return (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(address.subarray(12));\n    }\n    throw new Error('Invalid address');\n};\nconst bytesEqual = (bytes1, bytes2) => {\n    logger$c.debug('bytesEqual', {\n        bytes1,\n        bytes2,\n    });\n    if (bytes1.length !== bytes2.length) {\n        return false;\n    }\n    for (let i = 0; i < bytes1.length; i++) {\n        if (bytes1[i] !== bytes2[i]) {\n            return false;\n        }\n    }\n    return true;\n};\nconst AnkrChainIdMapping = new Map([\n    ['arbitrum', 42161],\n    ['avalanche_fuji', 43113],\n    ['avalanche', 43114],\n    ['base_sepolia', 84532],\n    ['base', 8453],\n    ['bsc', 56],\n    ['eth_holesky', 17000],\n    ['eth_sepolia', 11155111],\n    ['eth', 1],\n    ['fantom', 250],\n    ['flare', 14],\n    ['gnosis', 100],\n    ['linea', 59144],\n    ['optimism_testnet', 11155420],\n    ['optimism', 10],\n    ['polygon_amoy', 80002],\n    ['polygon_zkevm', 1101],\n    ['polygon', 137],\n    ['rollux', 570],\n    ['scroll', 534352],\n    ['story_testnet', 1513],\n    ['story', 1514],\n    ['syscoin', 57],\n    ['telos', 40],\n    ['xai', 660279],\n    ['xlayer', 196],\n]);\nconst createPermitSignature = async (contractAddress, client, spender, walletAddress, variant, version) => {\n    const contract = (0,viem__WEBPACK_IMPORTED_MODULE_18__.getContract)({\n        abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ERC20ABI,\n        address: contractAddress,\n        client,\n    });\n    const [name, chainID, nonce] = await Promise.all([\n        contract.read.name(),\n        client.request({ method: 'eth_chainId' }, { dedupe: true }),\n        contract.read.nonces([walletAddress]),\n    ]);\n    logger$c.debug('createPermitSigParams', {\n        account: walletAddress,\n        domain: {\n            chainId: (0,viem__WEBPACK_IMPORTED_MODULE_10__.hexToBigInt)(chainID),\n            name,\n            verifyingContract: contractAddress,\n            version,\n        },\n        message: {\n            deadline: viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256,\n            nonce,\n            owner: walletAddress,\n            spender: spender,\n            value: viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256,\n        },\n        primaryType: 'Permit',\n        types: ERC20PermitEIP712Type,\n    });\n    switch (variant) {\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical: {\n            return {\n                signature: await client.signTypedData({\n                    account: walletAddress,\n                    domain: {\n                        chainId: (0,viem__WEBPACK_IMPORTED_MODULE_10__.hexToBigInt)(chainID),\n                        name,\n                        verifyingContract: contractAddress,\n                        version: version.toString(),\n                    },\n                    message: {\n                        deadline: viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256,\n                        nonce,\n                        owner: walletAddress,\n                        spender: spender,\n                        value: viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256,\n                    },\n                    primaryType: 'Permit',\n                    types: ERC20PermitEIP712Type,\n                }),\n                variant,\n            };\n        }\n        case _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.PolygonEMT: {\n            return {\n                signature: await client.signTypedData({\n                    account: walletAddress,\n                    domain: {\n                        name,\n                        salt: (0,viem__WEBPACK_IMPORTED_MODULE_16__.pad)(chainID, {\n                            dir: 'left',\n                            size: 32,\n                        }),\n                        verifyingContract: contract.address,\n                        version: version.toString(10),\n                    },\n                    message: {\n                        from: walletAddress,\n                        functionSignature: packERC20Approve(spender),\n                        nonce,\n                    },\n                    primaryType: 'MetaTransaction',\n                    types: ERC20PermitEIP2612PolygonType,\n                }),\n                variant,\n            };\n        }\n        default: {\n            throw new Error('Token Not supported: (2612 details not found)');\n        }\n    }\n};\nconst vscSBCTx = async (input, vscDomain) => {\n    const ops = [];\n    const connection = (0,it_ws__WEBPACK_IMPORTED_MODULE_4__.connect)(new URL('/api/v1/create-sbc-tx', getVSCURL(vscDomain, 'wss')).toString());\n    try {\n        await connection.connected();\n        connection.socket.send((0,msgpackr__WEBPACK_IMPORTED_MODULE_5__.pack)(input));\n        let count = 0;\n        for await (const response of connection.source) {\n            const data = (0,msgpackr__WEBPACK_IMPORTED_MODULE_5__.unpack)(response);\n            logger$c.debug('vscSBCTx', { data });\n            if (data.errored) {\n                throw new Error('Error in VSC SBC Tx');\n            }\n            ops.push([(0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToBigInt)(input[data.part_idx].chain_id), (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(data.tx_hash)]);\n            count += 1;\n            if (count === input.length) {\n                break;\n            }\n        }\n    }\n    finally {\n        await connection.close();\n    }\n    return ops;\n};\nconst cosmosCreateRFF = async ({ address, cosmosURL, msg, wallet, }) => {\n    const client = await (0,_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.createCosmosClient)(wallet, getCosmosURL(cosmosURL, 'rpc'), {\n        broadcastPollIntervalMs: 250,\n    });\n    const res = await client.signAndBroadcast(address, [\n        {\n            typeUrl: '/xarchain.chainabstraction.MsgCreateRequestForFunds',\n            value: msg,\n        },\n    ], {\n        amount: [],\n        gas: 100000n.toString(10),\n    });\n    if ((0,_cosmjs_stargate__WEBPACK_IMPORTED_MODULE_6__.isDeliverTxFailure)(res)) {\n        throw new Error('Error creating RFF');\n    }\n    const decoded = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.MsgCreateRequestForFundsResponse.decode(res.msgResponses[0].value);\n    return decoded.id;\n};\nconst cosmosCreateDoubleCheckTx = async ({ address, cosmosURL, msg, wallet, }) => {\n    const client = await (0,_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.createCosmosClient)(wallet, getCosmosURL(cosmosURL, 'rpc'), {\n        broadcastPollIntervalMs: 250,\n    });\n    logger$c.debug('cosmosCreateDoubleCheckTx:1', { doubleCheckMsg: msg });\n    const res = await client.signAndBroadcast(address, [\n        {\n            typeUrl: '/xarchain.chainabstraction.MsgDoubleCheckTx',\n            value: msg,\n        },\n    ], {\n        amount: [],\n        gas: 100000n.toString(10),\n    });\n    if ((0,_cosmjs_stargate__WEBPACK_IMPORTED_MODULE_6__.isDeliverTxFailure)(res)) {\n        throw new Error('Error creating MsgDoubleCheckTx');\n    }\n    logger$c.debug('cosmosCreateDoubleCheckTx:2', { doubleCheckTx: res });\n};\nconst EXPECTED_CALIBUR_CODE = (0,viem__WEBPACK_IMPORTED_MODULE_30__.concat)(['0xef0100', CALIBUR_ADDRESS]);\nconst isAuthorizationCodeSet = async (chainID, address, cache) => {\n    const code = cache.getCode({\n        address,\n        chainID,\n    });\n    logger$c.debug('isAuthorizationCodeSet', { code, EXPECTED_CALIBUR_CODE });\n    if (!code) {\n        return false;\n    }\n    return code != '0x' && equalFold(code, EXPECTED_CALIBUR_CODE);\n};\nconst isNativeAddress = (contractAddress) => equalFold(contractAddress, ZERO_ADDRESS) || equalFold(contractAddress, EADDRESS);\n/**\n * Creates EIP2612 signature or executes non sponsored approval and transferFrom Tx\n */\nconst createPermitAndTransferFromTx = async ({ amount, approval, cache, chain, contractAddress, owner, ownerWallet, publicClient, spender, }) => {\n    const txList = [];\n    await ownerWallet.switchChain({\n        id: chain.id,\n    });\n    logger$c.debug('createPermitCalls', {\n        contractAddress,\n        EADDRESS,\n    });\n    let allowance = cache.getAllowance({\n        chainID: chain.id,\n        contractAddress,\n        owner,\n        spender,\n    });\n    if (allowance === undefined) {\n        logger$c.debug('createPermitCalls: allowance not found in cache', {\n            cache,\n            chain,\n            contractAddress,\n            owner,\n            spender,\n        });\n        allowance = await publicClient.readContract({\n            abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ERC20ABI,\n            address: contractAddress,\n            args: [owner, spender],\n            functionName: 'allowance',\n        });\n    }\n    logger$c.debug('createPermitTx', { allowance, amount });\n    if (allowance < amount) {\n        const { variant, version } = getTokenVersion(contractAddress);\n        if (variant === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported) {\n            const { request } = await publicClient.simulateContract({\n                chain,\n                abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ERC20ABI,\n                account: owner,\n                address: contractAddress,\n                args: [spender, viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256],\n                functionName: 'approve',\n            });\n            const hash = await ownerWallet.writeContract(request);\n            await waitForTxReceipt(hash, publicClient, 1);\n            // On retry the value will be present, so no need to refetch allowance\n            cache.addAllowanceValue({\n                chainID: chain.id,\n                contractAddress,\n                owner,\n                spender,\n            }, viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256);\n        }\n        else {\n            const approvalTx = approval ??\n                (await createPermitApprovalTx({\n                    contractAddress,\n                    owner,\n                    ownerWallet,\n                    spender,\n                    variant,\n                    version,\n                }));\n            txList.push(approvalTx);\n        }\n    }\n    txList.push({\n        data: (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n            abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ERC20ABI,\n            args: [owner, spender, amount],\n            functionName: 'transferFrom',\n        }),\n        to: contractAddress,\n        value: 0n,\n    });\n    return txList;\n};\nconst createPermitApprovalTx = async ({ contractAddress, owner, ownerWallet, spender, variant, version, }) => {\n    const { signature } = await createPermitSignature(contractAddress, ownerWallet, spender, owner, variant, version);\n    const { r, s, v } = (0,viem__WEBPACK_IMPORTED_MODULE_17__.parseSignature)(signature);\n    if (!v) {\n        throw new Error('invalid signature: v is not present');\n    }\n    return {\n        data: variant === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.PolygonEMT\n            ? (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n                abi: ERC20PermitABI,\n                args: [owner, packERC20Approve(spender), r, s, Number(v)],\n                functionName: 'executeMetaTransaction',\n            })\n            : (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n                abi: ERC20PermitABI,\n                args: [owner, spender, viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256, viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256, Number(v), r, s],\n                functionName: 'permit',\n            }),\n        to: contractAddress,\n        value: 0n,\n    };\n};\nconst packERC20Approve = (spender, amount = viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256) => {\n    return (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n        abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ERC20ABI,\n        args: [spender, amount],\n        functionName: 'approve',\n    });\n};\nconst multiplierByChain = (chainID) => {\n    switch (chainID) {\n        case 534352:\n            return 100n;\n        default:\n            return 3n;\n    }\n};\nconst getAnkrBalances = async (walletAddress, chainList, removeTransferFee = false) => {\n    const publicClients = {};\n    const res = await axios__WEBPACK_IMPORTED_MODULE_24__[\"default\"].post('https://rpc.ankr.com/multichain/269e541dd5773dac3204831e29b9538284dd3e9591d2b7cb2ac47d85eae213b9/', {\n        id: decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].random(2).mul(100).toNumber(),\n        jsonrpc: '2.0',\n        method: 'ankr_getAccountBalance',\n        params: {\n            blockchain: chainList.getAnkrNameList(),\n            onlyWhitelisted: true,\n            pageSize: 500,\n            walletAddress: walletAddress,\n        },\n    });\n    if (!res.data?.result)\n        throw new Error('balances cannot be retrieved');\n    const filteredAssets = res.data.result.assets.filter((asset) => AnkrChainIdMapping.has(asset.blockchain) &&\n        !new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](asset.tokenPrice?.trim() || 0).equals(0));\n    const assets = [];\n    const promises = [];\n    for (const asset of filteredAssets) {\n        promises.push((async () => {\n            let balance = asset.balance;\n            if (removeTransferFee && asset.tokenType === 'NATIVE') {\n                const chainID = AnkrChainIdMapping.get(asset.blockchain);\n                const chain = chainList.getChainByID(AnkrChainIdMapping.get(asset.blockchain));\n                if (!publicClients[chainID]) {\n                    const client = (0,viem__WEBPACK_IMPORTED_MODULE_21__.createPublicClient)({\n                        transport: (0,viem__WEBPACK_IMPORTED_MODULE_22__.http)(chain.rpcUrls.default.http[0]),\n                    });\n                    publicClients[chainID] = client;\n                }\n                const fee = await publicClients[chainID].estimateFeesPerGas();\n                const multipler = multiplierByChain(Number(chainID));\n                const transferFee = divDecimals(fee.maxFeePerGas * 1500000n * multipler, chain.nativeCurrency.decimals);\n                logger$c.debug('getAnkrBalances', {\n                    balance: asset.balance,\n                    chainID,\n                    transferFee: transferFee.toFixed(),\n                });\n                balance = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](asset.balance).gt(transferFee)\n                    ? decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sub(asset.balance, transferFee).toFixed(asset.tokenDecimals, decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ROUND_FLOOR)\n                    : '0';\n                logger$c.debug('getAnkrBalances', {\n                    chainID,\n                    newBalance: balance,\n                    oldBalance: asset.balance,\n                    transferFee: transferFee.toFixed(),\n                });\n            }\n            assets.push({\n                balance,\n                balanceUSD: asset.balanceUsd,\n                chainID: AnkrChainIdMapping.get(asset.blockchain),\n                tokenAddress: asset.tokenType === 'ERC20' ? asset.contractAddress : ZERO_ADDRESS,\n                tokenData: {\n                    decimals: asset.tokenDecimals,\n                    icon: asset.thumbnail,\n                    name: asset.tokenName,\n                    symbol: getTokenSymbol(asset.tokenSymbol),\n                },\n                universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n            });\n        })());\n    }\n    await Promise.all(promises);\n    return assets;\n};\nfunction getTokenSymbol(symbol) {\n    if (['USD₮', 'USD₮0', 'USDt'].includes(symbol)) {\n        return 'USDT';\n    }\n    return symbol;\n}\nconst toFlatBalance = (assets, currentChainID, selectedTokenAddress) => {\n    logger$c.debug('toFlatBalance', {\n        assets,\n    });\n    return assets\n        .map((a) => a.breakdown.map((b) => {\n        return {\n            amount: b.balance,\n            chainID: b.chain.id,\n            decimals: a.decimals,\n            symbol: a.symbol,\n            tokenAddress: convertTo32BytesHex(b.contractAddress === ZERO_ADDRESS ? EADDRESS : b.contractAddress),\n            universe: b.universe,\n            value: b.balanceInFiat,\n        };\n    }))\n        .flat()\n        .filter((b) => {\n        return !(b.chainID === currentChainID && equalFold(b.tokenAddress, selectedTokenAddress));\n    })\n        .filter((b) => b.universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM &&\n        new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](b.amount).gt(0) &&\n        new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](b.value).gt(0));\n};\nconst balancesToAssets = (ankrBalances, evmBalances, fuelBalances, chainList) => {\n    const assets = [];\n    const vscBalances = evmBalances.concat(fuelBalances);\n    logger$c.debug('balanceToAssets', {\n        ankrBalances,\n        evmBalances,\n        fuelBalances,\n    });\n    for (const balance of vscBalances) {\n        for (const currency of balance.currencies) {\n            const chain = chainList.getChainByID((0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(balance.chain_id));\n            if (!chain) {\n                continue;\n            }\n            const tokenAddress = convertAddressByUniverse((0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(currency.token_address), balance.universe);\n            const token = chainList.getTokenByAddress(chain.id, tokenAddress);\n            const decimals = token ? token.decimals : chain.nativeCurrency.decimals;\n            if (token) {\n                const asset = assets.find((s) => s.symbol === token.symbol);\n                if (asset) {\n                    asset.balance = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](asset.balance).add(currency.balance).toFixed();\n                    asset.balanceInFiat = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](asset.balanceInFiat)\n                        .add(currency.value)\n                        .toDecimalPlaces(2)\n                        .toNumber();\n                    asset.breakdown.push({\n                        balance: currency.balance,\n                        balanceInFiat: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](currency.value).toDecimalPlaces(2).toNumber(),\n                        chain: {\n                            id: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(balance.chain_id),\n                            logo: chain.custom.icon,\n                            name: chain.name,\n                        },\n                        contractAddress: tokenAddress,\n                        decimals,\n                        universe: balance.universe,\n                    });\n                }\n                else {\n                    assets.push({\n                        abstracted: true,\n                        balance: currency.balance,\n                        balanceInFiat: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](currency.value).toDecimalPlaces(2).toNumber(),\n                        breakdown: [\n                            {\n                                balance: currency.balance,\n                                balanceInFiat: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](currency.value).toDecimalPlaces(2).toNumber(),\n                                chain: {\n                                    id: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(balance.chain_id),\n                                    logo: chain.custom.icon,\n                                    name: chain.name,\n                                },\n                                contractAddress: tokenAddress,\n                                decimals,\n                                universe: balance.universe,\n                            },\n                        ],\n                        decimals: token.decimals,\n                        icon: getLogoFromSymbol(token.symbol),\n                        symbol: token.symbol,\n                    });\n                }\n            }\n        }\n    }\n    for (const asset of ankrBalances) {\n        if (new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](asset.balance).equals(0)) {\n            continue;\n        }\n        const d = chainData.get(asset.chainID);\n        if (!d) {\n            continue;\n        }\n        const chain = chainList.getChainByID(asset.chainID);\n        if (!chain) {\n            continue;\n        }\n        const existingAsset = assets.find((a) => equalFold(a.symbol, asset.tokenData.symbol));\n        if (existingAsset) {\n            if (!existingAsset.breakdown.find((t) => t.chain.id === chain.id && equalFold(t.contractAddress, asset.tokenAddress))) {\n                existingAsset.balance = decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(existingAsset.balance, asset.balance).toFixed();\n                existingAsset.balanceInFiat = decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(existingAsset.balanceInFiat, asset.balanceUSD)\n                    .toDecimalPlaces(2)\n                    .toNumber();\n                existingAsset.breakdown.push({\n                    balance: asset.balance,\n                    balanceInFiat: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](asset.balanceUSD).toDecimalPlaces(2).toNumber(),\n                    chain: {\n                        id: chain.id,\n                        logo: chain.custom.icon,\n                        name: chain.name,\n                    },\n                    contractAddress: asset.tokenAddress,\n                    decimals: asset.tokenData.decimals,\n                    universe: asset.universe,\n                });\n            }\n        }\n        else {\n            assets.push({\n                abstracted: true,\n                balance: asset.balance,\n                balanceInFiat: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](asset.balanceUSD).toDecimalPlaces(2).toNumber(),\n                breakdown: [\n                    {\n                        balance: asset.balance,\n                        balanceInFiat: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](asset.balanceUSD).toDecimalPlaces(2).toNumber(),\n                        chain: {\n                            id: chain.id,\n                            logo: chain.custom.icon,\n                            name: chain.name,\n                        },\n                        contractAddress: asset.tokenAddress,\n                        decimals: asset.tokenData.decimals,\n                        universe: asset.universe,\n                    },\n                ],\n                decimals: asset.tokenData.decimals,\n                icon: asset.tokenData.icon,\n                symbol: asset.tokenData.symbol,\n            });\n        }\n    }\n    assets.forEach((asset) => {\n        asset.breakdown.sort((a, b) => b.balanceInFiat - a.balanceInFiat);\n    });\n    assets.sort((a, b) => b.balanceInFiat - a.balanceInFiat);\n    return assets;\n};\nclass Cache {\n    constructor(publicClientList) {\n        this.publicClientList = publicClientList;\n        this.allowanceValues = new Map();\n        this.setCodeValues = new Map();\n        this.allowanceQueries = new Set();\n        this.nativeAllowanceQueries = new Set();\n        this.setCodeQueries = new Set();\n    }\n    addAllowanceQuery(input) {\n        this.allowanceQueries.add(input);\n    }\n    addAllowanceValue(input, value) {\n        this.allowanceValues.set(getAllowanceCacheKey(input), value);\n    }\n    addNativeAllowanceQuery(input) {\n        this.nativeAllowanceQueries.add(input);\n    }\n    addSetCodeQuery(input) {\n        this.setCodeQueries.add(input);\n    }\n    addSetCodeValue(input, value) {\n        this.setCodeValues.set(getSetCodeKey(input), value);\n    }\n    getAllowance(input) {\n        return this.allowanceValues.get(getAllowanceCacheKey(input));\n    }\n    getCode(input) {\n        return this.setCodeValues.get(getSetCodeKey(input));\n    }\n    async process() {\n        await Promise.all([\n            this.processNativeAllowanceRequests(),\n            this.processAllowanceRequests(),\n            this.processGetCodeRequests(),\n        ]);\n    }\n    async processNativeAllowanceRequests() {\n        const requests = [];\n        for (const input of this.nativeAllowanceQueries) {\n            const publicClient = this.publicClientList.get(input.chainID);\n            requests.push(publicClient\n                .readContract({\n                address: input.contractAddress,\n                abi: CaliburABI,\n                functionName: 'nativeAllowance',\n                args: [input.spender],\n            })\n                .then((code) => {\n                this.allowanceValues.set(getAllowanceCacheKey(input), code);\n            }));\n        }\n        await Promise.all(requests);\n    }\n    async processAllowanceRequests() {\n        // The request query list is small so don't care about performance here (for now)\n        const unprocessedInput = [...this.allowanceQueries].filter((v) => this.getAllowance(v) === undefined);\n        const inputByChainID = Map.groupBy(unprocessedInput, (i) => i.chainID);\n        const requests = [];\n        for (const [chainID, inputs] of inputByChainID) {\n            const publicClient = this.publicClientList.get(chainID);\n            for (const input of inputs) {\n                requests.push(equalFold(input.contractAddress, EADDRESS)\n                    ? Promise.resolve(this.allowanceValues.set(getAllowanceCacheKey(input), viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256))\n                    : publicClient\n                        .readContract({\n                        abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ERC20ABI,\n                        address: input.contractAddress,\n                        args: [input.owner, input.spender],\n                        functionName: 'allowance',\n                    })\n                        .then((allowance) => {\n                        this.allowanceValues.set(getAllowanceCacheKey(input), allowance);\n                    }));\n            }\n        }\n        await Promise.all(requests);\n    }\n    async processGetCodeRequests() {\n        const requests = [];\n        for (const input of this.setCodeQueries) {\n            const publicClient = this.publicClientList.get(input.chainID);\n            requests.push(publicClient\n                .getCode({\n                address: input.address,\n            })\n                .then((code) => {\n                this.setCodeValues.set(getSetCodeKey(input), code);\n            }));\n        }\n        await Promise.all(requests);\n    }\n}\n// To remove duplication of publicClients\nclass PublicClientList {\n    constructor(chainList) {\n        this.chainList = chainList;\n        this.list = {};\n    }\n    get(chainID) {\n        let client = this.list[Number(chainID)];\n        if (!client) {\n            const chain = this.chainList.getChainByID(Number(chainID));\n            if (!chain) {\n                throw new Error(`Chain not found: ${chainID}`);\n            }\n            client = (0,viem__WEBPACK_IMPORTED_MODULE_21__.createPublicClient)({\n                transport: (0,viem__WEBPACK_IMPORTED_MODULE_22__.http)(chain.rpcUrls.default.http[0]),\n            });\n            this.list[Number(chainID)] = client;\n        }\n        return client;\n    }\n}\nconst getAllowanceCacheKey = ({ chainID, contractAddress, owner, spender, }) => ('a' + contractAddress + chainID + owner + spender).toLowerCase();\nconst getSetCodeKey = (input) => ('a' + input.chainID + input.address).toLowerCase();\n// const APPROVE_GAS_LIMIT = 63_000n;\n// export const swapToGasIfPossible = async ({\n//   actualAddress,\n//   aggregators,\n//   assetsUsed,\n//   balances,\n//   chainList,\n//   ephemeralAddress,\n//   oraclePrices,\n// }: {\n//   actualAddress: Bytes;\n//   aggregators: Aggregator[];\n//   assetsUsed: {\n//     amount: string;\n//     chainID: number;\n//     contractAddress: `0x${string}`;\n//   }[];\n//   balances: Balances;\n//   chainList: ChainList;\n//   ephemeralAddress: Bytes;\n//   grpcURL: string;\n//   oraclePrices: OraclePriceResponse;\n// }) => {\n//   const aci: CreateAllowanceCacheInput = new Set();\n//   const blacklist: Hex[] = [];\n//   const data: {\n//     [k: number]: {\n//       amount: bigint;\n//       contractAddress: Hex;\n//       txs: Tx[];\n//       unsupportedTokens: Hex[];\n//     };\n//   } = {};\n//   let requote = false;\n//   const chainToUnsupportedTokens: Record<number, Hex[]> = {};\n//   const assetsGroupedByChain = Map.groupBy(\n//     assetsUsed,\n//     (asset) => asset.chainID,\n//   );\n//   for (const [chainID, swapQuotes] of assetsGroupedByChain) {\n//     for (const sQuote of swapQuotes) {\n//       if (!isEIP2612Supported(sQuote.contractAddress, BigInt(chainID))) {\n//         if (!chainToUnsupportedTokens[Number(chainID)]) {\n//           chainToUnsupportedTokens[Number(chainID)] = [];\n//         }\n//         aci.add({\n//           chainID: Number(chainID),\n//           contractAddress: sQuote.contractAddress,\n//           owner: convertToEVMAddress(actualAddress),\n//           spender: convertToEVMAddress(ephemeralAddress),\n//         });\n//         chainToUnsupportedTokens[Number(chainID)].push(sQuote.contractAddress);\n//       }\n//     }\n//   }\n//   logger.debug(\"checkAndSupplyGasForApproval:1\", {\n//     assetsGroupedByChain,\n//     chainToUnsupportedTokens,\n//   });\n//   const allowanceCache = await createAllowanceCache(aci, chainList);\n//   if (Object.keys(chainToUnsupportedTokens).length === 0) {\n//     return { blacklist, data, requote: false };\n//   }\n//   for (const chainID in chainToUnsupportedTokens) {\n//     const tokens: Hex[] = [];\n//     for (const token of chainToUnsupportedTokens[chainID]) {\n//       const allowance = allowanceCache.gget({\n//         chainID: Number(chainID),\n//         owner: convertToEVMAddress(actualAddress),\n//         spender: convertToEVMAddress(ephemeralAddress),\n//         tokenAddress: token,\n//       });\n//       if (!allowance || allowance < 100000000n) {\n//         tokens.push(token);\n//       }\n//     }\n//     if (tokens.length) {\n//       chainToUnsupportedTokens[chainID] = tokens;\n//     } else {\n//       delete chainToUnsupportedTokens[chainID];\n//     }\n//     const quotes = assetsGroupedByChain.get(Number(chainID));\n//     const balancesOnChain = balances.filter(\n//       (b) =>\n//         b.chain_id === Number(chainID) &&\n//         isEIP2612Supported(b.token_address, BigInt(chainID)),\n//     );\n//     const chain = chainList.getChainByID(Number(chainID));\n//     if (!chain) {\n//       throw new Error(`chain not found: ${chainID}`);\n//     }\n//     const publicClient = createPublicClient({\n//       transport: http(chain.rpcUrls.default.http[0]),\n//     });\n//     const gasPrice = await publicClient.estimateFeesPerGas();\n//     const gas =\n//       APPROVE_GAS_LIMIT *\n//       gasPrice.maxFeePerGas *\n//       BigInt(chainToUnsupportedTokens[chainID].length) *\n//       3n;\n//     const nativeBalance = balances.find(\n//       (b) =>\n//         b.chain_id === Number(chainID) && equalFold(b.token_address, EADDRESS),\n//     );\n//     logger.debug(\"checkAndSupplyGasForApproval:2\", {\n//       gas,\n//       gasPrice,\n//       nativeBalance,\n//     });\n//     if (new Decimal(nativeBalance?.amount ?? 0).gte(gas)) {\n//       data[Number(chainID)] = {\n//         // Since txs.length == 0, amount and contractAddress should not get used, only unsupported token\n//         amount: 0n,\n//         contractAddress: \"0x\",\n//         txs: [],\n//         unsupportedTokens: chainToUnsupportedTokens[chainID],\n//       };\n//       continue;\n//     }\n//     let done = false;\n//     // Split between sources included and excluded in source swaps\n//     const split = splitBalanceByQuotes(balancesOnChain, quotes!);\n//     logger.debug(\"checkAndSupplyGasForApproval:3\", {\n//       chainID,\n//       split,\n//     });\n//     for (const s of split.excluded) {\n//       const gasInToken = convertGasToToken(\n//         {\n//           contractAddress: s.token_address,\n//           decimals: s.decimals,\n//           priceUSD: s.priceUSD,\n//         },\n//         oraclePrices,\n//         chain.id,\n//         divDecimals(gas, chain.nativeCurrency.decimals),\n//       );\n//       logger.debug(\"checkAndSupplyGasForApproval:3:excluded\", {\n//         amount: s.amount,\n//         gasInToken: gasInToken.toFixed(),\n//         token: s,\n//       });\n//       if (gasInToken.lt(s.amount)) {\n//         const res = await swapToGasQuote(\n//           ephemeralAddress,\n//           actualAddress,\n//           new OmniversalChainID(Universe.ETHEREUM, chainID),\n//           {\n//             tokenAddress: EADDRESS_32_BYTES,\n//           },\n//           aggregators,\n//           {\n//             amount: mulDecimals(gasInToken, s.decimals),\n//             decimals: s.decimals,\n//             tokenAddress: convertTo32Bytes(s.token_address),\n//           },\n//         );\n//         if (res.quote) {\n//           const txs = getTxsFromQuote(\n//             res.aggregator,\n//             res.quote,\n//             convertTo32Bytes(s.token_address),\n//           );\n//           data[Number(chainID)] = {\n//             amount: mulDecimals(gasInToken, s.decimals),\n//             contractAddress: s.token_address,\n//             txs: [txs.approval!, txs.swap],\n//             unsupportedTokens: chainToUnsupportedTokens[chainID],\n//           };\n//           done = true;\n//           break;\n//         }\n//       }\n//     }\n//     if (!done) {\n//       for (const s of split.included) {\n//         const gasInToken = convertGasToToken(\n//           {\n//             contractAddress: s.token_address,\n//             decimals: s.decimals,\n//             priceUSD: s.priceUSD,\n//           },\n//           oraclePrices,\n//           chain.id,\n//           divDecimals(gas, chain.nativeCurrency.decimals),\n//         );\n//         logger.debug(\"checkAndSupplyGasForApproval:3:included\", {\n//           amount: s.amount,\n//           gasInToken: gasInToken.toFixed(),\n//         });\n//         if (gasInToken.gte(s.amount)) {\n//           const res = await swapToGasQuote(\n//             ephemeralAddress,\n//             actualAddress,\n//             new OmniversalChainID(Universe.ETHEREUM, chainID),\n//             {\n//               tokenAddress: EADDRESS_32_BYTES,\n//             },\n//             aggregators,\n//             {\n//               amount: mulDecimals(gasInToken, s.decimals),\n//               decimals: s.decimals,\n//               tokenAddress: convertTo32Bytes(s.token_address),\n//             },\n//           );\n//           if (res.quote) {\n//             const txs = getTxsFromQuote(\n//               res.aggregator,\n//               res.quote,\n//               convertTo32Bytes(s.token_address),\n//             );\n//             data[Number(chainID)] = {\n//               amount: mulDecimals(gasInToken, s.decimals),\n//               contractAddress: s.token_address,\n//               txs: [txs.approval!, txs.swap],\n//               unsupportedTokens: chainToUnsupportedTokens[chainID],\n//             };\n//             // since we had to use source swap token for gas\n//             // TODO: Check if we have enough if we swap for gas otherwise throw error\n//             done = true;\n//             requote = true;\n//             break;\n//           }\n//         }\n//       }\n//     }\n//     if (!done) {\n//       throw new Error(`could not swap token for gas on chain: ${chainID}`);\n//     }\n//   }\n//   return {\n//     blacklist,\n//     data,\n//     requote,\n//   };\n// };\n// const convertGasToToken = (\n//   token: { contractAddress: Hex; decimals: number; priceUSD: string },\n//   oraclePrices: OraclePriceResponse,\n//   destinationChainID: number,\n//   gas: Decimal,\n// ) => {\n//   const gasTokenPerUSD =\n//     oraclePrices\n//       .find(\n//         (rate) =>\n//           rate.chainId === destinationChainID &&\n//           equalFold(rate.tokenAddress, ZERO_ADDRESS),\n//       )\n//       ?.tokensPerUsd.toString() ?? \"0\";\n//   const transferTokenPerUSD = Decimal.div(1, token.priceUSD);\n//   logger.debug(\"convertGasToToken\", {\n//     gas: gas.toFixed(),\n//     gasTokenPerUSD,\n//     transferTokenPerUSD,\n//   });\n//   const gasInUSD = new Decimal(1).div(gasTokenPerUSD).mul(gas);\n//   const totalRequired = new Decimal(gasInUSD).div(transferTokenPerUSD);\n//   return totalRequired.toDP(token.decimals, Decimal.ROUND_CEIL);\n// };\nconst getTxsFromQuote = (aggregator, quote, inputToken, createApproval = true) => {\n    logger$c.debug('getTxsFromQuote', {\n        aggregator,\n        createApproval,\n        inputToken,\n        quote,\n    });\n    if (aggregator instanceof _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.LiFiAggregator) {\n        const originalResponse = quote.originalResponse;\n        const tx = originalResponse.transactionRequest;\n        logger$c.debug('getTxsFromQuote', {\n            'approval.amount': quote.inputAmount,\n            'approval.target': originalResponse.estimate.approvalAddress,\n            tx: tx,\n            'tx.amount': quote.inputAmount,\n            'tx.inputToken': inputToken,\n            'tx.outputAmount': quote.outputAmountMinimum,\n        });\n        const val = {\n            amount: quote.inputAmount,\n            approval: null,\n            inputToken,\n            outputAmount: quote.outputAmountMinimum,\n            swap: {\n                data: tx.data,\n                to: tx.to,\n                value: BigInt(tx.value),\n            },\n        };\n        if (createApproval) {\n            val.approval = {\n                data: packERC20Approve(originalResponse.estimate.approvalAddress, quote.inputAmount),\n                to: convertToEVMAddress(inputToken),\n                value: 0n,\n            };\n        }\n        return val;\n    }\n    else if (aggregator instanceof _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.BebopAggregator) {\n        const originalResponse = quote.originalResponse;\n        const tx = originalResponse.quote.tx;\n        logger$c.debug('getTxsFromQuote', {\n            'approval.amount': quote.inputAmount,\n            'approval.target': originalResponse.quote.approvalTarget,\n            tx: tx,\n            'tx.amount': quote.inputAmount,\n            'tx.inputToken': inputToken,\n            'tx.outputAmount': quote.outputAmountMinimum,\n        });\n        const val = {\n            amount: quote.inputAmount,\n            approval: null,\n            inputToken,\n            outputAmount: quote.outputAmountMinimum,\n            swap: {\n                data: tx.data,\n                to: tx.to,\n                value: BigInt(tx.value),\n            },\n        };\n        if (createApproval) {\n            val.approval = {\n                data: packERC20Approve(originalResponse.quote.approvalTarget, quote.inputAmount),\n                to: convertToEVMAddress(inputToken),\n                value: 0n,\n            };\n        }\n        return val;\n    }\n    throw new Error('Unknown aggregator');\n};\nconst createSwapIntent = (sources, destination, chainList) => {\n    const chain = chainList.getChainByID(destination.chainID);\n    if (!chain) {\n        throw new Error(`chain not found: ${destination.chainID}`);\n    }\n    const intent = {\n        destination: {\n            amount: destination.amount,\n            chain: {\n                id: chain.id,\n                logo: chain.custom.icon,\n                name: chain.name,\n            },\n            token: {\n                contractAddress: destination.contractAddress,\n                decimals: destination.decimals,\n                symbol: destination.symbol,\n            },\n        },\n        sources: [],\n    };\n    for (const source of sources) {\n        const chain = chainList.getChainByID(source.chainID);\n        if (!chain) {\n            throw new Error(`chain not found: ${source.chainID}`);\n        }\n        intent.sources.push({\n            amount: source.amount,\n            chain: {\n                id: chain.id,\n                logo: chain.custom.icon,\n                name: chain.name,\n            },\n            token: {\n                contractAddress: source.contractAddress,\n                decimals: source.decimals,\n                symbol: source.symbol,\n            },\n        });\n    }\n    return intent;\n};\nconst getTokenInfo = async (contractAddress, publicClient, chain) => {\n    if (isNativeAddress(contractAddress)) {\n        return {\n            contractAddress: ZERO_ADDRESS,\n            decimals: chain.nativeCurrency.decimals,\n            symbol: chain.nativeCurrency.symbol,\n        };\n    }\n    else {\n        const [decimals, symbol] = await Promise.all([\n            publicClient.readContract({\n                abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ERC20ABI,\n                address: contractAddress,\n                functionName: 'decimals',\n            }),\n            publicClient.readContract({\n                abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ERC20ABI,\n                address: contractAddress,\n                functionName: 'symbol',\n            }),\n        ]);\n        return { contractAddress, decimals, symbol };\n    }\n};\nconst metadataAxios = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.msgpackableAxios.create({\n    baseURL: 'https://metadata-cerise.arcana.network',\n});\nconst types = {\n    Record: [\n        { name: 'rff_id', type: 'uint256' },\n        { name: 'has_xcs', type: 'bool' },\n        { name: 'src', type: 'Transaction[]' },\n        { name: 'dst', type: 'Transaction' },\n    ],\n    Transaction: [\n        { name: 'univ', type: 'uint8' },\n        { name: 'chid', type: 'bytes32' },\n        { name: 'tx_hash', type: 'bytes32' },\n        { name: 'swaps', type: 'XCSSwap[]' },\n    ],\n    XCSSwap: [\n        { name: 'input_contract', type: 'bytes32' },\n        { name: 'input_amt', type: 'uint256' },\n        { name: 'input_decimals', type: 'uint8' },\n        { name: 'output_contract', type: 'bytes32' },\n        { name: 'output_amt', type: 'uint256' },\n        { name: 'output_decimals', type: 'uint8' },\n        { name: 'agg', type: 'uint8' },\n    ],\n};\nconst convertSwapMetaToSwap = (src) => {\n    const swaps = src.swaps.map((s) => {\n        return {\n            inputAmount: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToBigInt)(s.input_amt),\n            inputContract: convertToEVMAddress(s.input_contract),\n            inputDecimals: s.input_decimals,\n            outputAmount: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToBigInt)(s.output_amt),\n            outputContract: convertToEVMAddress(s.output_contract),\n            outputDecimals: s.output_decimals,\n        };\n    });\n    return {\n        chainId: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(src.chid),\n        swaps,\n        txHash: (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(src.tx_hash),\n    };\n};\nconst convertMetadataToSwapResult = (metadata, baseURL) => {\n    return {\n        sourceSwaps: metadata.src.map(convertSwapMetaToSwap),\n        explorerURL: getExplorerURL(baseURL, long__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fromBigInt(metadata.rff_id)),\n        destinationSwap: convertSwapMetaToSwap(metadata.dst),\n    };\n};\nfunction mswap2eip712swap(input) {\n    return {\n        agg: input.agg,\n        input_amt: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToBigInt)(input.input_amt),\n        input_contract: (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(input.input_contract),\n        input_decimals: input.input_decimals,\n        output_amt: (0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToBigInt)(input.output_amt),\n        output_contract: (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(input.output_contract),\n        output_decimals: input.output_decimals,\n    };\n}\nconst calculateValue = (amount, value, newAmount) => {\n    return decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].div(value, amount).mul(newAmount);\n};\nfunction mtx2eip712tx(input) {\n    return {\n        chid: (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(input.chid),\n        swaps: input.swaps.map(mswap2eip712swap),\n        tx_hash: (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(input.tx_hash),\n        univ: input.univ,\n    };\n}\nconst postSwap = async ({ metadata, wallet, }) => {\n    logger$c.debug('metadata', {\n        metadata,\n        msg: {\n            ...metadata,\n            dst: mtx2eip712tx(metadata.dst),\n            src: metadata.src.map(mtx2eip712tx),\n        },\n    });\n    const signature = await wallet.signTypedData({\n        domain: {\n            chainId: 1n,\n            name: 'CA Metadata',\n            verifyingContract: ZERO_ADDRESS,\n            version: '0.0.1',\n        },\n        message: {\n            ...metadata,\n            dst: mtx2eip712tx(metadata.dst),\n            src: metadata.src.map(mtx2eip712tx),\n        },\n        primaryType: 'Record',\n        types,\n    });\n    logger$c.debug('metadata', {\n        data: {\n            record: metadata,\n            rff_id: Number(metadata.rff_id),\n            sig: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(signature),\n        },\n        signature,\n    });\n    const rffIDN = Number(metadata.rff_id);\n    // @ts-ignore\n    delete metadata.rff_id;\n    const res = await metadataAxios({\n        data: {\n            record: metadata,\n            rff_id: rffIDN,\n            sig: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(signature),\n        },\n        method: 'POST',\n        url: `/api/v1/save-metadata/${rffIDN === 0 ? 'unlinked' : 'linked'}`,\n    });\n    return rffIDN === 0 ? res.data.value : rffIDN;\n};\nconst createSweeperTxs = ({ cache, chainID, COTCurrencyID, receiver, sender, tokenAddress, }) => {\n    const txs = [];\n    if (!tokenAddress) {\n        const currency = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ChaindataMap.get(new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.OmniversalChainID(_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM, chainID)).Currencies.find((c) => c.currencyID === COTCurrencyID);\n        if (!currency) {\n            throw new Error(`cot not found on chain ${chainID}`);\n        }\n        tokenAddress = convertToEVMAddress(currency.tokenAddress);\n    }\n    if (isNativeAddress(tokenAddress)) {\n        const nativeAllowance = cache.getAllowance({\n            chainID: Number(chainID),\n            contractAddress: sender,\n            owner: SWEEPER_ADDRESS,\n            spender: SWEEPER_ADDRESS,\n        });\n        logger$c.debug('createSweeperTxs', {\n            nativeAllowance,\n        });\n        if (!nativeAllowance || nativeAllowance === 0n) {\n            txs.push({\n                to: sender,\n                data: (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n                    abi: CaliburABI,\n                    functionName: 'approveNative',\n                    args: [SWEEPER_ADDRESS, viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256],\n                }),\n                value: 0n,\n            });\n        }\n        txs.push({\n            data: (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n                abi: SWEEP_ABI,\n                args: [receiver],\n                functionName: 'sweepERC7914',\n            }),\n            to: SWEEPER_ADDRESS,\n            value: 0n,\n        });\n    }\n    else {\n        const sweeperAllowance = cache.getAllowance({\n            chainID: Number(chainID),\n            contractAddress: convertToEVMAddress(tokenAddress),\n            owner: sender,\n            spender: SWEEPER_ADDRESS,\n        });\n        if (!sweeperAllowance || sweeperAllowance === 0n) {\n            txs.push({\n                data: packERC20Approve(SWEEPER_ADDRESS),\n                to: convertToEVMAddress(tokenAddress),\n                value: 0n,\n            });\n        }\n        txs.push({\n            data: (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n                abi: SWEEP_ABI,\n                args: [convertToEVMAddress(tokenAddress), receiver],\n                functionName: 'sweepERC20',\n            }),\n            to: SWEEPER_ADDRESS,\n            value: 0n,\n        });\n    }\n    return txs;\n};\nconst performDestinationSwap = async ({ actualAddress, cache, calls, chain, chainList, COT, emitter, ephemeralAddress, ephemeralWallet, hasDestinationSwap, publicClientList, vscDomain, }) => {\n    try {\n        // If destination swap token is COT then calls is an empty array,\n        // sweeper txs will send from ephemeral -> eoa, other cases it sweeps the dust\n        const hash = await (0,es_toolkit__WEBPACK_IMPORTED_MODULE_31__.retry)(async () => {\n            const sbcTx = await createSBCTxFromCalls({\n                cache,\n                calls: calls.concat(createSweeperTxs({\n                    cache,\n                    chainID: chain.id,\n                    COTCurrencyID: COT,\n                    receiver: actualAddress,\n                    sender: ephemeralAddress,\n                })),\n                chainID: chain.id,\n                ephemeralAddress,\n                ephemeralWallet,\n                publicClient: publicClientList.get(chain.id),\n            });\n            performance.mark('destination-swap-start');\n            const ops = await vscSBCTx([sbcTx], vscDomain);\n            performance.mark('destination-swap-end');\n            if (hasDestinationSwap) {\n                emitter.emit(DESTINATION_SWAP_HASH(ops[0], chainList));\n            }\n            performance.mark('destination-swap-mining-start');\n            await waitForSBCTxReceipt(ops, chainList, publicClientList);\n            performance.mark('destination-swap-mining-end');\n            return ops[0][1];\n        }, 2);\n        return hash;\n    }\n    catch (e) {\n        logger$c.error('destination swap failed twice, sweeping to eoa', e);\n        await vscSBCTx([\n            await createSBCTxFromCalls({\n                cache,\n                calls: createSweeperTxs({\n                    cache,\n                    chainID: chain.id,\n                    COTCurrencyID: COT,\n                    receiver: actualAddress,\n                    sender: ephemeralAddress,\n                }),\n                chainID: chain.id,\n                ephemeralAddress,\n                ephemeralWallet,\n                publicClient: publicClientList.get(chain.id),\n            }),\n        ], vscDomain).catch((e) => {\n            logger$c.error('error during destination sweep', e);\n        });\n        throw e;\n    }\n};\nconst getSwapSupportedChains = (chainList) => {\n    const chains = [];\n    for (const c of chainData.keys()) {\n        const chain = chainList.getChainByID(c);\n        if (!chain) {\n            continue;\n        }\n        const data = {\n            id: chain.id,\n            logo: chain.custom.icon,\n            name: chain.name,\n            tokens: [],\n        };\n        const tokens = chainData.get(c);\n        if (!tokens) {\n            continue;\n        }\n        tokens.forEach((t) => {\n            if (t.PermitVariant !== _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported) {\n                data.tokens.push({\n                    contractAddress: convertToEVMAddress(t.TokenContractAddress),\n                    decimals: t.TokenDecimals,\n                    logo: '',\n                    name: t.Name,\n                    symbol: t.Name,\n                });\n            }\n        });\n        chains.push(data);\n    }\n    return chains;\n};\n\nvar CurrencyID;\n(function (CurrencyID) {\n    CurrencyID[CurrencyID[\"AVAX\"] = 5] = \"AVAX\";\n    CurrencyID[CurrencyID[\"DAI\"] = 6] = \"DAI\";\n    CurrencyID[CurrencyID[\"ETH\"] = 3] = \"ETH\";\n    CurrencyID[CurrencyID[\"HYPE\"] = 16] = \"HYPE\";\n    CurrencyID[CurrencyID[\"KAIA\"] = 17] = \"KAIA\";\n    CurrencyID[CurrencyID[\"POL\"] = 4] = \"POL\";\n    CurrencyID[CurrencyID[\"USDC\"] = 1] = \"USDC\";\n    CurrencyID[CurrencyID[\"USDS\"] = 99] = \"USDS\";\n    CurrencyID[CurrencyID[\"USDT\"] = 2] = \"USDT\";\n    CurrencyID[CurrencyID[\"WETH\"] = 7] = \"WETH\";\n})(CurrencyID || (CurrencyID = {}));\nconst chainData = new Map([\n    [\n        10,\n        [\n            {\n                CurrencyID: CurrencyID.USDC,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.USDC],\n                PermitContractVersion: 2,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0xb2c639c533813f4aa9d7837caf62653d097ff85'),\n                TokenDecimals: 6,\n            },\n            {\n                CurrencyID: CurrencyID.USDT,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.USDT],\n                PermitContractVersion: 0,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported,\n                TokenContractAddress: convertTo32BytesHex('0x94b008aa00579c1307b0ef2c499ad98a8ce58e58'),\n                TokenDecimals: 6,\n            },\n            {\n                CurrencyID: CurrencyID.USDT,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.USDT],\n                PermitContractVersion: 1,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0x01bff41798a0bcf287b996046ca68b395dbc1071'),\n                TokenDecimals: 6,\n            },\n            {\n                CurrencyID: CurrencyID.DAI,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.DAI],\n                PermitContractVersion: 2,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0xda10009cbd5d07dd0cecc66161fc93d7c9000da1'),\n                TokenDecimals: 18,\n            },\n            {\n                CurrencyID: CurrencyID.ETH,\n                IsGasToken: true,\n                Name: CurrencyID[CurrencyID.ETH],\n                PermitContractVersion: 0,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported,\n                TokenContractAddress: convertTo32BytesHex(EADDRESS),\n                TokenDecimals: 18,\n            },\n            {\n                CurrencyID: CurrencyID.WETH,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.WETH],\n                PermitContractVersion: 0,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported,\n                TokenContractAddress: convertTo32BytesHex('0x4200000000000000000000000000000000000006'),\n                TokenDecimals: 18,\n            },\n        ],\n    ],\n    [\n        137,\n        [\n            {\n                CurrencyID: CurrencyID.POL,\n                IsGasToken: true,\n                Name: CurrencyID[CurrencyID.POL],\n                PermitContractVersion: 0,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported,\n                TokenContractAddress: convertTo32BytesHex(EADDRESS),\n                TokenDecimals: 18,\n            },\n            {\n                CurrencyID: CurrencyID.USDC,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.USDC],\n                PermitContractVersion: 2,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0x3c499c542cef5e3811e1192ce70d8cc03d5c3359'),\n                TokenDecimals: 6,\n            },\n            {\n                CurrencyID: CurrencyID.USDT,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.USDT],\n                PermitContractVersion: 1,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.PolygonEMT,\n                TokenContractAddress: convertTo32BytesHex('0xc2132d05d31c914a87c6611c10748aeb04b58e8f'),\n                TokenDecimals: 6,\n            },\n        ],\n    ],\n    [\n        42161,\n        [\n            {\n                CurrencyID: CurrencyID.WETH,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.WETH],\n                PermitContractVersion: 1,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0x82af49447d8a07e3bd95bd0d56f35241523fbab1'),\n                TokenDecimals: 18,\n            },\n            {\n                CurrencyID: CurrencyID.USDC,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.USDC],\n                PermitContractVersion: 2,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0xaf88d065e77c8cc2239327c5edb3a432268e5831'),\n                TokenDecimals: 6,\n            },\n            {\n                CurrencyID: CurrencyID.USDT,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.USDT],\n                PermitContractVersion: 1,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9'),\n                TokenDecimals: 6,\n            },\n            {\n                CurrencyID: CurrencyID.DAI,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.DAI],\n                PermitContractVersion: 2,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0xda10009cbd5d07dd0cecc66161fc93d7c9000da1'),\n                TokenDecimals: 6,\n            },\n            {\n                CurrencyID: CurrencyID.ETH,\n                IsGasToken: true,\n                Name: CurrencyID[CurrencyID.ETH],\n                PermitContractVersion: 0,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported,\n                TokenContractAddress: convertTo32BytesHex(EADDRESS),\n                TokenDecimals: 18,\n            },\n        ],\n    ],\n    [\n        534352,\n        [\n            {\n                CurrencyID: CurrencyID.WETH,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.WETH],\n                PermitContractVersion: 1,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0x5300000000000000000000000000000000000004'),\n                TokenDecimals: 18,\n            },\n            {\n                CurrencyID: CurrencyID.USDC,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.USDC],\n                PermitContractVersion: 2,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0x6efdbff2a14a7c8e15944d1f4a48f9f95f663a4'),\n                TokenDecimals: 6,\n            },\n            {\n                CurrencyID: CurrencyID.USDT,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.USDT],\n                PermitContractVersion: 1,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0xf55bec9cafdbe8730f096aa55dad6d22d44099df'),\n                TokenDecimals: 6,\n            },\n            {\n                CurrencyID: CurrencyID.DAI,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.DAI],\n                PermitContractVersion: 1,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0xcA77eB3fEFe3725Dc33bccB54eDEFc3D9f764f97'),\n                TokenDecimals: 6,\n            },\n            {\n                CurrencyID: CurrencyID.ETH,\n                IsGasToken: true,\n                Name: CurrencyID[CurrencyID.ETH],\n                PermitContractVersion: 0,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported,\n                TokenContractAddress: convertTo32BytesHex(EADDRESS),\n                TokenDecimals: 18,\n            },\n        ],\n    ],\n    [\n        8453,\n        [\n            {\n                CurrencyID: CurrencyID.WETH,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.WETH],\n                PermitContractVersion: 0,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported,\n                TokenContractAddress: convertTo32BytesHex('0x4200000000000000000000000000000000000006'),\n                TokenDecimals: 18,\n            },\n            {\n                CurrencyID: CurrencyID.USDC,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.USDC],\n                PermitContractVersion: 2,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'),\n                TokenDecimals: 6,\n            },\n            {\n                CurrencyID: CurrencyID.USDT,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.USDT],\n                PermitContractVersion: 0,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported,\n                TokenContractAddress: convertTo32BytesHex('0xfde4c96c8593536e31f229ea8f37b2ada2699bb2'),\n                TokenDecimals: 6,\n            },\n            {\n                CurrencyID: CurrencyID.USDS,\n                IsGasToken: false,\n                Name: CurrencyID[CurrencyID.USDS],\n                PermitContractVersion: 1,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.EIP2612Canonical,\n                TokenContractAddress: convertTo32BytesHex('0x820C137fa70C8691f0e44Dc420a5e53c168921Dc'),\n                TokenDecimals: 18,\n            },\n            {\n                CurrencyID: CurrencyID.ETH,\n                IsGasToken: true,\n                Name: CurrencyID[CurrencyID.ETH],\n                PermitContractVersion: 0,\n                PermitVariant: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported,\n                TokenContractAddress: convertTo32BytesHex(EADDRESS),\n                TokenDecimals: 18,\n            },\n        ],\n    ],\n]);\nconst filterSupportedTokens = (tokens) => {\n    return tokens.filter((t) => {\n        const d = chainData.get(t.chainID);\n        if (!d) {\n            return false;\n        }\n        const token = d.find((dt) => equalFold(dt.TokenContractAddress, t.tokenAddress));\n        if (!token) {\n            return false;\n        }\n        if (token.IsGasToken) {\n            return true;\n        }\n        // if (token.PermitVariant === PermitVariant.Unsupported) {\n        //   return false;\n        // }\n        return true;\n    });\n};\nconst getTokenVersion = (tokenAddress) => {\n    for (const [, tokens] of chainData.entries()) {\n        const t = tokens.find((t) => equalFold(convertTo32BytesHex(tokenAddress), t.TokenContractAddress));\n        if (t) {\n            return { variant: t.PermitVariant, version: t.PermitContractVersion };\n        }\n    }\n    throw new Error('token not available or has no version');\n};\nconst getTokenDecimals = (chainID, contractAddress) => {\n    const cData = chainData.get(Number(chainID));\n    if (!cData) {\n        throw new Error(`chain data not found for chain:${chainID}`);\n    }\n    const token = cData.find((c) => equalFold((0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(contractAddress), c.TokenContractAddress));\n    if (!token) {\n        throw new Error(`token not found: ${(0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(contractAddress)}`);\n    }\n    return {\n        decimals: token.TokenDecimals,\n        symbol: CurrencyID[token.CurrencyID],\n    };\n};\n\nconst ErrorChainDataNotFound = new Error('Chain data not found.');\nconst ErrorCOTNotFound = (chainID) => new Error(`COT not found on chain: ${chainID}`);\nconst ErrorTokenNotFound = (address, chainID) => new Error(`Token(${address}) not found on chain: ${chainID}`);\nconst ErrorInsufficientBalance = (available, required) => new Error(`Insufficient balance: available:${available}, required:${required}.`);\n\nconst logger$b = getLogger();\nconst createEmptyIntent = ({ chainID }) => ({\n    allSources: [],\n    destination: {\n        amount: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0),\n        chainID,\n        decimals: 6,\n        gas: 0n,\n        tokenContract: '0x',\n        universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    },\n    fees: {\n        caGas: '0',\n        collection: '0',\n        fulfilment: '0',\n        gasSupplied: '0',\n        protocol: '0',\n        solver: '0',\n    },\n    isAvailableBalanceInsufficient: false,\n    sources: [],\n});\nconst createIntent = ({ assets, feeStore, output, }) => {\n    const eoaToEphemeralCalls = {};\n    const intent = createEmptyIntent({ chainID: output.chainID });\n    let borrow = output.amount;\n    intent.destination.amount = borrow;\n    intent.destination.tokenContract = output.tokenAddress;\n    const protocolFee = feeStore.calculateProtocolFee(borrow);\n    borrow = borrow.add(protocolFee);\n    intent.fees.protocol = protocolFee.toFixed();\n    const fulfilmentFee = feeStore.calculateFulfilmentFee({\n        decimals: output.decimals,\n        destinationChainID: output.chainID,\n        destinationTokenAddress: output.tokenAddress,\n    });\n    borrow = borrow.add(fulfilmentFee);\n    intent.fees.fulfilment = fulfilmentFee.toFixed();\n    let accountedBalance = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n    logger$b.debug('createBridgeRFF:1', {\n        assets: assets.map((i) => ({\n            ...i,\n            eoaBalance: i.eoaBalance.toFixed(),\n            ephemeralBalance: i.ephemeralBalance.toFixed(),\n        })),\n        borrow: borrow.toFixed(),\n        fulfilmentFee: fulfilmentFee.toFixed(),\n        protocolFee: protocolFee.toFixed(),\n    });\n    for (const asset of assets) {\n        if (asset.chainID === output.chainID ||\n            decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(asset.eoaBalance, asset.ephemeralBalance).lte(0)) {\n            continue;\n        }\n        if (accountedBalance.gte(borrow)) {\n            break;\n        }\n        const unaccountedBalance = borrow.minus(accountedBalance);\n        const estimatedBorrowFromThisChain = decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(asset.eoaBalance.toString(), asset.ephemeralBalance.toString()).lte(unaccountedBalance)\n            ? decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(asset.eoaBalance.toString(), asset.ephemeralBalance.toString())\n            : unaccountedBalance;\n        const solverFee = feeStore.calculateSolverFee({\n            borrowAmount: estimatedBorrowFromThisChain,\n            decimals: asset.decimals,\n            destinationChainID: output.chainID,\n            destinationTokenAddress: output.tokenAddress,\n            sourceChainID: asset.chainID,\n            sourceTokenAddress: asset.contractAddress,\n        });\n        intent.fees.solver = solverFee.add(intent.fees.solver).toFixed();\n        borrow = borrow.add(solverFee);\n        const unaccountedBalance2 = borrow.minus(accountedBalance);\n        let borrowFromThisChain = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n        if (decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(asset.eoaBalance, asset.ephemeralBalance).lte(unaccountedBalance2)) {\n            logger$b.debug('createBridgeRFF:2.1', {\n                assetBalance: decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(asset.eoaBalance.toString(), asset.ephemeralBalance.toString()).toFixed(),\n                unaccountedBalance: unaccountedBalance2.toFixed(),\n            });\n            borrowFromThisChain = decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(asset.eoaBalance.toString(), asset.ephemeralBalance.toString());\n            // Create allowance and deposit tx for (asset.eoaBalance) from usdc(eoa) -> usdc(eph)\n            if (!asset.eoaBalance.eq(0)) {\n                eoaToEphemeralCalls[asset.chainID] = {\n                    amount: mulDecimals(asset.eoaBalance, asset.decimals),\n                    decimals: asset.decimals,\n                    tokenAddress: asset.contractAddress,\n                };\n            }\n        }\n        else {\n            borrowFromThisChain = unaccountedBalance2;\n            if (borrowFromThisChain.gt(asset.ephemeralBalance.toString())) {\n                logger$b.debug('createBridgeRFF:2.2', {\n                    assetEphemeral: asset.ephemeralBalance,\n                    borrowFromThisChain: borrowFromThisChain.toFixed(),\n                });\n                eoaToEphemeralCalls[asset.chainID] = {\n                    amount: mulDecimals(borrowFromThisChain.minus(asset.ephemeralBalance.toString()), asset.decimals),\n                    decimals: asset.decimals,\n                    tokenAddress: asset.contractAddress,\n                };\n            }\n        }\n        intent.sources.push({\n            amount: borrowFromThisChain,\n            chainID: asset.chainID,\n            tokenContract: asset.contractAddress,\n            universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n        });\n        accountedBalance = accountedBalance.add(borrowFromThisChain);\n    }\n    if (accountedBalance < borrow) {\n        intent.isAvailableBalanceInsufficient = true;\n    }\n    return { eoaToEphemeralCalls, intent };\n};\nconst createBridgeRFF = async ({ config, input, output, }) => {\n    logger$b.debug('createBridgeRFF', { input, output });\n    const feeStore = await getFeeStore(config.network.GRPC_URL);\n    const depositCalls = {};\n    const { eoaToEphemeralCalls, intent } = createIntent({\n        assets: input.assets,\n        feeStore,\n        output,\n    });\n    if (intent.isAvailableBalanceInsufficient) {\n        throw ErrorInsufficientBalance$1;\n    }\n    const { msgBasicCosmos, omniversalRFF, signatureData, sources } = await createRFFromIntent(intent, {\n        chainList: config.chainList,\n        cosmos: {\n            address: config.cosmos.address,\n            client: config.cosmos.wallet,\n        },\n        evm: {\n            address: config.evm.address,\n            client: config.evm.client,\n        },\n    }, _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM);\n    logger$b.debug('createIntent', { intent });\n    let intentID = long__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fromNumber(0);\n    const createRFF = async () => {\n        intentID = await cosmosCreateRFF({\n            address: config.cosmos.address,\n            cosmosURL: config.network.COSMOS_URL,\n            msg: msgBasicCosmos,\n            wallet: config.cosmos.wallet,\n        });\n        storeIntentHashToStore(config.evm.address, intentID.toNumber());\n        const doubleCheckTxMap = {};\n        omniversalRFF.protobufRFF.sources.map((s) => {\n            doubleCheckTxMap[(0,viem__WEBPACK_IMPORTED_MODULE_29__.bytesToNumber)(s.chainID)] = createDoubleCheckTx(s.chainID, config.cosmos, intentID, config.network.COSMOS_URL);\n        });\n        return {\n            createDoubleCheckTx: async () => {\n                try {\n                    for (const k in doubleCheckTxMap) {\n                        logger$b.debug('Starting double check tx', { chain: k });\n                        await doubleCheckTxMap[k]();\n                    }\n                }\n                catch (error) {\n                    logger$b.error('Error during double check tx', error);\n                }\n            },\n            intentID,\n        };\n    };\n    const allowances = await getAllowances(intent.sources.map((s) => ({\n        chainID: s.chainID,\n        tokenContract: s.tokenContract,\n    })), config.evm.address, config.chainList);\n    for (const [index, source] of sources.entries()) {\n        const evmSignatureData = signatureData.find((s) => s.universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM);\n        if (!evmSignatureData) {\n            throw new Error('Unknown signature type');\n        }\n        const chain = config.chainList.getChainByID(Number(source.chainID));\n        if (!chain) {\n            throw new Error('chain not found');\n        }\n        const allowance = allowances[Number(source.chainID)];\n        logger$b.debug('allowances', { allowance, chainID: Number(source.chainID) });\n        if (allowance == null) {\n            throw new Error('Allowance not applicable');\n        }\n        const tx = [];\n        if (allowance < source.value) {\n            const allowanceTx = {\n                data: packERC20Approve(config.chainList.getVaultContractAddress(Number(source.chainID))),\n                to: convertAddressByUniverse(source.tokenAddress, _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM),\n                value: 0n,\n            };\n            tx.push(allowanceTx);\n        }\n        console.log({\n            argsForRFFDeposit: [\n                omniversalRFF.asEVMRFF(),\n                (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(evmSignatureData.signature),\n                BigInt(index),\n            ],\n        });\n        tx.push({\n            data: (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n                abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.EVMVaultABI,\n                args: [omniversalRFF.asEVMRFF(), (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(evmSignatureData.signature), BigInt(index)],\n                functionName: 'deposit',\n            }),\n            to: config.chainList.getVaultContractAddress(Number(source.chainID)),\n            value: 0n,\n        });\n        depositCalls[Number(source.chainID)] = {\n            amount: source.value,\n            tokenAddress: convertAddressByUniverse(source.tokenAddress, source.universe),\n            tx: tx,\n        };\n    }\n    const chain = config.chainList.getChainByID(Number(output.chainID));\n    if (!chain) {\n        throw new Error('Unknown destination chain');\n    }\n    const ws = (0,viem__WEBPACK_IMPORTED_MODULE_32__.webSocket)(chain.rpcUrls.default.webSocket[0]);\n    const pc = (0,viem__WEBPACK_IMPORTED_MODULE_21__.createPublicClient)({\n        transport: ws,\n    });\n    const waitForFill = () => {\n        const s = signatureData.find((s) => s.universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM);\n        if (!s) {\n            throw new Error('Unknown signature type');\n        }\n        logger$b.debug(`Waiting for fill: ${intentID}`);\n        const r = {\n            filled: false,\n            intentID,\n            promise: evmWaitForFill(config.chainList.getVaultContractAddress(chain.id), pc, s.requestHash, intentID, config.network.GRPC_URL, config.network.COSMOS_URL),\n        };\n        r.promise.then(() => {\n            r.filled = true;\n            removeIntentHashFromStore(config.evm.address, r.intentID);\n        });\n        return r;\n    };\n    return {\n        createRFF,\n        depositCalls,\n        eoaToEphemeralCalls,\n        intent,\n        waitForFill,\n    };\n};\nconst createDoubleCheckTx = (chainID, cosmos, intentID, cosmosURL) => {\n    const msg = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.MsgDoubleCheckTx.create({\n        creator: cosmos.address,\n        packet: {\n            $case: 'depositPacket',\n            value: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.DepositVEPacket.create({\n                gasRefunded: false,\n                id: intentID,\n            }),\n        },\n        txChainID: chainID,\n        txUniverse: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n    });\n    return () => {\n        return cosmosCreateDoubleCheckTx({\n            address: cosmos.address,\n            cosmosURL,\n            msg,\n            wallet: cosmos.wallet,\n        });\n    };\n};\n\nconst logger$a = getLogger();\nconst getBalances = async (input) => {\n    const removeTransferFee = input.removeTransferFee ?? false;\n    const filter = input.filter ?? true;\n    const [ankrBalances, evmBalances, fuelBalances] = await Promise.all([\n        input.networkHint === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Environment.FOLLY\n            ? Promise.resolve([])\n            : getAnkrBalances(input.evmAddress, input.chainList, removeTransferFee),\n        getEVMBalancesForAddress(input.vscDomain, input.evmAddress),\n        input.fuelAddress\n            ? getFuelBalancesForAddress(input.vscDomain, input.fuelAddress)\n            : Promise.resolve([]),\n    ]);\n    const assets = balancesToAssets(ankrBalances, evmBalances, fuelBalances, input.chainList);\n    let balances = toFlatBalance(assets);\n    if (filter) {\n        balances = filterSupportedTokens(balances);\n    }\n    logger$a.debug('getBalances', {\n        assets,\n        balances,\n        removeTransferFee,\n    });\n    return { assets, balances };\n};\nconst determineSwapRoute = async (input, options) => {\n    logger$a.debug('determineSwapRoute', {\n        input,\n        options,\n    });\n    if (input.mode === _commons__WEBPACK_IMPORTED_MODULE_0__.SwapMode.EXACT_OUT) {\n        return _exactOutRoute(input.data, options);\n    }\n    else {\n        return _exactInRoute(input.data, options);\n    }\n};\nconst _exactOutRoute = async (input, params) => {\n    const [feeStore, { assets, balances }, oraclePrices] = await Promise.all([\n        getFeeStore(params.networkConfig.GRPC_URL),\n        getBalances({\n            networkHint: params.networkConfig.NETWORK_HINT,\n            evmAddress: params.address.eoa,\n            chainList: params.chainList,\n            removeTransferFee: true,\n            filter: true,\n            vscDomain: params.networkConfig.VSC_DOMAIN,\n        }),\n        fetchPriceOracle(params.networkConfig.GRPC_URL),\n    ]);\n    // Any existing COT balance on dst chain\n    let dstEOAToEphTx = null;\n    logger$a.debug('determineSwapRoute', { assets, balances, input });\n    const userAddressInBytes = convertTo32Bytes(params.address.ephemeral);\n    const dstOmniversalChainID = new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.OmniversalChainID(_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM, input.toChainId);\n    logger$a.debug('determineSwapRoute:destinationSwapInput', {\n        dstOmniversalChainID,\n        s: {\n            amount: BigInt(input.toAmount),\n            tokenAddress: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(input.toTokenAddress),\n        },\n        userAddressInBytes,\n    });\n    const dstChainDataMap = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ChaindataMap.get(dstOmniversalChainID);\n    if (!dstChainDataMap) {\n        throw ErrorChainDataNotFound;\n    }\n    const cotSymbol = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.CurrencyID[params.cotCurrencyID];\n    const dstChainCOT = dstChainDataMap.Currencies.find((c) => c.currencyID === params.cotCurrencyID);\n    if (!dstChainCOT) {\n        throw ErrorCOTNotFound(input.toChainId);\n    }\n    const dstChainCOTAddress = convertToEVMAddress(dstChainCOT.tokenAddress);\n    const dstChainCOTBalance = balances.find((b) => b.chainID === Number(input.toChainId) &&\n        equalFold(convertToEVMAddress(b.tokenAddress), dstChainCOTAddress));\n    const getDDS = async () => {\n        let dds = {\n            aggregator: params.aggregators[0],\n            inputAmount: divDecimals(input.toAmount, dstChainCOT.decimals),\n            outputAmount: 0n,\n            quote: null,\n        };\n        // If output token is not COT then only destination swap should exist\n        if (!equalFold(input.toTokenAddress, dstChainCOTAddress)) {\n            dds = await (0,_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.determineDestinationSwaps)(userAddressInBytes, null, dstOmniversalChainID, {\n                amount: BigInt(input.toAmount),\n                tokenAddress: convertTo32Bytes(input.toTokenAddress),\n            }, params.aggregators);\n        }\n        const createdAt = Date.now();\n        // If destination has COT then need to send it to ephemeral so that it can be used in swap\n        if (new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](dstChainCOTBalance?.amount ?? 0).gt(0)) {\n            dstEOAToEphTx = {\n                amount: mulDecimals(dstChainCOTBalance?.amount ?? 0, dstChainCOTBalance?.decimals ?? 0),\n                contractAddress: dstChainCOTAddress,\n            };\n        }\n        return {\n            ...dds,\n            createdAt,\n            dstChainCOT: dstChainCOT,\n            dstEOAToEphTx,\n            inputAmountWithBuffer: dds.inputAmount\n                .mul(1.02)\n                .toDP(dstChainCOT.decimals, decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ROUND_CEIL),\n            req: {\n                chain: dstOmniversalChainID,\n                inputToken: dstChainCOT.tokenAddress,\n                outputToken: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(input.toTokenAddress),\n            },\n        };\n    };\n    const destinationSwap = await getDDS();\n    logger$a.debug('destination swaps', destinationSwap);\n    const cotAsset = assets.find((asset) => {\n        return asset.abstracted && equalFold(asset.symbol, cotSymbol);\n    });\n    const dstSwapInputAmountInDecimal = destinationSwap.inputAmount\n        .mul(1.02)\n        .toDP(dstChainCOT.decimals, decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ROUND_CEIL);\n    logger$a.debug('determineSwapRoute:3', {\n        cotAsset,\n        dstChainCOTAddress,\n        dstChainCOTBalance,\n    });\n    const cotTotalBalance = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](cotAsset?.balance ?? '0');\n    const fulfilmentFee = feeStore.calculateFulfilmentFee({\n        decimals: dstChainCOT.decimals,\n        destinationChainID: Number(input.toChainId),\n        destinationTokenAddress: dstChainCOTAddress,\n    });\n    const fees = fulfilmentFee;\n    logger$a.debug('determineSwapRoute:4', {\n        cotAsset,\n        cotTotalBalance: cotTotalBalance.toFixed(),\n        diff: fees.toFixed(),\n        dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),\n    });\n    console.log({ cotAsset, dstChainCOTBalance });\n    let sourceSwaps = [];\n    let sourceSwapsRequired = false;\n    if (!dstChainCOTBalance) {\n        sourceSwapsRequired = true;\n    }\n    if (!cotAsset || new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](cotAsset.balance).lt(dstSwapInputAmountInDecimal)) {\n        sourceSwapsRequired = true;\n    }\n    if (sourceSwapsRequired) {\n        sourceSwaps = await (0,_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.autoSelectSources)(userAddressInBytes, balances.map((balance) => ({\n            amount: mulDecimals(balance.amount, balance.decimals),\n            chainID: new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.OmniversalChainID(balance.universe, balance.chainID),\n            tokenAddress: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(balance.tokenAddress),\n            value: balance.value,\n        })), dstSwapInputAmountInDecimal\n            .add(fees)\n            .mul(1.01)\n            .minus(cotAsset?.balance ?? '0'), params.aggregators, feeStore.data.fee.collection.map((f) => ({\n            ...f,\n            chainID: convertTo32Bytes(Number(f.chainID)),\n            fee: convertTo32Bytes(BigInt(f.fee)),\n            tokenAddress: convertTo32Bytes(f.tokenAddress),\n        })));\n    }\n    const sourceSwapCreationTime = Date.now();\n    console.log({\n        dstChainCOTBalance,\n        inequality: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](dstChainCOTBalance?.amount ?? 0).lt(dstSwapInputAmountInDecimal.add(fees)),\n    });\n    let bridgeInput = null;\n    const bridgeAssets = cotAsset?.breakdown.map((b) => ({\n        chainID: b.chain.id,\n        contractAddress: b.contractAddress,\n        decimals: b.decimals,\n        eoaBalance: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](b.balance),\n        ephemeralBalance: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0),\n    })) ?? [];\n    if (new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](dstChainCOTBalance?.amount ?? 0n).lt(dstSwapInputAmountInDecimal.add(fees))) {\n        // If swap happens to COT on destination chain\n        // then that amount doesn't needs to be in RFF\n        let dstCOTSwapAmount = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n        for (const swap of sourceSwaps) {\n            const bAsset = bridgeAssets.find((ba) => {\n                return (ba.chainID === Number(swap.req.chain.chainID) &&\n                    equalFold(ba.contractAddress, convertToEVMAddress(swap.req.outputToken)));\n            });\n            const token = params.chainList.getTokenByAddress(Number(swap.req.chain.chainID), convertToEVMAddress(swap.req.outputToken));\n            if (!token) {\n                throw ErrorTokenNotFound(convertToEVMAddress(swap.req.outputToken), Number(swap.req.chain.chainID));\n            }\n            const outputAmount = swap.quote.outputAmountMinimum;\n            if (bAsset) {\n                bAsset.ephemeralBalance = decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(bAsset.ephemeralBalance, divDecimals(outputAmount, token.decimals));\n            }\n            else {\n                bridgeAssets.push({\n                    chainID: Number(swap.req.chain.chainID),\n                    contractAddress: convertToEVMAddress(swap.req.outputToken),\n                    decimals: token.decimals,\n                    eoaBalance: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0),\n                    ephemeralBalance: divDecimals(outputAmount, token.decimals),\n                });\n            }\n            if (Number(swap.req.chain.chainID) === input.toChainId) {\n                dstCOTSwapAmount = dstCOTSwapAmount.plus(divDecimals(outputAmount, token.decimals));\n            }\n            logger$a.debug('determineSwapRoute:sourceSwap', {\n                outputAmountLikely: swap.quote.outputAmountLikely ?? 0,\n                outputAmountMinimum: swap.quote.outputAmountMinimum ?? 0,\n                swap,\n            });\n        }\n        // If COT from source swap at destination chain + existing COT accounts\n        // for requirement then RFF shouldn't be created\n        if (new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](dstChainCOTBalance?.amount ?? 0)\n            .plus(dstCOTSwapAmount)\n            .lt(dstSwapInputAmountInDecimal)) {\n            bridgeInput = {\n                amount: dstSwapInputAmountInDecimal\n                    .minus(dstChainCOTBalance?.amount ?? 0)\n                    .minus(dstCOTSwapAmount),\n                assets: bridgeAssets,\n                chainID: input.toChainId,\n                decimals: dstChainCOT.decimals,\n                tokenAddress: convertToEVMAddress(dstChainCOT.tokenAddress),\n            };\n        }\n    }\n    const assetsUsed = [];\n    for (const swap of sourceSwaps) {\n        const { decimals, symbol } = getTokenDecimals(Number(swap.req.chain.chainID), swap.req.inputToken);\n        assetsUsed.push({\n            amount: divDecimals(swap.quote.inputAmount, decimals).toFixed(),\n            chainID: Number(swap.req.chain.chainID),\n            contractAddress: convertToEVMAddress(swap.req.inputToken),\n            decimals,\n            symbol,\n        });\n    }\n    if (bridgeInput) {\n        const { eoaToEphemeralCalls } = createIntent({\n            assets: bridgeAssets,\n            feeStore,\n            output: bridgeInput,\n        });\n        for (const chain in eoaToEphemeralCalls) {\n            assetsUsed.push({\n                amount: divDecimals(eoaToEphemeralCalls[chain].amount, eoaToEphemeralCalls[chain].decimals).toFixed(),\n                chainID: Number(chain),\n                contractAddress: eoaToEphemeralCalls[chain].tokenAddress,\n                decimals: eoaToEphemeralCalls[chain].decimals,\n                symbol: cotSymbol,\n            });\n        }\n    }\n    return {\n        aggregators: params.aggregators,\n        assetsUsed,\n        balances,\n        bridgeInput,\n        cotSymbol,\n        destinationSwap,\n        getDDS,\n        oraclePrices,\n        sourceSwapCreationTime,\n        sourceSwaps,\n    };\n};\nconst calculateMaxBridgeFees = ({ assets, feeStore, dst, }) => {\n    const borrow = assets.reduce((accumulator, asset) => {\n        return accumulator.add(decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(asset.eoaBalance, asset.ephemeralBalance));\n    }, new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0));\n    const protocolFee = feeStore.calculateProtocolFee(new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](borrow));\n    let borrowWithFee = borrow.add(protocolFee);\n    const fulfilmentFee = feeStore.calculateFulfilmentFee({\n        decimals: dst.decimals,\n        destinationChainID: dst.chainId,\n        destinationTokenAddress: dst.tokenAddress,\n    });\n    borrowWithFee = borrowWithFee.add(fulfilmentFee);\n    logger$a.debug('calculateMaxBridgeFees:1', {\n        borrow: borrow.toFixed(),\n        protocolFee: protocolFee.toFixed(),\n        fulfilmentFee: fulfilmentFee.toFixed(),\n        borrowWithFee: borrowWithFee.toFixed(),\n    });\n    for (const asset of assets) {\n        const solverFee = feeStore.calculateSolverFee({\n            borrowAmount: decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(asset.eoaBalance, asset.ephemeralBalance),\n            decimals: asset.decimals,\n            destinationChainID: dst.chainId,\n            destinationTokenAddress: dst.tokenAddress,\n            sourceChainID: asset.chainID,\n            sourceTokenAddress: convertToEVMAddress(asset.contractAddress),\n        });\n        borrowWithFee = borrowWithFee.add(solverFee);\n        logger$a.debug('calculateMaxBridgeFees:2', {\n            borrow: borrow.toFixed(),\n            borrowWithFee: borrowWithFee.toFixed(),\n            solverFee: solverFee.toFixed(),\n        });\n    }\n    return borrowWithFee.minus(borrow);\n};\nconst _exactInRoute = async (input, params) => {\n    logger$a.debug('exactInRoute', {\n        input,\n        params,\n    });\n    const [feeStore, balanceResponse, oraclePrices] = await Promise.all([\n        getFeeStore(params.networkConfig.GRPC_URL),\n        getBalances({\n            networkHint: params.networkConfig.NETWORK_HINT,\n            evmAddress: params.address.eoa,\n            chainList: params.chainList,\n            removeTransferFee: true,\n            vscDomain: params.networkConfig.VSC_DOMAIN,\n        }),\n        fetchPriceOracle(params.networkConfig.GRPC_URL),\n    ]);\n    let { balances } = balanceResponse;\n    logger$a.debug('ExactIN:1', {\n        balances,\n    });\n    const assetsUsed = [];\n    let srcBalances = [];\n    if (input.from) {\n        for (const f of input.from) {\n            const srcBalance = balances.find((b) => {\n                logger$a.debug('ExactIN:2:input.src', {\n                    a: b.tokenAddress,\n                    b: convertTo32BytesHex(f.tokenAddress),\n                });\n                // We are keeping ZERO_ADDRESS as EAddress so have to make the comparisonAddr like this\n                let comparisonTokenAddress = convertTo32BytesHex(f.tokenAddress);\n                if (equalFold(comparisonTokenAddress, ZERO_ADDRESS)) {\n                    comparisonTokenAddress = EADDRESS;\n                }\n                return equalFold(b.tokenAddress, comparisonTokenAddress) && f.chainId === b.chainID;\n            });\n            if (!srcBalance) {\n                throw ErrorInsufficientBalance(f.amount.toString(), '0');\n            }\n            const requiredBalance = divDecimals(f.amount, srcBalance.decimals);\n            if (requiredBalance.gt(srcBalance.amount)) {\n                throw ErrorInsufficientBalance(srcBalance.amount, requiredBalance.toFixed());\n            }\n            srcBalances.push({\n                ...srcBalance,\n                amount: requiredBalance.toFixed(),\n                value: calculateValue(srcBalance.amount, srcBalance.value, f.amount).toNumber(),\n            });\n            assetsUsed.push({\n                amount: requiredBalance.toFixed(),\n                chainID: srcBalance.chainID,\n                contractAddress: srcBalance.tokenAddress,\n                decimals: srcBalance.decimals,\n                symbol: srcBalance.symbol,\n            });\n        }\n        // } else {\n        //   throw new Error('should have gone to single source swap route');\n        // }\n    }\n    else {\n        srcBalances = balances;\n    }\n    logger$a.debug('ExactIN:3', {\n        srcBalances,\n        assetsUsed,\n    });\n    const userAddressInBytes = convertTo32Bytes(params.address.ephemeral);\n    const dstOmniversalChainID = new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.OmniversalChainID(_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM, input.toChainId);\n    const dstChainDataMap = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ChaindataMap.get(dstOmniversalChainID);\n    if (!dstChainDataMap) {\n        throw new Error('chaindataMap not found');\n    }\n    const cotSymbol = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.CurrencyID[params.cotCurrencyID];\n    const dstChainCOT = dstChainDataMap.Currencies.find((c) => c.currencyID === params.cotCurrencyID);\n    if (!dstChainCOT) {\n        throw ErrorCOTNotFound(input.toChainId);\n    }\n    const dstChainCOTAddress = convertToEVMAddress(dstChainCOT.tokenAddress);\n    const bridgeAssets = [];\n    // Filter out COT's in sources\n    const cotSources = [];\n    let cotCombinedBalance = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n    for (const source of srcBalances) {\n        const cot = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ChaindataMap.get(new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.OmniversalChainID(_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM, source.chainID))?.Currencies.find((c) => c.currencyID === params.cotCurrencyID);\n        if (cot &&\n            equalFold(convertToEVMAddress(source.tokenAddress), convertToEVMAddress(cot.tokenAddress))) {\n            cotSources.push(source);\n            cotCombinedBalance = cotCombinedBalance.add(source.amount);\n            bridgeAssets.push({\n                chainID: source.chainID,\n                contractAddress: convertToEVMAddress(source.tokenAddress),\n                decimals: source.decimals,\n                eoaBalance: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](source.amount),\n                ephemeralBalance: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0),\n            });\n        }\n    }\n    logger$a.debug('ExactIN:4', {\n        cotCombinedBalance,\n        cotSources,\n        bridgeAssets,\n    });\n    // Add COT's to bridge asset eoaBalance\n    // Check if source swap is required (if all source balances are not COT currencyID)\n    const isSrcSwapRequired = cotSources.length !== srcBalances.length;\n    // Check if bridge is required (if all source balances are not on destination chain)\n    const isBridgeRequired = !srcBalances.every((b) => b.chainID === input.toChainId);\n    logger$a.debug('ExactIN:5', {\n        isSrcSwapRequired,\n        isBridgeRequired,\n    });\n    let sourceSwaps = [];\n    if (isSrcSwapRequired) {\n        const response = await (0,_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.liquidateInputHoldings)(userAddressInBytes, srcBalances.map((b) => ({\n            amount: mulDecimals(b.amount, b.decimals),\n            chainID: new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.OmniversalChainID(b.universe, b.chainID),\n            tokenAddress: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(b.tokenAddress),\n            value: b.value,\n        })), params.aggregators, feeStore.data.fee.collection.map((f) => ({\n            chainID: convertTo32Bytes(Number(f.chainID)),\n            fee: convertTo32Bytes(BigInt(f.fee)),\n            tokenAddress: convertTo32Bytes(f.tokenAddress),\n            universe: f.universe,\n        })));\n        sourceSwaps = response.quotes;\n    }\n    const sourceSwapCreationTime = Date.now();\n    let swapCombinedBalance = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n    for (const swap of sourceSwaps) {\n        const outputTokenAddress = convertToEVMAddress(swap.req.outputToken);\n        const token = params.chainList.getTokenByAddress(Number(swap.req.chain.chainID), outputTokenAddress);\n        if (!token) {\n            throw ErrorTokenNotFound(outputTokenAddress, Number(swap.req.chain.chainID));\n        }\n        const bridgeAsset = bridgeAssets.find((b) => equalFold(b.contractAddress, outputTokenAddress));\n        const outputAmountInDecimal = divDecimals(swap.quote.outputAmountMinimum, token.decimals);\n        if (bridgeAsset) {\n            bridgeAsset.ephemeralBalance = bridgeAsset.ephemeralBalance.add(outputAmountInDecimal);\n        }\n        else {\n            bridgeAssets.push({\n                chainID: Number(swap.req.chain.chainID),\n                contractAddress: outputTokenAddress,\n                decimals: token.decimals,\n                eoaBalance: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0),\n                ephemeralBalance: outputAmountInDecimal,\n            });\n        }\n        swapCombinedBalance = swapCombinedBalance.add(outputAmountInDecimal);\n    }\n    let dstSwapInputAmountInDecimal = decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(cotCombinedBalance, swapCombinedBalance);\n    logger$a.debug('ExactIN:6', {\n        dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),\n        bridgeAssets,\n    });\n    let bridgeInput = null;\n    if (isBridgeRequired) {\n        const maxFee = calculateMaxBridgeFees({\n            assets: bridgeAssets,\n            dst: {\n                chainId: input.toChainId,\n                tokenAddress: dstChainCOTAddress,\n                decimals: dstChainCOT.decimals,\n            },\n            feeStore,\n        });\n        dstSwapInputAmountInDecimal = dstSwapInputAmountInDecimal.minus(maxFee).mul(0.98);\n        logger$a.debug('ExactIN:7', {\n            dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),\n            maxFee: maxFee.toFixed(),\n        });\n        bridgeInput = {\n            amount: dstSwapInputAmountInDecimal,\n            assets: bridgeAssets,\n            chainID: input.toChainId,\n            decimals: dstChainCOT.decimals,\n            tokenAddress: convertToEVMAddress(dstChainCOT.tokenAddress),\n        };\n    }\n    logger$a.debug('beforeDDS: ExactIN', {\n        dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),\n    });\n    const getDDS = async () => {\n        let dds = {\n            aggregator: params.aggregators[0],\n            inputAmount: dstSwapInputAmountInDecimal,\n            outputAmount: mulDecimals(dstSwapInputAmountInDecimal, dstChainCOT.decimals),\n            quote: null,\n        };\n        logger$a.debug('getDDS: ExactIN: Before', {\n            dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),\n        });\n        dstSwapInputAmountInDecimal = dstSwapInputAmountInDecimal.toDP(dstChainCOT.decimals, decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ROUND_FLOOR);\n        // If toTokenAddress is not same as cot then create dstSwap\n        if (!equalFold(input.toTokenAddress, dstChainCOTAddress)) {\n            dds = await (0,_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.destinationSwapWithExactIn)(userAddressInBytes, dstOmniversalChainID, mulDecimals(dstSwapInputAmountInDecimal, dstChainCOT.decimals), convertTo32Bytes(input.toTokenAddress), params.aggregators, dstChainCOT.currencyID);\n        }\n        const createdAt = Date.now();\n        let dstEOAToEphTx = null;\n        const hasDstChainCOTInInput = cotSources.find((c) => equalFold(c.tokenAddress, dstChainCOTAddress));\n        if (hasDstChainCOTInInput) {\n            dstEOAToEphTx = {\n                amount: mulDecimals(hasDstChainCOTInInput.amount, hasDstChainCOTInInput.decimals),\n                contractAddress: hasDstChainCOTInInput.tokenAddress,\n            };\n        }\n        logger$a.debug('ExactIN: getDDS: SingleSrcSwap: After', {\n            dds,\n            dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),\n        });\n        return {\n            ...dds,\n            createdAt,\n            dstChainCOT: dstChainCOT,\n            dstEOAToEphTx,\n            inputAmountWithBuffer: dstSwapInputAmountInDecimal,\n            req: {\n                chain: dstOmniversalChainID,\n                inputToken: dstChainCOT.tokenAddress,\n                outputToken: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(input.toTokenAddress),\n            },\n        };\n    };\n    const destinationSwap = await getDDS();\n    logger$a.debug('getSwapRoute: ExactIN: After', {\n        destinationSwap,\n        dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),\n    });\n    return {\n        aggregators: params.aggregators,\n        assetsUsed,\n        balances,\n        bridgeInput,\n        cotSymbol,\n        destinationSwap,\n        getDDS,\n        oraclePrices,\n        sourceSwapCreationTime,\n        sourceSwaps,\n    };\n};\n\nconst logger$9 = getLogger();\nclass BaseRequest {\n    constructor(input) {\n        this.input = input;\n        this.steps = [];\n        this.buildIntent = async (sourceChains = []) => {\n            console.time('process:preIntentSteps');\n            console.time('preIntentSteps:API');\n            const [simulation, [balances, oraclePrices, feeStore]] = await Promise.all([\n                this.simulateTx(),\n                Promise.all([\n                    getBalances({\n                        networkHint: this.input.options.networkConfig.NETWORK_HINT,\n                        vscDomain: this.input.options.networkConfig.VSC_DOMAIN,\n                        evmAddress: this.input.evm.address,\n                        chainList: this.chainList,\n                        fuelAddress: this.input.fuel?.address,\n                    }),\n                    fetchPriceOracle(this.input.options.networkConfig.GRPC_URL),\n                    getFeeStore(this.input.options.networkConfig.GRPC_URL),\n                ]),\n            ]);\n            // if simulation is null, then the transaction is not a supported token transfer, so skip\n            if (!simulation) {\n                return;\n            }\n            console.timeEnd('preIntentSteps:API');\n            logger$9.debug('Step 1:', {\n                balances,\n                feeStore,\n                oraclePrices,\n                simulation,\n            });\n            console.time('preIntentSteps: Parse');\n            const { assets } = balances;\n            // Step 2: parse simulation results\n            const userAssets = new UserAssets(assets);\n            const { amount, gas, isIntentRequired } = this.parseSimulation({\n                assets: userAssets,\n                simulation,\n            });\n            console.timeEnd('preIntentSteps: Parse');\n            if (!isIntentRequired) {\n                return;\n            }\n            console.time('preIntentSteps: CalculateGas');\n            const gasInToken = convertGasToToken(simulation.token, oraclePrices, this.input.chain.id, this.input.chain.universe, gas);\n            console.timeEnd('preIntentSteps: CalculateGas');\n            logger$9.debug('preIntent:1', {\n                gasInNative: gas.toFixed(),\n                gasInToken: gasInToken.toFixed(),\n            });\n            // Step 4: create intent\n            console.time('preIntentSteps: CreateIntent');\n            const intent = this.createIntent({\n                amount,\n                assets: userAssets,\n                feeStore,\n                gas,\n                gasInToken,\n                sourceChains,\n                token: simulation.token,\n            });\n            console.timeEnd('preIntentSteps: CreateIntent');\n            console.timeEnd('process:preIntentSteps');\n            return { intent, token: simulation.token };\n        };\n        this.process = async () => {\n            const i = await this.buildIntent(this.input.options.sourceChains);\n            if (!i) {\n                return;\n            }\n            let intent = i.intent;\n            const token = i.token;\n            if (intent.isAvailableBalanceInsufficient) {\n                throw ErrorInsufficientBalance$1;\n            }\n            // Create steps like a crazy person to create another one again\n            const allowances = await getAllowances(intent.allSources, this.input.evm.address, this.input.chainList);\n            let unallowedSources = this.getUnallowedSources(intent, allowances);\n            this.createExpectedSteps(intent, unallowedSources);\n            let accepted = false;\n            const refresh = async (sourceChains) => {\n                if (accepted) {\n                    logger$9.warn('Intent refresh called after acceptance');\n                    return convertIntent(intent, token, this.chainList);\n                }\n                const i = await this.buildIntent(sourceChains);\n                intent = i.intent;\n                logger$9.debug('in refresh', {\n                    i,\n                    intent,\n                });\n                if (intent.isAvailableBalanceInsufficient) {\n                    throw ErrorInsufficientBalance$1;\n                }\n                unallowedSources = this.getUnallowedSources(intent, allowances);\n                this.createExpectedSteps(intent, unallowedSources);\n                return convertIntent(intent, token, this.chainList);\n            };\n            // wait for intent acceptance hook\n            await new Promise((resolve, reject) => {\n                const allow = () => {\n                    accepted = true;\n                    return resolve('User allowed intent');\n                };\n                const deny = () => {\n                    return reject(ErrorUserDeniedIntent$1);\n                };\n                this.input.hooks.onIntent({\n                    allow,\n                    deny,\n                    intent: convertIntent(intent, token, this.chainList),\n                    refresh,\n                });\n            });\n            this.markStepDone(INTENT_ACCEPTED);\n            console.time('process:AllowanceHook');\n            // Step 5: set allowance if not set\n            await this.waitForOnAllowanceHook(unallowedSources);\n            console.timeEnd('process:AllowanceHook');\n            // FIXME: Add showing intent again if prices change?\n            // Step 6: process intent\n            return await this.processIntent(intent);\n        };\n        this.markStepDone = (step, data) => {\n            const s = this.steps.find((s) => s.typeID === step.typeID);\n            if (s) {\n                this.input.options.emit('step_complete', {\n                    ...s,\n                    ...(data ? { data } : {}),\n                });\n            }\n        };\n        this.chainList = this.input.chainList;\n    }\n    getUnallowedSources(intent, allowances) {\n        const sources = [];\n        for (const s of intent.sources) {\n            if (s.chainID === intent.destination.chainID ||\n                isNativeAddress$1(s.universe, s.tokenContract)) {\n                continue;\n            }\n            const chain = this.chainList.getChainByID(s.chainID);\n            if (!chain) {\n                throw new Error('chain is not supported');\n            }\n            const token = this.chainList.getTokenByAddress(s.chainID, s.tokenContract);\n            if (!token) {\n                throw new Error('token is not supported');\n            }\n            const requiredAllowance = mulDecimals(s.amount, token.decimals);\n            const currentAllowance = allowances[s.chainID] ?? 0n;\n            logger$9.debug('getUnallowedSources:1', {\n                currentAllowance: currentAllowance.toString(),\n                requiredAllowance: requiredAllowance.toString(),\n                token,\n            });\n            if (requiredAllowance > currentAllowance) {\n                const d = {\n                    allowance: {\n                        current: currentAllowance.toString(),\n                        minimum: requiredAllowance.toString(),\n                    },\n                    chain: {\n                        id: chain.id,\n                        logo: chain.custom.icon,\n                        name: chain.name,\n                    },\n                    token: {\n                        contractAddress: token.contractAddress,\n                        decimals: token.decimals,\n                        logo: token.logo || '',\n                        name: token.name,\n                        symbol: token.symbol,\n                    },\n                };\n                sources.push(d);\n            }\n        }\n        return sources;\n    }\n    async processIntent(intent) {\n        logger$9.debug('intent', { intent });\n        const { explorerURL, id, requestHash, waitForDoubleCheckTx } = await this.processRFF(intent);\n        storeIntentHashToStore(this.input.evm.address, id.toNumber());\n        await this.waitForFill(requestHash, id, waitForDoubleCheckTx);\n        removeIntentHashFromStore(this.input.evm.address, id);\n        this.markStepDone(INTENT_FULFILLED);\n        return { explorerURL };\n    }\n    async processRFF(intent) {\n        const { destinations, sources, universes } = getSourcesAndDestinationsForRFF(intent, this.input.chainList, this.destinationUniverse);\n        const parties = [];\n        for (const universe of universes) {\n            if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM) {\n                parties.push({\n                    address: convertTo32BytesHex(this.input.evm.address),\n                    universe: universe,\n                });\n            }\n            if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL) {\n                parties.push({\n                    address: convertTo32BytesHex(this.input.fuel.address),\n                    universe,\n                });\n            }\n        }\n        logger$9.debug('processRFF:1', {\n            destinations,\n            parties,\n            sources,\n            universes,\n        });\n        const omniversalRff = new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.OmniversalRFF({\n            destinationChainID: convertTo32Bytes$1(intent.destination.chainID),\n            destinations: destinations.map((dest) => ({\n                tokenAddress: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(dest.tokenAddress),\n                value: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(dest.value),\n            })),\n            destinationUniverse: intent.destination.universe,\n            expiry: long__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fromString((BigInt(Date.now() + INTENT_EXPIRY) / 1000n).toString()),\n            nonce: window.crypto.getRandomValues(new Uint8Array(32)),\n            // @ts-ignore\n            signatureData: parties.map((p) => ({\n                address: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(p.address),\n                universe: p.universe,\n            })),\n            // @ts-ignore\n            sources: sources.map((source) => ({\n                chainID: convertTo32Bytes$1(source.chainID),\n                tokenAddress: convertTo32Bytes$1(source.tokenAddress),\n                universe: source.universe,\n                value: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(source.value),\n            })),\n        });\n        const signatureData = [];\n        for (const universe of universes) {\n            if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM) {\n                const { requestHash, signature } = await createRequestEVMSignature(omniversalRff.asEVMRFF(), this.input.evm.address, this.input.evm.client);\n                signatureData.push({\n                    address: convertTo32Bytes$1(this.input.evm.address),\n                    requestHash,\n                    signature,\n                    universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n                });\n            }\n            if (universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL) {\n                if (!this.input.fuel?.address ||\n                    !this.input.fuel?.provider ||\n                    !this.input.fuel?.connector) {\n                    logger$9.error('universe has fuel but not expected input', {\n                        fuelInput: this.input.fuel,\n                    });\n                    throw new Error('universe has fuel but not expected input');\n                }\n                const { requestHash, signature } = await createRequestFuelSignature(this.input.chainList.getVaultContractAddress(fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet), this.input.fuel.provider, this.input.fuel.connector, omniversalRff.asFuelRFF());\n                signatureData.push({\n                    address: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(this.input.fuel.address),\n                    requestHash,\n                    signature,\n                    universe: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL,\n                });\n            }\n        }\n        logger$9.debug('processRFF:2', { omniversalRff, signatureData });\n        this.markStepDone(INTENT_HASH_SIGNED);\n        const cosmosWalletAddress = (await this.input.cosmosWallet.getAccounts())[0].address;\n        const msgBasicCosmos = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.MsgCreateRequestForFunds.create({\n            destinationChainID: omniversalRff.protobufRFF.destinationChainID,\n            destinations: omniversalRff.protobufRFF.destinations,\n            destinationUniverse: omniversalRff.protobufRFF.destinationUniverse,\n            expiry: omniversalRff.protobufRFF.expiry,\n            nonce: omniversalRff.protobufRFF.nonce,\n            signatureData: signatureData.map((s) => ({\n                address: s.address,\n                signature: s.signature,\n                universe: s.universe,\n            })),\n            sources: omniversalRff.protobufRFF.sources,\n            user: cosmosWalletAddress,\n        });\n        logger$9.debug('processRFF:3', { msgBasicCosmos });\n        const intentID = await cosmosCreateRFF$1({\n            address: cosmosWalletAddress,\n            cosmosURL: this.input.options.networkConfig.COSMOS_URL,\n            msg: msgBasicCosmos,\n            wallet: this.input.cosmosWallet,\n        });\n        const explorerURL = getExplorerURL(this.input.options.networkConfig.EXPLORER_URL, intentID);\n        this.markStepDone(INTENT_SUBMITTED, {\n            explorerURL,\n            intentID: intentID.toNumber(),\n        });\n        const tokenCollections = [];\n        for (const [i, s] of sources.entries()) {\n            if (!isNativeAddress$1(s.universe, s.tokenAddress)) {\n                tokenCollections.push(i);\n            }\n        }\n        const evmDeposits = [];\n        const fuelDeposits = [];\n        const evmSignatureData = signatureData.find((d) => d.universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM);\n        if (!evmSignatureData && universes.has(_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM)) {\n            throw new Error('ethereum in universe list but no signature data present');\n        }\n        const fuelSignatureData = signatureData.find((d) => d.universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL);\n        if (!fuelSignatureData && universes.has(_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL)) {\n            throw new Error('fuel in universe list but no signature data present');\n        }\n        const doubleCheckTxs = [];\n        for (const [i, s] of sources.entries()) {\n            const chain = this.input.chainList.getChainByID(Number(s.chainID));\n            if (!chain) {\n                throw new Error('chain not found');\n            }\n            if (s.universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL) {\n                if (!this.input.fuel) {\n                    throw new Error('fuel is involved but no associated data');\n                }\n                const account = new fuels__WEBPACK_IMPORTED_MODULE_3__.Account(this.input.fuel.address, this.input.fuel.provider, this.input.fuel.connector);\n                const vault = new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ArcanaVault(this.chainList.getVaultContractAddress(fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet), account);\n                const tx = await vault.functions\n                    .deposit(omniversalRff.asFuelRFF(), (0,fuels__WEBPACK_IMPORTED_MODULE_3__.hexlify)(fuelSignatureData.signature), i)\n                    .callParams({\n                    forward: {\n                        amount: new fuels__WEBPACK_IMPORTED_MODULE_3__.BN(s.value.toString()),\n                        assetId: s.tokenAddress,\n                    },\n                })\n                    .call();\n                this.markStepDone(INTENT_DEPOSIT_REQ(i + 1));\n                fuelDeposits.push((async function () {\n                    const txResult = await tx.waitForResult();\n                    logger$9.debug('PostIntentSubmission: Fuel deposit result', {\n                        txResult,\n                    });\n                    if (txResult.transactionResult.isStatusFailure) {\n                        throw new Error('fuel deposit failed');\n                    }\n                })());\n            }\n            else if (s.universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM && isNativeAddress$1(s.universe, s.tokenAddress)) {\n                const chain = this.input.chainList.getChainByID(Number(s.chainID));\n                if (!chain) {\n                    throw new Error('chain not found');\n                }\n                await switchChain(this.input.evm.client, chain);\n                const publicClient = createPublicClientWithFallback(chain);\n                const { request } = await publicClient.simulateContract({\n                    abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.EVMVaultABI,\n                    account: this.input.evm.address,\n                    address: this.input.chainList.getVaultContractAddress(chain.id),\n                    args: [omniversalRff.asEVMRFF(), (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(evmSignatureData.signature), BigInt(i)],\n                    chain: chain,\n                    functionName: 'deposit',\n                    value: s.value,\n                });\n                const hash = await this.input.evm.client.writeContract(request);\n                this.markStepDone(INTENT_DEPOSIT_REQ(i + 1));\n                evmDeposits.push(waitForTxReceipt(hash, publicClient));\n            }\n            doubleCheckTxs.push(createDepositDoubleCheckTx(convertTo32Bytes$1(chain.id), {\n                address: cosmosWalletAddress,\n                wallet: this.input.cosmosWallet,\n            }, intentID, this.input.options.networkConfig));\n        }\n        if (evmDeposits.length || fuelDeposits.length) {\n            await Promise.all([Promise.all(evmDeposits), Promise.all(fuelDeposits)]);\n            this.markStepDone(INTENT_DEPOSITS_CONFIRMED);\n        }\n        logger$9.debug('PostIntentSubmission: Intent ID', {\n            id: intentID.toNumber(),\n        });\n        if (tokenCollections.length > 0) {\n            logger$9.debug('processRFF', {\n                intentID: intentID.toString(),\n                message: 'going to create RFF',\n                tokenCollections,\n            });\n            await vscCreateRFF(this.input.options.networkConfig.VSC_DOMAIN, intentID, this.markStepDone, tokenCollections);\n        }\n        else {\n            logger$9.debug('processRFF', {\n                message: 'going to publish RFF',\n            });\n            await vscPublishRFF(this.input.options.networkConfig.VSC_DOMAIN, intentID);\n        }\n        const destinationSigData = signatureData.find((s) => s.universe === intent.destination.universe);\n        if (!destinationSigData) {\n            throw new Error('requestHash not found for destination');\n        }\n        return {\n            explorerURL,\n            id: intentID,\n            requestHash: destinationSigData.requestHash,\n            waitForDoubleCheckTx: waitForDoubleCheckTx(doubleCheckTxs),\n        };\n    }\n    async setAllowances(input) {\n        const originalChain = this.input.chain.id;\n        logger$9.debug('setAllowances', { originalChain });\n        const sponsoredApprovalParams = [];\n        try {\n            for (const source of input) {\n                const chain = this.chainList.getChainByID(source.chainID);\n                if (!chain) {\n                    throw new Error('chain not supported');\n                }\n                const publicClient = createPublicClientWithFallback(chain);\n                const vc = this.input.chainList.getVaultContractAddress(chain.id);\n                const chainId = new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.OmniversalChainID(_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM, source.chainID);\n                const chainDatum = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ChaindataMap.get(chainId);\n                if (!chainDatum) {\n                    throw new Error('Chain data not found');\n                }\n                const currency = chainDatum.CurrencyMap.get(convertTo32Bytes$1(source.tokenContract));\n                if (!currency) {\n                    throw new Error('Currency not found');\n                }\n                await switchChain(this.input.evm.client, chain);\n                if (currency.permitVariant === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.Unsupported) {\n                    const h = await this.input.evm.client.writeContract({\n                        abi: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.ERC20ABI,\n                        account: this.input.evm.address,\n                        address: source.tokenContract,\n                        args: [vc, BigInt(source.amount)],\n                        chain,\n                        functionName: 'approve',\n                    });\n                    this.markStepDone(ALLOWANCE_APPROVAL_REQ(source.chainID));\n                    await publicClient.waitForTransactionReceipt({\n                        hash: h,\n                    });\n                    this.markStepDone(ALLOWANCE_APPROVAL_MINED(source.chainID));\n                }\n                else {\n                    const account = {\n                        address: this.input.evm.address,\n                        type: 'json-rpc',\n                    };\n                    const signed = (0,viem__WEBPACK_IMPORTED_MODULE_17__.parseSignature)(await signPermitForAddressAndValue(currency, this.input.evm.client, publicClient, account, vc, source.amount));\n                    this.markStepDone(ALLOWANCE_APPROVAL_REQ(source.chainID));\n                    sponsoredApprovalParams.push({\n                        address: convertTo32Bytes$1(account.address),\n                        chain_id: chainDatum.ChainID32,\n                        operations: [\n                            {\n                                sig_r: (0,viem__WEBPACK_IMPORTED_MODULE_15__.hexToBytes)(signed.r),\n                                sig_s: (0,viem__WEBPACK_IMPORTED_MODULE_15__.hexToBytes)(signed.s),\n                                sig_v: signed.yParity < 27 ? signed.yParity + 27 : signed.yParity,\n                                token_address: currency.tokenAddress,\n                                value: convertTo32Bytes$1(source.amount),\n                                variant: currency.permitVariant === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.PermitVariant.PolygonEMT ? 2 : 1,\n                            },\n                        ],\n                        universe: chainDatum.Universe,\n                    });\n                }\n            }\n            if (sponsoredApprovalParams.length) {\n                await vscCreateSponsoredApprovals(this.input.options.networkConfig.VSC_DOMAIN, sponsoredApprovalParams, this.markStepDone);\n            }\n        }\n        catch (e) {\n            console.error('Error setting allowances', e);\n            throw ErrorUserDeniedAllowance;\n        }\n        finally {\n            if (this.input.chain.universe === _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM) {\n                await switchChain(this.input.evm.client, this.input.chain);\n            }\n            this.markStepDone(ALLOWANCE_COMPLETE);\n        }\n    }\n    async waitForOnAllowanceHook(sources) {\n        if (sources.length === 0) {\n            return false;\n        }\n        await new Promise((resolve, reject) => {\n            const allow = (allowances) => {\n                if (sources.length !== allowances.length) {\n                    return reject(new Error(`invalid input length for allow(). expected: ${sources.length} got: ${allowances.length}`));\n                }\n                const val = [];\n                for (let i = 0; i < sources.length; i++) {\n                    const source = sources[i];\n                    const allowance = allowances[i];\n                    let amount = 0n;\n                    if (typeof allowance === 'string' && equalFold(allowance, 'max')) {\n                        amount = viem__WEBPACK_IMPORTED_MODULE_13__.maxUint256;\n                    }\n                    else if (typeof allowance === 'string' && equalFold(allowance, 'min')) {\n                        amount = mulDecimals(source.allowance.minimum, source.token.decimals);\n                    }\n                    else if (typeof allowance === 'string') {\n                        amount = mulDecimals(allowance, source.token.decimals);\n                    }\n                    else {\n                        amount = allowance;\n                    }\n                    val.push({\n                        amount,\n                        chainID: source.chain.id,\n                        tokenContract: source.token.contractAddress,\n                    });\n                }\n                this.setAllowances(val).then(resolve).catch(reject);\n            };\n            const deny = () => {\n                return reject(ErrorUserDeniedAllowance);\n            };\n            this.input.hooks.onAllowance({\n                allow,\n                deny,\n                sources,\n            });\n        });\n        return true;\n    }\n    createExpectedSteps(intent, unallowedSources) {\n        this.steps = createSteps(intent, this.chainList, unallowedSources);\n        this.input.options.emit('expected_steps', this.steps);\n        logger$9.debug('ExpectedSteps', this.steps);\n    }\n    createIntent(input) {\n        const { amount, assets, feeStore, gas, gasInToken, token } = input;\n        const intent = {\n            allSources: [],\n            destination: {\n                amount: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]('0'),\n                chainID: this.input.chain.id,\n                decimals: token.decimals,\n                gas: 0n,\n                tokenContract: token.contractAddress,\n                universe: this.destinationUniverse,\n            },\n            fees: {\n                caGas: '0',\n                collection: '0',\n                fulfilment: '0',\n                gasSupplied: input.gasInToken.toFixed(),\n                protocol: '0',\n                solver: '0',\n            },\n            isAvailableBalanceInsufficient: false,\n            sources: [],\n        };\n        const asset = assets.find(token.symbol);\n        if (!asset) {\n            throw new Error(`Asset ${token.symbol} not found in UserAssets`);\n        }\n        const allSources = asset.iterate(feeStore).map((v) => ({ ...v, amount: v.balance }));\n        intent.allSources = allSources;\n        const destinationBalance = asset.getBalanceOnChain(this.input.chain.id, token.contractAddress);\n        let borrow = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n        if (this.input.options.bridge) {\n            borrow = amount;\n        }\n        else {\n            if (amount.greaterThan(destinationBalance)) {\n                borrow = amount.minus(destinationBalance);\n            }\n            if (destinationBalance !== '0') {\n                intent.sources.push({\n                    amount: amount.greaterThan(destinationBalance) ? new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](destinationBalance) : amount,\n                    chainID: this.input.chain.id,\n                    tokenContract: token.contractAddress,\n                    universe: this.destinationUniverse,\n                });\n            }\n        }\n        const protocolFee = feeStore.calculateProtocolFee(borrow);\n        intent.fees.protocol = protocolFee.toFixed();\n        let borrowWithFee = borrow.add(gasInToken).add(protocolFee);\n        logger$9.debug('createIntent:0', {\n            borrow: borrow.toFixed(),\n            borrowWithFee: borrowWithFee.toFixed(),\n            destinationBalance,\n            gasInToken: gasInToken.toFixed(),\n            protocolFee: protocolFee.toFixed(),\n        });\n        const fulfilmentFee = feeStore.calculateFulfilmentFee({\n            decimals: token.decimals,\n            destinationChainID: this.input.chain.id,\n            destinationTokenAddress: token.contractAddress,\n        });\n        logger$9.debug('createIntent:1', { fulfilmentFee });\n        intent.fees.fulfilment = fulfilmentFee.toFixed();\n        borrowWithFee = borrowWithFee.add(fulfilmentFee);\n        let accountedAmount = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n        const allowedSources = allSources.filter((b) => {\n            if (input.sourceChains.length === 0) {\n                return true;\n            }\n            return input.sourceChains.includes(b.chainID);\n        });\n        logger$9.debug('createIntent:1.1', { allowedSources });\n        for (const assetC of allowedSources) {\n            if (accountedAmount.greaterThanOrEqualTo(borrowWithFee)) {\n                break;\n            }\n            if (assetC.chainID === this.input.chain.id) {\n                continue;\n            }\n            if (assetC.chainID === fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet) {\n                const fuelChain = this.chainList.getChainByID(fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet);\n                const baseAssetBalanceOnFuel = assets.getNativeBalance(fuelChain);\n                if (new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](baseAssetBalanceOnFuel).lessThan('0.000_003')) {\n                    logger$9.debug('fuel base asset balance is lesser than min expected deposit fee, so skip', {\n                        current: baseAssetBalanceOnFuel,\n                        minimum: '0.000_003',\n                    });\n                    continue;\n                }\n            }\n            if (!isNativeAddress$1(assetC.universe, assetC.tokenContract)) {\n                const collectionFee = feeStore.calculateCollectionFee({\n                    decimals: assetC.decimals,\n                    sourceChainID: assetC.chainID,\n                    sourceTokenAddress: assetC.tokenContract,\n                });\n                intent.fees.collection = collectionFee.add(intent.fees.collection).toFixed();\n                borrowWithFee = borrowWithFee.add(collectionFee);\n                logger$9.debug('createIntent:2', { collectionFee });\n            }\n            const unaccountedAmount = borrowWithFee.minus(accountedAmount);\n            let borrowFromThisChain = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](assetC.balance).lessThanOrEqualTo(unaccountedAmount)\n                ? new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](assetC.balance)\n                : unaccountedAmount;\n            logger$9.debug('createIntent:2.1', {\n                accountedAmount: accountedAmount.toFixed(),\n                asset: assetC,\n                balance: assetC.balance.toFixed(),\n                borrowFromThisChain: borrowFromThisChain.toFixed(),\n                unaccountedAmount: unaccountedAmount.toFixed(),\n            });\n            const solverFee = feeStore.calculateSolverFee({\n                borrowAmount: borrowFromThisChain,\n                decimals: assetC.decimals,\n                destinationChainID: this.input.chain.id,\n                destinationTokenAddress: token.contractAddress,\n                sourceChainID: assetC.chainID,\n                sourceTokenAddress: assetC.tokenContract,\n            });\n            intent.fees.solver = solverFee.add(intent.fees.solver).toFixed();\n            logger$9.debug('createIntent:3', { solverFee });\n            borrowWithFee = borrowWithFee.add(solverFee);\n            const unaccountedBalance = borrowWithFee.minus(accountedAmount);\n            borrowFromThisChain = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](assetC.balance).lessThanOrEqualTo(unaccountedBalance)\n                ? new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](assetC.balance)\n                : unaccountedBalance;\n            intent.sources.push({\n                amount: borrowFromThisChain,\n                chainID: assetC.chainID,\n                tokenContract: assetC.tokenContract,\n                universe: assetC.universe,\n            });\n            accountedAmount = accountedAmount.add(borrowFromThisChain);\n        }\n        intent.destination.amount = borrow;\n        if (accountedAmount < borrowWithFee) {\n            intent.isAvailableBalanceInsufficient = true;\n        }\n        if (!gas.equals(0)) {\n            intent.destination.gas = mulDecimals(gas, this.input.chain.nativeCurrency.decimals);\n        }\n        logger$9.debug('createIntent:4', { intent });\n        return intent;\n    }\n}\nconst waitForDoubleCheckTx = (input) => {\n    return async () => {\n        await Promise.allSettled(input.map((i) => i()));\n    };\n};\n\nconst logger$8 = getLogger();\nconst tokenRequestParseSimulation = ({ assets, bridge, chain, iGas, simulation, }) => {\n    const tokenContract = simulation.token.contractAddress;\n    const amount = simulation.amount ?? new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n    const nativeToken = chain.nativeCurrency;\n    logger$8.debug('ERC20RequestBase:ParseSimulation:1', {\n        assets,\n        tokenContract,\n    });\n    const { chainsWithBalance, destinationAssetBalance, destinationGasBalance } = assets.getAssetDetails(chain, tokenContract);\n    const gasMultiple = simulation.gasFee\n        .mul(chain.id === SOPHON_CHAIN_ID ? 3 : 2)\n        .add(divDecimals(iGas, nativeToken.decimals));\n    logger$8.debug('ERC20RequestBase:ParseSimulation:0', {\n        destinationGasBalance,\n        expectedGas: gasMultiple.toFixed(),\n        simGas: simulation.gasFee.toFixed(),\n    });\n    const isGasRequiredToBeBorrowed = bridge\n        ? gasMultiple.greaterThan(0)\n        : gasMultiple.greaterThan(destinationGasBalance);\n    let isIntentRequired = false;\n    if (bridge) {\n        isIntentRequired = true;\n    }\n    let gas = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n    logger$8.debug('ERC20RequestBase:parseSimulation:1', {\n        chainsWithBalance,\n        destinationAssetBalance,\n        isGasRequiredToBeBorrowed,\n    });\n    if (chainsWithBalance) {\n        if (amount.greaterThan(destinationAssetBalance)) {\n            isIntentRequired = true;\n        }\n        if (isGasRequiredToBeBorrowed) {\n            isIntentRequired = true;\n            gas = bridge ? gasMultiple : gasMultiple.minus(destinationGasBalance);\n        }\n    }\n    return {\n        amount,\n        gas,\n        isIntentRequired,\n    };\n};\nconst nativeRequestParseSimulation = ({ assets, bridge, chain, simulation, }) => {\n    const { chainsWithBalance, destinationGasBalance } = assets.getAssetDetails(chain, simulation.token.contractAddress);\n    const gasMultiple = simulation.gasFee.mul(2);\n    let isIntentRequired = false;\n    if (bridge) {\n        isIntentRequired = true;\n    }\n    if (chainsWithBalance) {\n        if (simulation.amount.add(gasMultiple).greaterThan(destinationGasBalance)) {\n            isIntentRequired = true;\n        }\n    }\n    logger$8.debug('parseSimulation', {\n        amount: simulation.amount.toFixed(),\n        destinationGasBalance: destinationGasBalance,\n        gas: gasMultiple.toFixed(),\n    });\n    return {\n        amount: simulation.amount,\n        gas: gasMultiple,\n        isIntentRequired,\n    };\n};\n\nconst logger$7 = getLogger();\nclass ERC20Transfer extends BaseRequest {\n    constructor(input) {\n        super(input);\n        this.input = input;\n        this.destinationUniverse = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM;\n        this.publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_21__.createPublicClient)({\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_32__.webSocket)(this.input.chain.rpcUrls.default.webSocket[0]),\n        });\n    }\n    parseSimulation({ assets, simulation }) {\n        return tokenRequestParseSimulation({\n            assets,\n            bridge: this.input.options.bridge,\n            chain: this.input.chain,\n            iGas: this.input.options.gas,\n            simulation,\n        });\n    }\n    async simulateTx() {\n        const { data, to } = this.input.evm.tx;\n        const from = this.input.evm.address;\n        const token = this.chainList.getTokenByAddress(this.input.chain.id, to);\n        const nativeToken = this.chainList.getNativeToken(this.input.chain.id);\n        if (!token) {\n            return;\n        }\n        const { args } = (0,viem__WEBPACK_IMPORTED_MODULE_14__.decodeFunctionData)({\n            abi: [ERC20TransferABI],\n            data: data ?? '0x00',\n        });\n        if ([HYPEREVM_CHAIN_ID, KAIA_CHAIN_ID, MONAD_TESTNET_CHAIN_ID].includes(this.input.chain.id)) {\n            this.simulateTxRes = {\n                amount: divDecimals(args[1], token.decimals),\n                gas: 100000n,\n                gasFee: new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0),\n                token,\n            };\n        }\n        if (this.simulateTxRes) {\n            let gasFee = 0n;\n            if (!this.input.options.bridge) {\n                const [{ gasPrice, maxFeePerGas }, l1Fee] = await Promise.all([\n                    this.publicClient.estimateFeesPerGas(),\n                    getL1Fee(this.input.chain, (0,viem__WEBPACK_IMPORTED_MODULE_33__.serializeTransaction)({\n                        chainId: this.input.chain.id,\n                        data: data ?? '0x00',\n                        to: to,\n                        type: 'eip1559',\n                    })),\n                ]);\n                const gasUnitPrice = maxFeePerGas ?? gasPrice ?? 0n;\n                if (gasUnitPrice === 0n) {\n                    throw new Error('could not get maxFeePerGas or gasPrice from RPC');\n                }\n                gasFee = this.simulateTxRes.gas * gasUnitPrice + l1Fee;\n            }\n            return {\n                ...this.simulateTxRes,\n                gasFee: divDecimals(gasFee, nativeToken.decimals),\n            };\n        }\n        const amountToAdd = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](args[1].toString())\n            .toHexadecimal()\n            .split('0x')[1]\n            .padStart(40, '0');\n        let txsToSimulate = [];\n        if (AaveTokenContracts[this.input.chain.id]?.[token.symbol]) {\n            txsToSimulate.push({\n                from: AaveTokenContracts[this.input.chain.id][token.symbol],\n                input: `0xa9059cbb000000000000000000000000${from\n                    .replace('0x', '')\n                    .toLowerCase()}000000000000000000000000${amountToAdd}`,\n                to: token.contractAddress,\n            });\n        }\n        else if (TOKEN_MINTER_CONTRACTS[this.input.chain.id]?.[token.symbol]) {\n            txsToSimulate.push({\n                from: TOKEN_MINTER_CONTRACTS[this.input.chain.id]?.[token.symbol],\n                input: `0x40c10f19000000000000000000000000${from\n                    .replace('0x', '')\n                    .toLowerCase()}000000000000000000000000000000000000000000000000000000003b9aca00`,\n                to: token.contractAddress,\n            });\n        }\n        txsToSimulate.push({\n            from,\n            input: data,\n            to,\n        });\n        if (TOP_OWNER[this.input.chain.id]?.[token.symbol]) {\n            const ownerAddress = TOP_OWNER[this.input.chain.id][token.symbol];\n            txsToSimulate = [\n                {\n                    from: ownerAddress,\n                    input: data,\n                    to,\n                },\n            ];\n        }\n        const [simulation, feeData, l1Fee] = await Promise.all([\n            simulateTransaction(this.input.chain.id, txsToSimulate, this.input.options.networkConfig.SIMULATION_URL),\n            this.publicClient.estimateFeesPerGas(),\n            getL1Fee(this.input.chain, (0,viem__WEBPACK_IMPORTED_MODULE_33__.serializeTransaction)({\n                chainId: this.input.chain.id,\n                data: data ?? '0x00',\n                to: to,\n                type: 'eip1559',\n            })),\n        ]);\n        logger$7.debug('simulateTx', { feeData });\n        const gasUnitPrice = feeData.maxFeePerGas ?? feeData.gasPrice ?? 0n;\n        if (gasUnitPrice === 0n) {\n            throw new Error('could not get maxFeePerGas or gasPrice from RPC');\n        }\n        let gasFee = (this.input.chain.id === SOPHON_CHAIN_ID\n            ? BigInt(simulation.data.gas)\n            : BigInt(simulation.data.gas_used)) *\n            gasUnitPrice +\n            l1Fee;\n        logger$7.debug('erc20:simulateTx', {\n            args,\n            feeData,\n            l1Fee,\n            maxFeePerGas: gasUnitPrice,\n            simulation,\n            totalGas: gasFee,\n            totalGasInDecimal: divDecimals(gasFee, nativeToken.decimals).toFixed(),\n        });\n        if (this.input.options.bridge) {\n            gasFee = 0n;\n        }\n        const amount = simulation.data.amount === '' ? args[1].toString() : simulation.data.amount;\n        this.simulateTxRes = {\n            amount: divDecimals(amount, token.decimals),\n            gas: this.input.chain.id === SOPHON_CHAIN_ID\n                ? BigInt(simulation.data.gas)\n                : BigInt(simulation.data.gas_used),\n            gasFee: divDecimals(gasFee, nativeToken.decimals),\n            token,\n        };\n        return this.simulateTxRes;\n    }\n    async waitForFill(requestHash, intentID, waitForDoubleCheckTx) {\n        logger$7.debug('waitForFill', {\n            intentID,\n            requestHash,\n            waitForDoubleCheckTx,\n        });\n        try {\n            await Promise.all([\n                waitForDoubleCheckTx(),\n                evmWaitForFill(this.input.chainList.getVaultContractAddress(this.input.chain.id), this.publicClient, requestHash, intentID, this.input.options.networkConfig.GRPC_URL, this.input.options.networkConfig.COSMOS_URL),\n            ]);\n        }\n        finally {\n            (await this.publicClient.transport.getRpcClient()).close();\n        }\n    }\n}\n\nconst logger$6 = getLogger();\nclass NativeTransfer extends BaseRequest {\n    constructor(input) {\n        super(input);\n        this.input = input;\n        this.destinationUniverse = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM;\n        const wsUrls = this.input.chain.rpcUrls?.default?.webSocket;\n        if (!wsUrls?.length) {\n            throw new Error(`Web-Socket RPC URL missing for chain ${this.input.chain.id}`);\n        }\n        this.publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_21__.createPublicClient)({\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_32__.webSocket)(wsUrls[0]),\n        });\n    }\n    parseSimulation({ assets, simulation }) {\n        return nativeRequestParseSimulation({\n            assets,\n            bridge: this.input.options.bridge,\n            chain: this.input.chain,\n            simulation,\n        });\n    }\n    async simulateTx() {\n        const { data, to, value } = this.input.evm.tx;\n        const nativeToken = this.input.chainList.getNativeToken(this.input.chain.id);\n        if (this.simulateTxRes) {\n            let gasFee = 0n;\n            if (!this.input.options.bridge) {\n                const [{ gasPrice, maxFeePerGas }, l1Fee] = await Promise.all([\n                    this.publicClient.estimateFeesPerGas(),\n                    getL1Fee(this.input.chain, (0,viem__WEBPACK_IMPORTED_MODULE_33__.serializeTransaction)({\n                        chainId: this.input.chain.id,\n                        data: data ?? '0x00',\n                        to: to,\n                        type: 'eip1559',\n                        value: (0,viem__WEBPACK_IMPORTED_MODULE_10__.hexToBigInt)(value ?? `0x00`),\n                    })),\n                ]);\n                const gasUnitPrice = maxFeePerGas ?? gasPrice;\n                gasFee = this.simulateTxRes.gas * gasUnitPrice + l1Fee;\n            }\n            return {\n                ...this.simulateTxRes,\n                gasFee: divDecimals(gasFee, nativeToken.decimals),\n            };\n        }\n        const txsToSimulate = [\n            {\n                from: ZERO_ADDRESS,\n                input: data ?? '0x00',\n                to,\n                value: value ?? '0x00',\n            },\n        ];\n        const [simulation, feeData, l1Fee] = await Promise.all([\n            simulateTransaction(this.input.chain.id, txsToSimulate, this.input.options.networkConfig.SIMULATION_URL),\n            this.publicClient.estimateFeesPerGas(),\n            getL1Fee(this.input.chain, (0,viem__WEBPACK_IMPORTED_MODULE_33__.serializeTransaction)({\n                chainId: this.input.chain.id,\n                data: data ?? '0x00',\n                to: to,\n                type: 'eip1559',\n                value: (0,viem__WEBPACK_IMPORTED_MODULE_10__.hexToBigInt)(value ?? '0x00'),\n            })),\n        ]);\n        const gasUnitPrice = feeData.maxFeePerGas ?? feeData.gasPrice ?? 0n;\n        if (gasUnitPrice === 0n) {\n            throw new Error('could not get maxFeePerGas or gasPrice from RPC');\n        }\n        let gasFee = BigInt(simulation.data.gas_used) * gasUnitPrice + l1Fee;\n        logger$6.debug('native:simulateTx', {\n            feeData,\n            l1Fee,\n            maxFeePerGas: gasUnitPrice,\n            simulation,\n            totalGas: gasFee,\n            totalGasInDecimal: divDecimals(gasFee, nativeToken.decimals),\n        });\n        if (this.input.options.bridge) {\n            gasFee = 0n;\n        }\n        this.simulateTxRes = {\n            amount: divDecimals(value ?? '0', nativeToken.decimals),\n            gas: BigInt(simulation.data.gas_used),\n            gasFee: divDecimals(gasFee, nativeToken.decimals),\n            token: {\n                contractAddress: ZERO_ADDRESS,\n                decimals: nativeToken.decimals,\n                name: nativeToken.name,\n                symbol: nativeToken.symbol,\n            },\n        };\n        return this.simulateTxRes;\n    }\n    async waitForFill(requestHash, intentID, waitForDoubleCheckTx) {\n        try {\n            await Promise.all([\n                waitForDoubleCheckTx(),\n                evmWaitForFill(this.input.chainList.getVaultContractAddress(this.input.chain.id), this.publicClient, requestHash, intentID, this.input.options.networkConfig.GRPC_URL, this.input.options.networkConfig.COSMOS_URL),\n            ]);\n        }\n        finally {\n            (await this.publicClient.transport.getRpcClient()).close();\n        }\n    }\n}\n\nconst logger$5 = getLogger();\nclass FuelNativeTransfer extends BaseRequest {\n    constructor(input) {\n        super(input);\n        this.input = input;\n        this.allowances = null;\n        this.destinationUniverse = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL;\n        if (!this.input.fuel?.tx) {\n            throw new Error('Invalid request');\n        }\n        if (!this.input.fuel.address) {\n            throw new Error('fuel address missing');\n        }\n        this.tx = this.input.fuel.tx;\n        this.fuelAddress = this.input.fuel.address;\n    }\n    parseSimulation(input) {\n        return nativeRequestParseSimulation({\n            ...input,\n            bridge: this.input.options.bridge,\n            chain: this.input.chain,\n        });\n    }\n    async simulateTx() {\n        logger$5.debug('fuel: reached simulate tx');\n        const nativeCurrency = this.input.chain.nativeCurrency;\n        if (this.simulateTxRes) {\n            let gasFee = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n            if (!this.input.options.bridge) {\n                const { assembledRequest } = await this.input.fuel.provider.assembleTx({\n                    feePayerAccount: new fuels__WEBPACK_IMPORTED_MODULE_3__.Account(this.input.fuel.address),\n                    request: this.input.fuel.tx,\n                });\n                gasFee = divDecimals(BigInt(assembledRequest.maxFee.toString()) * 2n, nativeCurrency.decimals);\n            }\n            return {\n                ...this.simulateTxRes,\n                gasFee,\n            };\n        }\n        this.simulateTxRes = await simulate(this.tx, this.fuelAddress, this.input.fuel.provider, this.input.chainList);\n        if (this.input.options.bridge && this.simulateTxRes) {\n            this.simulateTxRes.gasFee = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n        }\n        return this.simulateTxRes;\n    }\n    async waitForFill(_, intentID) {\n        const ac = new AbortController();\n        await Promise.race([\n            requestTimeout(3, ac),\n            cosmosFillCheck(intentID, this.input.options.networkConfig.GRPC_URL, this.input.options.networkConfig.COSMOS_URL, ac),\n        ]);\n    }\n}\n\nconst logger$4 = getLogger();\nclass FuelTokenTransfer extends BaseRequest {\n    constructor(input) {\n        super(input);\n        this.input = input;\n        this.allowances = null;\n        this.destinationUniverse = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.FUEL;\n        if (!this.input.fuel?.tx) {\n            throw new Error('Invalid request');\n        }\n        if (!this.input.fuel.address) {\n            throw new Error('fuel address missing');\n        }\n        this.tx = this.input.fuel.tx;\n        this.fuelAddress = this.input.fuel.address;\n    }\n    parseSimulation({ assets, simulation }) {\n        return tokenRequestParseSimulation({\n            assets,\n            bridge: this.input.options.bridge,\n            chain: this.input.chain,\n            iGas: this.input.options.gas,\n            simulation,\n        });\n    }\n    async simulateTx() {\n        logger$4.debug('fuel: reached simulate tx');\n        const nativeCurrency = this.input.chain.nativeCurrency;\n        if (this.simulateTxRes) {\n            let gasFee = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n            if (!this.input.options.bridge) {\n                const { assembledRequest } = await this.input.fuel.provider.assembleTx({\n                    feePayerAccount: new fuels__WEBPACK_IMPORTED_MODULE_3__.Account(this.input.fuel.address),\n                    request: this.input.fuel.tx,\n                });\n                gasFee = divDecimals(BigInt(assembledRequest.maxFee.toString()) * 2n, nativeCurrency.decimals);\n            }\n            return {\n                ...this.simulateTxRes,\n                gasFee,\n            };\n        }\n        this.simulateTxRes = await simulate(this.tx, this.fuelAddress, this.input.fuel.provider, this.input.chainList);\n        if (this.input.options.bridge && this.simulateTxRes) {\n            this.simulateTxRes.gasFee = new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n        }\n        return this.simulateTxRes;\n    }\n    async waitForFill(_, intentID) {\n        const ac = new AbortController();\n        await Promise.race([\n            requestTimeout(3, ac),\n            cosmosFillCheck(intentID, this.input.options.networkConfig.GRPC_URL, this.input.options.networkConfig.COSMOS_URL, ac),\n        ]);\n    }\n}\n\nconst logger$3 = getLogger();\nvar TxType;\n(function (TxType) {\n    TxType[TxType[\"EVMERC20Transfer\"] = 0] = \"EVMERC20Transfer\";\n    TxType[TxType[\"EVMNativeTransfer\"] = 1] = \"EVMNativeTransfer\";\n    TxType[TxType[\"FuelTokenTransfer\"] = 2] = \"FuelTokenTransfer\";\n    TxType[TxType[\"FuelNativeTransfer\"] = 3] = \"FuelNativeTransfer\";\n})(TxType || (TxType = {}));\nconst handlers = {\n    [TxType.EVMERC20Transfer]: ERC20Transfer,\n    [TxType.EVMNativeTransfer]: NativeTransfer,\n    [TxType.FuelNativeTransfer]: FuelNativeTransfer,\n    [TxType.FuelTokenTransfer]: FuelTokenTransfer,\n};\nconst createHandler = (input) => {\n    logger$3.debug('router', { input });\n    let handler = null;\n    let processTx = async () => { };\n    if (input.evm.tx) {\n        const tx = input.evm.tx;\n        if (isERC20TokenTransfer(input)) {\n            handler = handlers[TxType.EVMERC20Transfer];\n        }\n        else if (isNativeTokenTransfer(input)) {\n            handler = handlers[TxType.EVMNativeTransfer];\n        }\n        processTx = async () => {\n            if (!input.options.bridge && !input.options.skipTx) {\n                logger$3.debug('in processTx', {\n                    tx: input.evm.tx,\n                });\n                await switchChain(input.evm.client, input.chain);\n                return input.evm.client.request({\n                    method: 'eth_sendTransaction',\n                    params: [tx],\n                });\n            }\n            return;\n        };\n    }\n    else if (input.fuel?.tx) {\n        if (isFuelNativeTransfer(input.fuel.tx)) {\n            handler = handlers[TxType.FuelNativeTransfer];\n        }\n        else {\n            handler = handlers[TxType.FuelTokenTransfer];\n        }\n        processTx = async () => {\n            if (!input.options.bridge && !input.options.skipTx) {\n                logger$3.debug('in processTx', {\n                    address: input.fuel.address,\n                    provider: input.fuel.provider,\n                    tx: input.fuel?.tx,\n                });\n                const tx = await fixTx(input.fuel.address, input.fuel.tx, input.fuel.provider);\n                return input.fuel.connector.sendTransaction(input.fuel.address, tx, {\n                    provider: {\n                        url: FUEL_NETWORK_URL,\n                    },\n                });\n            }\n            return;\n        };\n    }\n    else {\n        throw Error('Unknown handler');\n    }\n    return {\n        handler: handler ? new handler(input) : null,\n        processTx,\n    };\n};\n\nconst logger$2 = getLogger();\nclass BridgeHandler {\n    constructor(input, options) {\n        this.input = input;\n        this.options = options;\n        this.depositCalls = {};\n        this.eoaToEphCalls = {};\n        this.status = {\n            filled: true,\n            intentID: long__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fromInt(0),\n            promise: Promise.resolve(),\n        };\n        this.waitForFill = () => ({\n            filled: true,\n            intentID: long__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fromNumber(0),\n            promise: Promise.resolve(),\n        });\n        this.createDoubleCheckTx = async () => { };\n        if (input) {\n            for (const asset of input.assets) {\n                options.cache.addAllowanceQuery({\n                    chainID: asset.chainID,\n                    contractAddress: asset.contractAddress,\n                    owner: options.address.ephemeral,\n                    spender: options.chainList.getVaultContractAddress(asset.chainID),\n                });\n            }\n        }\n    }\n    async createRFFDeposits() {\n        const waitingPromises = [];\n        if (Object.keys(this.depositCalls).length > 0) {\n            const sbcTx = [];\n            for (const c in this.depositCalls) {\n                const chain = this.options.chainList.getChainByID(Number(c));\n                if (!chain) {\n                    throw new Error('chain not found');\n                }\n                const publicClient = this.options.publicClientList.get(c);\n                const calls = [];\n                const e2e = this.eoaToEphCalls[Number(c)];\n                logger$2.debug('Eoa->Eph and deposit calls', {\n                    allEoAToEphemeralCalls: this.eoaToEphCalls,\n                    chain: c,\n                    eoAToEphemeralCalls: e2e,\n                    rffDepositCalls: { ...this.depositCalls },\n                });\n                await this.options.wallet.eoa.switchChain({\n                    id: Number(c),\n                });\n                if (e2e) {\n                    await this.options.wallet.eoa.switchChain({ id: chain.id });\n                    const txs = await createPermitAndTransferFromTx({\n                        amount: e2e.amount,\n                        cache: this.options.cache,\n                        chain,\n                        contractAddress: e2e.tokenAddress,\n                        owner: this.options.address.eoa,\n                        ownerWallet: this.options.wallet.eoa,\n                        publicClient,\n                        spender: this.options.address.ephemeral,\n                    });\n                    calls.push(...txs);\n                }\n                sbcTx.push(await createSBCTxFromCalls({\n                    cache: this.options.cache,\n                    calls: calls.concat(this.depositCalls[c].tx).concat(createSweeperTxs({\n                        cache: this.options.cache,\n                        chainID: chain.id,\n                        COTCurrencyID: this.options.cot.currencyID,\n                        receiver: this.options.address.eoa,\n                        sender: this.options.address.ephemeral,\n                    })),\n                    chainID: chain.id,\n                    ephemeralAddress: this.options.address.ephemeral,\n                    ephemeralWallet: this.options.wallet.ephemeral,\n                    publicClient,\n                }));\n            }\n            if (sbcTx.length) {\n                const ops = await vscSBCTx(sbcTx, this.options.networkConfig.VSC_DOMAIN);\n                ops.forEach((op) => {\n                    this.options.emitter.emit(SOURCE_SWAP_HASH(op, this.options.chainList));\n                });\n                waitingPromises.push(...ops.map(([chainID, hash]) => wrap(Number(chainID), waitForTxReceipt(hash, this.options.publicClientList.get(chainID), 2))));\n            }\n        }\n        await Promise.all(waitingPromises);\n    }\n    async process(metadata, inputAssets) {\n        if (this.input) {\n            for (const asset of this.input.assets) {\n                const updatedAsset = inputAssets.find((i) => i.chainID === asset.chainID && equalFold(i.tokenAddress, asset.contractAddress));\n                if (updatedAsset) {\n                    asset.ephemeralBalance = updatedAsset.amount;\n                }\n            }\n            const response = await createBridgeRFF({\n                config: {\n                    chainList: this.options.chainList,\n                    cosmos: {\n                        address: this.options.address.cosmos,\n                        wallet: this.options.wallet.cosmos,\n                    },\n                    evm: {\n                        address: this.options.address.ephemeral,\n                        client: this.options.wallet.ephemeral,\n                        eoaAddress: this.options.address.eoa,\n                    },\n                    network: {\n                        COSMOS_URL: this.options.networkConfig.COSMOS_URL,\n                        GRPC_URL: this.options.networkConfig.GRPC_URL,\n                    },\n                },\n                input: { assets: this.input.assets },\n                output: this.input,\n            });\n            this.depositCalls = response.depositCalls;\n            this.eoaToEphCalls = response.eoaToEphemeralCalls;\n            const [, { createDoubleCheckTx }] = await Promise.all([\n                this.createRFFDeposits(),\n                response.createRFF(),\n            ]);\n            this.waitForFill = response.waitForFill;\n            this.createDoubleCheckTx = createDoubleCheckTx;\n        }\n        this.status = this.waitForFill();\n        if (this.status.intentID.toNumber() != 0) {\n            await (0,es_toolkit__WEBPACK_IMPORTED_MODULE_31__.retry)(async () => {\n                await this.createDoubleCheckTx().then(() => {\n                    logger$2.info('double-check-returned');\n                    return true;\n                });\n            }, { delay: 3000, retries: 3 });\n            metadata.rff_id = BigInt(this.status.intentID.toNumber());\n            this.options.emitter.emit(RFF_ID(this.status.intentID.toNumber()));\n            // will just resolve immediately if no CA was required\n            logger$2.debug('Fill wait start');\n            performance.mark('fill-wait-start');\n            if (!this.status.filled) {\n                await this.status.promise;\n            }\n            performance.mark('fill-wait-end');\n            logger$2.debug('Fill wait complete');\n        }\n    }\n}\nclass DestinationSwapHandler {\n    constructor(dstSwap, dstTokenInfo, dst, options) {\n        this.dstSwap = dstSwap;\n        this.dstTokenInfo = dstTokenInfo;\n        this.dst = dst;\n        this.options = options;\n        this.destinationCalls = [];\n        if (dstSwap.dstEOAToEphTx) {\n            options.cache.addAllowanceQuery({\n                chainID: dst.chainID,\n                contractAddress: dstSwap.dstEOAToEphTx.contractAddress,\n                owner: options.address.eoa,\n                spender: options.address.ephemeral,\n            });\n        }\n        options.cache.addSetCodeQuery({\n            address: options.address.ephemeral,\n            chainID: dst.chainID,\n        });\n        logger$2.debug('dstSwapHandler:constructor', {\n            isNativeAddress: isNativeAddress(dst.token),\n        });\n        if (isNativeAddress(dst.token)) {\n            options.cache.addNativeAllowanceQuery({\n                chainID: dst.chainID,\n                contractAddress: options.address.ephemeral,\n                owner: SWEEPER_ADDRESS,\n                spender: SWEEPER_ADDRESS,\n            });\n        }\n        options.cache.addAllowanceQuery({\n            chainID: dst.chainID,\n            contractAddress: convertToEVMAddress(dstSwap.req.inputToken),\n            owner: options.address.ephemeral,\n            spender: SWEEPER_ADDRESS,\n        });\n    }\n    async createPermit() {\n        if (this.dstSwap.dstEOAToEphTx) {\n            const txs = await createPermitAndTransferFromTx({\n                amount: this.dstSwap.dstEOAToEphTx.amount,\n                cache: this.options.cache,\n                chain: this.options.chainList.getChainByID(this.dst.chainID),\n                contractAddress: this.dstSwap.dstEOAToEphTx.contractAddress,\n                owner: this.options.address.eoa,\n                ownerWallet: this.options.wallet.eoa,\n                publicClient: this.options.publicClientList.get(this.dst.chainID),\n                spender: this.options.address.ephemeral,\n            });\n            this.destinationCalls = this.destinationCalls.concat(txs);\n        }\n    }\n    // FIXME: Need to add retry and reqoute\n    async process(metadata) {\n        await this.options.wallet.eoa.switchChain({\n            id: Number(this.options.destinationChainID),\n        });\n        let hasDestinationSwap = false;\n        if (this.dstSwap.quote) {\n            hasDestinationSwap = true;\n            await this.requoteIfRequired( /*inputAmount*/);\n            const txs = getTxsFromQuote(this.dstSwap.aggregator, this.dstSwap.quote, this.dstSwap.req.inputToken, true);\n            if (txs.approval) {\n                this.destinationCalls.push(txs.approval);\n            }\n            this.destinationCalls.push(txs.swap);\n            logger$2.debug('swap:destinationCalls', {\n                destinationCalls: this.destinationCalls,\n            });\n            metadata.dst.swaps.push({\n                agg: 0,\n                input_amt: (0,viem__WEBPACK_IMPORTED_MODULE_15__.toBytes)(txs.amount),\n                input_contract: this.dstSwap.req.inputToken,\n                input_decimals: this.dstSwap.dstChainCOT.decimals,\n                output_amt: convertTo32Bytes(this.dst.amount ?? 0),\n                output_contract: convertTo32Bytes(this.dst.token),\n                output_decimals: this.dstTokenInfo.decimals,\n            });\n        }\n        if (hasDestinationSwap) {\n            this.options.emitter.emit(DESTINATION_SWAP_BATCH_TX(false));\n        }\n        // So whatever amount is swapped gets transferred ephemeral -> eoa\n        this.destinationCalls = this.destinationCalls.concat(createSweeperTxs({\n            cache: this.options.cache,\n            chainID: this.dst.chainID,\n            COTCurrencyID: this.options.cot.currencyID,\n            receiver: this.options.address.eoa,\n            sender: this.options.address.ephemeral,\n            tokenAddress: this.dst.token,\n        }));\n        // Destination swap batched tx to VSC and waiting for receipt (sweep after)\n        const hash = await performDestinationSwap({\n            actualAddress: this.options.address.eoa,\n            cache: this.options.cache,\n            calls: this.destinationCalls,\n            chain: this.options.chainList.getChainByID(this.dst.chainID),\n            chainList: this.options.chainList,\n            COT: this.options.cot.currencyID,\n            emitter: this.options.emitter,\n            ephemeralAddress: this.options.address.ephemeral,\n            ephemeralWallet: this.options.wallet.ephemeral,\n            hasDestinationSwap,\n            publicClientList: this.options.publicClientList,\n            vscDomain: this.options.networkConfig.VSC_DOMAIN,\n        });\n        if (hasDestinationSwap) {\n            this.options.emitter.emit(DESTINATION_SWAP_BATCH_TX(true));\n        }\n        this.options.emitter.emit(SWAP_COMPLETE);\n        performance.mark('xcs-ops-end');\n        logger$2.debug('before dst metadata', {\n            metadata,\n        });\n        metadata.dst.tx_hash = convertTo32Bytes(hash);\n    }\n    async requoteIfRequired() {\n        let requote = false;\n        if (this.dstSwap.aggregator instanceof _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.BebopAggregator) {\n            const quote = this.dstSwap.quote;\n            if (quote.originalResponse.quote.expiry * 1000 < Date.now()) {\n                logger$2.debug('DDS: BEBOP', {\n                    expiry: quote.originalResponse.quote.expiry * 1000,\n                    now: Date.now(),\n                });\n                requote = true;\n            }\n        }\n        else if (Date.now() - this.dstSwap.createdAt > minutesToMs(0.4)) {\n            requote = true;\n        }\n        // else if (this.dstSwap.quote?.inputAmount !== inputAmount) {\n        //   requote = true;\n        // }\n        if (requote) {\n            const ddsResponse = await this.dstSwap.getDDS();\n            if (!ddsResponse.quote) {\n                throw new Error('could not requote DS');\n            }\n            logger$2.debug('reqoutedDstSwap', {\n                inputAmountWithBuffer: this.dstSwap.inputAmountWithBuffer.toFixed(),\n                newInputAmount: ddsResponse.inputAmount.toFixed(),\n            });\n            const isExactIn = this.dst.amount == undefined;\n            if (!isExactIn && ddsResponse.inputAmount.gt(this.dstSwap.inputAmountWithBuffer)) {\n                throw new Error(`Rates changed for destination swap and could not be filled even with buffer. Before: ${this.dstSwap.inputAmountWithBuffer.toFixed()} ,After: ${ddsResponse.inputAmount.toFixed()}`);\n            }\n            this.dstSwap = { ...ddsResponse, getDDS: this.dstSwap.getDDS };\n        }\n    }\n}\nclass SourceSwapsHandler {\n    constructor(quotes, options) {\n        this.options = options;\n        this.disposableCache = {};\n        this.swaps = this.groupAndOrder(quotes);\n        for (const [chainID, swapQuotes] of this.iterate(this.swaps)) {\n            this.options.cache.addSetCodeQuery({\n                address: this.options.address.ephemeral,\n                chainID: Number(chainID),\n            });\n            for (const sQuote of swapQuotes) {\n                this.options.cache.addAllowanceQuery({\n                    chainID: Number(chainID),\n                    contractAddress: convertToEVMAddress(sQuote.input.req.inputToken),\n                    owner: this.options.address.eoa,\n                    spender: this.options.address.ephemeral,\n                });\n                this.options.cache.addAllowanceQuery({\n                    chainID: Number(chainID),\n                    contractAddress: convertToEVMAddress(sQuote.input.req.inputToken),\n                    owner: this.options.address.ephemeral,\n                    spender: SWEEPER_ADDRESS,\n                });\n            }\n        }\n    }\n    getSwapsAndMetadata(input) {\n        const swaps = [];\n        const metadata = [];\n        for (const swap of input) {\n            const td = swap.getTxsData();\n            const md = swap.getMetadata();\n            metadata.push(md);\n            swaps.push(td);\n        }\n        return { metadata, swaps };\n    }\n    *iterate(input) {\n        for (const [chainID, swaps] of input) {\n            const d = swaps.map((swap) => new Swap(swap));\n            yield [chainID, d];\n        }\n    }\n    async process(metadata, input = this.swaps, retry = true) {\n        logger$2.debug('sourceSwapsHandler', {\n            input,\n            metadata,\n            retry,\n        });\n        const waitingPromises = [];\n        const chains = [];\n        const assets = [];\n        for (const [chainID, swapQuotes] of this.iterate(input)) {\n            chains.push(chainID);\n            const sbcCalls = {\n                calls: [],\n                value: 0n,\n            };\n            const metadataTx = {\n                chid: convertTo32Bytes(chainID),\n                swaps: [],\n                tx_hash: new Uint8Array(),\n                univ: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n            };\n            const { metadata: mtd, swaps } = this.getSwapsAndMetadata(swapQuotes);\n            const publicClient = this.options.publicClientList.get(chainID);\n            const chain = this.options.chainList.getChainByID(Number(chainID));\n            if (!chain) {\n                throw new Error(`chain not found: ${chainID}`);\n            }\n            logger$2.debug('srcSwapHandler:process', {\n                swaps,\n                mtd,\n            });\n            metadataTx.swaps = metadataTx.swaps.concat(mtd);\n            // 1. Source swap calls\n            let amount = 0n;\n            {\n                for (const swap of swaps) {\n                    amount += swap.outputAmount;\n                    const { symbol } = getTokenDecimals(Number(chainID), swap.inputToken);\n                    if (isNativeAddress(convertToEVMAddress(swap.inputToken))) {\n                        sbcCalls.value += swap.amount;\n                    }\n                    else {\n                        this.options.emitter.emit(CREATE_PERMIT_FOR_SOURCE_SWAP(false, symbol, chain));\n                        const allowanceCacheKey = getAllowanceCacheKey({\n                            chainID: chain.id,\n                            contractAddress: convertToEVMAddress(swap.inputToken),\n                            owner: this.options.address.eoa,\n                            spender: this.options.address.ephemeral,\n                        });\n                        const txs = await createPermitAndTransferFromTx({\n                            amount: swap.amount,\n                            approval: this.disposableCache[allowanceCacheKey],\n                            cache: this.options.cache,\n                            chain,\n                            contractAddress: convertToEVMAddress(swap.inputToken),\n                            owner: this.options.address.eoa,\n                            ownerWallet: this.options.wallet.eoa,\n                            publicClient,\n                            spender: this.options.address.ephemeral,\n                        });\n                        // Approval & transferFrom\n                        if (txs.length === 2) {\n                            const approvalTx = txs[0];\n                            this.disposableCache[allowanceCacheKey] = approvalTx;\n                        }\n                        this.options.emitter.emit(CREATE_PERMIT_FOR_SOURCE_SWAP(true, symbol, chain));\n                        logger$2.debug('sourceSwap', {\n                            chainID,\n                            permitCalls: txs,\n                            swap,\n                        });\n                        sbcCalls.calls.push(...txs);\n                    }\n                    if (swap.approval) {\n                        sbcCalls.calls.push(swap.approval);\n                    }\n                    sbcCalls.calls.push(swap.swap);\n                }\n            }\n            // 2. Create batched calls\n            {\n                if (sbcCalls.value > 0n) {\n                    if (!(await checkAuthCodeSet(Number(chainID), this.options.address.ephemeral, this.options.cache))) {\n                        const ops = await vscSBCTx([\n                            await createSBCTxFromCalls({\n                                cache: this.options.cache,\n                                calls: [],\n                                chainID: chain.id,\n                                ephemeralAddress: this.options.address.ephemeral,\n                                ephemeralWallet: this.options.wallet.ephemeral,\n                                publicClient,\n                            }),\n                        ], this.options.networkConfig.VSC_DOMAIN);\n                        logger$2.debug('SetAuthCodeWithoutCalls', {\n                            ops,\n                        });\n                        await waitForSBCTxReceipt(ops, this.options.chainList, this.options.publicClientList);\n                        // We know its set since we got receipt,\n                        // and so if we come back on retry it is already set\n                        this.options.cache.addSetCodeValue({\n                            address: this.options.address.ephemeral,\n                            chainID: Number(chainID),\n                        }, EXPECTED_CALIBUR_CODE);\n                    }\n                    await this.options.wallet.eoa.switchChain({ id: Number(chainID) });\n                    /*\n                     * EOA creates & sends tx {\n                       to: ephemeralAddress (we check above it its delegated to calibur),\n                       value: sbcCalls.value,\n                       data: SignUsingEphemeral(AggregatorTx(approval(iff non native is involved) and swap))\n                     }\n                     */\n                    const hash = await caliburExecute({\n                        actualAddress: this.options.address.eoa,\n                        actualWallet: this.options.wallet.eoa,\n                        calls: sbcCalls.calls,\n                        chain,\n                        ephemeralAddress: this.options.address.ephemeral,\n                        ephemeralWallet: this.options.wallet.ephemeral,\n                        value: sbcCalls.value,\n                    });\n                    metadataTx.tx_hash = convertTo32Bytes(hash);\n                    this.options.emitter.emit(SOURCE_SWAP_HASH([BigInt(chain.id), hash], this.options.chainList));\n                    waitingPromises.push(wrap(Number(chainID), waitForTxReceipt(hash, publicClient, 2)));\n                }\n                else {\n                    logger$2.debug('sourceSwapsHandler', {\n                        calls: sbcCalls.calls,\n                    });\n                    waitingPromises.push((async () => {\n                        logger$2.debug('waitingPromises:1');\n                        const ops = await vscSBCTx([\n                            await createSBCTxFromCalls({\n                                cache: this.options.cache,\n                                calls: sbcCalls.calls,\n                                chainID: chain.id,\n                                ephemeralAddress: this.options.address.ephemeral,\n                                ephemeralWallet: this.options.wallet.ephemeral,\n                                publicClient,\n                            }),\n                        ], this.options.networkConfig.VSC_DOMAIN);\n                        const [chainID, hash] = ops[0];\n                        metadataTx.tx_hash = convertTo32Bytes(hash);\n                        this.options.emitter.emit(SOURCE_SWAP_HASH([chainID, hash], this.options.chainList));\n                        return wrap(Number(chainID), waitForTxReceipt(hash, this.options.publicClientList.get(chainID), 2));\n                    })());\n                }\n            }\n            assets.push({\n                amount: divDecimals(amount, getTokenDecimals(Number(chainID), swaps[0].outputToken).decimals),\n                chainID: Number(chainID),\n                tokenAddress: convertToEVMAddress(swaps[0].outputToken),\n            });\n            metadata.src.push(metadataTx);\n        }\n        // 3. Check status of all source swaps\n        // Refund COT(Ephemeral -> EOA) on failure of any source swap post retry\n        {\n            const responses = await Promise.allSettled(waitingPromises);\n            const someSrcSwapFailed = responses.some((r) => r.status === 'rejected');\n            const successfulSwaps = responses.filter((r) => r.status === 'fulfilled').map((r) => r.value);\n            const failedChains = chains.filter((c) => !successfulSwaps.includes(Number(c)));\n            logger$2.debug('sourceSwapProcessResults', {\n                failedChains,\n                responses,\n                retry,\n                someSrcSwapFailed,\n                successfulSwaps,\n                waitingPromises,\n            });\n            // Sweep from all other src swap if any failed\n            if (someSrcSwapFailed) {\n                if (retry) {\n                    try {\n                        const response = await this.retryWithSlippageCheck(metadata, failedChains);\n                        return response;\n                    }\n                    catch (e) {\n                        logger$2.debug('src swp failed', {\n                            e,\n                            successfulSwaps,\n                        });\n                        const sbcTxs = [];\n                        for (const chainID of successfulSwaps) {\n                            sbcTxs.push(await createSBCTxFromCalls({\n                                cache: this.options.cache,\n                                calls: createSweeperTxs({\n                                    cache: this.options.cache,\n                                    chainID,\n                                    COTCurrencyID: this.options.cot.currencyID,\n                                    receiver: this.options.address.eoa,\n                                    sender: this.options.address.ephemeral,\n                                }),\n                                chainID: chainID,\n                                ephemeralAddress: this.options.address.ephemeral,\n                                ephemeralWallet: this.options.wallet.ephemeral,\n                                publicClient: this.options.publicClientList.get(chainID),\n                            }));\n                        }\n                        try {\n                            const ops = await vscSBCTx(sbcTxs, this.options.networkConfig.VSC_DOMAIN);\n                            await waitForSBCTxReceipt(ops, this.options.chainList, this.options.publicClientList);\n                        }\n                        catch {\n                            // TODO: What to do here? Store it or something?\n                        }\n                        throw new Error('source swap failed');\n                    }\n                }\n                else {\n                    throw new Error('some source swap failed even after retry');\n                }\n            }\n            return assets;\n        }\n    }\n    async retryWithSlippageCheck(metadata, failedChains) {\n        let oldTotalOutputAmount = 0n;\n        logger$2.debug('sourceSwapsHandler:retryWithSlippageCheck:0', {\n            failedChains,\n        });\n        const quoteResponses = await (0,es_toolkit__WEBPACK_IMPORTED_MODULE_31__.retry)(() => {\n            const quoteRequests = [];\n            // if it comes to retry it should be set to 0\n            oldTotalOutputAmount = 0n;\n            for (const fChain of failedChains) {\n                const oldQuotes = this.swaps.get(fChain);\n                if (!oldQuotes) {\n                    logger$2.debug('how can old quote not be there???? we are iterating on it');\n                    continue;\n                }\n                for (const oq of oldQuotes) {\n                    oldTotalOutputAmount += oq.quote.outputAmountMinimum;\n                    logger$2.debug('retryWithSlippage:quoteRequests:1', {\n                        holding: {\n                            amount: oq.quote.inputAmount,\n                            tokenAddress: oq.req.inputToken,\n                        },\n                    });\n                    quoteRequests.push((0,_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.liquidateInputHoldings)(oq.req.userAddress, [\n                        {\n                            ...oq.originalHolding,\n                            amount: oq.quote.inputAmount,\n                            tokenAddress: oq.req.inputToken,\n                        },\n                    ], this.options.aggregators, [], oq.cur.currencyID).then((nq) => {\n                        logger$2.debug('retryWithSlippage:quoteRequests:2', {\n                            returnData: {},\n                        });\n                        return nq.quotes[0];\n                    }));\n                }\n            }\n            return Promise.all(quoteRequests);\n        }, 2);\n        logger$2.debug('sourceSwapsHandler:retryWithSlippageCheck:1', {\n            oldTotalOutputAmount,\n            quoteResponses,\n        });\n        let newTotalOutputAmount = 0n;\n        for (const q of quoteResponses) {\n            newTotalOutputAmount += q.quote.outputAmountMinimum;\n        }\n        const diff = oldTotalOutputAmount - newTotalOutputAmount;\n        if (diff > 0) {\n            if (!this.isSwapQuoteValid({\n                newAmount: newTotalOutputAmount,\n                oldAmount: oldTotalOutputAmount,\n                slippage: this.options.slippage,\n            })) {\n                throw new Error('slippage greater than max slippage');\n            }\n        }\n        logger$2.debug('sourceSwapsHandler:retryWithSlippageCheck:2', {\n            diff,\n            newTotalOutputAmount,\n            oldTotalOutputAmount,\n        });\n        return this.process(metadata, this.groupAndOrder(quoteResponses), false);\n    }\n    groupAndOrder(input) {\n        return Map.groupBy((0,es_toolkit__WEBPACK_IMPORTED_MODULE_34__.orderBy)(input, [\n            (s) => \n            // if native currency is involved move it up\n            equalFold(convertToEVMAddress(s.req.inputToken), EADDRESS) ? -1 : 1,\n        ], ['asc']), (s) => s.req.chain.chainID);\n    }\n    isSwapQuoteValid({ newAmount, oldAmount, slippage, }) {\n        const minAcceptable = decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].mul(oldAmount, decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sub(1, slippage));\n        logger$2.debug('isSwapQuoteValid', {\n            minAcceptable: minAcceptable.toFixed(),\n            newAmount,\n            oldAmount,\n        });\n        return new decimal_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](newAmount).gte(minAcceptable);\n    }\n}\nclass Swap {\n    constructor(input) {\n        this.input = input;\n        this.txs = null;\n    }\n    getMetadata() {\n        const txs = this.getTxsData();\n        const { decimals: inputDecimals } = getTokenDecimals(Number(this.input.req.chain.chainID), this.input.req.inputToken);\n        const { decimals: outputDecimals } = getTokenDecimals(Number(this.input.req.chain.chainID), this.input.req.outputToken);\n        return {\n            agg: 1,\n            input_amt: convertTo32Bytes(this.input.req.inputAmount),\n            input_contract: this.input.req.inputToken,\n            input_decimals: inputDecimals,\n            output_amt: convertTo32Bytes(txs.amount),\n            output_contract: this.input.req.outputToken,\n            output_decimals: outputDecimals,\n        };\n    }\n    getTxsData() {\n        return {\n            ...getTxsFromQuote(this.input.agg, this.input.quote, this.input.req.inputToken, !bytesEqual(EADDRESS_32_BYTES, this.input.req.inputToken)),\n            outputToken: this.input.req.outputToken,\n        };\n    }\n}\n// class SwapGroup {\n//   requoted = true;\n//   constructor(\n//     public swaps: Swap[],\n//     public chainID: number,\n//   ) {}\n//   execute() {\n//     // Requote\n//     // Execute\n//   }\n//   requote() {}\n// }\nconst wrap = async (chainID, promise) => {\n    await promise;\n    return chainID;\n};\n\nconst logger$1 = getLogger();\nconst ErrorUserDeniedIntent = new Error('User denied swap');\nconst swap = async (input, options, COT = _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.CurrencyID.USDC) => {\n    performance.clearMarks();\n    performance.clearMeasures();\n    const publicClientList = new PublicClientList(options.chainList);\n    const cache = new Cache(publicClientList);\n    const dstChain = options.chainList.getChainByID(input.data.toChainId);\n    if (!dstChain) {\n        throw new Error('destination chain not supported');\n    }\n    performance.mark('swap-start');\n    const emitter = {\n        emit: (step) => {\n            options.emit('swap_step', step);\n        },\n    };\n    emitter.emit(SWAP_START);\n    logger$1.debug('swapBegin', { options, input });\n    performance.mark('determine-swaps-start');\n    emitter.emit(DETERMINING_SWAP());\n    const aggregators = [\n        new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.LiFiAggregator(LIFI_API_KEY),\n        new _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.BebopAggregator(BEBOP_API_KEY),\n        // new ZeroExAggregator(ZERO_X_API_KEY),\n    ];\n    const swapRouteParams = { ...options, aggregators, cotCurrencyID: COT };\n    const [swapRoute, dstTokenInfo] = await Promise.all([\n        determineSwapRoute(input, swapRouteParams),\n        getTokenInfo(input.data.toTokenAddress, publicClientList.get(input.data.toChainId), dstChain),\n    ]);\n    logger$1.debug('initial-swap-route', {\n        dstTokenInfo,\n        swapRoute,\n    });\n    let { assetsUsed, bridgeInput, destinationSwap, sourceSwaps } = swapRoute;\n    logger$1.debug('initial-swap-route', {\n        assetsUsed,\n        bridgeInput,\n        destinationSwap,\n        dstTokenInfo,\n        sourceSwaps,\n        swapRoute,\n    });\n    emitter.emit(DETERMINING_SWAP(true));\n    performance.mark('determine-swaps-end');\n    performance.mark('xcs-ops-start');\n    // Swap Intent hook handling\n    {\n        if (options?.swapIntentHook) {\n            const hook = options?.swapIntentHook;\n            const destination = {\n                amount: divDecimals(input.mode === _commons__WEBPACK_IMPORTED_MODULE_0__.SwapMode.EXACT_OUT ? input.data.toAmount : destinationSwap.outputAmount, dstTokenInfo.decimals).toFixed(),\n                chainID: input.data.toChainId,\n                contractAddress: input.data.toTokenAddress,\n                decimals: dstTokenInfo.decimals,\n                symbol: dstTokenInfo.symbol,\n            };\n            let accepted = false;\n            const refresh = async () => {\n                if (accepted) {\n                    logger$1.warn('Swap Intent refresh called after acceptance');\n                    return createSwapIntent(assetsUsed, destination, options.chainList);\n                }\n                const swapRouteResponse = await determineSwapRoute(input, swapRouteParams);\n                sourceSwaps = swapRouteResponse.sourceSwaps;\n                assetsUsed = swapRouteResponse.assetsUsed;\n                destinationSwap = swapRouteResponse.destinationSwap;\n                bridgeInput = swapRouteResponse.bridgeInput;\n                logger$1.debug('refresh-swap-route', {\n                    dstTokenInfo,\n                    swapRoute: swapRouteResponse,\n                });\n                return createSwapIntent(assetsUsed, destination, options.chainList);\n            };\n            // wait for intent acceptance hook\n            await new Promise((resolve, reject) => {\n                const allow = () => {\n                    accepted = true;\n                    return resolve('User allowed intent');\n                };\n                const deny = () => {\n                    return reject(ErrorUserDeniedIntent);\n                };\n                hook({\n                    allow,\n                    deny,\n                    intent: createSwapIntent(assetsUsed, destination, options.chainList),\n                    refresh,\n                });\n            });\n        }\n    }\n    const metadata = {\n        dst: {\n            chid: convertTo32Bytes(input.data.toChainId),\n            swaps: [],\n            tx_hash: ZERO_BYTES_32,\n            univ: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.Universe.ETHEREUM,\n        },\n        has_xcs: true,\n        rff_id: 0n,\n        src: [],\n    };\n    const opt = {\n        address: options.address,\n        aggregators,\n        cache,\n        chainList: options.chainList,\n        cot: {\n            currencyID: COT,\n            symbol: _arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.CurrencyID[COT],\n        },\n        destinationChainID: input.data.toChainId,\n        emitter,\n        networkConfig: options.networkConfig,\n        publicClientList,\n        slippage: 0.005,\n        wallet: options.wallet,\n    };\n    const srcSwapsHandler = new SourceSwapsHandler(sourceSwaps, opt);\n    const bridgeHandler = new BridgeHandler(bridgeInput, opt);\n    const dstSwapHandler = new DestinationSwapHandler({ ...destinationSwap, getDDS: swapRoute.getDDS }, dstTokenInfo, {\n        chainID: input.data.toChainId,\n        token: input.data.toTokenAddress,\n        amount: input.mode === _commons__WEBPACK_IMPORTED_MODULE_0__.SwapMode.EXACT_OUT ? input.data.toAmount : destinationSwap.outputAmount,\n    }, opt);\n    performance.mark('allowance-cache-start');\n    await cache.process();\n    performance.mark('allowance-cache-end');\n    // 0.5: Destination swap: create permit\n    await dstSwapHandler.createPermit();\n    // 1: Source swap\n    const assets = await srcSwapsHandler.process(metadata);\n    // 2: Bridge, takes source swap output as input so bridge assets are adjusted accordingly\n    // wait for RFF Fill (if RFF required)\n    await bridgeHandler.process(metadata, assets);\n    // 3: Destination swap\n    await dstSwapHandler.process(metadata);\n    const result = convertMetadataToSwapResult(metadata, options.networkConfig.EXPLORER_URL);\n    performance.mark('swap-end');\n    try {\n        const id = await postSwap({\n            metadata,\n            wallet: options.wallet.ephemeral,\n        });\n        logger$1.debug('SwapID', { id });\n    }\n    catch (e) {\n        logger$1.error('postSwap', e);\n    }\n    calculatePerformance();\n    return result;\n};\nconst calculatePerformance = () => {\n    try {\n        const measures = [];\n        measures.push(performance.measure('xcs-total-duration', 'swap-start', 'swap-end'), performance.measure('xcs-ops-duration', 'xcs-ops-start', 'xcs-ops-end'), performance.measure('allowance-calls-duration', 'allowance-cache-start', 'allowance-cache-end'), performance.measure('determine-swaps-duration', 'determine-swaps-start', 'determine-swaps-end'));\n        const entries = performance.getEntries();\n        if (entries.find((entry) => entry.name === 'source-swap-tx-start')) {\n            measures.push(performance.measure('source-swap-tx-duration', 'source-swap-tx-start', 'source-swap-tx-end'), performance.measure('source-swap-mining-duration', 'source-swap-mining-start', 'source-swap-mining-end'));\n        }\n        measures.push(performance.measure('fill-wait-duration', 'fill-wait-start', 'fill-wait-end'), performance.measure('destination-swap-tx-duration', 'destination-swap-start', 'destination-swap-end'), performance.measure('destination-swap-mining-duration', 'destination-swap-mining-start', 'destination-swap-mining-end'));\n        console.log('Timings for XCS:');\n        measures.forEach((measure) => {\n            console.log(`${measure.name}: ${measure.duration}`);\n        });\n    }\n    catch (e) {\n        logger$1.error('calculatePerformance', e);\n    }\n    finally {\n        performance.clearMarks();\n        performance.clearMeasures();\n    }\n};\n\nvar _CA_cosmosWallet, _CA_ephemeralWallet;\nsetLogLevel(LOG_LEVEL.NOLOGS);\nconst logger = getLogger();\nvar INIT_STATUS;\n(function (INIT_STATUS) {\n    INIT_STATUS[INIT_STATUS[\"CREATED\"] = 0] = \"CREATED\";\n    INIT_STATUS[INIT_STATUS[\"RUNNING\"] = 1] = \"RUNNING\";\n    INIT_STATUS[INIT_STATUS[\"DONE\"] = 2] = \"DONE\";\n})(INIT_STATUS || (INIT_STATUS = {}));\nconst SIWE_STATEMENT = 'Sign in to enable Nexus';\nclass CA {\n    constructor(config = { debug: false, network: 'testnet' }) {\n        this._caEvents = new _metamask_safe_event_emitter__WEBPACK_IMPORTED_MODULE_7__[\"default\"]();\n        _CA_cosmosWallet.set(this, void 0);\n        _CA_ephemeralWallet.set(this, void 0);\n        this._hooks = {\n            onAllowance: (data) => data.allow(data.sources.map(() => 'max')),\n            onIntent: (data) => data.allow(),\n        };\n        this._initPromises = [];\n        this._initStatus = INIT_STATUS.CREATED;\n        this._isArcanaProvider = false;\n        this._deinit = () => {\n            (0,tslib__WEBPACK_IMPORTED_MODULE_35__.__classPrivateFieldSet)(this, _CA_cosmosWallet, undefined, \"f\");\n            if (this._evm) {\n                this._evm.provider.removeListener('accountsChanged', this.onAccountsChanged);\n            }\n            if (this._refundInterval) {\n                clearInterval(this._refundInterval);\n                this._refundInterval = undefined;\n            }\n            this._initStatus = INIT_STATUS.CREATED;\n        };\n        this._getEVMProviderWithCA = () => {\n            if (!this._evm) {\n                throw new Error('EVM provider is not set');\n            }\n            return this._evm.modProvider;\n        };\n        this._init = async () => {\n            if (!this._evm) {\n                throw new Error('use setEVMProvider before calling init()');\n            }\n            if (this._initStatus === INIT_STATUS.CREATED) {\n                this._initStatus = INIT_STATUS.RUNNING;\n                try {\n                    const address = await this._getEVMAddress();\n                    this._setProviderHooks();\n                    if (!this._isArcanaProvider) {\n                        (0,tslib__WEBPACK_IMPORTED_MODULE_35__.__classPrivateFieldSet)(this, _CA_cosmosWallet, await this._createCosmosWallet(), \"f\");\n                        this._checkPendingRefunds();\n                    }\n                    this._initStatus = INIT_STATUS.DONE;\n                    this._resolveInitPromises();\n                    this._caEvents.emit('accountsChanged', [address]);\n                }\n                catch (e) {\n                    this._initStatus = INIT_STATUS.CREATED;\n                    logger.error('Error initializing CA', e);\n                    throw new Error('Error initializing CA');\n                }\n            }\n            else if (this._initStatus === INIT_STATUS.RUNNING) {\n                return await this._waitForInit();\n            }\n        };\n        this.onAccountsChanged = (accounts) => {\n            this._deinit();\n            if (accounts.length !== 0) {\n                this._init();\n            }\n        };\n        this._config = getSDKConfig(config);\n        this._networkConfig = getNetworkConfig(this._config.network);\n        this.chainList = new ChainList(this._networkConfig.NETWORK_HINT);\n        if (this._config.debug) {\n            setLogLevel(LOG_LEVEL.DEBUG);\n        }\n    }\n    _allowance() {\n        if (!this._evm) {\n            throw new Error('EVM provider is not set');\n        }\n        return new AllowanceQuery(this._evm.client, this._networkConfig, this.chainList);\n    }\n    async _bridge(input) {\n        const bq = new BridgeQuery(input, this._init, this._changeChain.bind(this), this._createEVMHandler.bind(this), this._createFuelHandler.bind(this), await this._getEVMAddress(), this.chainList, this._fuel?.account);\n        await bq.initHandler();\n        return { exec: bq.exec, simulate: bq.simulate };\n    }\n    async _getFuelWithCA() {\n        if (!this._fuel) {\n            throw new Error('Fuel connector is not set.');\n        }\n        return {\n            connector: this._fuel.modConnector,\n            provider: this._fuel.modProvider,\n        };\n    }\n    async _getMyIntents(page = 1) {\n        const wallet = await this._getCosmosWallet();\n        const address = (await wallet.getAccounts())[0].address;\n        return fetchMyIntents(address, this._networkConfig.GRPC_URL, page);\n    }\n    async _getUnifiedBalance(symbol) {\n        const balances = await this._getUnifiedBalances();\n        return balances.find((s) => equalFold(s.symbol, symbol));\n    }\n    async _getUnifiedBalances() {\n        if (!this._evm) {\n            throw new Error('CA not initialized');\n        }\n        const { assets } = await getBalances({\n            networkHint: this._networkConfig.NETWORK_HINT,\n            evmAddress: (await this._evm.client.requestAddresses())[0],\n            chainList: this.chainList,\n            filter: false,\n            vscDomain: this._networkConfig.VSC_DOMAIN,\n            fuelAddress: this._fuel?.address,\n        });\n        return assets;\n    }\n    _isInitialized() {\n        return this._initStatus === INIT_STATUS.DONE;\n    }\n    async _swapWithExactIn(input, options) {\n        return swap({\n            mode: _commons__WEBPACK_IMPORTED_MODULE_0__.SwapMode.EXACT_IN,\n            data: input,\n        }, await this.getCommonSwapParams(options));\n    }\n    async _swapWithExactOut(input, options) {\n        return swap({\n            mode: _commons__WEBPACK_IMPORTED_MODULE_0__.SwapMode.EXACT_OUT,\n            data: input,\n        }, await this.getCommonSwapParams(options));\n    }\n    async getCommonSwapParams(options) {\n        return {\n            emit: this._caEvents.emit.bind(this._caEvents),\n            chainList: this.chainList,\n            address: {\n                cosmos: (await (0,tslib__WEBPACK_IMPORTED_MODULE_35__.__classPrivateFieldGet)(this, _CA_cosmosWallet, \"f\").getAccounts())[0].address,\n                eoa: (await this._evm.client.getAddresses())[0],\n                ephemeral: (0,tslib__WEBPACK_IMPORTED_MODULE_35__.__classPrivateFieldGet)(this, _CA_ephemeralWallet, \"f\").address,\n            },\n            wallet: {\n                cosmos: (0,tslib__WEBPACK_IMPORTED_MODULE_35__.__classPrivateFieldGet)(this, _CA_cosmosWallet, \"f\"),\n                ephemeral: (0,tslib__WEBPACK_IMPORTED_MODULE_35__.__classPrivateFieldGet)(this, _CA_ephemeralWallet, \"f\"),\n                eoa: this._evm.client,\n            },\n            networkConfig: this._networkConfig,\n            ...options,\n        };\n    }\n    async _handleEVMTx(args, options = {}) {\n        const response = await this._createEVMHandler(args.params[0], getTxOptions(options));\n        if (response) {\n            await response.handler?.process();\n            return response.processTx();\n        }\n        return;\n    }\n    async _setEVMProvider(provider) {\n        if (this._evm?.provider === provider) {\n            return;\n        }\n        this._evm = {\n            client: (0,viem__WEBPACK_IMPORTED_MODULE_36__.createWalletClient)({\n                transport: (0,viem__WEBPACK_IMPORTED_MODULE_37__.custom)(provider),\n            }).extend(viem__WEBPACK_IMPORTED_MODULE_38__.publicActions),\n            modProvider: Object.assign({}, provider, {\n                request: async (args) => {\n                    if (args.method === 'eth_sendTransaction') {\n                        if (!this._isArcanaProvider) {\n                            return this._handleEVMTx(args);\n                        }\n                    }\n                    return provider.request(args);\n                },\n            }),\n            provider,\n        };\n        this._isArcanaProvider = isArcanaWallet(provider);\n    }\n    async _setFuelConnector(connector) {\n        if (this._fuel?.connector === connector) {\n            return;\n        }\n        logger.debug('setFuelConnector', {\n            connected: connector.connected,\n            connector: connector,\n        });\n        if (!(await connector.isConnected())) {\n            await connector.connect();\n        }\n        const address = await connector.currentAccount();\n        if (!address) {\n            throw new Error('could not get current account from connector');\n        }\n        const modProvider = getFuelProvider(this._getUnifiedBalances.bind(this), address, this.chainList.getChainByID(fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet));\n        const provider = new fuels__WEBPACK_IMPORTED_MODULE_3__.Provider(FUEL_NETWORK_URL, {\n            resourceCacheTTL: -1,\n        });\n        const clone = Object.create(connector);\n        clone.sendTransaction = async (_address, _transaction, _params) => {\n            logger.debug('fuelClone:sendTransaction:1', {\n                _address,\n                _params,\n                _transaction,\n            });\n            const handlerResponse = await this._createFuelHandler(_transaction, {\n                bridge: false,\n                gas: 0n,\n            });\n            if (handlerResponse) {\n                await handlerResponse.handler?.process();\n            }\n            logger.debug('fuelClone:sendTransaction:2', {\n                request: Object.assign({\n                    inputs: [],\n                }, _transaction),\n            });\n            const tx = await fixTx(_address, _transaction, provider);\n            return connector.sendTransaction(_address, tx, _params);\n        };\n        this._fuel = {\n            account: new fuels__WEBPACK_IMPORTED_MODULE_3__.Account(address, modProvider, connector),\n            address,\n            connector: connector,\n            modConnector: clone,\n            modProvider,\n            provider,\n        };\n    }\n    _setOnAllowanceHook(hook) {\n        this._hooks.onAllowance = hook;\n    }\n    _setOnIntentHook(hook) {\n        this._hooks.onIntent = hook;\n    }\n    async _transfer(input) {\n        const tq = new TransferQuery(input, this._init, this._changeChain.bind(this), this._createEVMHandler.bind(this), this._createFuelHandler.bind(this), await this._getEVMAddress(), this.chainList, this._fuel?.account);\n        await tq.initHandler();\n        return { exec: tq.exec, simulate: tq.simulate };\n    }\n    _changeChain(chainID) {\n        if (!this._evm) {\n            throw new Error('EVM provider is not set');\n        }\n        const chain = this.chainList.getChainByID(chainID);\n        if (!chain) {\n            throw new Error('chain not supported');\n        }\n        return switchChain(this._evm.client, chain);\n    }\n    async _checkPendingRefunds() {\n        await this._init();\n        const account = await this._getEVMAddress();\n        try {\n            await refundExpiredIntents(account, this._networkConfig.COSMOS_URL, (0,tslib__WEBPACK_IMPORTED_MODULE_35__.__classPrivateFieldGet)(this, _CA_cosmosWallet, \"f\"));\n            this._refundInterval = window.setInterval(async () => {\n                await refundExpiredIntents(account, this._networkConfig.COSMOS_URL, (0,tslib__WEBPACK_IMPORTED_MODULE_35__.__classPrivateFieldGet)(this, _CA_cosmosWallet, \"f\"));\n            }, minutesToMs(10));\n        }\n        catch (e) {\n            logger.error('Error checking pending refunds', e);\n        }\n    }\n    async _createCosmosWallet() {\n        const sig = await this._signatureForLogin();\n        const pvtKey = _starkware_industries_starkware_crypto_utils__WEBPACK_IMPORTED_MODULE_8__.keyDerivation.getPrivateKeyFromEthSignature(sig);\n        const cosmosWallet = await (0,_arcana_ca_common__WEBPACK_IMPORTED_MODULE_1__.createCosmosWallet)(`0x${pvtKey.padStart(64, '0')}`);\n        (0,tslib__WEBPACK_IMPORTED_MODULE_35__.__classPrivateFieldSet)(this, _CA_ephemeralWallet, (0,viem_accounts__WEBPACK_IMPORTED_MODULE_39__.privateKeyToAccount)(`0x${pvtKey.padStart(64, '0')}`), \"f\");\n        const address = (await cosmosWallet.getAccounts())[0].address;\n        await cosmosFeeGrant(this._networkConfig.COSMOS_URL, this._networkConfig.VSC_DOMAIN, address);\n        return cosmosWallet;\n    }\n    async _createEVMHandler(tx, options = {}) {\n        if (!this._evm) {\n            throw new Error('EVM provider is not set');\n        }\n        if (!isEVMTx(tx)) {\n            logger.debug('invalid evm tx, returning', { tx });\n            return null;\n        }\n        const opt = getTxOptions(options);\n        const chainId = await this._getChainID();\n        const chain = this.chainList.getChainByID(chainId);\n        if (!chain) {\n            logger.info('chain not supported, returning', {\n                chainId,\n            });\n            return null;\n        }\n        return createHandler({\n            chain,\n            chainList: this.chainList,\n            cosmosWallet: await this._getCosmosWallet(),\n            evm: {\n                address: await this._getEVMAddress(),\n                client: this._evm.client,\n                tx,\n            },\n            fuel: this._fuel,\n            hooks: this._hooks,\n            options: {\n                emit: this._caEvents.emit.bind(this._caEvents),\n                networkConfig: this._networkConfig,\n                ...opt,\n            },\n        });\n    }\n    getEVMClient() {\n        if (!this._evm) {\n            throw new Error('EVM provider is not set');\n        }\n        return this._evm.client;\n    }\n    async _createFuelHandler(tx, options = {}) {\n        const chain = this.chainList.getChainByID(fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet);\n        if (!chain) {\n            throw new Error(`chain not found: ${fuels__WEBPACK_IMPORTED_MODULE_3__.CHAIN_IDS.fuel.mainnet}`);\n        }\n        if (!this._fuel) {\n            throw new Error('Fuel provider is not connected');\n        }\n        const address = await this._fuel.connector.currentAccount();\n        if (!address) {\n            throw new Error('could not get current account from connector');\n        }\n        const opt = getTxOptions(options);\n        return createHandler({\n            chain,\n            chainList: this.chainList,\n            cosmosWallet: await this._getCosmosWallet(),\n            evm: {\n                address: await this._getEVMAddress(),\n                client: this._evm.client,\n            },\n            fuel: {\n                address,\n                connector: this._fuel.connector,\n                provider: this._fuel.provider,\n                tx,\n            },\n            hooks: {\n                onAllowance: this._hooks.onAllowance,\n                onIntent: this._hooks.onIntent,\n            },\n            options: {\n                emit: this._caEvents.emit.bind(this._caEvents),\n                networkConfig: this._networkConfig,\n                ...opt,\n            },\n        });\n    }\n    _getChainID() {\n        if (!this._evm) {\n            throw new Error('EVM provider is not set');\n        }\n        return this._evm.client.getChainId();\n    }\n    async _getCosmosWallet() {\n        if (!(0,tslib__WEBPACK_IMPORTED_MODULE_35__.__classPrivateFieldGet)(this, _CA_cosmosWallet, \"f\")) {\n            (0,tslib__WEBPACK_IMPORTED_MODULE_35__.__classPrivateFieldSet)(this, _CA_cosmosWallet, await this._createCosmosWallet(), \"f\");\n        }\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_35__.__classPrivateFieldGet)(this, _CA_cosmosWallet, \"f\");\n    }\n    async _getEVMAddress() {\n        if (!this._evm) {\n            throw new Error('EVM provider is not set');\n        }\n        return (await this._evm.client.requestAddresses())[0];\n    }\n    _resolveInitPromises() {\n        const list = this._initPromises;\n        this._initPromises = [];\n        for (const r of list) {\n            r();\n        }\n    }\n    async _setProviderHooks() {\n        if (!this._evm) {\n            throw new Error('EVM provider is not set');\n        }\n        if (this._evm.provider) {\n            this._evm.provider.on('accountsChanged', this.onAccountsChanged);\n        }\n    }\n    async _signatureForLogin() {\n        if (!this._evm) {\n            throw new Error('EVM provider is not set');\n        }\n        const scheme = window.location.protocol.slice(0, -1);\n        const domain = window.location.host;\n        const origin = window.location.origin;\n        const address = await this._getEVMAddress();\n        const message = (0,viem_siwe__WEBPACK_IMPORTED_MODULE_40__.createSiweMessage)({\n            address,\n            chainId: 1,\n            domain,\n            issuedAt: new Date('2024-12-16T12:17:43.182Z'), // this remains same to arrive at same pvt key\n            nonce: 'iLjYWC6s8frYt4l8w', // maybe this can be shortened hash of address\n            scheme,\n            statement: SIWE_STATEMENT,\n            uri: origin,\n            version: '1',\n        });\n        const currentChain = await this._getChainID();\n        try {\n            await this._evm.client.switchChain({ id: 1 });\n            const res = await this._evm.client.signMessage({\n                account: address,\n                message,\n            });\n            return res;\n        }\n        finally {\n            await this._evm.client.switchChain({ id: currentChain });\n        }\n    }\n    async _waitForInit() {\n        const promise = new Promise((resolve) => {\n            this._initPromises.push(resolve);\n        });\n        return await promise;\n    }\n    _getSwapSupportedChainsAndTokens() {\n        return getSwapSupportedChains(this.chainList);\n    }\n}\n_CA_cosmosWallet = new WeakMap(), _CA_ephemeralWallet = new WeakMap();\nCA.getSupportedChains = getSupportedChains;\n\n/**\n * Check if a chain is supported\n */\nfunction isSupportedChain(chainId) {\n    return Object.values(_commons__WEBPACK_IMPORTED_MODULE_0__.SUPPORTED_CHAINS).includes(chainId);\n}\n/**\n * Check if a token is supported\n */\nfunction isSupportedToken(token) {\n    const supportedTokens = ['ETH', 'USDC', 'USDT'];\n    return supportedTokens.includes(token.toUpperCase());\n}\n\n/**\n * Service responsible for transaction handling and preparation\n */\nclass TransactionService {\n    constructor(adapter) {\n        this.adapter = adapter;\n        // Flag to enable/disable gas estimation (can be set via constructor or method)\n        this.enableGasEstimation = true;\n    }\n    /**\n     * Enable or disable gas estimation before transaction execution\n     */\n    setGasEstimationEnabled(enabled) {\n        this.enableGasEstimation = enabled;\n    }\n    /**\n     * Estimate gas for a transaction before execution\n     */\n    async estimateTransactionGas(provider, transactionParams) {\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Starting gas estimation...');\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Transaction params:', {\n            from: transactionParams.from,\n            to: transactionParams.to,\n            data: transactionParams.data.slice(0, 50) + '...', // Truncate for logging\n            value: transactionParams.value,\n        });\n        try {\n            // Step 1: Estimate gas\n            const gasEstimate = (await provider.request({\n                method: 'eth_estimateGas',\n                params: [transactionParams],\n            }));\n            const gasEstimateDecimal = parseInt(gasEstimate, 16);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Gas estimation successful:', {\n                gasEstimateHex: gasEstimate,\n                gasEstimateDecimal: gasEstimateDecimal,\n                gasEstimateFormatted: gasEstimateDecimal.toLocaleString(),\n            });\n            // Step 2: Get current gas price for cost calculation\n            let gasPriceGwei;\n            let estimatedCostEth;\n            try {\n                const gasPrice = (await provider.request({\n                    method: 'eth_gasPrice',\n                }));\n                const gasPriceDecimal = parseInt(gasPrice, 16);\n                const estimatedCostWei = gasEstimateDecimal * gasPriceDecimal;\n                const estimatedCostEthNum = estimatedCostWei / 1e18;\n                gasPriceGwei = (gasPriceDecimal / 1e9).toFixed(4) + ' gwei';\n                estimatedCostEth = estimatedCostEthNum.toFixed(8) + ' ETH';\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Gas cost estimation:', {\n                    gasPriceHex: gasPrice,\n                    gasPriceGwei: gasPriceGwei,\n                    estimatedCostWei: estimatedCostWei.toString(),\n                    estimatedCostEth: estimatedCostEth,\n                });\n            }\n            catch (gasPriceError) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('TransactionService - Failed to get gas price:', gasPriceError);\n            }\n            return {\n                success: true,\n                gasEstimate,\n                gasEstimateDecimal,\n                gasPriceGwei,\n                estimatedCostEth,\n            };\n        }\n        catch (gasEstimateError) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('TransactionService - Gas estimation failed:', gasEstimateError);\n            // Extract revert reason if available\n            let revertReason;\n            let errorMessage = 'Gas estimation failed';\n            if (gasEstimateError && typeof gasEstimateError === 'object') {\n                if ('data' in gasEstimateError && gasEstimateError.data) {\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('TransactionService - Gas estimation revert data:', gasEstimateError.data);\n                    revertReason = JSON.stringify(gasEstimateError.data);\n                }\n                if ('message' in gasEstimateError && gasEstimateError.message) {\n                    errorMessage = gasEstimateError.message;\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('TransactionService - Gas estimation error message:', errorMessage);\n                    // Extract common revert patterns\n                    if (errorMessage.includes('execution reverted')) {\n                        const revertMatch = errorMessage.match(/execution reverted:?\\s*(.+)/i);\n                        if (revertMatch && revertMatch[1]) {\n                            revertReason = revertMatch[1].trim();\n                        }\n                        else {\n                            revertReason = 'Transaction would revert (no reason provided)';\n                        }\n                    }\n                    else if (errorMessage.includes('insufficient funds')) {\n                        revertReason = 'Insufficient funds for gas * price + value';\n                    }\n                    else if (errorMessage.includes('out of gas')) {\n                        revertReason = 'Transaction would run out of gas';\n                    }\n                }\n            }\n            return {\n                success: false,\n                error: errorMessage,\n                revertReason,\n            };\n        }\n    }\n    /**\n     * Ensure we're on the correct chain, switch if needed\n     */\n    async ensureCorrectChain(targetChainId) {\n        try {\n            const currentChainId = await this.adapter.nexusSDK.getEVMClient().getChainId();\n            if (currentChainId !== targetChainId) {\n                try {\n                    await this.adapter.nexusSDK.getEVMClient().switchChain({ id: targetChainId });\n                    return { success: true };\n                }\n                catch (switchError) {\n                    if (switchError &&\n                        typeof switchError === 'object' &&\n                        'code' in switchError &&\n                        switchError.code === 4902) {\n                        throw new Error(`Chain ${targetChainId} is not configured in wallet. Please add it manually.`);\n                    }\n                    throw switchError;\n                }\n            }\n            return { success: true };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: (0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'chain switching'),\n            };\n        }\n    }\n    /**\n     * Prepare execution by validating parameters and encoding function call\n     */\n    async prepareExecution(params) {\n        // Get the from address first (needed for callback)\n        const fromAddress = await this.adapter.nexusSDK.getEVMClient().getAddresses();\n        if (!fromAddress || fromAddress.length === 0) {\n            throw new Error('No accounts available');\n        }\n        // Ensure we're on the correct chain\n        const chainResult = await this.ensureCorrectChain(params.toChainId);\n        if (!chainResult.success) {\n            throw new Error(`Failed to switch to chain ${params.toChainId}: ${chainResult.error}`);\n        }\n        // Call buildFunctionParams callback to get the actual function parameters\n        // For ETH transactions, provide ETH as token and 0 as amount if tokenApproval is undefined\n        const token = params.tokenApproval?.token || 'ETH';\n        const amount = params.tokenApproval?.amount || '0';\n        const { functionParams, value: callbackValue } = params.buildFunctionParams(token, amount, params.toChainId, fromAddress[0]);\n        // Validate contract parameters with built function params\n        const validation = (0,_commons__WEBPACK_IMPORTED_MODULE_0__.validateContractParams)({\n            contractAddress: params.contractAddress,\n            contractAbi: params.contractAbi,\n            functionName: params.functionName,\n            functionParams,\n            chainId: params.toChainId,\n        });\n        if (!validation.isValid) {\n            throw new Error(`Invalid contract parameters: ${validation.error}`);\n        }\n        // Encode the function call\n        const encodingResult = (0,_commons__WEBPACK_IMPORTED_MODULE_0__.encodeContractCall)({\n            contractAbi: params.contractAbi,\n            functionName: params.functionName,\n            functionParams,\n        });\n        if (!encodingResult.success) {\n            throw new Error(`Failed to encode contract call: ${encodingResult.error}`);\n        }\n        return {\n            provider: this.adapter.nexusSDK.getEVMProviderWithCA(),\n            fromAddress: fromAddress[0],\n            encodedData: encodingResult.data,\n            value: callbackValue,\n        };\n    }\n    /**\n     * Send transaction with enhanced error handling and polling support\n     */\n    async sendTransaction(provider, fromAddress, contractAddress, encodedData, value, options) {\n        const transactionParams = {\n            from: fromAddress,\n            to: contractAddress,\n            data: encodedData,\n            value: value || '0x0',\n        };\n        try {\n            // Perform gas estimation if enabled\n            if (this.enableGasEstimation) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Performing pre-execution gas estimation...');\n                const gasEstimation = await this.estimateTransactionGas(provider, transactionParams);\n                if (!gasEstimation.success) {\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('TransactionService - Pre-execution gas estimation failed:', gasEstimation.error);\n                    if (gasEstimation.revertReason) {\n                        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`TransactionService - Transaction will likely fail: ${gasEstimation.revertReason}`);\n                        throw new Error(`Transaction simulation failed: ${gasEstimation.revertReason}`);\n                    }\n                }\n                else {\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Gas estimation completed successfully:', {\n                        gasEstimate: gasEstimation.gasEstimate,\n                        estimatedCost: gasEstimation.estimatedCostEth,\n                        gasPrice: gasEstimation.gasPriceGwei,\n                    });\n                }\n            }\n            else {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Gas estimation disabled, proceeding with transaction');\n            }\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Sending transaction...');\n            const response = await provider.request({\n                method: 'eth_sendTransaction',\n                params: [transactionParams],\n            });\n            // Get transaction hash with fallback polling\n            const hashResult = await (0,_commons__WEBPACK_IMPORTED_MODULE_0__.getTransactionHashWithFallback)(provider, response, {\n                enablePolling: options.enableTransactionPolling,\n                timeout: options.transactionTimeout,\n                fromAddress,\n            });\n            if (!hashResult.success || !hashResult.hash) {\n                throw new Error(hashResult.error || 'Failed to retrieve transaction hash from provider response');\n            }\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Transaction sent successfully:', {\n                transactionHash: hashResult.hash,\n            });\n            return hashResult.hash;\n        }\n        catch (error) {\n            // Enhanced error handling for common transaction failures\n            if (error && typeof error === 'object' && 'code' in error) {\n                if (error.code === 4001) {\n                    throw new Error('Transaction rejected by user');\n                }\n                else if (error.code === -32e3) {\n                    throw new Error('Insufficient funds for transaction');\n                }\n                else if (error.code === -32603) {\n                    throw new Error('Internal JSON-RPC error during transaction');\n                }\n            }\n            throw new Error(`Transaction failed: ${(0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'transaction')}`);\n        }\n    }\n    /**\n     * Handle transaction confirmation with receipt and confirmations\n     */\n    async handleTransactionConfirmation(provider, transactionHash, options, chainId) {\n        if (!options.waitForReceipt) {\n            return {};\n        }\n        try {\n            const receiptResult = await (0,_commons__WEBPACK_IMPORTED_MODULE_0__.waitForTransactionReceipt)(provider, transactionHash, {\n                timeout: options.receiptTimeout,\n                requiredConfirmations: options.requiredConfirmations,\n            }, chainId);\n            if (!receiptResult.success) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Failed to get transaction receipt: ${receiptResult.error}`);\n                return {};\n            }\n            return {\n                receipt: receiptResult.receipt,\n                confirmations: receiptResult.confirmations,\n                gasUsed: receiptResult.receipt?.gasUsed?.toString(),\n                effectiveGasPrice: receiptResult.receipt?.effectiveGasPrice?.toString(),\n            };\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Receipt retrieval failed: ${(0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'receipt retrieval')}`);\n            return {};\n        }\n    }\n    /**\n     * Build execute result with transaction information\n     */\n    buildExecuteResult(transactionHash, chainId, receiptInfo) {\n        return {\n            transactionHash,\n            explorerUrl: (0,_commons__WEBPACK_IMPORTED_MODULE_0__.getBlockExplorerUrl)(chainId, transactionHash),\n            chainId,\n            ...receiptInfo,\n        };\n    }\n    /**\n     * Direct native token transfer (ETH, MATIC, AVAX, etc.)\n     */\n    async transferNativeToken(provider, fromAddress, toAddress, amount, // Amount in human-readable format (e.g., \"0.1\")\n    decimals = 18) {\n        const { parseUnits } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12\"), __webpack_require__.e(\"vendor-chunks/abitype@1.1.0_typescript@5.9.3_zod@4.1.12\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/index.js\"));\n        const valueInWei = parseUnits(amount, decimals);\n        const transactionParams = {\n            from: fromAddress,\n            to: toAddress,\n            data: '0x',\n            value: `0x${valueInWei.toString(16)}`,\n        };\n        try {\n            // Perform gas estimation if enabled\n            if (this.enableGasEstimation) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Performing gas estimation for native token transfer...');\n                const gasEstimation = await this.estimateTransactionGas(provider, transactionParams);\n                if (!gasEstimation.success) {\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('TransactionService - Gas estimation failed for native token transfer:', gasEstimation.error);\n                    throw new Error(`Native token transfer gas estimation failed: ${gasEstimation.error}`);\n                }\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Native token transfer gas estimation successful:', {\n                    gasEstimate: gasEstimation.gasEstimate,\n                    estimatedCost: gasEstimation.estimatedCostEth,\n                });\n            }\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Sending native token transfer...');\n            const response = await provider.request({\n                method: 'eth_sendTransaction',\n                params: [transactionParams],\n            });\n            const transactionHash = (0,_commons__WEBPACK_IMPORTED_MODULE_0__.getTransactionHashWithFallback)(provider, response);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Native token transfer sent successfully:', transactionHash);\n            return transactionHash;\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('TransactionService - Native token transfer failed:', error);\n            throw new Error(`Native token transfer failed: ${(0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'native transfer')}`);\n        }\n    }\n    /**\n     * Direct ERC20 token transfer\n     */\n    async transferERC20Token(provider, fromAddress, tokenAddress, toAddress, amount, // Amount in human-readable format (e.g., \"100\")\n    decimals = 18) {\n        const { parseUnits } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12\"), __webpack_require__.e(\"vendor-chunks/abitype@1.1.0_typescript@5.9.3_zod@4.1.12\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/index.js\"));\n        try {\n            const amountInWei = parseUnits(amount, decimals);\n            // ERC20 transfer function selector: transfer(address,uint256)\n            const transferSelector = '0xa9059cbb';\n            const paddedRecipient = toAddress.slice(2).padStart(64, '0');\n            const paddedAmount = amountInWei.toString(16).padStart(64, '0');\n            const transferData = `${transferSelector}${paddedRecipient}${paddedAmount}`;\n            const transactionParams = {\n                from: fromAddress,\n                to: tokenAddress,\n                data: transferData,\n                value: '0x0',\n            };\n            // Perform gas estimation if enabled\n            if (this.enableGasEstimation) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Performing gas estimation for ERC20 transfer...');\n                const gasEstimation = await this.estimateTransactionGas(provider, transactionParams);\n                if (!gasEstimation.success) {\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('TransactionService - Gas estimation failed for ERC20 transfer:', gasEstimation.error);\n                    if (gasEstimation.revertReason) {\n                        throw new Error(`ERC20 transfer will fail: ${gasEstimation.revertReason}`);\n                    }\n                    throw new Error(`ERC20 transfer gas estimation failed: ${gasEstimation.error}`);\n                }\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - ERC20 transfer gas estimation successful:', {\n                    gasEstimate: gasEstimation.gasEstimate,\n                    estimatedCost: gasEstimation.estimatedCostEth,\n                });\n            }\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - Sending ERC20 transfer...');\n            const response = await provider.request({\n                method: 'eth_sendTransaction',\n                params: [transactionParams],\n            });\n            const transactionHash = (0,_commons__WEBPACK_IMPORTED_MODULE_0__.getTransactionHashWithFallback)(provider, response);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('TransactionService - ERC20 transfer sent successfully:', transactionHash);\n            return transactionHash;\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('TransactionService - ERC20 transfer failed:', error);\n            throw new Error(`ERC20 transfer failed: ${(0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'ERC20 transfer')}`);\n        }\n    }\n}\n\n/**\n * Internal constants for adapter behavior\n */\nconst ADAPTER_CONSTANTS$1 = {\n    // Default 2% buffer (200 bps) to handle precision issues. Can be overridden per-call via ExecuteParams.approvalBufferBps\n    APPROVAL_BUFFER_BPS_DEFAULT: 200n,\n    DEFAULT_DECIMALS: 18,\n    MAX_APPROVAL_AMOUNT: '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',\n};\n/**\n * Service responsible for handling contract approvals\n */\nclass ApprovalService {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    /**\n     * Check if approval is needed for a token spending operation\n     */\n    async checkApprovalNeeded(tokenApproval, spenderAddress, chainId, approvalBufferBps) {\n        const accounts = await this.adapter.nexusSDK.getEVMClient().getAddresses();\n        if (!accounts || accounts.length === 0) {\n            throw new Error('No accounts available');\n        }\n        const ownerAddress = accounts[0];\n        const tokenContractAddress = (0,_commons__WEBPACK_IMPORTED_MODULE_0__.getTokenContractAddress)(tokenApproval.token, chainId);\n        if (!tokenContractAddress) {\n            throw new Error(`Token contract address not found for ${tokenApproval.token} on chain ${chainId}`);\n        }\n        try {\n            // Convert amount to proper token units - handle both decimal and integer formats\n            let amountInWei;\n            // Get token metadata for decimal handling\n            const tokenMetadata = _commons__WEBPACK_IMPORTED_MODULE_0__.TOKEN_METADATA[tokenApproval.token.toUpperCase()];\n            const decimals = tokenMetadata?.decimals || ADAPTER_CONSTANTS$1.DEFAULT_DECIMALS;\n            try {\n                // Handle both decimal strings (user-friendly) and integer strings (already converted)\n                // This matches the logic from the legacy adapter\n                if (tokenApproval.amount.includes('.')) {\n                    // Decimal amount - user-friendly format like \"0.01\"\n                    amountInWei = (0,viem__WEBPACK_IMPORTED_MODULE_41__.parseUnits)(tokenApproval.amount, decimals);\n                }\n                else {\n                    // Integer amount - likely already in wei/micro format like \"10000\"\n                    // For USDC and other 6-decimal tokens, check if this is already in micro-units\n                    const amountNum = BigInt(tokenApproval.amount);\n                    const USDC_THRESHOLD = 1000000n; // 1 USDC in micro-units\n                    if (decimals === 6 && amountNum > USDC_THRESHOLD) {\n                        // For USDC, large numbers are likely already in micro-units\n                        amountInWei = amountNum;\n                    }\n                    else if (decimals === 18 && amountNum > 1000000000000000000n) {\n                        // For ETH, large numbers are likely already in wei\n                        amountInWei = amountNum;\n                    }\n                    else {\n                        // Small numbers are likely user amounts that need conversion\n                        amountInWei = (0,viem__WEBPACK_IMPORTED_MODULE_41__.parseUnits)(tokenApproval.amount, decimals);\n                    }\n                }\n            }\n            catch (error) {\n                throw new Error(`Failed to parse amount ${tokenApproval.amount} for ${tokenApproval.token}: ${(0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'amount parsing')}`);\n            }\n            const currentAllowance = await this.adapter.nexusSDK.getEVMClient().readContract({\n                address: tokenContractAddress,\n                abi: viem__WEBPACK_IMPORTED_MODULE_42__.erc20Abi,\n                functionName: 'allowance',\n                args: [ownerAddress, spenderAddress],\n            });\n            // Add a small buffer to avoid repeated approvals due to minor amount differences\n            const bufferBps = approvalBufferBps !== undefined && approvalBufferBps >= 0\n                ? BigInt(approvalBufferBps)\n                : ADAPTER_CONSTANTS$1.APPROVAL_BUFFER_BPS_DEFAULT;\n            const requiredAmountWithBuffer = amountInWei + (amountInWei * bufferBps) / 10000n;\n            const needsApproval = currentAllowance < requiredAmountWithBuffer;\n            return {\n                needsApproval,\n                currentAllowance,\n                requiredAmount: amountInWei,\n                tokenAddress: tokenContractAddress,\n                spenderAddress,\n                token: tokenApproval.token,\n                chainId,\n                hasPendingApproval: !needsApproval,\n            };\n        }\n        catch (error) {\n            throw new Error(`Failed to check approval for ${tokenApproval.token}: ${(0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'approval check')}`);\n        }\n    }\n    /**\n     * Ensure contract approval is in place for token spending\n     */\n    async ensureContractApproval(tokenApproval, spenderAddress, chainId, waitForConfirmation = false, approvalBufferBps) {\n        try {\n            // Check if approval is needed\n            const approvalInfo = await this.checkApprovalNeeded(tokenApproval, spenderAddress, chainId, approvalBufferBps);\n            // Skip approval if sufficient allowance exists\n            if (!approvalInfo.needsApproval) {\n                return {\n                    wasNeeded: false,\n                    confirmed: true,\n                };\n            }\n            const accounts = await this.adapter.nexusSDK.getEVMClient().getAddresses();\n            if (!accounts || accounts.length === 0) {\n                return {\n                    wasNeeded: true,\n                    error: 'No accounts available',\n                };\n            }\n            // Calculate buffer amount with proper decimal handling for MetaMask display\n            const bufferBps = approvalBufferBps !== undefined && approvalBufferBps >= 0\n                ? BigInt(approvalBufferBps)\n                : ADAPTER_CONSTANTS$1.APPROVAL_BUFFER_BPS_DEFAULT;\n            const requiredAmountWithBuffer = approvalInfo.requiredAmount + (approvalInfo.requiredAmount * bufferBps) / 10000n;\n            // Get token decimals for proper formatting\n            const tokenMetadata = _commons__WEBPACK_IMPORTED_MODULE_0__.TOKEN_METADATA[tokenApproval.token.toUpperCase()];\n            const tokenDecimals = tokenMetadata?.decimals || ADAPTER_CONSTANTS$1.DEFAULT_DECIMALS;\n            // Convert to human-readable format first, then back to wei for better MetaMask display\n            // This ensures MetaMask shows \"0.01001\" instead of \"10100\"\n            const humanReadableAmount = (0,viem__WEBPACK_IMPORTED_MODULE_43__.formatUnits)(requiredAmountWithBuffer, tokenDecimals);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG approval - Human readable amount for MetaMask:', {\n                humanReadableAmount,\n                token: tokenApproval.token,\n            });\n            // Convert back to wei for the transaction\n            const finalApprovalAmount = (0,viem__WEBPACK_IMPORTED_MODULE_41__.parseUnits)(humanReadableAmount, tokenDecimals);\n            const chain = this.adapter.nexusSDK.chainList.getChainByID(chainId);\n            if (!chain) {\n                throw new Error('chain not supported');\n            }\n            const transactionHash = await this.adapter.nexusSDK.getEVMClient().writeContract({\n                functionName: 'approve',\n                abi: viem__WEBPACK_IMPORTED_MODULE_42__.erc20Abi,\n                address: approvalInfo.tokenAddress,\n                args: [spenderAddress, finalApprovalAmount],\n                chain,\n                account: accounts[0],\n            });\n            if (waitForConfirmation) {\n                try {\n                    await this.adapter.nexusSDK.getEVMClient().waitForTransactionReceipt({\n                        hash: transactionHash,\n                        retryCount: 10,\n                    });\n                }\n                catch (confirmationError) {\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('DEBUG approval - Confirmation failed:', confirmationError);\n                    return {\n                        transactionHash,\n                        wasNeeded: true,\n                        confirmed: false,\n                        error: `Approval confirmation failed: ${(0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(confirmationError, 'approval confirmation')}`,\n                    };\n                }\n                return {\n                    transactionHash,\n                    wasNeeded: true,\n                    confirmed: true,\n                };\n            }\n            return {\n                transactionHash,\n                wasNeeded: false,\n                confirmed: false,\n            };\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('DEBUG approval - Error:', error);\n            return {\n                wasNeeded: true,\n                error: (0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'contract approval'),\n            };\n        }\n    }\n}\n\n/**\n * Multi-step simulation engine with state override capabilities\n */\nclass SimulationEngine {\n    constructor(adapter) {\n        this.adapter = adapter;\n    }\n    ensureInitialized() {\n        if (!this.adapter.nexusSDK.isInitialized()) {\n            throw new Error('Adapter not initialized');\n        }\n    }\n    /**\n     * Main entry point for enhanced simulation with automatic state setup\n     */\n    async simulateWithStateSetup(params) {\n        this.ensureInitialized();\n        try {\n            const { user, tokenRequired, amountRequired, contractCall } = params;\n            const chainId = contractCall.toChainId;\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG SimulationEngine - Starting enhanced simulation with full context:', {\n                user,\n                tokenRequired,\n                amountRequired,\n                chainId,\n                contract: contractCall.contractAddress,\n                function: contractCall.functionName,\n                contractCallParams: {\n                    tokenApproval: contractCall.tokenApproval,\n                    buildFunctionParams: typeof contractCall.buildFunctionParams,\n                },\n            });\n            // Step 1: Check user's current token balance\n            const balanceCheck = await this.checkUserBalance(user, tokenRequired, chainId, amountRequired);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG SimulationEngine - Balance check result:', balanceCheck);\n            // Step 2: Generate simulation steps\n            const steps = await this.generateSimulationSteps({\n                user,\n                tokenRequired,\n                amountRequired,\n                contractCall,\n                balanceCheck,\n            });\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG SimulationEngine - Generated steps:', steps.length);\n            // Step 3: Execute multi-step simulation\n            const result = await this.executeBatchSimulation(steps, chainId);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG SimulationEngine - Simulation complete:', {\n                success: result.success,\n                totalGas: result.totalGasUsed,\n                stepsExecuted: result.steps.length,\n            });\n            return result;\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('DEBUG SimulationEngine - Simulation failed:', error);\n            return this.createFailedResult(`Enhanced simulation failed: ${(0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'simulation')}`);\n        }\n    }\n    /**\n     * Check user's token balance on specific chain\n     */\n    async checkUserBalance(user, token, chainId, requiredAmount) {\n        try {\n            const tokenAddress = (0,_commons__WEBPACK_IMPORTED_MODULE_0__.getTokenContractAddress)(token, chainId);\n            if (!tokenAddress) {\n                throw new Error(`Token ${token} not supported on chain ${chainId}`);\n            }\n            // For native ETH, use eth_getBalance\n            if (token === 'ETH') {\n                const balance = await this.adapter.nexusSDK.getEVMClient().getBalance({\n                    address: user,\n                    blockTag: 'latest',\n                });\n                const balanceBigInt = BigInt(balance);\n                const requiredBigInt = requiredAmount ? BigInt(requiredAmount) : BigInt(0);\n                const sufficient = balanceBigInt >= requiredBigInt;\n                const shortfall = sufficient ? '0' : (requiredBigInt - balanceBigInt).toString();\n                return {\n                    balance: balance.toString(),\n                    sufficient,\n                    shortfall,\n                    tokenAddress,\n                };\n            }\n            const balance = await this.adapter.nexusSDK.getEVMClient().readContract({\n                abi: viem__WEBPACK_IMPORTED_MODULE_42__.erc20Abi,\n                functionName: 'balanceOf',\n                args: [user],\n                address: tokenAddress,\n            });\n            if (requiredAmount) {\n                const requiredBigInt = BigInt(requiredAmount);\n                const sufficient = balance >= requiredBigInt;\n                const shortfall = sufficient ? '0' : (requiredBigInt - balance).toString();\n                return {\n                    balance: balance.toString(),\n                    sufficient,\n                    shortfall,\n                    tokenAddress,\n                };\n            }\n            return {\n                balance: balance.toString(),\n                sufficient: false, // Cannot determine without required amount\n                shortfall: '0',\n                tokenAddress,\n            };\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Failed to check balance for ${token} on chain ${chainId}:`, error);\n            return {\n                balance: '0',\n                sufficient: false,\n                shortfall: requiredAmount || '0',\n                tokenAddress: (0,_commons__WEBPACK_IMPORTED_MODULE_0__.getTokenContractAddress)(token, chainId) || '',\n            };\n        }\n    }\n    /**\n     * Get the storage slot for token balances mapping - Production Ready Static Mapping\n     * Based on actual contract analysis for all supported tokens and chains\n     */\n    getBalanceStorageSlot(token, chainId) {\n        const storageSlotMapping = {\n            // Ethereum Mainnet (1)\n            1: {\n                ETH: 0,\n                USDC: 9,\n                USDT: 2,\n            },\n            // Base Mainnet (8453)\n            8453: {\n                ETH: 0,\n                USDC: 9,\n                USDT: 2,\n            },\n            // Arbitrum One (42161)\n            42161: {\n                ETH: 0,\n                USDC: 9,\n                USDT: 2,\n            },\n            // Optimism (10)\n            10: {\n                ETH: 0,\n                USDC: 9,\n                USDT: 2,\n            },\n            // Polygon (137)\n            137: {\n                ETH: 0,\n                USDC: 9,\n                USDT: 2,\n            },\n            // Avalanche C-Chain (43114)\n            43114: {\n                ETH: 0,\n                USDC: 9,\n                USDT: 2,\n            },\n            // Scroll (534352)\n            534352: {\n                ETH: 0,\n                USDC: 9,\n                USDT: 2,\n            },\n            // Base Sepolia Testnet (84532)\n            84532: {\n                ETH: 0,\n                USDC: 9,\n                USDT: 2,\n            },\n            // Arbitrum Sepolia Testnet (421614)\n            421614: {\n                ETH: 0,\n                USDC: 9,\n                USDT: 2,\n            },\n            // Optimism Sepolia Testnet (11155420)\n            11155420: {\n                ETH: 0,\n                USDC: 9,\n                USDT: 2,\n            },\n            // Polygon Amoy Testnet (80002)\n            80002: {\n                ETH: 0,\n                USDC: 9,\n                USDT: 2,\n            },\n        };\n        const chainMapping = storageSlotMapping[chainId];\n        if (!chainMapping) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Unsupported chain ${chainId}, falling back to defaults`);\n            // Fallback defaults based on most common patterns\n            return token === 'USDC' ? 9 : token === 'USDT' ? 2 : 0;\n        }\n        const slot = chainMapping[token];\n        if (slot === undefined) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Token ${token} not supported on chain ${chainId}, falling back to defaults`);\n            return token === 'USDC' ? 9 : token === 'USDT' ? 2 : 0;\n        }\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`Using storage slot ${slot} for ${token} on chain ${chainId}`);\n        return slot;\n    }\n    /**\n     * Generate state overrides to fund user with required tokens\n     */\n    async generateStateOverrides(user, token, requiredAmount, chainId) {\n        try {\n            const tokenAddress = (0,_commons__WEBPACK_IMPORTED_MODULE_0__.getTokenContractAddress)(token, chainId);\n            if (!tokenAddress) {\n                throw new Error(`Token ${token} not supported on chain ${chainId}`);\n            }\n            // For native ETH\n            if (token === 'ETH') {\n                return {\n                    [user]: {\n                        balance: `0x${BigInt(requiredAmount).toString(16)}`,\n                    },\n                };\n            }\n            // For ERC20 tokens - override the balance mapping using verified storage slots\n            const balanceSlot = this.getBalanceStorageSlot(token, chainId);\n            // Calculate storage slot for user's balance: keccak256(user_address . balances_slot)\n            const userBalanceSlot = (0,viem__WEBPACK_IMPORTED_MODULE_27__.keccak256)((0,viem__WEBPACK_IMPORTED_MODULE_44__.encodePacked)(['address', 'uint256'], [user, BigInt(balanceSlot)]));\n            // Convert amount to hex with proper padding\n            const amountHex = `0x${BigInt(requiredAmount).toString(16).padStart(64, '0')}`;\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`Generating state override for ${token} on chain ${chainId}: slot=${balanceSlot}, storageKey=${userBalanceSlot}`);\n            return {\n                [tokenAddress]: {\n                    storage: {\n                        [userBalanceSlot]: amountHex,\n                    },\n                },\n            };\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('Error generating state overrides:', error);\n            throw error;\n        }\n    }\n    /**\n     * Generate the sequence of simulation steps needed\n     */\n    async generateSimulationSteps(params) {\n        const { user, tokenRequired, amountRequired, contractCall, balanceCheck } = params;\n        const steps = [];\n        // Check if user has sufficient balance\n        const requiredAmountBigInt = BigInt(amountRequired);\n        const currentBalanceBigInt = BigInt(balanceCheck.balance);\n        const needsFunding = currentBalanceBigInt < requiredAmountBigInt;\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG generateSimulationSteps - Balance analysis:', {\n            required: requiredAmountBigInt.toString(),\n            current: currentBalanceBigInt.toString(),\n            needsFunding,\n            tokenRequired,\n            user,\n            contractCall: {\n                functionName: contractCall.functionName,\n                contractAddress: contractCall.contractAddress,\n                tokenApproval: contractCall.tokenApproval,\n                buildFunctionParamsType: typeof contractCall.buildFunctionParams,\n            },\n        });\n        // Step 1: Funding step (if needed)\n        if (needsFunding) {\n            const stateOverrides = await this.generateStateOverrides(user, tokenRequired, amountRequired, contractCall.toChainId);\n            steps.push({\n                type: 'funding',\n                required: true,\n                description: `Fund user with ${amountRequired} ${tokenRequired}`,\n                stepId: 'funding-step',\n                stateOverride: stateOverrides,\n                params: {\n                    chainId: contractCall.toChainId.toString(),\n                    from: user,\n                    to: user,\n                    value: '0x0',\n                },\n            });\n        }\n        // First, convert amountRequired from micro-units to user-friendly format for the callback\n        // The callback expects amount in user-friendly format (e.g., \"0.01\" for 0.01 USDC)\n        // but amountRequired comes in micro-units (e.g., \"10000\" for 0.01 USDC)\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('Token metadata:', { meta: _commons__WEBPACK_IMPORTED_MODULE_0__.TOKEN_METADATA, tokenRequired });\n        const decimals = _commons__WEBPACK_IMPORTED_MODULE_0__.TOKEN_METADATA[tokenRequired]?.decimals ?? 6;\n        const userFriendlyAmount = (0,viem__WEBPACK_IMPORTED_MODULE_43__.formatUnits)(BigInt(amountRequired), decimals);\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG SimulationEngine - Amount conversion:', {\n            microUnits: amountRequired,\n            decimals,\n            userFriendly: userFriendlyAmount,\n        });\n        // Call the buildFunctionParams with user-friendly amount\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG SimulationEngine - Calling buildFunctionParams with:', {\n            tokenRequired,\n            userFriendlyAmount,\n            chainId: contractCall.toChainId,\n            user,\n        });\n        const { functionParams, value } = contractCall.buildFunctionParams(tokenRequired, userFriendlyAmount, contractCall.toChainId, user);\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG SimulationEngine - buildFunctionParams result:', {\n            functionParams,\n            value,\n            functionParamsLength: functionParams?.length,\n            functionParamsTypes: functionParams?.map((p) => typeof p),\n        });\n        // Step 2: Approval step (if needed for ERC20)\n        if (tokenRequired !== 'ETH' && contractCall.tokenApproval) {\n            const actualAmountToApprove = amountRequired;\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG SimulationEngine - Approval step preparation:', {\n                tokenRequired,\n                amountRequired,\n                actualAmountToApprove,\n                contractToApprove: contractCall.contractAddress,\n                tokenAddress: balanceCheck.tokenAddress,\n            });\n            const approvalCallData = await this.buildApprovalCallData(contractCall.contractAddress, actualAmountToApprove);\n            steps.push({\n                type: 'approval',\n                required: true,\n                description: `Approve ${contractCall.contractAddress} to spend ${tokenRequired}`,\n                stepId: 'approval-step',\n                dependsOn: needsFunding ? ['funding-step'] : undefined,\n                params: {\n                    chainId: contractCall.toChainId.toString(),\n                    from: user,\n                    to: balanceCheck.tokenAddress,\n                    data: approvalCallData,\n                    value: '0x0',\n                },\n            });\n        }\n        // Step 3: Execute step\n        // Encode the function call with the built parameters\n        const encodingResult = (0,_commons__WEBPACK_IMPORTED_MODULE_0__.encodeContractCall)({\n            contractAbi: contractCall.contractAbi,\n            functionName: contractCall.functionName,\n            functionParams,\n        });\n        if (!encodingResult.success) {\n            throw new Error(`Failed to encode contract call: ${encodingResult.error}`);\n        }\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG SimulationEngine - Execute step preparation:', {\n            encodedData: encodingResult.data,\n            contractCallValue: contractCall.value,\n            callbackValue: value,\n            finalValue: value || contractCall.value || '0x0',\n            dependsOn: tokenRequired !== 'ETH' ? ['approval-step'] : needsFunding ? ['funding-step'] : undefined,\n        });\n        steps.push({\n            type: 'execute',\n            required: true,\n            description: `Execute ${contractCall.functionName} on ${contractCall.contractAddress}`,\n            stepId: 'execute-step',\n            dependsOn: tokenRequired !== 'ETH' ? ['approval-step'] : needsFunding ? ['funding-step'] : undefined,\n            params: {\n                chainId: contractCall.toChainId.toString(),\n                from: user,\n                to: contractCall.contractAddress,\n                data: encodingResult.data,\n                value: value || contractCall.value || '0x0',\n            },\n        });\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG SimulationEngine - Final steps generated:', {\n            totalSteps: steps.length,\n            stepTypes: steps.map((s) => s.type),\n            stepIds: steps.map((s) => s.stepId),\n        });\n        return steps;\n    }\n    /**\n     * Build approval call data for ERC20 token\n     */\n    async buildApprovalCallData(spender, amount) {\n        // ERC20 approve function selector: approve(address,uint256)\n        const approveSelector = '0x095ea7b3';\n        const paddedSpender = spender.slice(2).padStart(64, '0');\n        const paddedAmount = BigInt(amount).toString(16).padStart(64, '0');\n        return `${approveSelector}${paddedSpender}${paddedAmount}`;\n    }\n    /**\n     * Execute batch simulation using bundle endpoint\n     */\n    async executeBatchSimulation(steps, chainId) {\n        const simulationClient = getSimulationClient();\n        if (!simulationClient) {\n            return this.createFailedResult('Simulation client not configured');\n        }\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG executeBatchSimulation - Starting bundle simulation with ${steps.length} steps`);\n        // Build cumulative state overrides\n        let cumulativeStateOverrides = {};\n        const bundleSimulations = [];\n        for (const step of steps) {\n            // Merge cumulative state overrides with step-specific overrides\n            cumulativeStateOverrides = this.mergeStateOverrides(cumulativeStateOverrides, step.stateOverride || {});\n            // Add to bundle\n            bundleSimulations.push({\n                stepId: step.stepId || '',\n                type: step.type,\n                from: step.params.from || '',\n                to: step.params.to || '',\n                data: step.params.data || '0x',\n                value: step.params.value || '0x0',\n                stateOverride: { ...cumulativeStateOverrides }, // Each step gets cumulative state\n            });\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG executeBatchSimulation - Prepared step: ${step.stepId} (${step.type})`);\n        }\n        try {\n            // Execute bundle simulation\n            const bundleRequest = {\n                chainId: chainId.toString(),\n                simulations: bundleSimulations,\n            };\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG executeBatchSimulation - Sending bundle request');\n            const bundleResult = await simulationClient.simulateBundle(bundleRequest);\n            if (!bundleResult.success) {\n                return {\n                    totalGasUsed: '0',\n                    success: false,\n                    error: 'Bundle simulation failed',\n                    steps: bundleResult.results.map((result) => ({\n                        stepId: result.stepId,\n                        type: bundleSimulations.find((sim) => sim.stepId === result.stepId)?.type || '',\n                        gasUsed: result.gasUsed,\n                        success: result.success,\n                        error: result.error,\n                    })),\n                    stateOverrides: cumulativeStateOverrides,\n                };\n            }\n            // Process successful bundle result\n            const executedSteps = bundleResult.results.map((result) => {\n                const stepType = bundleSimulations.find((sim) => sim.stepId === result.stepId)?.type || '';\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG executeBatchSimulation - Step ${result.stepId} completed:`, {\n                    gasUsed: result.gasUsed,\n                });\n                return {\n                    stepId: result.stepId,\n                    type: stepType,\n                    gasUsed: result.gasUsed,\n                    success: result.success,\n                    error: result.error,\n                    stateChanges: bundleSimulations.find((sim) => sim.stepId === result.stepId)\n                        ?.stateOverride,\n                };\n            });\n            return {\n                totalGasUsed: bundleResult.totalGasUsed,\n                success: true,\n                steps: executedSteps,\n                stateOverrides: cumulativeStateOverrides,\n                simulationMetadata: {\n                    blockNumber: 'latest',\n                    timestamp: new Date().toISOString(),\n                    chainId: chainId.toString(),\n                },\n            };\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('Bundle simulation error:', error);\n            return this.createFailedResult(`Bundle simulation failed: ${(0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'bundle simulation')}`);\n        }\n    }\n    /**\n     * Merge two state override objects\n     */\n    mergeStateOverrides(base, additional) {\n        const merged = { ...base };\n        for (const [address, overrides] of Object.entries(additional)) {\n            if (merged[address]) {\n                merged[address] = {\n                    ...merged[address],\n                    ...overrides,\n                    storage: {\n                        ...merged[address].storage,\n                        ...overrides.storage,\n                    },\n                };\n            }\n            else {\n                merged[address] = overrides;\n            }\n        }\n        return merged;\n    }\n    /**\n     * Create a failed simulation result\n     */\n    createFailedResult(error) {\n        return {\n            totalGasUsed: '0',\n            success: false,\n            error,\n            steps: [],\n        };\n    }\n}\n\n/**\n * Service responsible for handling execution operations\n */\nclass ExecuteService {\n    constructor(adapter) {\n        this.adapter = adapter;\n        this.transactionService = new TransactionService(adapter);\n        this.approvalService = new ApprovalService(adapter);\n    }\n    /**\n     * Enable or disable gas estimation for transactions\n     */\n    setGasEstimationEnabled(enabled) {\n        this.transactionService.setGasEstimationEnabled(enabled);\n    }\n    /**\n     * Execute a contract call with approval handling\n     */\n    async execute(params) {\n        try {\n            // Prepare execution (includes chain switching)\n            const preparation = await this.transactionService.prepareExecution(params);\n            // Handle approval if needed (after chain switching)\n            let approvalTxHash;\n            if (params.tokenApproval) {\n                const approvalResult = await this.approvalService.ensureContractApproval(params.tokenApproval, params.contractAddress, params.toChainId, false, params.approvalBufferBps);\n                if (approvalResult.error) {\n                    throw new Error(`Approval failed: ${approvalResult.error}`);\n                }\n                approvalTxHash = approvalResult.transactionHash;\n            }\n            // Send transaction\n            const transactionHash = await this.transactionService.sendTransaction(preparation.provider, preparation.fromAddress, params.contractAddress, preparation.encodedData, preparation.value || params.value || '0x0', {\n                enableTransactionPolling: params.enableTransactionPolling,\n                transactionTimeout: params.transactionTimeout,\n                waitForReceipt: params.waitForReceipt,\n                receiptTimeout: params.receiptTimeout,\n                requiredConfirmations: params.requiredConfirmations,\n            });\n            // Handle transaction confirmation\n            const receiptInfo = await this.transactionService.handleTransactionConfirmation(preparation.provider, transactionHash, {\n                waitForReceipt: params.waitForReceipt,\n                receiptTimeout: params.receiptTimeout,\n                requiredConfirmations: params.requiredConfirmations,\n            }, params.toChainId);\n            // Build result\n            const result = this.transactionService.buildExecuteResult(transactionHash, params.toChainId, receiptInfo);\n            // If approval happened, attach approval tx hash if available\n            if (params.tokenApproval && approvalTxHash) {\n                // Augment the typed result by casting to the extended type locally before returning\n                const extendedResult = {\n                    ...result,\n                    approvalTransactionHash: approvalTxHash,\n                };\n                return extendedResult;\n            }\n            return result;\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    /**\n     * Simulate contract execution\n     */\n    async simulateExecute(params) {\n        try {\n            // Get simulation client\n            const simulationClient = getSimulationClient();\n            if (!simulationClient) {\n                return {\n                    contractAddress: params.contractAddress,\n                    functionName: params.functionName,\n                    gasUsed: '0',\n                    success: false,\n                    error: 'Simulation client not configured',\n                };\n            }\n            // Get user address for callback\n            const fromAddress = await this.adapter.nexusSDK.getEVMClient().getAddresses();\n            if (!fromAddress || fromAddress.length === 0) {\n                throw new Error('No accounts available');\n            }\n            // Prepare execution to get encoded data and value (calls buildFunctionParams internally)\n            const preparation = await this.transactionService.prepareExecution(params);\n            // Create simulation parameters\n            const simulationParams = {\n                from: preparation.fromAddress,\n                to: params.contractAddress,\n                data: preparation.encodedData,\n                value: preparation.value || params.value || '0x0',\n                chainId: params.toChainId.toString(),\n            };\n            // Run simulation\n            const simulationResult = await simulationClient.simulate(simulationParams);\n            if (!simulationResult.success) {\n                return {\n                    contractAddress: params.contractAddress,\n                    functionName: params.functionName,\n                    gasUsed: '0',\n                    success: false,\n                    error: simulationResult.errorMessage || 'Simulation failed',\n                };\n            }\n            const gasUsedDecimal = (0,viem__WEBPACK_IMPORTED_MODULE_10__.hexToNumber)(simulationResult.gasUsed);\n            let gasCostEth;\n            try {\n                const gasPriceHex = (await this.adapter.nexusSDK.request({\n                    method: 'eth_gasPrice',\n                }));\n                const gasPriceWei = parseInt(gasPriceHex, 16);\n                const costEthNum = (gasUsedDecimal * gasPriceWei) / 1e18;\n                gasCostEth = costEthNum.toFixed(8);\n            }\n            catch (gpErr) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('Failed to fetch gas price during simulation cost calc:', gpErr);\n            }\n            return {\n                gasUsed: gasUsedDecimal.toString(),\n                success: true,\n                ...(gasCostEth ? { gasCostEth } : {}),\n            };\n        }\n        catch (error) {\n            return {\n                contractAddress: params.contractAddress,\n                functionName: params.functionName,\n                gasUsed: '0',\n                success: false,\n                error: (0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'execution simulation'),\n            };\n        }\n    }\n    /**\n     * Enhanced simulation with automatic state setup\n     */\n    async simulateExecuteEnhanced(params) {\n        try {\n            // Check if we should use enhanced simulation\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.debug('DEBUG ExecuteService - Full params received:', {\n                functionName: params.functionName,\n                contractAddress: params.contractAddress,\n                tokenApproval: params.tokenApproval,\n                buildFunctionParams: typeof params.buildFunctionParams,\n                toChainId: params.toChainId,\n            });\n            const shouldUseEnhancedSimulation = this.shouldUseEnhancedSimulation(params);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.debug('DEBUG ExecuteService - Final enhanced simulation decision:', shouldUseEnhancedSimulation);\n            if (shouldUseEnhancedSimulation) {\n                return await this.runEnhancedSimulation(params);\n            }\n            return await this.simulateExecute(params);\n        }\n        catch (error) {\n            return {\n                contractAddress: params.contractAddress,\n                functionName: params.functionName,\n                gasUsed: '0',\n                success: false,\n                error: (0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'enhanced simulation'),\n            };\n        }\n    }\n    /**\n     * Determine if enhanced simulation should be used\n     */\n    shouldUseEnhancedSimulation(params) {\n        // Use enhanced simulation if:\n        // 1. Token approval is required (indicates ERC20 interaction)\n        // 2. Function is likely to fail without proper balance setup\n        const shouldUse = params.tokenApproval !== undefined &&\n            params.tokenApproval.token !== 'ETH' &&\n            this.isComplexContractCall(params);\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.debug('DEBUG shouldUseEnhancedSimulation - Decision:', {\n            hasTokenApproval: !!params.tokenApproval,\n            isComplex: this.isComplexContractCall(params),\n            functionName: params.functionName,\n            finalDecision: shouldUse,\n        });\n        return (params.tokenApproval !== undefined &&\n            params.tokenApproval.token !== 'ETH' &&\n            this.isComplexContractCall(params));\n    }\n    /**\n     * Check if this is a complex contract call that benefits from enhanced simulation\n     */\n    isComplexContractCall(params) {\n        const complexFunctions = [\n            'deposit',\n            'withdraw',\n            'swap',\n            'trade',\n            'stake',\n            'unstake',\n            'mint',\n            'burn',\n            'transfer',\n            'transferFrom',\n            'approve',\n            'supply',\n            'borrow',\n            'repay',\n            'redeem',\n            'lend',\n        ];\n        return complexFunctions.some((func) => params.functionName.toLowerCase().includes(func.toLowerCase()));\n    }\n    /**\n     * Run enhanced simulation with automatic state setup\n     */\n    async runEnhancedSimulation(params) {\n        try {\n            // Check if evmProvider is available\n            if (!this.adapter.nexusSDK.getEVMProviderWithCA()) {\n                throw new Error('EVM provider not available for enhanced simulation');\n            }\n            const simulationEngine = new SimulationEngine(this.adapter);\n            // Get user address\n            const preparation = await this.transactionService.prepareExecution(params);\n            // Convert tokenApproval amount to proper format if needed\n            const tokenAmount = params.tokenApproval?.amount || '0';\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG ExecuteService - Running enhanced simulation:', {\n                user: preparation.fromAddress,\n                token: params.tokenApproval?.token,\n                amount: tokenAmount,\n                function: params.functionName,\n            });\n            // Run enhanced simulation (tokenApproval is guaranteed to exist here due to shouldUseEnhancedSimulation check)\n            if (!params.tokenApproval) {\n                throw new Error('Enhanced simulation requires token approval information');\n            }\n            const enhancedResult = await simulationEngine.simulateWithStateSetup({\n                user: preparation.fromAddress,\n                tokenRequired: params.tokenApproval.token,\n                amountRequired: tokenAmount,\n                contractCall: params,\n            });\n            // Convert enhanced result to ExecuteSimulation format\n            if (!enhancedResult.success) {\n                return {\n                    contractAddress: params.contractAddress,\n                    functionName: params.functionName,\n                    gasUsed: '0',\n                    success: false,\n                    error: enhancedResult.error || 'Enhanced simulation failed',\n                };\n            }\n            // enhancedResult.totalGasUsed is already an ETH-denominated string (SimulationEngine converts)\n            return {\n                contractAddress: params.contractAddress,\n                functionName: params.functionName,\n                gasUsed: enhancedResult.totalGasUsed,\n                success: true,\n                gasCostEth: enhancedResult.totalGasUsed,\n            };\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('Enhanced simulation failed, falling back to standard:', error);\n            // Fallback to standard simulation\n            return await this.simulateExecute(params);\n        }\n    }\n}\n\n// Local constants for the service\nconst ADAPTER_CONSTANTS = {\n    DEFAULT_DECIMALS: 18,\n};\nclass BridgeExecuteService {\n    constructor(adapter) {\n        this.adapter = adapter;\n        this.skipBridge = false;\n        this.optimalBridgeAmount = '0';\n        this.executeService = new ExecuteService(adapter);\n    }\n    /**\n     * Enable or disable gas estimation for execute transactions\n     * This provides easy control over whether gas estimation runs before execution\n     */\n    setGasEstimationEnabled(enabled) {\n        // Access the transaction service through the execute service's public method\n        this.executeService.setGasEstimationEnabled(enabled);\n    }\n    /**\n     * Bridge and execute operation - combines bridge and execute with proper sequencing\n     * Now includes smart balance checking to skip bridging when sufficient funds exist\n     */\n    async bridgeAndExecute(params) {\n        const { toChainId, token, amount, execute, enableTransactionPolling = false, transactionTimeout = 30000, waitForReceipt = true, receiptTimeout = 300000, requiredConfirmations = 1, } = params;\n        // Declare here so accessible in catch/finally\n        let stepForwarder = () => { };\n        try {\n            // Normalize the input amount to ensure consistent processing\n            const normalizedAmount = this.normalizeAmountToWei(amount, token);\n            // Check if simulation was run - if not, calculate optimal bridge amount\n            if (this.optimalBridgeAmount === '0' && !this.skipBridge) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('Simulation was not run, calculating optimal bridge amount...');\n                const bridgeOptimization = await this.calculateOptimalBridgeAmount(toChainId, token, normalizedAmount);\n                this.skipBridge = bridgeOptimization.skipBridge;\n                this.optimalBridgeAmount = bridgeOptimization.optimalAmount;\n            }\n            // Use the skipBridge flag set during simulation to determine execution path\n            if (this.skipBridge && execute) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`Enhanced smart routing: Sufficient ${token} + gas balance on chain ${toChainId}, skipping bridge and executing directly`);\n                // Skip bridging - execute directly with existing funds\n                return await this.executeDirectly(execute, toChainId, token, normalizedAmount, enableTransactionPolling, transactionTimeout, waitForReceipt, receiptTimeout, requiredConfirmations);\n            }\n            // Original bridge-and-execute flow when enhanced balance check fails\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`Enhanced smart routing: Insufficient ${token} or gas balance on chain ${toChainId}, proceeding with bridge + execute`);\n            // Set up listeners to capture Arcana bridge steps and forward step completions\n            const bridgeStepsPromise = new Promise((resolve) => {\n                const expectedHandler = (steps) => {\n                    this.adapter.nexusSDK.nexusEvents.off(_commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS.EXPECTED_STEPS, expectedHandler);\n                    resolve(steps);\n                };\n                this.adapter.nexusSDK.nexusEvents.on(_commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS.EXPECTED_STEPS, expectedHandler);\n            });\n            stepForwarder = (step) => {\n                this.adapter.nexusSDK.nexusEvents.emit(_commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS.BRIDGE_EXECUTE_COMPLETED_STEPS, step);\n            };\n            this.adapter.nexusSDK.nexusEvents.on(_commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS.STEP_COMPLETE, stepForwarder);\n            // Perform the actual bridge transaction using optimal amount\n            // Convert optimal bridge amount from wei to user-friendly format for bridge service\n            const tokenMetadata = _commons__WEBPACK_IMPORTED_MODULE_0__.TOKEN_METADATA[token.toUpperCase()];\n            const decimals = tokenMetadata?.decimals || 18;\n            const { formatUnits } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12\"), __webpack_require__.e(\"vendor-chunks/abitype@1.1.0_typescript@5.9.3_zod@4.1.12\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/index.js\"));\n            const userFriendlyBridgeAmount = formatUnits(BigInt(this.optimalBridgeAmount), decimals);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('Bridge amount conversion for execution:', {\n                optimalBridgeAmountWei: this.optimalBridgeAmount,\n                userFriendlyBridgeAmount,\n                decimals,\n                token,\n            });\n            const bridgeResult = await this.adapter.nexusSDK.bridge({\n                token,\n                amount: userFriendlyBridgeAmount,\n                chainId: toChainId,\n            });\n            if (!bridgeResult.success) {\n                throw new Error(`Bridge failed: ${bridgeResult.error}`);\n            }\n            // Wait for captured bridge steps\n            const bridgeSteps = await bridgeStepsPromise;\n            // Add a small delay to ensure bridge settlement is complete\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG bridgeAndExecute - Waiting for bridge settlement...');\n            await new Promise((resolve) => setTimeout(resolve, 2000)); // 2 second delay\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG bridgeAndExecute - Bridge settlement delay complete');\n            // Prepare extra steps for approval/execute/receipt/confirmation\n            const extraSteps = [];\n            const makeStep = (typeID, type, data = {}) => ({\n                typeID,\n                type,\n                data: {\n                    chainID: toChainId,\n                    chainName: _commons__WEBPACK_IMPORTED_MODULE_0__.CHAIN_METADATA[toChainId]?.name || toChainId.toString(),\n                    ...data,\n                },\n            });\n            if (execute?.tokenApproval) {\n                extraSteps.push(makeStep('AP', 'APPROVAL'));\n            }\n            if (execute) {\n                extraSteps.push(makeStep('TS', 'TRANSACTION_SENT'));\n                if (waitForReceipt) {\n                    extraSteps.push(makeStep('RR', 'RECEIPT_RECEIVED'));\n                }\n                if ((requiredConfirmations ?? 0) > 0) {\n                    extraSteps.push(makeStep('CN', 'TRANSACTION_CONFIRMED'));\n                }\n            }\n            // Emit consolidated expected steps for the whole operation\n            this.adapter.nexusSDK.nexusEvents.emit(_commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS.BRIDGE_EXECUTE_EXPECTED_STEPS, [\n                ...bridgeSteps,\n                ...extraSteps,\n            ]);\n            const { executeTransactionHash, executeExplorerUrl, approvalTransactionHash } = await this.handleExecutePhase(execute, toChainId, token, normalizedAmount, enableTransactionPolling, transactionTimeout, waitForReceipt, receiptTimeout, requiredConfirmations, \n            // pass helper to emit steps\n            (step) => this.adapter.nexusSDK.nexusEvents.emit(_commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS.BRIDGE_EXECUTE_COMPLETED_STEPS, step), makeStep);\n            const result = {\n                executeTransactionHash,\n                executeExplorerUrl,\n                approvalTransactionHash,\n                bridgeTransactionHash: bridgeResult.transactionHash,\n                bridgeExplorerUrl: bridgeResult.explorerUrl,\n                toChainId,\n                success: true,\n                bridgeSkipped: false, // bridge was performed normally\n            };\n            // Clean up listener\n            this.adapter.nexusSDK.nexusEvents.off(_commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS.STEP_COMPLETE, stepForwarder);\n            return result;\n        }\n        catch (error) {\n            const errorMessage = (0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'bridge and execute');\n            // Forward error step (generic) for UI consumers\n            this.adapter.nexusSDK.nexusEvents.emit(_commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS.BRIDGE_EXECUTE_COMPLETED_STEPS, {\n                typeID: 'ER',\n                type: 'operation.failed',\n                data: {\n                    error: errorMessage,\n                    stage: errorMessage.includes('Execute phase failed') ? 'execute' : 'bridge',\n                },\n            });\n            // Clean listener\n            this.adapter.nexusSDK.nexusEvents.off(_commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS.STEP_COMPLETE, stepForwarder);\n            return {\n                toChainId,\n                success: false,\n                error: `Bridge and execute operation failed: ${errorMessage}`,\n                bridgeSkipped: false, // error occurred during normal bridge flow\n            };\n        }\n    }\n    /**\n     * Simulate bridge and execute operation\n     * Now includes smart routing simulation\n     */\n    async simulateBridgeAndExecute(params) {\n        try {\n            const { execute } = params;\n            const steps = [];\n            // Normalize the input amount to ensure consistent processing\n            const normalizedAmount = this.normalizeAmountToWei(params.amount, params.token);\n            // First, calculate optimal bridge amount based on destination balance\n            const bridgeOptimization = await this.calculateOptimalBridgeAmount(params.toChainId, params.token, normalizedAmount);\n            this.skipBridge = bridgeOptimization.skipBridge;\n            this.optimalBridgeAmount = bridgeOptimization.optimalAmount;\n            // Run simulations with optimal amounts\n            let bridgeSimulation = null;\n            let bridgeReceiveAmount = '0';\n            let totalBridgeFee = '0';\n            // Only add bridge step if we're not skipping it\n            if (!this.skipBridge) {\n                // Convert optimal bridge amount from wei to user-friendly format for bridge service\n                const tokenMetadata = _commons__WEBPACK_IMPORTED_MODULE_0__.TOKEN_METADATA[params.token.toUpperCase()];\n                const decimals = tokenMetadata?.decimals || 18;\n                const { formatUnits } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12\"), __webpack_require__.e(\"vendor-chunks/abitype@1.1.0_typescript@5.9.3_zod@4.1.12\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/index.js\"));\n                const userFriendlyBridgeAmount = formatUnits(BigInt(this.optimalBridgeAmount), decimals);\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('Bridge amount conversion for simulation:', {\n                    optimalBridgeAmountWei: this.optimalBridgeAmount,\n                    userFriendlyBridgeAmount,\n                    decimals,\n                    token: params.token,\n                });\n                bridgeSimulation = await this.adapter.nexusSDK.simulateBridge({\n                    token: params.token,\n                    amount: userFriendlyBridgeAmount,\n                    chainId: params.toChainId,\n                });\n                steps.push({\n                    type: 'bridge',\n                    required: true,\n                    simulation: bridgeSimulation,\n                    description: `Bridge ${userFriendlyBridgeAmount} ${params.token} to chain ${params.toChainId}`,\n                });\n                // Enhanced bridge analysis\n                if (bridgeSimulation?.intent) {\n                    const intent = bridgeSimulation.intent;\n                    // Extract destination amount (received amount after bridging)\n                    if (intent.destination?.amount && intent.destination.amount !== '0') {\n                        bridgeReceiveAmount = intent.destination.amount;\n                    }\n                    // Format bridge fees properly\n                    if (intent.fees?.total) {\n                        totalBridgeFee = `${intent.fees.total}`;\n                    }\n                }\n            }\n            let executeSimulation;\n            const approvalRequired = false;\n            if (execute) {\n                try {\n                    // Use the received amount from bridge simulation for execute simulation\n                    let receivedAmountForContract = normalizedAmount; // fallback to normalized original amount\n                    if (bridgeReceiveAmount !== '0') {\n                        // Get token decimals from bridge simulation\n                        const tokenDecimals = bridgeSimulation?.intent?.token?.decimals || bridgeSimulation?.token?.decimals;\n                        if (tokenDecimals) {\n                            const receivedAmountBigInt = (0,viem__WEBPACK_IMPORTED_MODULE_41__.parseUnits)(bridgeReceiveAmount, tokenDecimals);\n                            receivedAmountForContract = receivedAmountBigInt.toString();\n                        }\n                    }\n                    // Create execute parameters for simulation - use wei format for SimulationEngine\n                    // SimulationEngine expects amounts in wei format, not user-friendly format\n                    const modifiedExecuteParams = {\n                        ...execute,\n                        toChainId: params.toChainId,\n                        tokenApproval: {\n                            token: params.token,\n                            amount: receivedAmountForContract, // Keep in wei format for SimulationEngine\n                        },\n                    };\n                    executeSimulation =\n                        await this.executeService.simulateExecuteEnhanced(modifiedExecuteParams);\n                    if (executeSimulation) {\n                        steps.push({\n                            type: 'execute',\n                            required: true,\n                            simulation: executeSimulation,\n                            description: `Execute ${execute.functionName} on contract ${execute.contractAddress}`,\n                        });\n                    }\n                    // Execute analysis details are available in the simulation result\n                }\n                catch (simulationError) {\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Execute simulation error: ${simulationError}`);\n                    executeSimulation = {\n                        contractAddress: execute.contractAddress,\n                        functionName: execute.functionName,\n                        gasUsed: '0',\n                        success: false,\n                        error: `Simulation failed: ${simulationError}`,\n                    };\n                    steps.push({\n                        type: 'execute',\n                        required: true,\n                        simulation: executeSimulation,\n                        description: `Execute ${execute.functionName} on contract ${execute.contractAddress} (failed)`,\n                    });\n                }\n            }\n            // Calculate enhanced total cost with approval step\n            let totalEstimatedCost;\n            if (totalBridgeFee !== '0' || executeSimulation?.gasUsed) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.debug('DEBUG bridge-execute-service - totalBridgeFee (ETH):', totalBridgeFee);\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.debug('DEBUG bridge-execute-service - executeSimulation?.gasUsed:', executeSimulation?.gasUsed);\n                try {\n                    const executeFee = executeSimulation?.gasCostEth || executeSimulation?.gasUsed || '0';\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.debug('DEBUG bridge-execute-service - executeFee source value:', executeFee);\n                    let executeFeeEth = executeFee;\n                    // If gasCostEth wasn't available, executeFee will be gas units – convert.\n                    if (executeSimulation?.gasCostEth === undefined) {\n                        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.debug('DEBUG bridge-execute-service - executeFee (gas units):', executeFee);\n                        try {\n                            // Get the current gas price from the connected provider (wei, hex string)\n                            const gasPriceHex = (await this.adapter.nexusSDK.request({\n                                method: 'eth_gasPrice',\n                            }));\n                            const gasPriceWei = parseInt(gasPriceHex, 16);\n                            // gasUsed (string) * gasPriceWei (number) => wei, then convert to ETH\n                            const gasUsedNum = parseFloat(executeFee);\n                            const costEthNum = (gasUsedNum * gasPriceWei) / 1e18; // 1e18 wei per ETH\n                            executeFeeEth = costEthNum.toFixed(8); // keep reasonable precision\n                        }\n                        catch (gpErr) {\n                            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('Failed to fetch gas price for execute fee conversion:', gpErr);\n                        }\n                    }\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.debug('DEBUG bridge-execute-service - executeFee (ETH):', executeFeeEth);\n                    // Add bridge fee (already an ETH figure) with converted execute fee\n                    const totalFeeEth = (parseFloat(totalBridgeFee) + parseFloat(executeFeeEth)).toString();\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.debug('DEBUG bridge-execute-service - totalFeeEth:', totalFeeEth);\n                    totalEstimatedCost = {\n                        total: totalFeeEth,\n                        breakdown: {\n                            bridge: totalBridgeFee,\n                            execute: executeFeeEth,\n                        },\n                    };\n                }\n                catch (error) {\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('Could not calculate total cost - cost breakdown may be incomplete:', error);\n                }\n            }\n            // Enhanced balance check after simulations are complete\n            // Re-validate the skip bridge decision with actual gas estimates\n            if (!this.skipBridge && executeSimulation?.gasUsed) {\n                const finalOptimization = await this.calculateOptimalBridgeAmount(params.toChainId, params.token, normalizedAmount, executeSimulation?.gasUsed, executeSimulation?.gasCostEth);\n                // Update skip bridge decision if gas check reveals we can skip\n                if (finalOptimization.skipBridge && !this.skipBridge) {\n                    this.skipBridge = true;\n                    this.optimalBridgeAmount = '0';\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('Updated bridge decision after gas validation: bridge can be skipped');\n                }\n            }\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`Enhanced balance check result: skipBridge = ${this.skipBridge} for chain ${params.toChainId}`);\n            // Adjust simulation result based on skip decision\n            let finalBridgeSimulation = bridgeSimulation;\n            let finalSteps = steps;\n            if (this.skipBridge) {\n                // When bridge is skipped, set bridgeSimulation to null and filter out bridge steps\n                finalBridgeSimulation = null;\n                finalSteps = steps.filter((step) => step.type !== 'bridge');\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('Bridge will be skipped - using execute-only simulation result');\n                return {\n                    steps: finalSteps,\n                    bridgeSimulation: finalBridgeSimulation,\n                    executeSimulation,\n                    totalEstimatedCost,\n                    success: true,\n                    metadata: {\n                        contractAddress: executeSimulation?.contractAddress ?? '',\n                        functionName: executeSimulation?.functionName ?? '',\n                        bridgeReceiveAmount: this.skipBridge\n                            ? params.amount.toString()\n                            : bridgeReceiveAmount !== '0'\n                                ? bridgeReceiveAmount\n                                : this.optimalBridgeAmount,\n                        bridgeFee: this.skipBridge ? '0' : totalBridgeFee.replace(' ETH', '') || '0',\n                        inputAmount: params.amount.toString(),\n                        optimalBridgeAmount: this.optimalBridgeAmount,\n                        targetChain: params.toChainId,\n                        approvalRequired,\n                        bridgeSkipped: this.skipBridge,\n                        token: params?.token,\n                    },\n                };\n            }\n            return {\n                steps: finalSteps,\n                bridgeSimulation: finalBridgeSimulation,\n                executeSimulation,\n                totalEstimatedCost,\n                success: true,\n            };\n        }\n        catch (error) {\n            return {\n                steps: [],\n                bridgeSimulation: null,\n                executeSimulation: undefined,\n                success: false,\n                error: `Simulation failed: ${(0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'simulation')}`,\n            };\n        }\n    }\n    /**\n     * Handle the execute phase of bridge and execute\n     * Uses callback-based parameter pattern for dynamic parameter building\n     */\n    async handleExecutePhase(execute, toChainId, bridgeToken, bridgeAmount, enableTransactionPolling, transactionTimeout, waitForReceipt, receiptTimeout, requiredConfirmations, emitStep, makeStep, approvalBufferBpsOverride) {\n        if (!execute || !emitStep || !makeStep)\n            return {};\n        try {\n            // Debug logging to understand amount handling\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG handleExecutePhase - Bridge amount (micro-units):', bridgeAmount);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG handleExecutePhase - Bridge token:', bridgeToken);\n            const { formatUnits } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12\"), __webpack_require__.e(\"vendor-chunks/abitype@1.1.0_typescript@5.9.3_zod@4.1.12\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.38.2_bufferutil@4.0.9_typescript@5.9.3_utf-8-validate@5.0.10_zod@4.1.12/node_modules/viem/_esm/index.js\"));\n            const decimals = _commons__WEBPACK_IMPORTED_MODULE_0__.TOKEN_METADATA[bridgeToken]?.decimals || 18;\n            const userFriendlyAmount = formatUnits(BigInt(bridgeAmount), decimals);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG handleExecutePhase - Amount conversion:', {\n                microUnits: bridgeAmount,\n                decimals,\n                userFriendly: userFriendlyAmount,\n                bridgeToken,\n            });\n            // Create execute parameters with user-friendly amount for the callback\n            const finalExecuteParams = {\n                ...execute,\n                toChainId,\n                tokenApproval: {\n                    token: bridgeToken,\n                    amount: userFriendlyAmount,\n                },\n                ...(approvalBufferBpsOverride !== undefined\n                    ? { approvalBufferBps: approvalBufferBpsOverride }\n                    : undefined),\n            };\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG handleExecutePhase - Execute params created with user-friendly amount:', {\n                userFriendlyAmount,\n                originalBridgeAmount: bridgeAmount,\n                token: bridgeToken,\n                decimals,\n            });\n            // Check user balance on destination chain before executing\n            try {\n                const destinationBalance = await this.getDestinationChainBalance(toChainId, bridgeToken);\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG handleExecutePhase - User balance on destination chain:', {\n                    chainId: toChainId,\n                    token: bridgeToken,\n                    balance: destinationBalance,\n                    requiredAmount: bridgeAmount,\n                });\n            }\n            catch (balanceError) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('DEBUG handleExecutePhase - Could not check destination balance:', balanceError);\n            }\n            // Execute the target contract call - let execute service handle approval\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG handleExecutePhase - Executing contract call with params:', {\n                ...finalExecuteParams,\n                toChainId,\n            });\n            const executeResult = await this.executeService.execute({\n                ...finalExecuteParams,\n                enableTransactionPolling,\n                transactionTimeout,\n                waitForReceipt,\n                receiptTimeout,\n                requiredConfirmations,\n            });\n            // Check if we should verify transaction success\n            if (executeResult.transactionHash) {\n                // Transaction sent step\n                emitStep(makeStep('TS', 'transaction.sent', {\n                    txHash: executeResult.transactionHash,\n                }));\n            }\n            if (waitForReceipt && executeResult.transactionHash) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG handleExecutePhase - Checking transaction success for:', executeResult.transactionHash);\n                const transactionCheck = await this.checkTransactionSuccess(executeResult.transactionHash, toChainId);\n                if (!transactionCheck.success) {\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('DEBUG handleExecutePhase - Transaction failed:', transactionCheck.error);\n                    emitStep(makeStep('EX', 'execute', {\n                        error: transactionCheck.error,\n                    }));\n                    throw new Error(`Execute transaction failed: ${transactionCheck.error}`);\n                }\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG handleExecutePhase - Transaction succeeded with gas used:', transactionCheck.gasUsed);\n                // Emit receipt received step\n                emitStep(makeStep('RR', 'receipt.received', {\n                    txHash: executeResult.transactionHash,\n                }));\n                // Emit confirmation step if requiredConfirmations met\n                if ((requiredConfirmations ?? 0) > 0) {\n                    emitStep(makeStep('CN', 'transaction.confirmed', {\n                        confirmations: requiredConfirmations,\n                    }));\n                }\n            }\n            return {\n                executeTransactionHash: executeResult.transactionHash,\n                executeExplorerUrl: executeResult.explorerUrl,\n                approvalTransactionHash: executeResult.approvalTransactionHash,\n            };\n        }\n        catch (executeError) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error('DEBUG handleExecutePhase - Execute error:', executeError);\n            emitStep(makeStep('EX', 'execute', { error: executeError.message }));\n            throw new Error(`Execute phase failed: ${(0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(executeError, 'execute phase')}`);\n        }\n    }\n    /**\n     * Normalize amount input to wei format for consistent processing\n     * Supports various input formats and automatically handles token decimals\n     */\n    normalizeAmountToWei(amount, token) {\n        try {\n            // Convert to string if it's a number\n            const amountStr = amount.toString();\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG normalizeAmountToWei - Input:', { amount: amountStr, token });\n            // Handle edge cases\n            if (!amountStr || amountStr === '0') {\n                return '0';\n            }\n            // Get token metadata for accurate decimal handling\n            const tokenUpper = token.toUpperCase();\n            const tokenMetadata = _commons__WEBPACK_IMPORTED_MODULE_0__.TOKEN_METADATA[tokenUpper];\n            const decimals = tokenMetadata?.decimals || ADAPTER_CONSTANTS?.DEFAULT_DECIMALS || 18;\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG normalizeAmountToWei - Token info:', {\n                tokenUpper,\n                decimals,\n                tokenMetadata,\n            });\n            // If it's already in wei format (no decimals, large number), return as-is\n            // Check length to avoid converting small integers to wei incorrectly\n            if (!amountStr.includes('.') && amountStr.length > 10) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG normalizeAmountToWei - Already in wei format');\n                return amountStr;\n            }\n            // Handle hex values\n            if (amountStr.startsWith('0x')) {\n                const result = BigInt(amountStr).toString();\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG normalizeAmountToWei - Hex conversion: ${result}`);\n                return result;\n            }\n            // Handle decimal amounts (need conversion to wei)\n            if (amountStr.includes('.')) {\n                const result = (0,viem__WEBPACK_IMPORTED_MODULE_41__.parseUnits)(amountStr, decimals).toString();\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG normalizeAmountToWei - Decimal conversion: ${amountStr} -> ${result}`);\n                return result;\n            }\n            // Handle whole number inputs\n            const numValue = parseFloat(amountStr);\n            // For USDC specifically, be more careful with the conversion\n            // USDC typically has 6 decimals, so 1 USDC = 1,000,000 micro-USDC\n            const USDC_MICRO_UNITS_THRESHOLD = 1000000; // 1 USDC\n            if (tokenUpper === 'USDC') {\n                // For USDC, small numbers (< 1,000,000) are likely user amounts that need conversion\n                if (numValue < USDC_MICRO_UNITS_THRESHOLD) {\n                    const result = (0,viem__WEBPACK_IMPORTED_MODULE_41__.parseUnits)(amountStr, 6).toString();\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG normalizeAmountToWei - USDC user amount conversion: ${amountStr} -> ${result}`);\n                    return result;\n                }\n                else {\n                    // Larger numbers are likely already in micro-USDC\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG normalizeAmountToWei - USDC already in micro format');\n                    return amountStr;\n                }\n            }\n            // For small whole numbers, likely represent user-friendly amounts (e.g., \"1\" ETH)\n            // For larger numbers, likely already in wei format\n            if (numValue < 1000 || (tokenMetadata?.decimals === 6 && numValue < 1000000)) {\n                // Convert small numbers as user-friendly amounts\n                const result = (0,viem__WEBPACK_IMPORTED_MODULE_41__.parseUnits)(amountStr, decimals).toString();\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG normalizeAmountToWei - User amount conversion: ${amountStr} -> ${result}`);\n                return result;\n            }\n            else {\n                // Assume larger numbers are already in the correct format\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG normalizeAmountToWei - Already in correct format');\n                return amountStr;\n            }\n        }\n        catch (error) {\n            // If conversion fails, return original\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Failed to normalize amount ${amount} for token ${token}:`, error);\n            return amount.toString();\n        }\n    }\n    /**\n     * Get transaction receipt with retry logic\n     * Note: Assumes we're already on the correct chain (handled by checkTransactionSuccess)\n     */\n    async getTransactionReceipt(txHash, maxRetries = 3) {\n        return this.adapter.nexusSDK.getEVMClient().waitForTransactionReceipt({\n            hash: txHash,\n            retryCount: maxRetries,\n        });\n    }\n    /**\n     * Simulate a failed transaction to get the revert reason\n     * Note: Assumes we're already on the correct chain (handled by checkTransactionSuccess)\n     */\n    async simulateFailedTransaction(txHash) {\n        try {\n            // Get the original transaction details\n            const tx = await this.adapter.nexusSDK.getEVMClient().getTransaction({\n                hash: txHash,\n            });\n            if (!tx || tx === null) {\n                return null;\n            }\n            // Type guard to ensure transaction has required properties\n            if (typeof tx !== 'object' || tx === null) {\n                return 'Invalid transaction data';\n            }\n            if (!tx.to || !tx.input) {\n                return 'Invalid transaction data';\n            }\n            // Get the transaction receipt to find the block number where it failed\n            const receipt = await this.adapter.nexusSDK.getEVMClient().getTransactionReceipt({\n                hash: txHash,\n            });\n            // Use the block number where the transaction was mined, or the previous block\n            // This ensures we simulate the exact state when the transaction failed\n            let simulationBlock = 0n;\n            if (receipt) {\n                if (receipt.blockNumber) {\n                    simulationBlock = receipt.blockNumber;\n                }\n            }\n            else if (tx.blockNumber) {\n                simulationBlock = tx.blockNumber;\n            }\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG simulateFailedTransaction - Simulating at block: ${simulationBlock}`);\n            // Simulate the transaction call to get revert reason\n            await this.adapter.nexusSDK.getEVMClient().call({\n                to: tx.to,\n                data: tx.input,\n                value: tx.value,\n                gas: tx.gas,\n                blockNumber: simulationBlock,\n            });\n            // If eth_call succeeds when we expected it to fail, this is suspicious\n            // The original transaction failed but the simulation passes\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('DEBUG simulateFailedTransaction - eth_call succeeded but original transaction failed. This might indicate a state-dependent failure.');\n            return 'Transaction failed due to state changes or gas issues';\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info('DEBUG simulateFailedTransaction - eth_call failed as expected, extracting revert reason');\n            // This is the expected path - eth_call should fail and give us the revert reason\n            // Extract revert reason from error\n            if (error && typeof error === 'object' && 'data' in error) {\n                const providerError = error;\n                if (providerError.data?.message) {\n                    return providerError.data.message;\n                }\n            }\n            if (error && typeof error === 'object' && 'message' in error) {\n                const errorWithMessage = error;\n                // Parse common revert reason patterns\n                const revertMatch = errorWithMessage.message.match(/revert (.+?)(?:\\s|$)/i);\n                if (revertMatch) {\n                    return revertMatch[1];\n                }\n                // Check for execution reverted patterns\n                if (errorWithMessage.message.includes('execution reverted')) {\n                    const cleanMessage = errorWithMessage.message.replace('execution reverted: ', '').trim();\n                    return cleanMessage || 'Transaction reverted without reason';\n                }\n                // Handle other common error patterns\n                if (errorWithMessage.message.includes('insufficient funds')) {\n                    return 'Insufficient funds for gas * price + value';\n                }\n                if (errorWithMessage.message.includes('gas required exceeds allowance')) {\n                    return 'Out of gas';\n                }\n                return errorWithMessage.message;\n            }\n            return 'Transaction simulation failed';\n        }\n    }\n    /**\n     * Check transaction success and get detailed error information\n     */\n    async checkTransactionSuccess(txHash, chainId, maxRetries = 5, retryDelay = 3000) {\n        for (let attempt = 1; attempt <= maxRetries; attempt++) {\n            try {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG checkTransactionSuccess - Attempt ${attempt}/${maxRetries}: Checking transaction: ${txHash} on chain: ${chainId}`);\n                // Ensure we're on the correct chain before checking transaction\n                const currentChainId = await this.adapter.nexusSDK.getEVMClient().getChainId();\n                if (currentChainId !== chainId) {\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG checkTransactionSuccess - Switching from chain ${currentChainId} to ${chainId}`);\n                    try {\n                        await this.adapter.nexusSDK.getEVMClient().switchChain({ id: chainId });\n                        // Wait a bit after chain switch\n                        await new Promise((resolve) => setTimeout(resolve, 1000));\n                    }\n                    catch (switchError) {\n                        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error(`DEBUG checkTransactionSuccess - Failed to switch to chain ${chainId}:`, switchError);\n                        return {\n                            success: false,\n                            error: `Failed to switch to chain ${chainId} for transaction verification`,\n                        };\n                    }\n                }\n                // 1. Get transaction receipt - basic success/failure\n                const receipt = await this.getTransactionReceipt(txHash);\n                if (!receipt) {\n                    if (attempt < maxRetries) {\n                        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG checkTransactionSuccess - Receipt not found, retrying in ${retryDelay}ms...`);\n                        await new Promise((resolve) => setTimeout(resolve, retryDelay));\n                        continue; // Retry\n                    }\n                    return {\n                        success: false,\n                        error: 'Transaction receipt not found after multiple attempts',\n                    };\n                }\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG checkTransactionSuccess - Receipt status: ${receipt.status}`);\n                // Check if transaction succeeded\n                if (receipt.status === 'success') {\n                    return {\n                        success: true,\n                        gasUsed: (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(receipt.gasUsed),\n                    };\n                }\n                else {\n                    let errorMessage = 'Transaction failed';\n                    // 3. Simulate the transaction to get detailed error\n                    try {\n                        const simulationError = await this.simulateFailedTransaction(txHash);\n                        if (simulationError) {\n                            errorMessage = simulationError;\n                        }\n                    }\n                    catch (simError) {\n                        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn('DEBUG checkTransactionSuccess - Simulation failed:', simError);\n                        // Keep generic error message if simulation fails\n                    }\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG checkTransactionSuccess - Final error: ${errorMessage}`);\n                    return {\n                        success: false,\n                        error: errorMessage,\n                        gasUsed: (0,viem__WEBPACK_IMPORTED_MODULE_19__.toHex)(receipt.gasUsed),\n                    };\n                }\n                // Transaction failed - now get the error reason\n            }\n            catch (error) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.error(`DEBUG checkTransactionSuccess - Attempt ${attempt} failed:`, error);\n                if (attempt < maxRetries) {\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`DEBUG checkTransactionSuccess - Retrying in ${retryDelay}ms...`);\n                    await new Promise((resolve) => setTimeout(resolve, retryDelay));\n                    continue; // Retry\n                }\n                // Final attempt failed\n                return {\n                    success: false,\n                    error: `Failed to check transaction status after ${maxRetries} attempts: ${(0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'transaction check')}`,\n                };\n            }\n        }\n        // This should never be reached, but just in case\n        return {\n            success: false,\n            error: `Transaction check failed after ${maxRetries} attempts`,\n        };\n    }\n    /**\n     * Calculate optimal bridge amount based on destination chain balance\n     * Returns the exact amount needed to bridge, or indicates if bridge can be skipped entirely\n     */\n    async calculateOptimalBridgeAmount(chainId, token, requiredAmount, gasEstimate, gasCostEth) {\n        try {\n            // Get destination chain balance\n            const destinationBalance = await this.getDestinationChainBalance(chainId, token);\n            if (destinationBalance === null) {\n                // If we can't get balance info, bridge the full amount\n                return { skipBridge: false, optimalAmount: requiredAmount };\n            }\n            const requiredAmountBigInt = BigInt(requiredAmount);\n            const destinationBalanceBigInt = BigInt(destinationBalance);\n            // Check if we have sufficient balance on destination to skip bridge entirely\n            if (destinationBalanceBigInt >= requiredAmountBigInt) {\n                // Check gas balance if we have gas estimate\n                if (gasEstimate || gasCostEth) {\n                    const hasGasBalance = await this.checkGasBalance(chainId, gasEstimate, gasCostEth);\n                    if (!hasGasBalance) {\n                        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`Insufficient gas balance on chain ${chainId}, cannot skip bridge`);\n                        return { skipBridge: false, optimalAmount: requiredAmount };\n                    }\n                }\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`Sufficient ${token} and gas balance on chain ${chainId}, bridge can be skipped`);\n                return { skipBridge: true, optimalAmount: '0' };\n            }\n            // Calculate how much we need to bridge (required - what's already on destination)\n            const optimalBridgeAmountBigInt = requiredAmountBigInt - destinationBalanceBigInt;\n            const optimalAmount = (optimalBridgeAmountBigInt > 0n ? optimalBridgeAmountBigInt : 0n).toString();\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`Optimal bridge calculation:`, {\n                token,\n                chainId,\n                requiredAmount,\n                destinationBalance,\n                optimalBridgeAmount: optimalAmount,\n            });\n            return { skipBridge: false, optimalAmount };\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Failed to calculate optimal bridge amount: ${error}`);\n            // Default to bridging full amount on error\n            return { skipBridge: false, optimalAmount: requiredAmount };\n        }\n    }\n    /**\n     * Get destination chain balance for a specific token\n     * Returns balance in wei as string, or null if not found\n     */\n    async getDestinationChainBalance(chainId, token) {\n        try {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`Getting ${token} balance on chain ${chainId}`);\n            // Get user's unified balances\n            const balances = (await this.adapter.nexusSDK.getUnifiedBalances());\n            // Find the balance for the specific token\n            const tokenBalance = balances.find((asset) => asset.symbol === token);\n            if (!tokenBalance || !tokenBalance.breakdown) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`No ${token} balance found`);\n                return null;\n            }\n            // Find balance on the specific chain\n            const chainBalance = tokenBalance.breakdown.find((balance) => balance.chain.id === chainId);\n            if (!chainBalance) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`No ${token} balance found on chain ${chainId}`);\n                return '0'; // Return 0 if no balance on this chain\n            }\n            // Get token metadata for decimal conversion\n            const tokenMetadata = _commons__WEBPACK_IMPORTED_MODULE_0__.TOKEN_METADATA[token.toUpperCase()];\n            const decimals = tokenMetadata?.decimals || 18;\n            // Convert the balance to wei for calculation\n            const balanceInWei = (0,viem__WEBPACK_IMPORTED_MODULE_41__.parseUnits)(chainBalance.balance, decimals);\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`Balance found:`, {\n                token,\n                chainId,\n                balance: chainBalance.balance,\n                balanceInWei: balanceInWei.toString(),\n            });\n            return balanceInWei.toString();\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Failed to get destination chain balance: ${error}`);\n            return null;\n        }\n    }\n    /**\n     * Check native token balance for gas requirements\n     */\n    async checkGasBalance(chainId, gasEstimate, gasCostEth) {\n        try {\n            // Get native token symbol for this chain\n            const chainMetadata = _commons__WEBPACK_IMPORTED_MODULE_0__.CHAIN_METADATA[chainId];\n            if (!chainMetadata) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`No chain metadata found for chain ${chainId}`);\n                return false;\n            }\n            const nativeTokenSymbol = chainMetadata.nativeCurrency.symbol;\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`Checking ${nativeTokenSymbol} balance on chain ${chainId} for gas`);\n            // Get user's unified balances\n            const balances = (await this.adapter.nexusSDK.getUnifiedBalances());\n            // Find the native token balance\n            const nativeTokenBalance = balances.find((asset) => asset.symbol === nativeTokenSymbol);\n            if (!nativeTokenBalance || !nativeTokenBalance.breakdown) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`No ${nativeTokenSymbol} balance found`);\n                return false;\n            }\n            // Find balance on the specific chain\n            const chainBalance = nativeTokenBalance.breakdown.find((balance) => balance.chain.id === chainId);\n            if (!chainBalance) {\n                _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`No ${nativeTokenSymbol} balance found on chain ${chainId}`);\n                return false;\n            }\n            // Calculate required gas cost\n            let requiredGasCost = '0';\n            if (gasCostEth) {\n                // If we have gas cost in ETH, use it directly\n                requiredGasCost = gasCostEth;\n            }\n            else if (gasEstimate) {\n                // Convert gas estimate to ETH using current gas price\n                try {\n                    const gasPriceHex = (await this.adapter.nexusSDK.request({\n                        method: 'eth_gasPrice',\n                    }));\n                    const gasPriceWei = parseInt(gasPriceHex, 16);\n                    const gasUsedNum = parseFloat(gasEstimate);\n                    const costEthNum = (gasUsedNum * gasPriceWei) / 1e18; // Convert wei to ETH\n                    requiredGasCost = costEthNum.toString();\n                }\n                catch (error) {\n                    _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Failed to fetch gas price for gas balance check: ${error}`);\n                    return false;\n                }\n            }\n            // Add 10% buffer to required gas cost\n            const requiredGasCostWithBuffer = (parseFloat(requiredGasCost) * 1.1).toString();\n            // Compare balances (both in user-friendly format like ETH)\n            const userBalance = parseFloat(chainBalance.balance);\n            const requiredGasFloat = parseFloat(requiredGasCostWithBuffer);\n            const hasSufficientGasBalance = userBalance >= requiredGasFloat;\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.info(`Gas balance check result:`, {\n                nativeTokenSymbol,\n                chainId,\n                userBalance: chainBalance.balance,\n                requiredGasCost,\n                requiredGasCostWithBuffer,\n                hasSufficientGasBalance,\n            });\n            return hasSufficientGasBalance;\n        }\n        catch (error) {\n            _commons__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Failed to check gas balance: ${error}`);\n            return false;\n        }\n    }\n    /**\n     * Execute directly without bridging when user has sufficient funds\n     * Uses callback-based parameters for dynamic execution\n     */\n    async executeDirectly(execute, toChainId, token, amount, enableTransactionPolling, transactionTimeout, waitForReceipt, receiptTimeout, requiredConfirmations) {\n        try {\n            // Emit expected steps for execute-only flow\n            const executeSteps = [];\n            const makeStep = (typeID, type, data = {}) => ({\n                typeID,\n                type,\n                data: {\n                    chainID: toChainId,\n                    chainName: _commons__WEBPACK_IMPORTED_MODULE_0__.CHAIN_METADATA[toChainId]?.name || toChainId.toString(),\n                    ...data,\n                },\n            });\n            // Add steps for execute-only flow\n            if (execute.tokenApproval) {\n                executeSteps.push(makeStep('AP', 'APPROVAL'));\n            }\n            executeSteps.push(makeStep('TS', 'TRANSACTION_SENT'));\n            if (waitForReceipt) {\n                executeSteps.push(makeStep('RR', 'RECEIPT_RECEIVED'));\n            }\n            if ((requiredConfirmations ?? 0) > 0) {\n                executeSteps.push(makeStep('CN', 'TRANSACTION_CONFIRMED'));\n            }\n            // Emit expected steps for execute-only flow\n            this.adapter.nexusSDK.nexusEvents.emit(_commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS.BRIDGE_EXECUTE_EXPECTED_STEPS, executeSteps);\n            // Execute directly using existing funds\n            const { executeTransactionHash, executeExplorerUrl, approvalTransactionHash } = await this.handleExecutePhase(execute, toChainId, token, amount, enableTransactionPolling, transactionTimeout, waitForReceipt, receiptTimeout, requiredConfirmations, (step) => this.adapter.nexusSDK.nexusEvents.emit(_commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS.BRIDGE_EXECUTE_COMPLETED_STEPS, step), makeStep);\n            return {\n                executeTransactionHash,\n                executeExplorerUrl,\n                approvalTransactionHash,\n                bridgeTransactionHash: undefined, // bridge was skipped\n                bridgeExplorerUrl: undefined, // bridge was skipped\n                toChainId,\n                success: true,\n                bridgeSkipped: true, // bridge was skipped due to sufficient funds\n            };\n        }\n        catch (error) {\n            const errorMessage = (0,_commons__WEBPACK_IMPORTED_MODULE_0__.extractErrorMessage)(error, 'execute directly');\n            // Emit error step\n            this.adapter.nexusSDK.nexusEvents.emit(_commons__WEBPACK_IMPORTED_MODULE_0__.NEXUS_EVENTS.BRIDGE_EXECUTE_COMPLETED_STEPS, {\n                typeID: 'ER',\n                type: 'operation.failed',\n                data: {\n                    error: errorMessage,\n                    stage: 'execute',\n                },\n            });\n            return {\n                toChainId,\n                success: false,\n                error: `Execute-only operation failed: ${errorMessage}`,\n                bridgeSkipped: true, // error occurred during execute-only flow\n            };\n        }\n    }\n}\n\n/**\n * Provides a unified interface for chain abstraction operations.\n */\nclass ChainAbstractionAdapter {\n    constructor(nexusSDK) {\n        this.nexusSDK = nexusSDK;\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.debug('ChainAbstractionAdapter', { nexusSDK });\n        // Initialize services\n        this.executeService = new ExecuteService(this);\n        this.bridgeExecuteService = new BridgeExecuteService(this);\n        this.setGasEstimationEnabled(true);\n    }\n    async getEVMClient() {\n        return this.nexusSDK.getEVMClient();\n    }\n    /**\n     * Execute a contract call using the execute service.\n     */\n    async execute(params) {\n        return this.executeService.execute(params);\n    }\n    /**\n     * Simulate contract execution using the execute service.\n     */\n    async simulateExecute(params) {\n        return this.executeService.simulateExecute(params);\n    }\n    /**\n     * Get the list of supported chains from the CA SDK.\n     */\n    getSupportedChains(env) {\n        return getSupportedChains(env);\n    }\n    /**\n     * Check if a chain is supported by the adapter.\n     */\n    isSupportedChain(chainId) {\n        return isSupportedChain(chainId);\n    }\n    /**\n     * Check if a token is supported by the adapter.\n     */\n    isSupportedToken(token) {\n        return isSupportedToken(token);\n    }\n    /**\n     * Bridge and execute operation - uses the BridgeExecuteService\n     */\n    async bridgeAndExecute(params) {\n        return this.bridgeExecuteService.bridgeAndExecute(params);\n    }\n    /**\n     * Simulate bridge and execute operation\n     */\n    async simulateBridgeAndExecute(params) {\n        return this.bridgeExecuteService.simulateBridgeAndExecute(params);\n    }\n    /**\n     * Enable or disable gas estimation for transactions\n     * When enabled, gas estimation will run before each transaction execution\n     * This helps identify potential failures early and provides cost estimates\n     */\n    setGasEstimationEnabled(enabled) {\n        this.bridgeExecuteService.setGasEstimationEnabled(enabled);\n        this.executeService.setGasEstimationEnabled(enabled);\n    }\n}\n\n// src/core/sdk/index.ts\nclass NexusSDK extends CA {\n    constructor(config) {\n        super(config);\n        _commons__WEBPACK_IMPORTED_MODULE_0__.logger.debug('Nexus SDK initialized with config:', config);\n        this.nexusAdapter = new ChainAbstractionAdapter(this);\n        this.nexusEvents = this._caEvents;\n        this.utils = new NexusUtils(this.nexusAdapter, () => this.isInitialized());\n    }\n    /**\n     * Initialize the SDK with a provider\n     */\n    async initialize(provider) {\n        // Initialize the core adapter first\n        this._setEVMProvider(provider);\n        await this._init();\n        const BACKEND_URL = 'https://nexus-backend.avail.so';\n        {\n            try {\n                const initResult = await initializeSimulationClient(BACKEND_URL);\n                if (!initResult.success) {\n                    throw new Error('Backend initialization failed');\n                }\n            }\n            catch (error) {\n                throw new Error('Backend initialization failed');\n            }\n        }\n    }\n    /**\n     * Get unified balances across all chains\n     */\n    async getUnifiedBalances() {\n        return this._getUnifiedBalances();\n    }\n    /**\n     * Get unified balance for a specific token\n     */\n    async getUnifiedBalance(symbol) {\n        return this._getUnifiedBalance(symbol);\n    }\n    /**\n     * Cross chain token transfer\n     */\n    async bridge(params) {\n        try {\n            const result = await (await this._bridge(params)).exec();\n            return {\n                success: true,\n                explorerUrl: result?.explorerURL ?? '',\n            };\n        }\n        catch (e) {\n            return {\n                success: false,\n                error: e instanceof Error ? e.message : String(e),\n            };\n        }\n    }\n    /**\n     * Cross chain token transfer to EOA\n     */\n    async transfer(params) {\n        try {\n            const result = await (await this._transfer({ ...params, to: params.recipient })).exec();\n            return {\n                success: true,\n                transactionHash: result.hash,\n                explorerUrl: result.explorerURL,\n            };\n        }\n        catch (e) {\n            return {\n                success: false,\n                error: e instanceof Error ? e.message : String(e),\n            };\n        }\n    }\n    async swapWithExactIn(input, options) {\n        try {\n            const result = await this._swapWithExactIn(input, options);\n            return {\n                success: true,\n                result,\n            };\n        }\n        catch (error) {\n            console.error('Error in swap with exact out', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error),\n            };\n        }\n    }\n    async swapWithExactOut(input, options) {\n        try {\n            const result = await this._swapWithExactOut(input, options);\n            return {\n                success: true,\n                result,\n            };\n        }\n        catch (error) {\n            console.error('Error in swap with exact out', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error),\n            };\n        }\n    }\n    /**\n     * Get chain abstracted provider allowing use of chain asbtraction\n     * @returns EthereumProvider\n     */\n    getEVMProviderWithCA() {\n        return this._getEVMProviderWithCA();\n    }\n    /**\n     * Simulate bridge transaction to get costs and fees\n     */\n    async simulateBridge(params) {\n        return (await this._bridge(params)).simulate();\n    }\n    /**\n     * Simulate transfer transaction to get costs and fees\n     */\n    async simulateTransfer(params) {\n        return (await this._transfer({ ...params, to: params.recipient })).simulate();\n    }\n    /**\n     * Get user's intents with pagination\n     */\n    async getMyIntents(page = 1) {\n        return this._getMyIntents(page);\n    }\n    /**\n     * Check allowance for tokens on a specific chain\n     */\n    async getAllowance(chainId, tokens) {\n        return this._allowance().get({ chainID: chainId, tokens });\n    }\n    /**\n     * Set allowance for a token on a specific chain\n     */\n    async setAllowance(chainId, tokens, amount) {\n        return this._allowance().set({ chainID: chainId, tokens, amount });\n    }\n    /**\n     * Revoke allowance for a token on a specific chain\n     */\n    async revokeAllowance(chainId, tokens) {\n        return this._allowance().revoke({ chainID: chainId, tokens });\n    }\n    /**\n     * Set callback for intent status updates\n     */\n    setOnIntentHook(callback) {\n        this._setOnIntentHook(callback);\n    }\n    /**\n     * Set callback for allowance approval events\n     */\n    setOnAllowanceHook(callback) {\n        this._setOnAllowanceHook(callback);\n    }\n    async deinit() {\n        return this._deinit();\n    }\n    async request(args) {\n        return this._handleEVMTx(args);\n    }\n    /**\n     * Standalone function to execute funds into a smart contract\n     * @param params execute parameters including contract details and transaction settings\n     * @returns Promise resolving to execute result with transaction hash and explorer URL\n     */\n    async execute(params) {\n        return this.nexusAdapter.execute(params);\n    }\n    /**\n     * Simulate a standalone execute to estimate gas costs and validate parameters\n     * @param params execute parameters for simulation\n     * @returns Promise resolving to simulation result with gas estimates\n     */\n    async simulateExecute(params) {\n        return this.nexusAdapter.simulateExecute(params);\n    }\n    /**\n     * Enhanced bridge and execute function with optional execute step and improved error handling\n     * @param params Enhanced bridge and execute parameters\n     * @returns Promise resolving to comprehensive operation result\n     */\n    async bridgeAndExecute(params) {\n        return this.nexusAdapter.bridgeAndExecute(params);\n    }\n    /**\n     * Simulate bridge and execute operation using bridge output amounts for realistic execute cost estimation\n     * This method provides more accurate gas estimates by using the actual amount that will be\n     * received on the destination chain after bridging (accounting for fees, slippage, etc.)\n     * Includes detailed step-by-step breakdown with approval handling.\n     */\n    async simulateBridgeAndExecute(params) {\n        return this.nexusAdapter.simulateBridgeAndExecute(params);\n    }\n    getSwapSupportedChainsAndTokens() {\n        return this._getSwapSupportedChainsAndTokens();\n    }\n    isInitialized() {\n        return this._isInitialized();\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGF2YWlsLXByb2plY3QrbmV4dXMtY29yZUAwLjAuMS1iZXRhLjBfYnVmZmVydXRpbEA0LjAuOV9nb29nbGUtcHJvdG9idWZAMy4yMS40X3V0Zi04LXZhXzU2ZGQ1NTBjOGI5ZTA2Mzk2OTRjZDkxNzYzNzdmYTcyL25vZGVfbW9kdWxlcy9AYXZhaWwtcHJvamVjdC9uZXh1cy1jb3JlL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRoQjtBQUNsZ0I7QUFDNEs7QUFDb1Y7QUFDdUM7QUFDaGlCO0FBQzhGO0FBQ3JHO0FBQ007QUFDUTtBQUNrQztBQUNIO0FBQ1g7QUFDaUI7QUFDekI7QUFDTjtBQUN0QjtBQUNzQjtBQUNGOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1EQUFhO0FBQzFDLDBCQUEwQixnREFBVTtBQUNwQywyQkFBMkIsaURBQVc7QUFDdEMsOEJBQThCLG9EQUFjO0FBQzVDLCtCQUErQixxREFBZTtBQUM5Qyw0QkFBNEIsa0RBQVk7QUFDeEMsNEJBQTRCLGtEQUFZO0FBQ3hDLHVDQUF1Qyw2REFBdUI7QUFDOUQsdUNBQXVDLDZEQUF1QjtBQUM5RCxnQ0FBZ0Msc0RBQWdCO0FBQ2hELGdDQUFnQyxzREFBZ0I7QUFDaEQsaUNBQWlDLHVEQUFpQjtBQUNsRCx3Q0FBd0MsOERBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBOEI7QUFDeEMsVUFBVSxpQ0FBaUM7QUFDM0MsVUFBVSxrQ0FBa0M7QUFDNUMsVUFBVSw0Q0FBNEM7QUFDdEQ7QUFDQTtBQUNBLFVBQVUsZ0NBQWdDO0FBQzFDLFVBQVUsa0NBQWtDO0FBQzVDLFVBQVUsZ0NBQWdDO0FBQzFDLFVBQVUsZ0NBQWdDO0FBQzFDLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBOEI7QUFDeEMsVUFBVSxpQ0FBaUM7QUFDM0MsVUFBVSw0Q0FBNEM7QUFDdEQsVUFBVSwrQkFBK0I7QUFDekM7QUFDQTtBQUNBLFVBQVUsZ0NBQWdDO0FBQzFDLFVBQVUsK0JBQStCO0FBQ3pDLFVBQVUsMENBQTBDO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGdFQUFnRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIscURBQXFEO0FBQ3hFO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLHFEQUFxRDtBQUN4RTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQWtEO0FBQ3RFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLDJEQUF3QjtBQUM1RCxxQ0FBcUMsMkRBQXdCO0FBQzdELHVDQUF1QyxtREFBZ0I7QUFDdkQsSUFBSSxtREFBZ0I7QUFDcEIsa0NBQWtDLG1EQUFnQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCLDZDQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJLFlBQVk7QUFDekIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUyxJQUFJLFlBQVk7QUFDekIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUIsRUFBRSx5REFBa0I7QUFDekQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnRUFBaUIsQ0FBQyx1REFBUTtBQUNsRCx1QkFBdUIsMkRBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlEQUFVLENBQUMsMENBQUc7QUFDL0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNERBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQkFBMkIscURBQWM7QUFDekM7QUFDQSx1QkFBdUIsaURBQVU7QUFDakMsdUJBQXVCLGlEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw0REFBYTtBQUNqRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQSx5QkFBeUIsbURBQWdCLGVBQWUsbURBQWdCO0FBQ3hFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4QkFBOEI7QUFDcEMsTUFBTSxpQ0FBaUM7QUFDdkMsTUFBTSxrQ0FBa0M7QUFDeEMsTUFBTSw0Q0FBNEM7QUFDbEQ7QUFDQTtBQUNBLE1BQU0sOEJBQThCO0FBQ3BDLE1BQU0saUNBQWlDO0FBQ3ZDLE1BQU0sNENBQTRDO0FBQ2xELE1BQU0sK0JBQStCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsa0RBQVc7QUFDaEMsYUFBYSx1REFBUTtBQUNyQixpQkFBaUIsaURBQVU7QUFDM0Isa0JBQWtCLHNCQUFzQjtBQUN4QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QseUJBQXlCLHVCQUF1QixJQUFJLGNBQWM7QUFDbEU7QUFDQTtBQUNBLGFBQWEsNERBQWE7QUFDMUI7QUFDQSxzQkFBc0Isa0VBQW1CO0FBQ3pDO0FBQ0EsYUFBYSw0REFBYTtBQUMxQixhQUFhLDREQUFhO0FBQzFCLGFBQWEsNERBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0REFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0REFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0RBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQ0FBaUM7QUFDM0QsMEJBQTBCLGtDQUFrQztBQUM1RCwwQkFBMEIsZ0NBQWdDO0FBQzFELDBCQUEwQixpQ0FBaUM7QUFDM0QsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxhQUFhLDREQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRCwwQkFBMEIsa0NBQWtDO0FBQzVELDBCQUEwQixnQ0FBZ0M7QUFDMUQsMEJBQTBCLGdDQUFnQztBQUMxRCwwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLGFBQWEsNERBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMENBQUc7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQ0FBaUM7QUFDM0QsMEJBQTBCLGtDQUFrQztBQUM1RCwwQkFBMEIsZ0NBQWdDO0FBQzFELDBCQUEwQixpQ0FBaUM7QUFDM0QsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxhQUFhLDREQUFhO0FBQzFCLDRCQUE0Qix5REFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBDQUFHO0FBQzdCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQ0FBZ0M7QUFDMUQsMEJBQTBCLCtCQUErQjtBQUN6RCwwQkFBMEIsMENBQTBDO0FBQ3BFO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBa0I7QUFDakMsdUJBQXVCLDJDQUFJO0FBQzNCLFNBQVM7QUFDVDtBQUNBLFdBQVcseURBQWtCO0FBQzdCLG1CQUFtQiwrQ0FBUSx1Q0FBdUMsMkNBQUk7QUFDdEUsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhDQUFLLHNDQUFzQyxRQUFRO0FBQ2pFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0NBQWtDO0FBQ3JFLHlCQUF5QixxRUFBa0I7QUFDM0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsWUFBWSxvRUFBa0I7QUFDOUIseURBQXlELFVBQVUsTUFBTSxvQkFBb0I7QUFDN0Y7QUFDQSx3QkFBd0IsK0VBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUVBQWtCO0FBQzNDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJEQUFZO0FBQ25DO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBLGdCQUFnQixvRUFBa0I7QUFDbEMsZ0NBQWdDLG1FQUFvQjtBQUNwRCxtREFBbUQsZUFBZTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQ0FBa0M7QUFDL0UseUJBQXlCLHFFQUFrQjtBQUMzQztBQUNBLEtBQUs7QUFDTDtBQUNBLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFlBQVksb0VBQWtCO0FBQzlCO0FBQ0E7QUFDQSxrREFBa0Qsb0JBQW9CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSxLQUFLLFNBQVM7QUFDOUMsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4Q0FBTztBQUN6QyxxQkFBcUIsdURBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNENBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVEQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBDQUFHO0FBQzlCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsbUNBQW1DLDRDQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVcsR0FBRyxRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBVyxDQUFDLDhDQUFPO0FBQ3pDLFlBQVksY0FBYztBQUMxQjtBQUNBLHNCQUFzQiwrQ0FBUTtBQUM5QixLQUFLO0FBQ0wsYUFBYSw4QkFBOEIsK0NBQVE7QUFDbkQ7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBTyx1QkFBdUIsa0RBQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0RBQU8sWUFBWSxrREFBTywrQkFBK0Isa0RBQU87QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0RBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFPO0FBQzFCLDZCQUE2QixrREFBTztBQUNwQywwQkFBMEIsa0RBQU87QUFDakMsd0JBQXdCLGtEQUFPO0FBQy9CLG1CQUFtQixrREFBTztBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQywwREFBVztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RCxnQkFBZ0IsaURBQVUsR0FBRyxLQUFLLDBEQUFXLG1CQUFtQjtBQUNoRSxnQkFBZ0IsMERBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0RBQVM7QUFDMUIsc0JBQXNCLDhDQUFPO0FBQzdCO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUIsS0FBSztBQUNMLGFBQWEsYUFBYSxrREFBVyxHQUFHLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtEQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhDQUFPO0FBQ3RCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLDBDQUFHLENBQUMsOENBQU87QUFDMUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBSztBQUNoQjtBQUNBO0FBQ0EscUJBQXFCLHVEQUFRO0FBQzdCO0FBQ0EsbUJBQW1CLGlEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQVE7QUFDbEM7QUFDQSxtQkFBbUIsaURBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhEQUFlO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLHVEQUFRO0FBQzVCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwREFBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBEQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCLHVEQUFRO0FBQ2pDO0FBQ0E7QUFDQSx5QkFBeUIsdURBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtEQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFPO0FBQzFCLFNBQVM7QUFDVDtBQUNBLDhCQUE4QixrREFBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsK0VBQStFLDRDQUFTO0FBQ3hGO0FBQ0EsaURBQWlELGtEQUFPO0FBQ3hEO0FBQ0Esd0JBQXdCLGtEQUFPO0FBQy9CLGtDQUFrQyxrREFBTztBQUN6QztBQUNBO0FBQ0Esa0NBQWtDLGtEQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNLGtEQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtEQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBEQUFXLFlBQVk7QUFDL0MsZ0NBQWdDLDhEQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQWE7QUFDekM7QUFDQTtBQUNBLG1CQUFtQixvREFBYTtBQUNoQyxTQUFTO0FBQ1QsNkJBQTZCLHVEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQWE7QUFDbEM7QUFDQSxzQkFBc0IsdURBQVE7QUFDOUIsbUJBQW1CLG9EQUFhO0FBQ2hDLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdURBQVE7QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQWE7QUFDbEMsMEJBQTBCLGtEQUFPLENBQUMsb0RBQWEsa0JBQWtCLGtEQUFPO0FBQ3hFLG1EQUFtRCw0Q0FBSztBQUN4RCw4QkFBOEIsa0RBQU8sWUFBWSxrREFBTyxDQUFDLG9EQUFhLGtCQUFrQixrREFBTztBQUMvRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4Q0FBOEM7QUFDM0U7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVCQUF1QixrREFBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0RBQXdEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVCQUF1QixrREFBTztBQUM5QjtBQUNBLG1CQUFtQixrREFBTyxrQ0FBa0Msa0RBQU87QUFDbkU7QUFDQTtBQUNBLHFDQUFxQyxrREFBTyx3Q0FBd0Msa0RBQU87QUFDM0Y7QUFDQTtBQUNBLHlCQUF5Qix5R0FBeUc7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQkFBbUIsa0RBQU87QUFDMUIsaUJBQWlCLGtEQUFPO0FBQ3hCO0FBQ0EsNEJBQTRCLGtEQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvREFBYTtBQUMxQyx5QkFBeUIsb0RBQWE7QUFDdEMsMkRBQTJELDRDQUFLO0FBQ2hFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9EQUFhO0FBQzFDLHlCQUF5QixvREFBYTtBQUN0QywyREFBMkQsNENBQUs7QUFDaEU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9EQUFhO0FBQ3JELHNFQUFzRSw0Q0FBSztBQUMzRTtBQUNBO0FBQ0EsbUNBQW1DLG9EQUFhO0FBQ2hELGlFQUFpRSw0Q0FBSztBQUN0RTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLEtBQUssVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUFJO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBLDBDQUEwQyxnREFBTTtBQUNoRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsVUFBVSxHQUFHLFFBQVE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1DQUFtQyxVQUFVO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFPO0FBQzlCO0FBQ0E7QUFDQSwrQkFBK0IsOENBQUk7QUFDbkM7QUFDQTtBQUNBLHlCQUF5QixnREFBTTtBQUMvQiw0REFBNEQsTUFBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxvREFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtCQUErQiw4Q0FBSSxHQUFHLG1CQUFtQjtBQUN6RDtBQUNBLHlCQUF5QixnREFBTTtBQUMvQixzREFBc0QsTUFBTTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVc7QUFDbkU7QUFDQTtBQUNBLDBFQUEwRSxNQUFNO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1REFBUTtBQUNqQixTQUFTLHVEQUFRO0FBQ2pCLFNBQVMsdURBQVE7QUFDakIsU0FBUyx1REFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrREFBTztBQUM1Qiw0QkFBNEIsa0RBQU87QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHVEQUFRO0FBQ2xGO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBLHlCQUF5Qix1REFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx5QkFBeUIsdURBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4Qiw0REFBYTtBQUMzQztBQUNBO0FBQ0EsMEJBQTBCLDhDQUFPO0FBQ2pDLG1CQUFtQiw4Q0FBTztBQUMxQixTQUFTO0FBQ1Q7QUFDQSxnQkFBZ0IsNENBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUFPO0FBQzVCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOENBQU87QUFDMUIsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCLHVEQUFRO0FBQ2pDLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQVE7QUFDbEMsYUFBYTtBQUNiO0FBQ0EseUJBQXlCLHVEQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5Qiw2RUFBNkUsNENBQVM7QUFDbkk7QUFDQSx5QkFBeUIsOENBQU87QUFDaEM7QUFDQTtBQUNBLDBCQUEwQix1REFBUTtBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLDJCQUEyQix1RUFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1REFBUTtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCLHVEQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFXO0FBQzVCLGlCQUFpQiwwREFBVztBQUM1QjtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFXO0FBQzVCO0FBQ0E7QUFDQSxpQkFBaUIsMERBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0VBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Qsa0JBQWtCLHVEQUFRO0FBQzFCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxrQkFBa0IsdURBQVE7QUFDMUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxrQkFBa0IsdURBQVE7QUFDMUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULGtCQUFrQix1REFBUTtBQUMxQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxrQkFBa0IsdURBQVE7QUFDMUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxrQkFBa0IsdURBQVE7QUFDMUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxrQkFBa0IsdURBQVE7QUFDMUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Qsa0JBQWtCLHVEQUFRO0FBQzFCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFhO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0REFBYTtBQUM1QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQWE7QUFDNUM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFhO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0REFBYTtBQUM1QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFhO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0REFBYTtBQUM1QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQWE7QUFDNUM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFhO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0REFBYTtBQUM1QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFhO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0REFBYTtBQUM1QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQWE7QUFDNUM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFhO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0REFBYTtBQUM1QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0EsOENBQThDLDRDQUFPO0FBQ3JEO0FBQ0EsNENBQTRDLDRDQUFPLGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsUUFBUTtBQUNuRixvRUFBb0UsUUFBUSx3QkFBd0IsUUFBUTtBQUM1Ryx1R0FBdUcsVUFBVSxhQUFhLFNBQVM7O0FBRXZJO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1REFBUTtBQUMxQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRCx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0EsdUNBQXVDLHlCQUF5QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCLGtEQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGtEQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrREFBTztBQUNwRCxjQUFjLGtEQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtEQUFPO0FBQzdDLFlBQVksa0RBQU87QUFDbkI7QUFDQSw4QkFBOEIsa0RBQU87QUFDckM7QUFDQSxhQUFhO0FBQ2Isa0NBQWtDLGtEQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVEQUFRO0FBQzlCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RCx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQXdEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLLEVBQUUsdURBQVE7QUFDZixxQ0FBcUMsUUFBUTtBQUM3QyxtQkFBbUIsNENBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvREFBYTtBQUMxQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsVUFBVTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEVBQTBFLHVEQUFRO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNENBQTRDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHVEQUFRO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFLO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IseURBQWtCO0FBQ3BDLHFCQUFxQiwwREFBVztBQUNoQyxpREFBaUQsNENBQUs7QUFDdEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQVM7QUFDeEIsZUFBZSx5REFBa0I7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyREFBMkQsdURBQVE7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOERBQWU7QUFDbEM7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsdURBQVE7QUFDNUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCLDhDQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlCQUF5QjtBQUNwRTtBQUNBLHFDQUFxQyxnRUFBaUIsQ0FBQyx1REFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBTztBQUNqQyxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCLDJEQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0RUFBeUI7QUFDakQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtEQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4Q0FBTztBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQ0FBb0Msa0RBQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLGtEQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0IsOEJBQThCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0RBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9FQUFpQjtBQUM3QztBQUNBLHlCQUF5QixnRUFBaUI7QUFDMUMsMEJBQTBCLDhDQUFPO0FBQ2pDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFPO0FBQy9CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFPO0FBQy9CLDhCQUE4QixrREFBTztBQUNyQyxLQUFLO0FBQ0wsWUFBWSxrREFBTztBQUNuQjtBQUNBO0FBQ0EsbUNBQW1DLGtEQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrREFBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0RBQU87QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQSwrQkFBK0Isa0RBQU87QUFDdEMsS0FBSyxNQUFNLGtEQUFPO0FBQ2xCLDBEQUEwRCxrREFBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUMsZ0VBQWlCLENBQUMsdURBQVE7QUFDL0QsNEJBQTRCLDJEQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtEQUFPO0FBQ3hDO0FBQ0Esb0JBQW9CLDJEQUFZLFNBQVMsZ0VBQWlCLENBQUMsdURBQVE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBTztBQUN2QyxzQ0FBc0Msa0RBQU87QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0IseUVBQXNCO0FBQ3JEO0FBQ0EseUJBQXlCLGdFQUFpQjtBQUMxQywwQkFBMEIsOENBQU87QUFDakM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtEQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtEQUFPO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrREFBTztBQUM3QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkZBQTZGLGtEQUFPO0FBQ3BHO0FBQ0E7QUFDQSx3QkFBd0IsNkVBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4Q0FBTztBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLElBQUk7QUFDNUMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0MsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0JBQWdCLG1DQUFtQztBQUNuRDtBQUNBO0FBQ0EsNkJBQTZCLHVEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2Qix1REFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0NBQWtDLDREQUFhO0FBQy9DO0FBQ0E7QUFDQSw4QkFBOEIsOENBQU87QUFDckMsdUJBQXVCLDhDQUFPO0FBQzlCLGFBQWE7QUFDYjtBQUNBLG9CQUFvQiw0Q0FBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOENBQU87QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBTztBQUM5QixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkIsdURBQVE7QUFDckMsd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBUTtBQUN0QyxpQkFBaUI7QUFDakI7QUFDQSw2QkFBNkIsdURBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QixnRkFBZ0YsNENBQVM7QUFDMUk7QUFDQSw2QkFBNkIsOENBQU87QUFDcEM7QUFDQTtBQUNBLDhCQUE4Qix1REFBUTtBQUN0QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHlDQUF5Qyw4QkFBOEI7QUFDdkU7QUFDQTtBQUNBLCtCQUErQix1RUFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsdURBQVE7QUFDbEYsK0NBQStDLHVEQUFRO0FBQ3ZEO0FBQ0E7QUFDQSwyRUFBMkUsdURBQVE7QUFDbkYsZ0RBQWdELHVEQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdURBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUFPO0FBQzNDLGtDQUFrQywwREFBVyx3Q0FBd0MsNENBQVM7QUFDOUY7QUFDQSx3REFBd0QsOENBQU87QUFDL0Q7QUFDQTtBQUNBLG9DQUFvQyxxQ0FBRTtBQUN0QztBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG9DQUFvQyx1REFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyx5QkFBeUIsMERBQVc7QUFDcEM7QUFDQTtBQUNBLHFEQUFxRCw0Q0FBSztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnRUFBaUIsQ0FBQyx1REFBUTtBQUM5RCxtQ0FBbUMsMkRBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0REFBYTtBQUM1RDtBQUNBLDZCQUE2Qix1REFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxREFBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaURBQVU7QUFDakQsdUNBQXVDLGlEQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSw0REFBYTtBQUNqRiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVEQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixnQkFBZ0IsT0FBTyxrQkFBa0I7QUFDcEk7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBbUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtEQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0EsaUVBQWlFLHlCQUF5QjtBQUMxRjtBQUNBO0FBQ0EseUJBQXlCLGtEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxrREFBTztBQUNoRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyQ0FBMkMsZUFBZTtBQUMxRDtBQUNBO0FBQ0Esa0NBQWtDLGtEQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0Q0FBUztBQUM1Qyw4REFBOEQsNENBQVM7QUFDdkU7QUFDQSx3QkFBd0Isa0RBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1EQUFtRCxlQUFlO0FBQ2xFO0FBQ0E7QUFDQSwwQ0FBMEMsa0RBQU87QUFDakQsc0JBQXNCLGtEQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBLHNDQUFzQyxrREFBTztBQUM3QyxzQkFBc0Isa0RBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsMENBQTBDO0FBQ2pGO0FBQ0EsNENBQTRDLGtEQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksb0VBQW9FO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQ0FBb0M7QUFDNUUsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1REFBUTtBQUMzQyw0QkFBNEIseURBQWtCO0FBQzlDLHVCQUF1QixnREFBUztBQUNoQyxTQUFTO0FBQ1Q7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8sRUFBRSx5REFBa0I7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCO0FBQ2pEO0FBQ0EsK0NBQStDLDJEQUFvQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0RBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxtQ0FBbUMsMEJBQTBCLFlBQVk7QUFDekU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJEQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVEQUFRO0FBQzNDO0FBQ0E7QUFDQSxvRUFBb0Usb0JBQW9CO0FBQ3hGO0FBQ0EsNEJBQTRCLHlEQUFrQjtBQUM5Qyx1QkFBdUIsZ0RBQVM7QUFDaEMsU0FBUztBQUNUO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBLCtDQUErQywyREFBb0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0RBQVc7QUFDMUMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyREFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0RBQVc7QUFDbEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVEQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBTztBQUNwQztBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0MseUNBQXlDLDBDQUFPO0FBQ2hEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrREFBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1REFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtEQUFPO0FBQ3BDO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQyx5Q0FBeUMsMENBQU87QUFDaEQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtEQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBSTtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdFQUFnRSxjQUFjO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhLElBQUkseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQkFBMkIsOENBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw4REFBZTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdIQUF3SCw4Q0FBOEMsVUFBVSxrQ0FBa0M7QUFDbE47QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdURBQVE7QUFDOUI7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGdFQUFnRSxxQkFBcUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUNBQXFDLGtEQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsdUNBQXVDLHlFQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvREFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RCw4QkFBOEIsa0RBQU8sZ0JBQWdCLGtEQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1CQUFtQixrREFBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMseURBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkRBQWM7QUFDMUIsWUFBWSw4REFBZTtBQUMzQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFVBQVUsd0RBQXdEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsOENBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVEQUFRO0FBQzFCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFZO0FBQ2hDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsOENBQThDO0FBQ3RHO0FBQ0E7QUFDQSwrQkFBK0IsOENBQVE7QUFDdkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYSxJQUFJLGlCQUFpQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RCw2QkFBNkIsb0VBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOERBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4Q0FBUTtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOENBQVE7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDhEQUFzQjtBQUNyRDtBQUNBLDJCQUEyQiw4REFBc0I7QUFDakQsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCLDhEQUFzQjtBQUM5QywyQkFBMkIsOERBQXNCO0FBQ2pEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5REFBa0I7QUFDdEMsMkJBQTJCLDZDQUFNO0FBQ2pDLGFBQWEsU0FBUyxnREFBYTtBQUNuQyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSEFBc0gsNENBQVM7QUFDL0gsNkJBQTZCLDJDQUFRO0FBQ3JDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQ0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsOERBQXNCO0FBQ3RHO0FBQ0Esb0ZBQW9GLDhEQUFzQjtBQUMxRyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUZBQWE7QUFDcEMsbUNBQW1DLHFFQUFrQixNQUFNLHlCQUF5QjtBQUNwRixRQUFRLDhEQUFzQiw0QkFBNEIsbUVBQW1CLE1BQU0seUJBQXlCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELElBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLGtEQUFrRCw0Q0FBUztBQUMzRDtBQUNBLGdEQUFnRCw0Q0FBUyxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4REFBc0I7QUFDbkMsWUFBWSw4REFBc0I7QUFDbEM7QUFDQSxlQUFlLDhEQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkRBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBUTtBQUNoQixRQUFRLDRDQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZLDRDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxtQkFBbUI7QUFDaEcsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxlQUFlO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZEQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCLElBQUksa0JBQWtCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0EsMkJBQTJCLGdFQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0EsK0JBQStCLDREQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrREFBK0QscUJBQXFCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBUTtBQUN4QjtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFRO0FBQzVCO0FBQ0Esd0JBQXdCLDRDQUFRLDREQUE0RCwyQkFBMkI7QUFDdkgsMEVBQTBFLDJCQUEyQjtBQUNyRztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBUTtBQUN4QjtBQUNBLFlBQVksNENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUNBQXFDLHdFQUE4QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUTtBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNkRBQW1CLHVCQUF1QjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtRUFBeUI7QUFDakU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQiw0Q0FBUSw0Q0FBNEMsb0JBQW9CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUSxtQ0FBbUMsNkRBQW1CLDZCQUE2QjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkRBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLFFBQVEsa2JBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQVE7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBUTtBQUM1QixvRkFBb0Ysb0JBQW9CO0FBQ3hHO0FBQ0EsZ0JBQWdCLDRDQUFRO0FBQ3hCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxZQUFZLDRDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixvQ0FBb0Msd0VBQThCO0FBQ2xFLFlBQVksNENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUTtBQUNwQiw2REFBNkQsNkRBQW1CLDJCQUEyQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLFFBQVEsa2JBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQixFQUFFLGdCQUFnQixFQUFFLGFBQWE7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBUTtBQUN4QjtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFRO0FBQzVCO0FBQ0EscUVBQXFFLDJCQUEyQjtBQUNoRztBQUNBLDZFQUE2RSxvQkFBb0I7QUFDakc7QUFDQSxnQkFBZ0IsNENBQVE7QUFDeEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFlBQVksNENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9DQUFvQyx3RUFBOEI7QUFDbEUsWUFBWSw0Q0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUFRO0FBQ3BCLHNEQUFzRCw2REFBbUIsMEJBQTBCO0FBQ25HO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpRUFBdUI7QUFDNUQ7QUFDQSxvRUFBb0UscUJBQXFCLFdBQVcsUUFBUTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9EQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpREFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHNCQUFzQixNQUFNLG9CQUFvQixJQUFJLDZEQUFtQiwwQkFBMEI7QUFDM0o7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJDQUFRO0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG9CQUFvQixJQUFJLDZEQUFtQiwwQkFBMEI7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvREFBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0RBQWE7QUFDckQsWUFBWSw0Q0FBUTtBQUNwQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0NBQXdDLGlEQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQ0FBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxvQkFBb0IsNENBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsNkRBQW1CLDZDQUE2QztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUFRO0FBQ3BCO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQSxZQUFZLDRDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksNENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWSw0Q0FBUTtBQUNwQjtBQUNBO0FBQ0EsWUFBWSw0Q0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUTtBQUNwQiwwRUFBMEUsNkRBQW1CLHNCQUFzQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpRUFBdUI7QUFDeEQ7QUFDQSx5Q0FBeUMsT0FBTyx5QkFBeUIsUUFBUTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJDQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQVEscUNBQXFDLE9BQU8sV0FBVyxRQUFRO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlFQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUSwyQkFBMkIsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUSxlQUFlLE9BQU8seUJBQXlCLFFBQVE7QUFDM0U7QUFDQTtBQUNBLFFBQVEsNENBQVEsNEJBQTRCLE1BQU0sTUFBTSxPQUFPLFdBQVcsUUFBUTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpRUFBdUI7QUFDeEQ7QUFDQSx5Q0FBeUMsT0FBTyx5QkFBeUIsUUFBUTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9DQUFvQztBQUMxRSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnREFBUyxDQUFDLG1EQUFZO0FBQzFEO0FBQ0EsbUNBQW1DLHNEQUFzRDtBQUN6RixZQUFZLDRDQUFRLHVDQUF1QyxPQUFPLFdBQVcsUUFBUSxTQUFTLFlBQVksZUFBZSxnQkFBZ0I7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWtFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRDQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCLEVBQUUsY0FBYztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRDQUFRLDJCQUEyQixNQUFNLG9EQUFjLGlCQUFpQjtBQUNoRix5QkFBeUIsb0RBQWM7QUFDdkMsbUNBQW1DLGtEQUFhO0FBQ2hELFFBQVEsNENBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUSw0Q0FBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0Isd0JBQXdCO0FBQ3hDLFFBQVEsNENBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhCQUE4QixXQUFXLGNBQWM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrREFBK0QscUJBQXFCO0FBQ3BGO0FBQ0EsUUFBUSw0Q0FBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQkFBMkIsS0FBSyw2QkFBNkI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsUUFBUSw0Q0FBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCLEVBQUUsY0FBYyxFQUFFLGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBUSx3RUFBd0UsY0FBYztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkJBQTZCO0FBQzlELGFBQWE7QUFDYixZQUFZLDRDQUFRLHVEQUF1RCxhQUFhLEdBQUcsVUFBVTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBUSw2Q0FBNkMsZUFBZTtBQUNwRjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQVE7QUFDcEIsd0VBQXdFLDZEQUFtQiw2QkFBNkI7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrREFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWEsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZEQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZLDRDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4S0FBOEs7QUFDOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFRLDRDQUE0QyxPQUFPLHlCQUF5QixVQUFVO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUSw4Q0FBOEMsT0FBTywwQkFBMEIsVUFBVTtBQUM3RztBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0RBQVk7QUFDdEU7QUFDQTtBQUNBLHFEQUFxRCxrREFBWTtBQUNqRSxhQUFhO0FBQ2I7QUFDQSx1REFBdUQsa0RBQVk7QUFDbkU7QUFDQSxpREFBaUQsa0RBQVk7QUFDN0Q7QUFDQTtBQUNBLGtDQUFrQyxvREFBYztBQUNoRDtBQUNBLG9CQUFvQixjQUFjLFFBQVEsa2JBQWM7QUFDeEQ7QUFDQSxZQUFZLDRDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0RBQWtELG1CQUFtQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQVE7QUFDcEIsdUVBQXVFO0FBQ3ZFLFlBQVksNENBQVE7QUFDcEI7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvREFBYztBQUM3QztBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0RBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNFQUFzRTtBQUMxRjtBQUNBLDZEQUE2RCxrREFBWTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtEQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2REFBbUI7QUFDcEQ7QUFDQSxtREFBbUQsa0RBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxrREFBa0Qsa0RBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGFBQWE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9EQUFjO0FBQ3BEO0FBQ0Esd0JBQXdCLGNBQWMsUUFBUSxrYkFBYztBQUM1RDtBQUNBLGdCQUFnQiw0Q0FBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQkFBMEIsRUFBRSxjQUFjLFdBQVcsaUJBQWlCO0FBQ2pILGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsa0JBQWtCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaURBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHNCQUFzQixjQUFjLHdCQUF3QjtBQUNoSCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQVEsbUNBQW1DLGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHNCQUFzQixjQUFjLHlCQUF5QjtBQUM3RyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBUTtBQUN4QixnQkFBZ0IsNENBQVE7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNENBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsNEJBQTRCLDRDQUFRO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsNENBQVE7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBUTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSw0Q0FBUSxxREFBcUQsaUJBQWlCLFlBQVksaUJBQWlCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2REFBbUIsc0JBQXNCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQVE7QUFDcEIsWUFBWSw0Q0FBUTtBQUNwQixvQkFBb0IsY0FBYyxRQUFRLGtiQUFjO0FBQ3hELDZCQUE2QixvREFBYztBQUMzQztBQUNBLFlBQVksNENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFlBQVksNENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQVE7QUFDeEI7QUFDQTtBQUNBLFlBQVksNENBQVE7QUFDcEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQVE7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBUTtBQUM1QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1FQUFtRSx1QkFBdUI7QUFDMUY7QUFDQSxnQkFBZ0IsNENBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQVE7QUFDcEIsaURBQWlELDZCQUE2QjtBQUM5RSxxREFBcUQsNkRBQW1CLGdDQUFnQztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQVEsK0NBQStDLDBCQUEwQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0RBQWM7QUFDaEQ7QUFDQSxZQUFZLDRDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBUSxzREFBc0QsT0FBTztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBWTtBQUMzQyxnQkFBZ0IsNENBQVEsMERBQTBELFdBQVcsS0FBSyxPQUFPO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaURBQVk7QUFDL0Msb0JBQW9CLDRDQUFRLG1FQUFtRSxXQUFXLEtBQUssT0FBTztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBWTtBQUMzQyxnQkFBZ0IsNENBQVEsOERBQThELFdBQVcsS0FBSyxPQUFPO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUFRLG9DQUFvQyxRQUFRLFlBQVksTUFBTTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUFRLGdFQUFnRSxnQkFBZ0I7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksNENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0EsZ0JBQWdCLDRDQUFRLGlEQUFpRCxRQUFRLEdBQUcsV0FBVywwQkFBMEIsUUFBUSxZQUFZLFFBQVE7QUFDcko7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFRLDhEQUE4RCxnQkFBZ0IsS0FBSyxRQUFRO0FBQ3ZIO0FBQ0EsaUZBQWlGLGFBQWE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNENBQVEsb0VBQW9FLFFBQVE7QUFDNUc7QUFDQTtBQUNBLGdFQUFnRSxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRDQUFRLHdFQUF3RSxXQUFXO0FBQ25IO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBUSx5REFBeUQsZUFBZTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0Q0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNENBQVE7QUFDaEM7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBUSxzREFBc0QsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBUSxrREFBa0QsU0FBUztBQUNuRjtBQUNBLG9CQUFvQiw0Q0FBUSxxREFBcUQsV0FBVztBQUM1RjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxZQUFZLFlBQVksNkRBQW1CLDZCQUE2QjtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsWUFBWTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRDQUFRLDJDQUEyQyxRQUFRO0FBQ25GLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFRLG9CQUFvQixPQUFPLDJCQUEyQixRQUFRO0FBQ3RGLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFlBQVksNENBQVEsb0RBQW9ELE1BQU07QUFDOUU7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQVEsaUJBQWlCLE9BQU8sbUJBQW1CLFFBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBUSxZQUFZLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBUSxZQUFZLE9BQU8seUJBQXlCLFFBQVE7QUFDNUUsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxrQ0FBa0Msb0RBQWM7QUFDaEQ7QUFDQTtBQUNBLGlDQUFpQyxpREFBWTtBQUM3QyxZQUFZLDRDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQVEsa0RBQWtELE1BQU07QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9EQUFjO0FBQ2hEO0FBQ0EsZ0JBQWdCLDRDQUFRLDJDQUEyQyxRQUFRO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQVEsa0JBQWtCLG1CQUFtQixtQkFBbUIsU0FBUztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFRLFlBQVksbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQVEsWUFBWSxtQkFBbUIseUJBQXlCLFFBQVE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQVEsMERBQTBELE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBUSxzQ0FBc0MsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9EQUFjO0FBQzdDO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0RBQVk7QUFDL0Q7QUFDQSxvQkFBb0Isc0VBQXNFLHlOQUF5TixrREFBWTtBQUMvVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkRBQW1CO0FBQ3BEO0FBQ0EsbURBQW1ELGtEQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxhQUFhO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBUSxvQ0FBb0MsVUFBVTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRDQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUNBQWlDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUNBQWlDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMEJBQTBCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9CIiwic291cmNlcyI6WyIvVXNlcnMveW91c3VrZS9NeVByb2plY3QvbXktbmV4dXMtYXBwL25vZGVfbW9kdWxlcy8ucG5wbS9AYXZhaWwtcHJvamVjdCtuZXh1cy1jb3JlQDAuMC4xLWJldGEuMF9idWZmZXJ1dGlsQDQuMC45X2dvb2dsZS1wcm90b2J1ZkAzLjIxLjRfdXRmLTgtdmFfNTZkZDU1MGM4YjllMDYzOTY5NGNkOTE3NjM3N2ZhNzIvbm9kZV9tb2R1bGVzL0BhdmFpbC1wcm9qZWN0L25leHVzLWNvcmUvZGlzdC9pbmRleC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0QmFsYW5jZSwgcGFyc2VVbml0cywgZm9ybWF0VW5pdHMsIGlzVmFsaWRBZGRyZXNzLCB0cnVuY2F0ZUFkZHJlc3MsIGNoYWluSWRUb0hleCwgaGV4VG9DaGFpbklkLCBnZXRNYWlubmV0VG9rZW5NZXRhZGF0YSwgZ2V0VGVzdG5ldFRva2VuTWV0YWRhdGEsIGdldFRva2VuTWV0YWRhdGEsIGdldENoYWluTWV0YWRhdGEsIGZvcm1hdFRva2VuQW1vdW50LCBmb3JtYXRUZXN0bmV0VG9rZW5BbW91bnQsIGxvZ2dlciBhcyBsb2dnZXIkbSwgQ0hBSU5fTUVUQURBVEEsIENhbGlidXJTQkNUeXBlcywgU3dhcE1vZGUsIFNVUFBPUlRFRF9DSEFJTlMsIGV4dHJhY3RFcnJvck1lc3NhZ2UsIHZhbGlkYXRlQ29udHJhY3RQYXJhbXMsIGVuY29kZUNvbnRyYWN0Q2FsbCwgZ2V0VHJhbnNhY3Rpb25IYXNoV2l0aEZhbGxiYWNrLCB3YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0LCBnZXRCbG9ja0V4cGxvcmVyVXJsLCBnZXRUb2tlbkNvbnRyYWN0QWRkcmVzcywgVE9LRU5fTUVUQURBVEEsIE5FWFVTX0VWRU5UUyB9IGZyb20gJy4vY29tbW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbW1vbnMnO1xuZXhwb3J0IHsgQ0hBSU5fTUVUQURBVEEsIERFU1RJTkFUSU9OX1NXQVBfVE9LRU5TLCBNQUlOTkVUX0NIQUlOUywgTkVYVVNfRVZFTlRTLCBTVVBQT1JURURfQ0hBSU5TLCBURVNUTkVUX0NIQUlOUywgVEVTVE5FVF9UT0tFTl9NRVRBREFUQSwgVE9LRU5fQ09OVFJBQ1RfQUREUkVTU0VTLCBUT0tFTl9NRVRBREFUQSB9IGZyb20gJy4vY29tbW9ucyc7XG5pbXBvcnQgeyBoZXhUb0JpZ0ludCwgZm9ybWF0RXRoZXIsIEludGVybmFsUnBjRXJyb3IsIFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvciwgU3dpdGNoQ2hhaW5FcnJvciwgbWF4VWludDI1NiwgaGV4VG9CeXRlcywgcGFkLCBwYXJzZVNpZ25hdHVyZSwgY3JlYXRlUHVibGljQ2xpZW50LCBodHRwLCBmYWxsYmFjaywgZ2V0Q29udHJhY3QsIGJ5dGVzVG9IZXgsIGVuY29kZUZ1bmN0aW9uRGF0YSwgZGVjb2RlRnVuY3Rpb25EYXRhLCB0b0J5dGVzLCB0b0hleCwgZ2V0QWJpSXRlbSwgZW5jb2RlQWJpUGFyYW1ldGVycywga2VjY2FrMjU2LCBoYXNoTWVzc2FnZSwgYnl0ZXNUb051bWJlciwgYnl0ZXNUb0JpZ0ludCwgY29uY2F0LCB3ZWJTb2NrZXQsIHNlcmlhbGl6ZVRyYW5zYWN0aW9uLCBjcmVhdGVXYWxsZXRDbGllbnQsIGN1c3RvbSwgcHVibGljQWN0aW9ucywgcGFyc2VVbml0cyBhcyBwYXJzZVVuaXRzJDEsIGVyYzIwQWJpLCBmb3JtYXRVbml0cyBhcyBmb3JtYXRVbml0cyQxLCBlbmNvZGVQYWNrZWQsIGhleFRvTnVtYmVyIH0gZnJvbSAndmllbSc7XG5pbXBvcnQgeyBPbW5pdmVyc2FsQ2hhaW5JRCwgVW5pdmVyc2UsIENoYWluZGF0YU1hcCwgUGVybWl0VmFyaWFudCwgRVJDMjBBQkksIFBlcm1pdENyZWF0aW9uRXJyb3IsIGNyZWF0ZUNvc21vc0NsaWVudCwgTXNnUmVmdW5kUmVxLCBNc2dSZWZ1bmRSZXFSZXNwb25zZSwgTXNnQ3JlYXRlUmVxdWVzdEZvckZ1bmRzUmVzcG9uc2UsIEVudmlyb25tZW50LCBFVk1WYXVsdEFCSSwgQXJjYW5hVmF1bHQsIE1zZ0RvdWJsZUNoZWNrVHgsIERlcG9zaXRWRVBhY2tldCwgR3JwY1dlYkltcGwsIFF1ZXJ5Q2xpZW50SW1wbCwgT21uaXZlcnNhbFJGRiwgTXNnQ3JlYXRlUmVxdWVzdEZvckZ1bmRzLCBnZXRWYXVsdENvbnRyYWN0TWFwLCBtc2dwYWNrYWJsZUF4aW9zLCBMaUZpQWdncmVnYXRvciwgQmVib3BBZ2dyZWdhdG9yLCBDdXJyZW5jeUlEIGFzIEN1cnJlbmN5SUQkMSwgYXV0b1NlbGVjdFNvdXJjZXMsIGxpcXVpZGF0ZUlucHV0SG9sZGluZ3MsIGRldGVybWluZURlc3RpbmF0aW9uU3dhcHMsIGRlc3RpbmF0aW9uU3dhcFdpdGhFeGFjdEluLCBjcmVhdGVDb3Ntb3NXYWxsZXQgfSBmcm9tICdAYXJjYW5hL2NhLWNvbW1vbic7XG5pbXBvcnQgRGVjaW1hbCBmcm9tICdkZWNpbWFsLmpzJztcbmltcG9ydCB7IENIQUlOX0lEUywgaGV4bGlmeSwgYXJyYXlpZnksIGJuLCBPdXRwdXRUeXBlLCBBY2NvdW50LCBQcm92aWRlciwgQWRkcmVzcywgQk4sIHJhbmRvbUJ5dGVzLCBVVFhPX0lEX0xFTiB9IGZyb20gJ2Z1ZWxzJztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAnaXQtd3MnO1xuaW1wb3J0IHsgcGFjaywgdW5wYWNrIH0gZnJvbSAnbXNncGFja3InO1xuaW1wb3J0IHsgaXNEZWxpdmVyVHhTdWNjZXNzLCBpc0RlbGl2ZXJUeEZhaWx1cmUgfSBmcm9tICdAY29zbWpzL3N0YXJnYXRlJztcbmltcG9ydCB7IF9fY2xhc3NQcml2YXRlRmllbGRTZXQsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgU2FmZUV2ZW50RW1pdHRlciBmcm9tICdAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyJztcbmltcG9ydCB7IGtleURlcml2YXRpb24gfSBmcm9tICdAc3Rhcmt3YXJlLWluZHVzdHJpZXMvc3Rhcmt3YXJlLWNyeXB0by11dGlscyc7XG5pbXBvcnQgeyBwcml2YXRlS2V5VG9BY2NvdW50IH0gZnJvbSAndmllbS9hY2NvdW50cyc7XG5pbXBvcnQgeyBjcmVhdGVTaXdlTWVzc2FnZSB9IGZyb20gJ3ZpZW0vc2l3ZSc7XG5pbXBvcnQgTG9uZyBmcm9tICdsb25nJztcbmltcG9ydCB7IHRvSGV4IGFzIHRvSGV4JDEgfSBmcm9tICd2aWVtL3V0aWxzJztcbmltcG9ydCB7IHJldHJ5LCBvcmRlckJ5IH0gZnJvbSAnZXMtdG9vbGtpdCc7XG5cbmNsYXNzIE5leHVzVXRpbHMge1xuICAgIGNvbnN0cnVjdG9yKGFkYXB0ZXIsIGlzUmVhZHkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gYWRhcHRlcjtcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gaXNSZWFkeTtcbiAgICAgICAgLy8gUHVyZSB1dGlsaXR5IGZ1bmN0aW9ucyAobm8gYWRhcHRlciBkZXBlbmRlbmN5KVxuICAgICAgICB0aGlzLmZvcm1hdEJhbGFuY2UgPSBmb3JtYXRCYWxhbmNlO1xuICAgICAgICB0aGlzLnBhcnNlVW5pdHMgPSBwYXJzZVVuaXRzO1xuICAgICAgICB0aGlzLmZvcm1hdFVuaXRzID0gZm9ybWF0VW5pdHM7XG4gICAgICAgIHRoaXMuaXNWYWxpZEFkZHJlc3MgPSBpc1ZhbGlkQWRkcmVzcztcbiAgICAgICAgdGhpcy50cnVuY2F0ZUFkZHJlc3MgPSB0cnVuY2F0ZUFkZHJlc3M7XG4gICAgICAgIHRoaXMuY2hhaW5JZFRvSGV4ID0gY2hhaW5JZFRvSGV4O1xuICAgICAgICB0aGlzLmhleFRvQ2hhaW5JZCA9IGhleFRvQ2hhaW5JZDtcbiAgICAgICAgdGhpcy5nZXRNYWlubmV0VG9rZW5NZXRhZGF0YSA9IGdldE1haW5uZXRUb2tlbk1ldGFkYXRhO1xuICAgICAgICB0aGlzLmdldFRlc3RuZXRUb2tlbk1ldGFkYXRhID0gZ2V0VGVzdG5ldFRva2VuTWV0YWRhdGE7XG4gICAgICAgIHRoaXMuZ2V0VG9rZW5NZXRhZGF0YSA9IGdldFRva2VuTWV0YWRhdGE7XG4gICAgICAgIHRoaXMuZ2V0Q2hhaW5NZXRhZGF0YSA9IGdldENoYWluTWV0YWRhdGE7XG4gICAgICAgIHRoaXMuZm9ybWF0VG9rZW5BbW91bnQgPSBmb3JtYXRUb2tlbkFtb3VudDtcbiAgICAgICAgdGhpcy5mb3JtYXRUZXN0bmV0VG9rZW5BbW91bnQgPSBmb3JtYXRUZXN0bmV0VG9rZW5BbW91bnQ7XG4gICAgfVxuICAgIGVuc3VyZUluaXRpYWxpemVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSZWFkeSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05leHVzU0RLIG11c3QgYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIHVzaW5nIHV0aWxzIG1ldGhvZHMgdGhhdCByZXF1aXJlIGFkYXB0ZXIgYWNjZXNzLiBDYWxsIHNkay5pbml0aWFsaXplKCkgZmlyc3QuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U3VwcG9ydGVkQ2hhaW5zKCkge1xuICAgICAgICB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuZ2V0U3VwcG9ydGVkQ2hhaW5zKCk7XG4gICAgfVxuICAgIGdldFN3YXBTdXBwb3J0ZWRDaGFpbnNBbmRUb2tlbnMoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5uZXh1c1NESy5nZXRTd2FwU3VwcG9ydGVkQ2hhaW5zQW5kVG9rZW5zKCk7XG4gICAgfVxuICAgIC8qIFNhbWUgZm9yIGlzU3VwcG9ydGVkQ2hhaW4gLyBpc1N1cHBvcnRlZFRva2VuICovXG4gICAgaXNTdXBwb3J0ZWRDaGFpbihjaGFpbklkKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5pc1N1cHBvcnRlZENoYWluKGNoYWluSWQpO1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZFRva2VuKHRva2VuKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5pc1N1cHBvcnRlZFRva2VuKHRva2VuKTtcbiAgICB9XG59XG5cbmNvbnN0IEJBQ0tFTkRfVVJMID0gJ2h0dHBzOi8vbmV4dXMtYmFja2VuZC5hdmFpbC5zbyc7XG4vKipcbiAqIEJhY2tlbmQgY2xpZW50IGZvciBnYXMgZXN0aW1hdGlvbiB1c2luZyBuZXcgQVBJXG4gKi9cbmNsYXNzIEJhY2tlbmRTaW11bGF0aW9uQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gY29uZmlnLmJhc2VVcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgc3BlY2lmaWMgY2hhaW4gaXMgc3VwcG9ydGVkXG4gICAgICovXG4gICAgYXN5bmMgaXNDaGFpblN1cHBvcnRlZChjaGFpbklkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vYXBpL2dhcy1lc3RpbWF0aW9uL2NoZWNrLWNoYWluLyR7Y2hhaW5JZH1gKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5kYXRhPy5zdXBwb3J0ZWQgPT09IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIkbS53YXJuKGBFcnJvciBjaGVja2luZyBjaGFpbiBzdXBwb3J0IGZvciAke2NoYWluSWR9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHN1cHBvcnRlZCBjaGFpbnNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdXBwb3J0ZWRDaGFpbnMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vYXBpL2dhcy1lc3RpbWF0aW9uL3N1cHBvcnRlZC1jaGFpbnNgKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3MgPyByZXN1bHQuZGF0YSB8fCBudWxsIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oJ0Vycm9yIGZldGNoaW5nIHN1cHBvcnRlZCBjaGFpbnM6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNlcnZpY2Ugc3RhdHVzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2VydmljZVN0YXR1cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9hcGkvZ2FzLWVzdGltYXRpb24vc3RhdHVzYCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8gcmVzdWx0LmRhdGEgfHwgbnVsbCA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIkbS53YXJuKCdFcnJvciBmZXRjaGluZyBzZXJ2aWNlIHN0YXR1czonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWFsdGggY2hlY2tcbiAgICAgKi9cbiAgICBhc3luYyBoZWFsdGhDaGVjaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9hcGkvaGVhbHRoYCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8gcmVzdWx0LmRhdGEgfHwgbnVsbCA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIkbS53YXJuKCdFcnJvciBwZXJmb3JtaW5nIGhlYWx0aCBjaGVjazonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGNvbm5lY3Rpdml0eSBhbmQgc2VydmljZSBoZWFsdGhcbiAgICAgKi9cbiAgICBhc3luYyB0ZXN0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWx0aCA9IGF3YWl0IHRoaXMuaGVhbHRoQ2hlY2soKTtcbiAgICAgICAgICAgIHJldHVybiBoZWFsdGg/LnN0YXR1cyA9PT0gJ29rJztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oJ0Nvbm5lY3Rpb24gdGVzdCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBkZXRhaWxlZCBzZXJ2aWNlIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2VydmljZUluZm8oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbaGVhbHRoLCBzdGF0dXNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuaGVhbHRoQ2hlY2soKSwgdGhpcy5nZXRTZXJ2aWNlU3RhdHVzKCldKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGVhbHRoeTogaGVhbHRoPy5zdGF0dXMgPT09ICdvaycsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZDogc3RhdHVzPy5jb25maWd1cmVkIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN1cHBvcnRlZENoYWluczogc3RhdHVzPy5zdXBwb3J0ZWRDaGFpbnNDb3VudCB8fCAwLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGhlYWx0aD8udmVyc2lvbixcbiAgICAgICAgICAgICAgICB1cHRpbWU6IGhlYWx0aD8udXB0aW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oJ0Vycm9yIGdldHRpbmcgc2VydmljZSBpbmZvOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGVhbHRoeTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkQ2hhaW5zOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW11bGF0ZSB0cmFuc2FjdGlvbiB1c2luZyBUZW5kZXJseSdzIEdhdGV3YXkgUlBDIHdpdGggc3RhdGUgb3ZlcnJpZGVzXG4gICAgICogVGhpcyBwcm92aWRlcyBtb3JlIGFjY3VyYXRlIHNpbXVsYXRpb24gcmVzdWx0cyB0aGFuIGJhc2ljIGdhcyBlc3RpbWF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgc2ltdWxhdGUocmVxdWVzdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2FwaS9nYXMtZXN0aW1hdGlvbi9zaW11bGF0ZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpbXVsYXRpb24gQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gLSAke2Vycm9yVGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MgfHwgIXJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvciB8fCByZXN1bHQubWVzc2FnZSB8fCAnU2ltdWxhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdhc0RhdGEgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2FzVXNlZDogZ2FzRGF0YS5nYXNVc2VkLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBnYXNEYXRhLmdhc1ByaWNlIHx8ICcweDAnLFxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogZ2FzRGF0YS5tYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGdhc0RhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZWRDb3N0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsRmVlOiBnYXNEYXRhPy5nYXNVc2VkIHx8ICcwJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlciRtLmVycm9yKCdTaW11bGF0aW9uIEFQSSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdhc1VzZWQ6ICcweDAnLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiAnMHgwJyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxuICAgICAgICAgICAgICAgIGVzdGltYXRlZENvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxGZWU6ICcwJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBjdXJyZW50IGdhcyBwcmljZSB2aWEgUlBDXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3VycmVudEdhc1ByaWNlKGNoYWluSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJwY1VybCA9IHRoaXMuZ2V0UnBjVXJsKGNoYWluSWQpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChycGNVcmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2FzUHJpY2UnLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUlBDIHJlcXVlc3QgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJQQyBlcnJvcjogJHtyZXN1bHQuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnZlcnQgaGV4IGdhcyBwcmljZSB0byBiaWdpbnRcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0JpZ0ludChyZXN1bHQucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oJ0ZhaWxlZCB0byBmZXRjaCBjdXJyZW50IGdhcyBwcmljZSwgdXNpbmcgZmFsbGJhY2s6JywgZXJyb3IpO1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gMjAgZ3dlaSBpZiBSUEMgY2FsbCBmYWlsc1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgnMjAwMDAwMDAwMDAnKTsgLy8gMjAgZ3dlaSBpbiB3ZWlcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgUlBDIFVSTCBmb3IgYSBnaXZlbiBjaGFpbiBJRCB1c2luZyBDSEFJTl9NRVRBREFUQVxuICAgICAqL1xuICAgIGdldFJwY1VybChjaGFpbklkKSB7XG4gICAgICAgIGNvbnN0IGNoYWluSWROdW0gPSBwYXJzZUludChjaGFpbklkLCAxMCk7XG4gICAgICAgIGNvbnN0IGNoYWluTWV0YWRhdGEgPSBDSEFJTl9NRVRBREFUQVtjaGFpbklkTnVtXTtcbiAgICAgICAgaWYgKCFjaGFpbk1ldGFkYXRhIHx8ICFjaGFpbk1ldGFkYXRhLnJwY1VybHMgfHwgY2hhaW5NZXRhZGF0YS5ycGNVcmxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBSUEMgVVJMIGF2YWlsYWJsZSBmb3IgY2hhaW4gJHtjaGFpbklkfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSB0aGUgZmlyc3QgUlBDIFVSTCBmcm9tIHRoZSBtZXRhZGF0YVxuICAgICAgICByZXR1cm4gY2hhaW5NZXRhZGF0YS5ycGNVcmxzWzBdO1xuICAgIH1cbiAgICBhc3luYyBzaW11bGF0ZUJ1bmRsZShyZXF1ZXN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdERUJVRyBzaW11bGF0ZUJ1bmRsZSAtIHJlcXVlc3Q6JywgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCwgbnVsbCwgMikpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2FwaS9nYXMtZXN0aW1hdGlvbi9idW5kbGVgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdW5kbGUgc2ltdWxhdGlvbiBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAtICR7ZXJyb3JUZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcyB8fCAhcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0Lm1lc3NhZ2UgfHwgJ0J1bmRsZSBzaW11bGF0aW9uIGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnREVCVUcgc2ltdWxhdGVCdW5kbGUgLSBiYWNrZW5kIHJlc3BvbnNlOicsIHJlc3VsdCk7XG4gICAgICAgICAgICAvLyBGZXRjaCBjdXJyZW50IGdhcyBwcmljZSB2aWEgUlBDXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50R2FzUHJpY2UgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRHYXNQcmljZShyZXF1ZXN0LmNoYWluSWQpO1xuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnREVCVUcgLSBSYXcgZ2FzIHByaWNlIGZyb20gUlBDICh3ZWkpOicsIGN1cnJlbnRHYXNQcmljZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIC0gR2FzIHByaWNlIGluIGd3ZWk6JywgKE51bWJlcihjdXJyZW50R2FzUHJpY2UpIC8gMWU5KS50b0ZpeGVkKDIpKTtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIC0gQ2hhaW4gSUQ6JywgcmVxdWVzdC5jaGFpbklkKTtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYWNrZW5kIHJlc3BvbnNlIHRvIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRSZXN1bHRzID0gcmVzdWx0LmRhdGEubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhc1VzZWQgPSBoZXhUb0JpZ0ludChpdGVtLmdhc1VzZWQpO1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIC0gR2FzIHVzZWQgKHVuaXRzKTonLCBnYXNVc2VkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhc0Nvc3RXZWkgPSBnYXNVc2VkICogY3VycmVudEdhc1ByaWNlO1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIC0gR2FzIGNvc3QgKHdlaSk6JywgZ2FzQ29zdFdlaS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXNDb3N0RXRoZXIgPSBmb3JtYXRFdGhlcihnYXNDb3N0V2VpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGVwSWQ6IHJlcXVlc3Quc2ltdWxhdGlvbnNbaW5kZXhdPy5zdGVwSWQgfHwgYHN0ZXAtJHtpbmRleH1gLFxuICAgICAgICAgICAgICAgICAgICBnYXNVc2VkOiBnYXNDb3N0RXRoZXIsIC8vIEh1bWFuLXJlYWRhYmxlIGNvc3QgbGlrZSBcIjAuMDA0MjA1XCJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdG90YWwgY29zdFxuICAgICAgICAgICAgY29uc3QgdG90YWxHYXNDb3N0V2VpID0gcmVzdWx0LmRhdGEucmVkdWNlKChzdW0sIGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXNVc2VkID0gaGV4VG9CaWdJbnQoaXRlbS5nYXNVc2VkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtICsgZ2FzVXNlZCAqIGN1cnJlbnRHYXNQcmljZTtcbiAgICAgICAgICAgIH0sIEJpZ0ludCgwKSk7XG4gICAgICAgICAgICBjb25zdCB0b3RhbEdhc0Nvc3RFdGhlciA9IGZvcm1hdEV0aGVyKHRvdGFsR2FzQ29zdFdlaSk7XG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdERUJVRyBzaW11bGF0ZUJ1bmRsZSAtIHRyYW5zZm9ybWVkIHJlc3BvbnNlOicsIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzOiB0cmFuc2Zvcm1lZFJlc3VsdHMsXG4gICAgICAgICAgICAgICAgdG90YWxHYXNVc2VkOiB0b3RhbEdhc0Nvc3RFdGhlcixcbiAgICAgICAgICAgICAgICBnYXNQcmljZVVzZWQ6IGZvcm1hdEV0aGVyKGN1cnJlbnRHYXNQcmljZSAqIEJpZ0ludCgxMDAwMDAwMDAwKSkgKyAnIGd3ZWknLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0czogdHJhbnNmb3JtZWRSZXN1bHRzLFxuICAgICAgICAgICAgICAgIHRvdGFsR2FzVXNlZDogdG90YWxHYXNDb3N0RXRoZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyJG0uZXJyb3IoJ0J1bmRsZSBzaW11bGF0aW9uIEFQSSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlc3VsdHM6IHJlcXVlc3Quc2ltdWxhdGlvbnMubWFwKChzaW0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBJZDogc2ltLnN0ZXBJZCxcbiAgICAgICAgICAgICAgICAgICAgZ2FzVXNlZDogJzAuMCcsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIHRvdGFsR2FzVXNlZDogJzAuMCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBEZWZhdWx0IGJhY2tlbmQgc2ltdWxhdGlvbiBjbGllbnQgaW5zdGFuY2VcbiAqL1xubGV0IGRlZmF1bHRTaW11bGF0aW9uQ2xpZW50ID0gbnVsbDtcbi8qKlxuICogQ29uZmlndXJlIHRoZSBkZWZhdWx0IHNpbXVsYXRpb24gY2xpZW50XG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZVNpbXVsYXRpb25CYWNrZW5kKGNvbmZpZykge1xuICAgIGRlZmF1bHRTaW11bGF0aW9uQ2xpZW50ID0gbmV3IEJhY2tlbmRTaW11bGF0aW9uQ2xpZW50KGNvbmZpZyk7XG59XG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCBzaW11bGF0aW9uIGNsaWVudFxuICovXG5mdW5jdGlvbiBnZXRTaW11bGF0aW9uQ2xpZW50KCkge1xuICAgIHJldHVybiBkZWZhdWx0U2ltdWxhdGlvbkNsaWVudDtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZSBzaW11bGF0aW9uIGNsaWVudCB3aXRoIGhlYWx0aCBjaGVja1xuICovXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplU2ltdWxhdGlvbkNsaWVudChiYXNlVXJsID0gQkFDS0VORF9VUkwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBuZXcgQmFja2VuZFNpbXVsYXRpb25DbGllbnQoeyBiYXNlVXJsIH0pO1xuICAgICAgICAvLyBUZXN0IHRoZSBjb25uZWN0aW9uXG4gICAgICAgIGNvbnN0IGlzSGVhbHRoeSA9IGF3YWl0IGNsaWVudC50ZXN0Q29ubmVjdGlvbigpO1xuICAgICAgICBpZiAoIWlzSGVhbHRoeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogYEJhY2tlbmQgc2VydmljZSBhdCAke2Jhc2VVcmx9IGlzIG5vdCByZXNwb25kaW5nIG9yIHVuaGVhbHRoeWAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbmZpZ3VyZSBhcyBkZWZhdWx0IGNsaWVudFxuICAgICAgICBkZWZhdWx0U2ltdWxhdGlvbkNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBpbml0aWFsaXphdGlvbiBlcnJvcicsXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8gSW5pdGlhbGl6ZSB3aXRoIEJBQ0tFTkRfVVJMIGJ5IGRlZmF1bHRcbmNvbmZpZ3VyZVNpbXVsYXRpb25CYWNrZW5kKHsgYmFzZVVybDogQkFDS0VORF9VUkwgfSk7XG5cbmNvbnN0IExPR19MRVZFTCA9IHtcbiAgICBERUJVRzogMSxcbiAgICBFUlJPUjogNCxcbiAgICBJTkZPOiAyLFxuICAgIE5PTE9HUzogNSxcbiAgICBXQVJOSU5HOiAzLFxufTtcbmNvbnN0IHNlbmRFeGNlcHRpb24gPSAobXNnKSA9PiB7XG59O1xuY29uc3Qgc2V0TG9nTGV2ZWwgPSAobGV2ZWwpID0+IHtcbiAgICBzdGF0ZS5sb2dMZXZlbCA9IGxldmVsO1xufTtcbmNvbnN0IGdldExvZ2dlciA9ICgpID0+IHtcbiAgICByZXR1cm4gc3RhdGUubG9nZ2VyO1xufTtcbmNsYXNzIExvZ2dlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJlZml4ID0gXCJYQVJfQ0FfU0RLXCI7XG4gICAgfVxuICAgIGNvbnNvbGVMb2cobGV2ZWwsIG1lc3NhZ2UsIHBhcmFtcykge1xuICAgICAgICBpZiAobGV2ZWwgPCBzdGF0ZS5sb2dMZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICAgIGNhc2UgTE9HX0xFVkVMLkRFQlVHOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYFtERUJVR11gLCBtZXNzYWdlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMT0dfTEVWRUwuRVJST1I6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW0VSUk9SXWAsIG1lc3NhZ2UsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExPR19MRVZFTC5JTkZPOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgW0lORk9dYCwgbWVzc2FnZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTE9HX0xFVkVMLldBUk5JTkc6XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbV0FSTl1gLCBtZXNzYWdlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0xPR11gLCBtZXNzYWdlLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlYnVnKG1lc3NhZ2UsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxMb2coTE9HX0xFVkVMLkRFQlVHLCBtZXNzYWdlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBlcnJvcihtZXNzYWdlLCBlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsTG9nKExPR19MRVZFTC5FUlJPUiwgbWVzc2FnZSwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgc2VuZEV4Y2VwdGlvbihKU09OLnN0cmluZ2lmeSh7IGVycm9yOiBlcnIubWVzc2FnZSwgbWVzc2FnZSB9KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlcnIgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbExvZyhMT0dfTEVWRUwuRVJST1IsIG1lc3NhZ2UsIGVycik7XG4gICAgICAgICAgICBzZW5kRXhjZXB0aW9uKEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6IGVyciwgbWVzc2FnZSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5mbyhtZXNzYWdlLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aGlzLmludGVybmFsTG9nKExPR19MRVZFTC5JTkZPLCBtZXNzYWdlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBpbnRlcm5hbExvZyhsZXZlbCwgbWVzc2FnZSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGxvZ01lc3NhZ2UgPSBgWyR7dGhpcy5wcmVmaXh9XSBNc2c6ICR7bWVzc2FnZX1cXG5gO1xuICAgICAgICB0aGlzLmNvbnNvbGVMb2cobGV2ZWwsIGxvZ01lc3NhZ2UsIHBhcmFtcyk7XG4gICAgfVxuICAgIHdhcm4obWVzc2FnZSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbExvZyhMT0dfTEVWRUwuV0FSTklORywgbWVzc2FnZSwgcGFyYW1zKTtcbiAgICB9XG59XG5jb25zdCBzdGF0ZSA9IHtcbiAgICBsb2dnZXI6IG5ldyBMb2dnZXIoKSxcbiAgICBsb2dMZXZlbDogTE9HX0xFVkVMLk5PTE9HUyxcbn07XG5cbmNvbnN0IElOVEVOVF9BQ0NFUFRFRCA9IHtcbiAgICB0eXBlOiAnSU5URU5UX0FDQ0VQVEVEJyxcbiAgICB0eXBlSUQ6ICdJQScsXG59O1xuY29uc3QgSU5URU5UX0hBU0hfU0lHTkVEID0ge1xuICAgIHR5cGU6ICdJTlRFTlRfSEFTSF9TSUdORUQnLFxuICAgIHR5cGVJRDogJ0lIUycsXG59O1xuY29uc3QgSU5URU5UX1NVQk1JVFRFRCA9IHtcbiAgICB0eXBlOiAnSU5URU5UX1NVQk1JVFRFRCcsXG4gICAgdHlwZUlEOiAnSVMnLFxufTtcbmNvbnN0IElOVEVOVF9JTklUX1NURVBTID0gW1xuICAgIElOVEVOVF9IQVNIX1NJR05FRCxcbiAgICB7XG4gICAgICAgIC4uLklOVEVOVF9TVUJNSVRURUQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGV4cGxvcmVyVVJMOiAnJyxcbiAgICAgICAgICAgIGludGVudElEOiAwLFxuICAgICAgICB9LFxuICAgIH0sXG5dO1xuY29uc3QgSU5URU5UX0ZVTEZJTExFRCA9IHtcbiAgICB0eXBlOiAnSU5URU5UX0ZVTEZJTExFRCcsXG4gICAgdHlwZUlEOiAnSUYnLFxufTtcbmNvbnN0IEFMTE9XQU5DRV9BUFBST1ZBTF9SRVEgPSAoY2hhaW5JRCkgPT4gKHtcbiAgICB0eXBlOiAnQUxMT1dBTkNFX1VTRVJfQVBQUk9WQUwnLFxuICAgIHR5cGVJRDogYEFVQV8ke2NoYWluSUR9YCxcbn0pO1xuY29uc3QgQUxMT1dBTkNFX0FQUFJPVkFMX01JTkVEID0gKGNoYWluSUQpID0+ICh7XG4gICAgdHlwZTogJ0FMTE9XQU5DRV9BUFBST1ZBTF9NSU5FRCcsXG4gICAgdHlwZUlEOiBgQUFNXyR7Y2hhaW5JRH1gLFxufSk7XG5jb25zdCBBTExPV0FOQ0VfQ09NUExFVEUgPSB7XG4gICAgdHlwZTogJ0FMTE9XQU5DRV9BTExfRE9ORScsXG4gICAgdHlwZUlEOiAnQUFEJyxcbn07XG5jb25zdCBJTlRFTlRfREVQT1NJVF9SRVEgPSAoaWQpID0+ICh7XG4gICAgdHlwZTogJ0lOVEVOVF9ERVBPU0lUJyxcbiAgICB0eXBlSUQ6IGBJRF8ke2lkfWAsXG59KTtcbmNvbnN0IElOVEVOVF9ERVBPU0lUU19DT05GSVJNRUQgPSB7XG4gICAgdHlwZTogJ0lOVEVOVF9ERVBPU0lUU19DT05GSVJNRUQnLFxuICAgIHR5cGVJRDogJ1VJREMnLFxufTtcbmNvbnN0IElOVEVOVF9DT0xMRUNUSU9OX0NPTVBMRVRFID0ge1xuICAgIHR5cGU6ICdJTlRFTlRfQ09MTEVDVElPTl9DT01QTEVURScsXG4gICAgdHlwZUlEOiAnSUNDJyxcbn07XG5jb25zdCBJTlRFTlRfQ09MTEVDVElPTiA9IChpZCkgPT4gKHtcbiAgICB0eXBlOiAnSU5URU5UX0NPTExFQ1RJT04nLFxuICAgIHR5cGVJRDogYElDXyR7aWR9YCxcbn0pO1xuY29uc3QgSU5URU5UX0ZJTklTSF9TVEVQUyA9IFtJTlRFTlRfRlVMRklMTEVEXTtcbmNvbnN0IGNyZWF0ZVN0ZXBzID0gKGludGVudCwgY2hhaW5MaXN0LCB1bmFsbG93ZWRTb3VyY2VzKSA9PiB7XG4gICAgY29uc3Qgc3RlcHMgPSBbXTtcbiAgICBzdGVwcy5wdXNoKElOVEVOVF9BQ0NFUFRFRCk7XG4gICAgaWYgKHVuYWxsb3dlZFNvdXJjZXMgJiYgdW5hbGxvd2VkU291cmNlcz8ubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiB1bmFsbG93ZWRTb3VyY2VzKSB7XG4gICAgICAgICAgICBzdGVwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAuLi5BTExPV0FOQ0VfQVBQUk9WQUxfUkVRKHNvdXJjZS5jaGFpbi5pZCksXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklEOiBzb3VyY2UuY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluTmFtZTogc291cmNlLmNoYWluLm5hbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAuLi5BTExPV0FOQ0VfQVBQUk9WQUxfTUlORUQoc291cmNlLmNoYWluLmlkKSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSUQ6IHNvdXJjZS5jaGFpbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5OYW1lOiBzb3VyY2UuY2hhaW4ubmFtZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcHMucHVzaChBTExPV0FOQ0VfQ09NUExFVEUpO1xuICAgIH1cbiAgICBzdGVwcy5wdXNoKC4uLklOVEVOVF9JTklUX1NURVBTKTtcbiAgICBjb25zdCBzb3VyY2VzID0gaW50ZW50LnNvdXJjZXMuZmlsdGVyKChzKSA9PiBzLmNoYWluSUQgIT09IGludGVudC5kZXN0aW5hdGlvbi5jaGFpbklEKTtcbiAgICBsZXQgY29sbGVjdGlvbnMgPSAwLCBkZXBvc2l0cyA9IDA7XG4gICAgZm9yIChjb25zdCBbaSwgc10gb2Ygc291cmNlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgaXNOYXRpdmUgPSBpc05hdGl2ZUFkZHJlc3MkMShzLnVuaXZlcnNlLCBzLnRva2VuQ29udHJhY3QpO1xuICAgICAgICBpZiAoaXNOYXRpdmUpIHtcbiAgICAgICAgICAgIGRlcG9zaXRzKys7XG4gICAgICAgICAgICBjb25zdCBjaGFpbiA9IGNoYWluTGlzdC5nZXRDaGFpbkJ5SUQocy5jaGFpbklEKTtcbiAgICAgICAgICAgIGlmICghY2hhaW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY2hhaW4gSUQgJHtzLmNoYWluSUR9IHdoaWxlIGJ1aWxkaW5nIHN0ZXBzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGVwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAuLi5JTlRFTlRfREVQT1NJVF9SRVEoaSArIDEpLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBzLmFtb3VudC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklEOiBjaGFpbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5OYW1lOiBjaGFpbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IGNoYWluLm5hdGl2ZUN1cnJlbmN5LnN5bWJvbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9ucysrO1xuICAgICAgICAgICAgc3RlcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgLi4uSU5URU5UX0NPTExFQ1RJT04oaSArIDEpLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybWVkOiBpICsgMSxcbiAgICAgICAgICAgICAgICAgICAgdG90YWw6IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbnMgPiAwKSB7XG4gICAgICAgIHN0ZXBzLnB1c2goSU5URU5UX0NPTExFQ1RJT05fQ09NUExFVEUpO1xuICAgIH1cbiAgICBpZiAoZGVwb3NpdHMgPiAwKSB7XG4gICAgICAgIHN0ZXBzLnB1c2goSU5URU5UX0RFUE9TSVRTX0NPTkZJUk1FRCk7XG4gICAgfVxuICAgIHN0ZXBzLnB1c2goLi4uSU5URU5UX0ZJTklTSF9TVEVQUyk7XG4gICAgcmV0dXJuIHN0ZXBzO1xufTtcblxuY29uc3QgRVJDMjBUcmFuc2ZlckFCSSA9IHtcbiAgICBjb25zdGFudDogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdfdG8nLFxuICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnX3ZhbHVlJyxcbiAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIG5hbWU6ICd0cmFuc2ZlcicsXG4gICAgb3V0cHV0czogW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG59O1xuY29uc3QgRVJDMjBBbGxvd2FuY2VBQkkgPSB7XG4gICAgY29uc3RhbnQ6IHRydWUsXG4gICAgaW5wdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdfb3duZXInLFxuICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnX3NwZW5kZXInLFxuICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgbmFtZTogJ2FsbG93YW5jZScsXG4gICAgb3V0cHV0czogW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHBheWFibGU6IGZhbHNlLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG59O1xuY29uc3QgQUJJID0gW1xuICAgIHtcbiAgICAgICAgY29uc3RhbnQ6IHRydWUsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgcGF5YWJsZTogZmFsc2UsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBjb25zdGFudDogZmFsc2UsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfc3BlbmRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3ZhbHVlJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnYXBwcm92ZScsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGNvbnN0YW50OiB0cnVlLFxuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiAndG90YWxTdXBwbHknLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgcGF5YWJsZTogZmFsc2UsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBjb25zdGFudDogZmFsc2UsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfZnJvbScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3RvJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfdmFsdWUnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICd0cmFuc2ZlckZyb20nLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgcGF5YWJsZTogZmFsc2UsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBjb25zdGFudDogdHJ1ZSxcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogJ2RlY2ltYWxzJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50OCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGNvbnN0YW50OiB0cnVlLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX293bmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiAnYmFsYW5jZU9mJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBwYXlhYmxlOiBmYWxzZSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGNvbnN0YW50OiB0cnVlLFxuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiAnc3ltYm9sJyxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgcGF5YWJsZTogZmFsc2UsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAgRVJDMjBUcmFuc2ZlckFCSSxcbiAgICBFUkMyMEFsbG93YW5jZUFCSSxcbiAgICB7XG4gICAgICAgIHBheWFibGU6IHRydWUsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3BheWFibGUnLFxuICAgICAgICB0eXBlOiAnZmFsbGJhY2snLFxuICAgIH0sXG4gICAge1xuICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdvd25lcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ0FwcHJvdmFsJyxcbiAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZnJvbScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0bycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdUcmFuc2ZlcicsXG4gICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgfSxcbl07XG5jb25zdCBFUkMyMFBlcm1pdEFCSSA9IFtcbiAgICB7XG4gICAgICAgIGNvbW1lbnQ6ICdGcm9tIHRoZSBFSVAtMjYxMiBzcGVjLicsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdvd25lcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3BlbmRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2RlYWRsaW5lJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQ4JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQ4JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMzMicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3InLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlczMyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMzMicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3MnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlczMyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdwZXJtaXQnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGNvbW1lbnQ6ICdBdmFpbGFibGUgb24gYnJpZGdlZCB0b2tlbnMgb24gUG9seWdvbi4nLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndXNlckFkZHJlc3MnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdmdW5jdGlvblNpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMzMicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NpZ1InLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlczMyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMzMicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NpZ1MnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlczMyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDgnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzaWdWJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAndWludDgnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ2V4ZWN1dGVNZXRhVHJhbnNhY3Rpb24nLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdwYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuXTtcbmNvbnN0IEVSQzIwUGVybWl0RUlQNzEyVHlwZSA9IHtcbiAgICBFSVA3MTJEb21haW46IFtcbiAgICAgICAgeyBuYW1lOiAnbmFtZScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsgbmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICdjaGFpbklkJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgIHsgbmFtZTogJ3ZlcmlmeWluZ0NvbnRyYWN0JywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgXSxcbiAgICBQZXJtaXQ6IFtcbiAgICAgICAgeyBuYW1lOiAnb3duZXInLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICAgICAgeyBuYW1lOiAnc3BlbmRlcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgICAgICB7IG5hbWU6ICd2YWx1ZScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgICAgICB7IG5hbWU6ICdub25jZScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgICAgICB7IG5hbWU6ICdkZWFkbGluZScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIF0sXG59O1xuY29uc3QgRVJDMjBQZXJtaXRFSVAyNjEyUG9seWdvblR5cGUgPSB7XG4gICAgRUlQNzEyRG9tYWluOiBbXG4gICAgICAgIHsgbmFtZTogJ25hbWUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgeyBuYW1lOiAndmVyaWZ5aW5nQ29udHJhY3QnLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICAgICAgeyBuYW1lOiAnc2FsdCcsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgIF0sXG4gICAgTWV0YVRyYW5zYWN0aW9uOiBbXG4gICAgICAgIHsgbmFtZTogJ25vbmNlJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgIHsgbmFtZTogJ2Zyb20nLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICAgICAgeyBuYW1lOiAnZnVuY3Rpb25TaWduYXR1cmUnLCB0eXBlOiAnYnl0ZXMnIH0sXG4gICAgXSxcbn07XG5cbnZhciBnYXNPcmFjbGVBQkkgPSBbXG4gICAgeyBpbnB1dHM6IFtdLCBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLCB0eXBlOiBcImNvbnN0cnVjdG9yXCIgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwiREVDSU1BTFNcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJiYXNlRmVlXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwiZGVjaW1hbHNcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJwdXJlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJnYXNQcmljZVwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJieXRlc1wiLCBuYW1lOiBcIl9kYXRhXCIsIHR5cGU6IFwiYnl0ZXNcIiB9XSxcbiAgICAgICAgbmFtZTogXCJnZXRMMUZlZVwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJieXRlc1wiLCBuYW1lOiBcIl9kYXRhXCIsIHR5cGU6IFwiYnl0ZXNcIiB9XSxcbiAgICAgICAgbmFtZTogXCJnZXRMMUdhc1VzZWRcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJsMUJhc2VGZWVcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJvdmVyaGVhZFwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcInNjYWxhclwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcInZlcnNpb25cIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInN0cmluZ1wiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbl07XG5cbmNvbnN0IEZpbGxFdmVudCA9IHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAgICB7XG4gICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgICAgIG5hbWU6IFwicmVxdWVzdEhhc2hcIixcbiAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICBuYW1lOiBcImZyb21cIixcbiAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICBuYW1lOiBcInNvbHZlclwiLFxuICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBuYW1lOiBcIkZpbGxcIixcbiAgICB0eXBlOiBcImV2ZW50XCIsXG59O1xuXG5jb25zdCBFcnJvclVzZXJEZW5pZWRJbnRlbnQkMSA9IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IobmV3IEVycm9yKFwiVXNlciBkZW5pZWQgaW50ZW50LlwiKSk7XG5jb25zdCBFcnJvclVzZXJEZW5pZWRBbGxvd2FuY2UgPSBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKG5ldyBFcnJvcihcIlVzZXIgZGVuaWVkIGFsbG93YW5jZS5cIikpO1xuY29uc3QgRXJyb3JJbnN1ZmZpY2llbnRCYWxhbmNlJDEgPSBuZXcgSW50ZXJuYWxScGNFcnJvcihuZXcgRXJyb3IoXCJJbnN1ZmZpY2llbnQgYmFsYW5jZS5cIikpO1xubmV3IEludGVybmFsUnBjRXJyb3IobmV3IEVycm9yKFwiRXJyb3Igd2hpbGUgYnVpbGRpbmcgaW50ZW50LlwiKSk7XG5jb25zdCBFcnJvckxpcXVpZGl0eVRpbWVvdXQgPSBuZXcgSW50ZXJuYWxScGNFcnJvcihuZXcgRXJyb3IoXCJUaW1lZCBvdXQgd2FpdGluZyBmb3IgbGlxdWlkaXR5LlwiKSk7XG5cbmNvbnN0IGxvZ2dlciRsID0gZ2V0TG9nZ2VyKCk7XG5jb25zdCBpc0VWTVR4ID0gKHR4KSA9PiB7XG4gICAgbG9nZ2VyJGwuZGVidWcoJ2lzRVZNVHgnLCB0eCk7XG4gICAgaWYgKHR5cGVvZiB0eCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXR4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCEoJ3RvJyBpbiB0eCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoISgnZGF0YScgaW4gdHggfHwgJ3ZhbHVlJyBpbiB0eCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBnZXRBbGxvd2FuY2UgPSAoY2hhaW4sIGFkZHJlc3MsIHRva2VuQ29udHJhY3QsIGNoYWluTGlzdCkgPT4ge1xuICAgIGxvZ2dlciRsLmRlYnVnKCdnZXRBbGxvd2FuY2UnLCB7XG4gICAgICAgIHRva2VuQ29udHJhY3QsXG4gICAgICAgIFpFUk9fQUREUkVTUyxcbiAgICB9KTtcbiAgICBpZiAoZXF1YWxGb2xkKFpFUk9fQUREUkVTUywgdG9rZW5Db250cmFjdCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYXhVaW50MjU2KTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50V2l0aEZhbGxiYWNrKGNoYWluKTtcbiAgICByZXR1cm4gcHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICAgIGFiaTogQUJJLFxuICAgICAgICBhZGRyZXNzOiB0b2tlbkNvbnRyYWN0LFxuICAgICAgICBhcmdzOiBbYWRkcmVzcywgY2hhaW5MaXN0LmdldFZhdWx0Q29udHJhY3RBZGRyZXNzKGNoYWluLmlkKV0sXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogJ2FsbG93YW5jZScsXG4gICAgfSk7XG59O1xuY29uc3QgZ2V0QWxsb3dhbmNlcyA9IGFzeW5jIChpbnB1dCwgYWRkcmVzcywgY2hhaW5MaXN0KSA9PiB7XG4gICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgaW5wdXQpIHtcbiAgICAgICAgaWYgKGkuY2hhaW5JRCA9PT0gQ0hBSU5fSURTLmZ1ZWwubWFpbm5ldCkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChQcm9taXNlLnJlc29sdmUoMG4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluID0gY2hhaW5MaXN0LmdldENoYWluQnlJRChpLmNoYWluSUQpO1xuICAgICAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hhaW4gbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGdldEFsbG93YW5jZShjaGFpbiwgYWRkcmVzcywgaS50b2tlbkNvbnRyYWN0LCBjaGFpbkxpc3QpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgZm9yIChjb25zdCBpIGluIHJlc3VsdCkge1xuICAgICAgICB2YWx1ZXNbaW5wdXRbaV0uY2hhaW5JRF0gPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuY29uc3Qgd2FpdEZvckludGVudEZ1bGZpbG1lbnQgPSBhc3luYyAocHVibGljQ2xpZW50LCB2YXVsdENvbnRyYWN0QWRkciwgcmVxdWVzdEhhc2gsIGFjKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVud2F0Y2ggPSBwdWJsaWNDbGllbnQud2F0Y2hDb250cmFjdEV2ZW50KHtcbiAgICAgICAgICAgIGFiaTogW0ZpbGxFdmVudF0sXG4gICAgICAgICAgICBhZGRyZXNzOiB2YXVsdENvbnRyYWN0QWRkcixcbiAgICAgICAgICAgIGFyZ3M6IHsgcmVxdWVzdEhhc2ggfSxcbiAgICAgICAgICAgIGV2ZW50TmFtZTogJ0ZpbGwnLFxuICAgICAgICAgICAgb25Mb2dzOiAobG9ncykgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRsLmRlYnVnKCd3YWl0Rm9ySW50ZW50RnVsZmlsbWVudCcsIHsgbG9ncyB9KTtcbiAgICAgICAgICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCdvaycpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvbGw6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgYWMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgdW53YXRjaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoJ29rIGZyb20gb3V0c2lkZScpO1xuICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfSk7XG59O1xuY29uc3QgcmVxdWVzdFRpbWVvdXQgPSAodGltZW91dCwgYWMpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoRXJyb3JMaXF1aWRpdHlUaW1lb3V0KTtcbiAgICAgICAgfSwgbWludXRlc1RvTXModGltZW91dCkpO1xuICAgICAgICBhYy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHQpO1xuICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfSk7XG59O1xuY29uc3QgZ2V0VG9rZW5UeEZ1bmN0aW9uID0gKGRhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGFyZ3MsIGZ1bmN0aW9uTmFtZSB9ID0gZGVjb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaTogQUJJLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGFyZ3MsIGZ1bmN0aW9uTmFtZSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIkbC5kZWJ1ZygnZ2V0VG9rZW5UeEZ1bmN0aW9uJywgZSk7XG4gICAgICAgIHJldHVybiB7IGFyZ3M6IFtdLCBmdW5jdGlvbk5hbWU6ICd1bmtub3duJyB9O1xuICAgIH1cbn07XG5jb25zdCBzZXRBbGxvd2FuY2VzID0gYXN5bmMgKHRva2VuQ29udHJhY3RBZGRyZXNzZXMsIGNsaWVudCwgbmV0d29ya0NvbmZpZywgY2hhaW5MaXN0LCBjaGFpbiwgYW1vdW50KSA9PiB7XG4gICAgY29uc3QgdmF1bHRBZGRyID0gY2hhaW5MaXN0LmdldFZhdWx0Q29udHJhY3RBZGRyZXNzKGNoYWluLmlkKTtcbiAgICBjb25zdCBwID0gW107XG4gICAgY29uc3QgYWRkcmVzcyA9IChhd2FpdCBjbGllbnQuZ2V0QWRkcmVzc2VzKCkpWzBdO1xuICAgIGNvbnN0IGNoYWluSWQgPSBuZXcgT21uaXZlcnNhbENoYWluSUQoVW5pdmVyc2UuRVRIRVJFVU0sIGNoYWluLmlkKTtcbiAgICBjb25zdCBjaGFpbkRhdHVtID0gQ2hhaW5kYXRhTWFwLmdldChjaGFpbklkKTtcbiAgICBpZiAoIWNoYWluRGF0dW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFpbiBkYXRhIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBhY2NvdW50ID0ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICB0eXBlOiAnanNvbi1ycGMnLFxuICAgIH07XG4gICAgY29uc3QgcHVibGljQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50V2l0aEZhbGxiYWNrKGNoYWluKTtcbiAgICBjb25zdCBzcG9uc29yZWRBcHByb3ZhbFBhcmFtcyA9IHtcbiAgICAgICAgYWRkcmVzczogaGV4VG9CeXRlcyhwYWQoYWRkcmVzcywge1xuICAgICAgICAgICAgZGlyOiAnbGVmdCcsXG4gICAgICAgICAgICBzaXplOiAzMixcbiAgICAgICAgfSkpLFxuICAgICAgICBjaGFpbl9pZDogY2hhaW5EYXR1bS5DaGFpbklEMzIsXG4gICAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgICB1bml2ZXJzZTogY2hhaW5EYXR1bS5Vbml2ZXJzZSxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgYWRkciBvZiB0b2tlbkNvbnRyYWN0QWRkcmVzc2VzKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbmN5ID0gY2hhaW5EYXR1bS5DdXJyZW5jeU1hcC5nZXQoY29udmVydFRvMzJCeXRlcyQxKGFkZHIpKTtcbiAgICAgICAgaWYgKCFjdXJyZW5jeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW5jeSBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVuY3kucGVybWl0VmFyaWFudCA9PT0gUGVybWl0VmFyaWFudC5VbnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IGNsaWVudC53cml0ZUNvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBhYmk6IEFCSSxcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHIsXG4gICAgICAgICAgICAgICAgYXJnczogW3ZhdWx0QWRkciwgYW1vdW50XSxcbiAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdhcHByb3ZlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcC5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHVibGljQ2xpZW50LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoe1xuICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zOiAyLFxuICAgICAgICAgICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAncmV2ZXJ0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0QWxsb3dhbmNlIGZhaWxlZCB3aXRoIHR4IHJldmVydCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkID0gcGFyc2VTaWduYXR1cmUoYXdhaXQgc2lnblBlcm1pdEZvckFkZHJlc3NBbmRWYWx1ZShjdXJyZW5jeSwgY2xpZW50LCBwdWJsaWNDbGllbnQsIGFjY291bnQsIHZhdWx0QWRkciwgYW1vdW50KSk7XG4gICAgICAgICAgICBzcG9uc29yZWRBcHByb3ZhbFBhcmFtcy5vcGVyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHNpZ19yOiBoZXhUb0J5dGVzKHNpZ25lZC5yKSxcbiAgICAgICAgICAgICAgICBzaWdfczogaGV4VG9CeXRlcyhzaWduZWQucyksXG4gICAgICAgICAgICAgICAgc2lnX3Y6IHNpZ25lZC55UGFyaXR5IDwgMjcgPyBzaWduZWQueVBhcml0eSArIDI3IDogc2lnbmVkLnlQYXJpdHksXG4gICAgICAgICAgICAgICAgdG9rZW5fYWRkcmVzczogY3VycmVuY3kudG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjb252ZXJ0VG8zMkJ5dGVzJDEoYW1vdW50KSxcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBjdXJyZW5jeS5wZXJtaXRWYXJpYW50ID09PSBQZXJtaXRWYXJpYW50LlBvbHlnb25FTVQgPyAyIDogMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwLmxlbmd0aCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwKTtcbiAgICB9XG4gICAgaWYgKHNwb25zb3JlZEFwcHJvdmFsUGFyYW1zLm9wZXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGF3YWl0IHZzY0NyZWF0ZVNwb25zb3JlZEFwcHJvdmFscyhuZXR3b3JrQ29uZmlnLlZTQ19ET01BSU4sIFtzcG9uc29yZWRBcHByb3ZhbFBhcmFtc10pO1xuICAgIH1cbiAgICByZXR1cm47XG59O1xuY29uc3QgREVGQVVMVF9HQVNfT1JBQ0xFX0FERFJFU1MgPSAnMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBGJztcbmNvbnN0IEwxX0dBU19PUkFDTEVTID0ge1xuICAgIDEwOiBERUZBVUxUX0dBU19PUkFDTEVfQUREUkVTUyxcbiAgICAxMTE1NTQyMDogREVGQVVMVF9HQVNfT1JBQ0xFX0FERFJFU1MsXG4gICAgNTM0MzUyOiAnMHg1MzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyJyxcbiAgICA4NDUzOiBERUZBVUxUX0dBU19PUkFDTEVfQUREUkVTUyxcbiAgICA4NDUzMjogREVGQVVMVF9HQVNfT1JBQ0xFX0FERFJFU1MsXG59O1xuY29uc3QgY2hhaW5zV2l0aEdhc09yYWNsZXMgPSBPYmplY3Qua2V5cyhMMV9HQVNfT1JBQ0xFUykubWFwKE51bWJlcik7XG5jb25zdCBnZXRMMUZlZSA9IGFzeW5jIChjaGFpbiwgaW5wdXQgPSAnMHgnKSA9PiB7XG4gICAgbGV0IGZlZSA9IDBuO1xuICAgIGlmIChjaGFpbnNXaXRoR2FzT3JhY2xlcy5pbmNsdWRlcyhjaGFpbi5pZCkpIHtcbiAgICAgICAgZmVlID0gYXdhaXQgZmV0Y2hMMUZlZShjaGFpbiwgaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gZmVlO1xufTtcbmNvbnN0IGZldGNoTDFGZWUgPSAoY2hhaW4sIGlucHV0KSA9PiB7XG4gICAgY29uc3QgcGMgPSBjcmVhdGVQdWJsaWNDbGllbnRXaXRoRmFsbGJhY2soY2hhaW4pO1xuICAgIHJldHVybiBwYy5yZWFkQ29udHJhY3Qoe1xuICAgICAgICBhYmk6IGdhc09yYWNsZUFCSSxcbiAgICAgICAgYWRkcmVzczogTDFfR0FTX09SQUNMRVNbY2hhaW4uaWRdLFxuICAgICAgICBhcmdzOiBbaW5wdXRdLFxuICAgICAgICBmdW5jdGlvbk5hbWU6ICdnZXRMMUZlZScsXG4gICAgfSk7XG59O1xuY29uc3Qgd2FpdEZvclR4UmVjZWlwdCA9IGFzeW5jIChoYXNoLCBwdWJsaWNDbGllbnQsIGNvbmZpcm1hdGlvbnMgPSAxKSA9PiB7XG4gICAgY29uc3QgciA9IGF3YWl0IHB1YmxpY0NsaWVudC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHtcbiAgICAgICAgY29uZmlybWF0aW9ucyxcbiAgICAgICAgaGFzaCxcbiAgICB9KTtcbiAgICBpZiAoci5zdGF0dXMgPT09ICdyZXZlcnRlZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiByZXZlcnRlZDogJHtoYXNofWApO1xuICAgIH1cbn07XG5jb25zdCBzd2l0Y2hDaGFpbiA9IGFzeW5jIChjbGllbnQsIGNoYWluKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2xpZW50LnN3aXRjaENoYWluKHsgaWQ6IGNoYWluLmlkIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFN3aXRjaENoYWluRXJyb3IgJiYgZS5jb2RlID09PSBTd2l0Y2hDaGFpbkVycm9yLmNvZGUpIHtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5hZGRDaGFpbih7XG4gICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5zd2l0Y2hDaGFpbih7IGlkOiBjaGFpbi5pZCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn07XG5jb25zdCBFSVA3MTJEb21haW4gPSBbXG4gICAgeyBuYW1lOiAnbmFtZScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgeyBuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgeyBuYW1lOiAnY2hhaW5JZCcsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIHsgbmFtZTogJ3ZlcmlmeWluZ0NvbnRyYWN0JywgdHlwZTogJ2FkZHJlc3MnIH0sXG5dO1xuY29uc3QgUG9seWdvbkRvbWFpbiA9IFtcbiAgICB7IG5hbWU6ICduYW1lJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICB7IG5hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICB7IG5hbWU6ICd2ZXJpZnlpbmdDb250cmFjdCcsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgIHsgbmFtZTogJ3NhbHQnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbl07XG5hc3luYyBmdW5jdGlvbiBzaWduUGVybWl0Rm9yQWRkcmVzc0FuZFZhbHVlKGN1ciwgY2xpZW50LCBwdWJsaWNDbGllbnQsIGFjY291bnQsIHNwZW5kZXIsIHZhbHVlLCBkZWFkbGluZSkge1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gZ2V0Q29udHJhY3Qoe1xuICAgICAgICBhYmk6IEVSQzIwQUJJLFxuICAgICAgICBhZGRyZXNzOiBieXRlc1RvSGV4KGN1ci50b2tlbkFkZHJlc3Muc3ViYXJyYXkoMTIpKSxcbiAgICAgICAgY2xpZW50OiB7IHB1YmxpYzogcHVibGljQ2xpZW50IH0sXG4gICAgfSk7XG4gICAgY29uc3Qgd2FsbGV0QWRkcmVzcyA9IGFjY291bnQuYWRkcmVzcztcbiAgICBkZWFkbGluZSA9IGRlYWRsaW5lID8/IDJuICoqIDI1Nm4gLSAxbjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IHJlcXVlc3RzVG9CZU1hZGUgPSBbXG4gICAgICAgICgoKSA9PiB7XG4gICAgICAgICAgICAvLyBIYWNrIGZvciBzb3Bob24gRVRIXG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3QucmVhZC5uYW1lKCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpLFxuICAgICAgICBjbGllbnQucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9LCB7IGRlZHVwZTogdHJ1ZSB9KSxcbiAgICBdO1xuICAgIHN3aXRjaCAoY3VyLnBlcm1pdFZhcmlhbnQpIHtcbiAgICAgICAgY2FzZSBQZXJtaXRWYXJpYW50LlVuc3VwcG9ydGVkOlxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGVybWl0Q3JlYXRpb25FcnJvcignUGVybWl0cyBhcmUgdW5zdXBwb3J0ZWQgb24gdGhpcyBjdXJyZW5jeScpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUGVybWl0VmFyaWFudC5EQUk6XG4gICAgICAgIGNhc2UgUGVybWl0VmFyaWFudC5FSVAyNjEyQ2Fub25pY2FsOlxuICAgICAgICBjYXNlIFBlcm1pdFZhcmlhbnQuUG9seWdvbjI2MTI6IHtcbiAgICAgICAgICAgIHJlcXVlc3RzVG9CZU1hZGVbMl0gPSBjb250cmFjdC5yZWFkLm5vbmNlcyhbd2FsbGV0QWRkcmVzc10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBQZXJtaXRWYXJpYW50LlBvbHlnb25FTVQ6IHtcbiAgICAgICAgICAgIHJlcXVlc3RzVG9CZU1hZGVbMl0gPSBjb250cmFjdC5yZWFkLmdldE5vbmNlKFt3YWxsZXRBZGRyZXNzXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW25hbWUsIGNoYWluSUQsIG5vbmNlXSA9IGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3RzVG9CZU1hZGUpO1xuICAgIHN3aXRjaCAoY3VyLnBlcm1pdFZhcmlhbnQpIHtcbiAgICAgICAgY2FzZSBQZXJtaXRWYXJpYW50LkRBSToge1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zaWduVHlwZWREYXRhKHtcbiAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgIGRvbWFpbjoge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBoZXhUb0JpZ0ludChjaGFpbklEKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGNvbnRyYWN0LmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IGN1ci5wZXJtaXRDb250cmFjdFZlcnNpb24udG9TdHJpbmcoMTApLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleHBpcnk6IGRlYWRsaW5lLFxuICAgICAgICAgICAgICAgICAgICBob2xkZXI6IHdhbGxldEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgICAgICBzcGVuZGVyOiBzcGVuZGVyLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJpbWFyeVR5cGU6ICdQZXJtaXQnLFxuICAgICAgICAgICAgICAgIHR5cGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIEVJUDcxMkRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgUGVybWl0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdob2xkZXInLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3NwZW5kZXInLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25vbmNlJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdleHBpcnknLCB0eXBlOiAndWludDI1NicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2FsbG93ZWQnLCB0eXBlOiAnYm9vbCcgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBQZXJtaXRWYXJpYW50LkVJUDI2MTJDYW5vbmljYWw6IHtcbiAgICAgICAgICAgIHJldHVybiBjbGllbnQuc2lnblR5cGVkRGF0YSh7XG4gICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICBkb21haW46IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogaGV4VG9CaWdJbnQoY2hhaW5JRCksXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBjb250cmFjdC5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBjdXIucGVybWl0Q29udHJhY3RWZXJzaW9uLnRvU3RyaW5nKDEwKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVhZGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgICAgICBvd25lcjogd2FsbGV0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgc3BlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5VHlwZTogJ1Blcm1pdCcsXG4gICAgICAgICAgICAgICAgdHlwZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgRUlQNzEyRG9tYWluLFxuICAgICAgICAgICAgICAgICAgICBQZXJtaXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ293bmVyJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdzcGVuZGVyJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd2YWx1ZScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbm9uY2UnLCB0eXBlOiAndWludDI1NicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2RlYWRsaW5lJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUGVybWl0VmFyaWFudC5Qb2x5Z29uMjYxMjoge1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zaWduVHlwZWREYXRhKHtcbiAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgIGRvbWFpbjoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBzYWx0OiBwYWQoY2hhaW5JRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiAzMixcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBjb250cmFjdC5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBjdXIucGVybWl0Q29udHJhY3RWZXJzaW9uLnRvU3RyaW5nKDEwKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJ5OiBkZWFkbGluZSxcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyOiB3YWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICAgICAgc3BlbmRlcjogc3BlbmRlcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByaW1hcnlUeXBlOiAnUGVybWl0JyxcbiAgICAgICAgICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgICAgICAgICBFSVA3MTJEb21haW46IFBvbHlnb25Eb21haW4sXG4gICAgICAgICAgICAgICAgICAgIFBlcm1pdDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnaG9sZGVyJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdzcGVuZGVyJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdub25jZScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZXhwaXJ5JywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdhbGxvd2VkJywgdHlwZTogJ2Jvb2wnIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUGVybWl0VmFyaWFudC5Qb2x5Z29uRU1UOiB7XG4gICAgICAgICAgICBjb25zdCBmdW5jU2lnID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgICAgICBhYmk6IEFCSSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbc3BlbmRlciwgdmFsdWVdLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ2FwcHJvdmUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNpZ25UeXBlZERhdGEoe1xuICAgICAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICAgICAgZG9tYWluOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNhbHQ6IHBhZChjaGFpbklELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXI6ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDMyLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGNvbnRyYWN0LmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IGN1ci5wZXJtaXRDb250cmFjdFZlcnNpb24udG9TdHJpbmcoMTApLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiB3YWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblNpZ25hdHVyZTogZnVuY1NpZyxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5VHlwZTogJ01ldGFUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgRUlQNzEyRG9tYWluOiBQb2x5Z29uRG9tYWluLFxuICAgICAgICAgICAgICAgICAgICBNZXRhVHJhbnNhY3Rpb246IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25vbmNlJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdmcm9tJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdmdW5jdGlvblNpZ25hdHVyZScsIHR5cGU6ICdieXRlcycgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBjcmVhdGVQdWJsaWNDbGllbnRXaXRoRmFsbGJhY2sgPSAoY2hhaW4pID0+IHtcbiAgICBpZiAoY2hhaW4ucnBjVXJscy5kZWZhdWx0Lmh0dHAubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICAgICAgdHJhbnNwb3J0OiBodHRwKGNoYWluLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICB0cmFuc3BvcnQ6IGZhbGxiYWNrKGNoYWluLnJwY1VybHMuZGVmYXVsdC5odHRwLm1hcCgocykgPT4gaHR0cChzKSkpLFxuICAgIH0pO1xufTtcblxuY29uc3QgbG9nZ2VyJGsgPSBnZXRMb2dnZXIoKTtcbmNvbnN0IGdldENvc21vc1VSTCA9IChjb3Ntb3NVUkwsIGtpbmQpID0+IHtcbiAgICBjb25zdCB1ID0gbmV3IFVSTChjb3Ntb3NVUkwpO1xuICAgIGlmIChraW5kID09PSAncnBjJykge1xuICAgICAgICAvLyBGSVhNRTogZG9uJ3QgaGFyZGNvZGUgcG9ydCBoZXJlXG4gICAgICAgIHUucG9ydCA9ICcyNjY1MCc7XG4gICAgfVxuICAgIHJldHVybiB1LnRvU3RyaW5nKCk7XG59O1xuY29uc3QgY29zbW9zRmVlR3JhbnQgPSBhc3luYyAoY29zbW9zVVJMLCB2c2NEb21haW4sIGFkZHJlc3MpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBheGlvcy5nZXQoYC9jb3Ntb3MvYXV0aC92MWJldGExL2FjY291bnRzLyR7YWRkcmVzc31gLCB7XG4gICAgICAgICAgICBiYXNlVVJMOiBnZXRDb3Ntb3NVUkwoY29zbW9zVVJMLCAncmVzdCcpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyJGsuZXJyb3IoJ1JlcXVlc3RpbmcgYSBmZWUgZ3JhbnQnLCBlKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB2c2NDcmVhdGVGZWVHcmFudCh2c2NEb21haW4sIGFkZHJlc3MpO1xuICAgICAgICBsb2dnZXIkay5kZWJ1ZygnRmVlIGdyYW50IHJlc3BvbnNlJywgcmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59O1xuY29uc3QgY29zbW9zQ3JlYXRlUkZGJDEgPSBhc3luYyAoeyBhZGRyZXNzLCBjb3Ntb3NVUkwsIG1zZywgd2FsbGV0LCB9KSA9PiB7XG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgY3JlYXRlQ29zbW9zQ2xpZW50KHdhbGxldCwgZ2V0Q29zbW9zVVJMKGNvc21vc1VSTCwgJ3JwYycpLCB7XG4gICAgICAgIGJyb2FkY2FzdFBvbGxJbnRlcnZhbE1zOiAyNTAsXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LnNpZ25BbmRCcm9hZGNhc3QoYWRkcmVzcywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGVVcmw6ICcveGFyY2hhaW4uY2hhaW5hYnN0cmFjdGlvbi5Nc2dDcmVhdGVSZXF1ZXN0Rm9yRnVuZHMnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtc2csXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLCB7XG4gICAgICAgICAgICBhbW91bnQ6IFtdLFxuICAgICAgICAgICAgZ2FzOiAxMDAwMDBuLnRvU3RyaW5nKDEwKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0RlbGl2ZXJUeEZhaWx1cmUocmVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBSRkYg4oCTIGNvZGU9JHtyZXMuY29kZX0gbG9nPSR7cmVzLnJhd0xvZyA/PyAnbi9hJ31gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNvZGVkID0gTXNnQ3JlYXRlUmVxdWVzdEZvckZ1bmRzUmVzcG9uc2UuZGVjb2RlKHJlcy5tc2dSZXNwb25zZXNbMF0udmFsdWUpO1xuICAgICAgICByZXR1cm4gZGVjb2RlZC5pZDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGNsaWVudC5kaXNjb25uZWN0KCk7XG4gICAgfVxufTtcbmNvbnN0IGNvc21vc1JlZnVuZEludGVudCA9IGFzeW5jIChjb3Ntb3NVUkwsIGludGVudElELCB3YWxsZXQpID0+IHtcbiAgICBjb25zdCBhZGRyZXNzID0gKGF3YWl0IHdhbGxldC5nZXRBY2NvdW50cygpKVswXS5hZGRyZXNzO1xuICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IGNyZWF0ZUNvc21vc0NsaWVudCh3YWxsZXQsIGdldENvc21vc1VSTChjb3Ntb3NVUkwsICdycGMnKSwge1xuICAgICAgICBicm9hZGNhc3RQb2xsSW50ZXJ2YWxNczogMjUwLFxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBjbGllbnQuc2lnbkFuZEJyb2FkY2FzdChhZGRyZXNzLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZVVybDogJy94YXJjaGFpbi5jaGFpbmFic3RyYWN0aW9uLk1zZ1JlZnVuZFJlcScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IE1zZ1JlZnVuZFJlcS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBjcmVhdG9yOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICByZmZJRDogaW50ZW50SUQsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLCB7XG4gICAgICAgICAgICBhbW91bnQ6IFtdLFxuICAgICAgICAgICAgZ2FzOiAxMDAwMDBuLnRvU3RyaW5nKDEwKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ2dlciRrLmRlYnVnKCdSZWZ1bmQgcmVzcG9uc2UnLCB7IHJlc3AgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNEZWxpdmVyVHhTdWNjZXNzKHJlc3ApKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb2RlZCA9IE1zZ1JlZnVuZFJlcVJlc3BvbnNlLmRlY29kZShyZXNwLm1zZ1Jlc3BvbnNlc1swXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJGsuZGVidWcoJ1JlZnVuZCBzdWNjZXNzJywgeyBkZWNvZGVkLCByZXNwIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzcC5jb2RlID09PSAxOCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwLnJhd0xvZz8uaW5jbHVkZXMoJ1JGRiBhbHJlYWR5IHJlZnVuZGVkJykgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVzcC5yYXdMb2c/LmluY2x1ZGVzKCdSRkYgYWxyZWFkeSBmaWxsZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSRkYgaXMgbm90IGV4cGlyZWQgeWV0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlciRrLmVycm9yKCdSZWZ1bmQgZmFpbGVkJywgZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjbGllbnQuZGlzY29ubmVjdCgpO1xuICAgIH1cbn07XG5jb25zdCBjb3Ntb3NDcmVhdGVEb3VibGVDaGVja1R4JDEgPSBhc3luYyAoeyBhZGRyZXNzLCBjb3Ntb3NVUkwsIG1zZywgd2FsbGV0LCB9KSA9PiB7XG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgY3JlYXRlQ29zbW9zQ2xpZW50KHdhbGxldCwgZ2V0Q29zbW9zVVJMKGNvc21vc1VSTCwgJ3JwYycpLCB7XG4gICAgICAgIGJyb2FkY2FzdFBvbGxJbnRlcnZhbE1zOiAyNTAsXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgICAgbG9nZ2VyJGsuZGVidWcoJ2Nvc21vc0NyZWF0ZURvdWJsZUNoZWNrVHgnLCB7IGRvdWJsZUNoZWNrTXNnOiBtc2cgfSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5zaWduQW5kQnJvYWRjYXN0KGFkZHJlc3MsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlVXJsOiAnL3hhcmNoYWluLmNoYWluYWJzdHJhY3Rpb24uTXNnRG91YmxlQ2hlY2tUeCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1zZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sIHtcbiAgICAgICAgICAgIGFtb3VudDogW10sXG4gICAgICAgICAgICBnYXM6IDEwMDAwMG4udG9TdHJpbmcoMTApLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzRGVsaXZlclR4RmFpbHVyZShyZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNyZWF0aW5nIE1zZ0RvdWJsZUNoZWNrVHgnKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIkay5kZWJ1ZygnZG91YmxlIGNoZWNrIHJlc3BvbnNlJywgeyBkb3VibGVDaGVja1R4OiByZXMgfSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjbGllbnQuZGlzY29ubmVjdCgpO1xuICAgIH1cbn07XG5jb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuY29uc3QgY29zbW9zRmlsbENoZWNrID0gYXN5bmMgKGludGVudElELCBncnBjVVJMLCBjb3Ntb3NVUkwsIGFjKSA9PiB7XG4gICAgcmV0dXJuIFByb21pc2UuYW55KFtcbiAgICAgICAgd2FpdEZvckNvc21vc0ZpbGxFdmVudChpbnRlbnRJRCwgY29zbW9zVVJMLCBhYyksXG4gICAgICAgIGNoZWNrSW50ZW50RmlsbGVkKGludGVudElELCBncnBjVVJMKSxcbiAgICBdKTtcbn07XG5jb25zdCB3YWl0Rm9yQ29zbW9zRmlsbEV2ZW50ID0gYXN5bmMgKGludGVudElELCBjb3Ntb3NVUkwsIGFjKSA9PiB7XG4gICAgY29uc3QgdSA9IG5ldyBVUkwoJy93ZWJzb2NrZXQnLCBjb3Ntb3NVUkwpO1xuICAgIHUucHJvdG9jb2wgPSAnd3NzJztcbiAgICB1LnBvcnQgPSAnMjY2NTAnO1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBjb25uZWN0KHUudG9TdHJpbmcoKSk7XG4gICAgYXdhaXQgY29ubmVjdGlvbi5jb25uZWN0ZWQoKTtcbiAgICBhYy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnb2sgZnJvbSBvdXRzaWRlJyk7XG4gICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGNvbnN0IEVWRU5UID0gJ3hhcmNoYWluLmNoYWluYWJzdHJhY3Rpb24uUkZGRnVsZmlsbGVkRXZlbnQuaWQnO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbm5lY3Rpb24uc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgaWQ6ICcwJyxcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgbWV0aG9kOiAnc3Vic2NyaWJlJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBgJHtFVkVOVH09J1wiJHtpbnRlbnRJRH1cIidgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHJlc3Agb2YgY29ubmVjdGlvbi5zb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWRSZXNwb25zZSA9IEpTT04ucGFyc2UoZGVjb2Rlci5kZWNvZGUocmVzcCkpO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRSZXNwb25zZS5yZXN1bHQuZXZlbnRzICYmXG4gICAgICAgICAgICAgICAgRVZFTlQgaW4gZGVjb2RlZFJlc3BvbnNlLnJlc3VsdC5ldmVudHMgJiZcbiAgICAgICAgICAgICAgICBkZWNvZGVkUmVzcG9uc2UucmVzdWx0LmV2ZW50c1tFVkVOVF0uaW5jbHVkZXMoYFwiJHtpbnRlbnRJRH1cImApKSB7XG4gICAgICAgICAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29rJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhaXRGb3JDb3Ntb3NGaWxsRXZlbnQ6IG91dCBvZiBsb29wIGJ1dCBubyBldmVudHMnKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9XG59O1xuXG5jb25zdCBsb2dnZXIkaiA9IGdldExvZ2dlcigpO1xuZnVuY3Rpb24gY29udmVydEFkZHJlc3NCeVVuaXZlcnNlKGlucHV0LCB1bml2ZXJzZSkge1xuICAgIGNvbnN0IGlucHV0SXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnO1xuICAgIGNvbnN0IGJ5dGVzID0gaW5wdXRJc1N0cmluZyA/IHRvQnl0ZXMoaW5wdXQpIDogaW5wdXQ7XG4gICAgaWYgKHVuaXZlcnNlID09PSBVbml2ZXJzZS5FVEhFUkVVTSkge1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAyMCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0SXNTdHJpbmcgPyBpbnB1dCA6IGJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRJc1N0cmluZyA/IHRvSGV4KGJ5dGVzLnN1YmFycmF5KDEyKSkgOiBieXRlcy5zdWJhcnJheSgxMik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxlbmd0aCBvZiBpbnB1dCcpO1xuICAgIH1cbiAgICBpZiAodW5pdmVyc2UgPT09IFVuaXZlcnNlLkZVRUwpIHtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dElzU3RyaW5nID8gaW5wdXQgOiBieXRlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAyMCkge1xuICAgICAgICAgICAgY29uc3QgcGFkZGVkID0gcGFkKGJ5dGVzLCB7XG4gICAgICAgICAgICAgICAgZGlyOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgc2l6ZTogMzIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dElzU3RyaW5nID8gdG9IZXgocGFkZGVkKSA6IHBhZGRlZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGVuZ3RoIG9mIGlucHV0Jyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5pdmVyc2UgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuY29uc3QgbWludXRlc1RvTXMgPSAobWluKSA9PiBtaW4gKiA2MCAqIDEwMDA7XG5jb25zdCBJTlRFTlRfS0VZID0gJ3hhci1zZGstaW50ZW50cyc7XG5jb25zdCBnZXRJbnRlbnRLZXkgPSAoYWRkcmVzcykgPT4ge1xuICAgIHJldHVybiBgJHtJTlRFTlRfS0VZfS0ke2FkZHJlc3N9YDtcbn07XG5jb25zdCBzdG9yZUludGVudEhhc2hUb1N0b3JlID0gKGFkZHJlc3MsIGlkLCBjcmVhdGVkQXQgPSBEYXRlLm5vdygpKSA9PiB7XG4gICAgbGV0IGludGVudHMgPSBbXTtcbiAgICBjb25zdCBmZXRjaGVkSW50ZW50cyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldEludGVudEtleShhZGRyZXNzKSk7XG4gICAgaWYgKGZldGNoZWRJbnRlbnRzKSB7XG4gICAgICAgIGludGVudHMgPSBKU09OLnBhcnNlKGZldGNoZWRJbnRlbnRzKSA/PyBbXTtcbiAgICB9XG4gICAgaW50ZW50cy5wdXNoKHsgY3JlYXRlZEF0LCBpZCB9KTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRJbnRlbnRLZXkoYWRkcmVzcyksIEpTT04uc3RyaW5naWZ5KGludGVudHMpKTtcbn07XG5jb25zdCByZW1vdmVJbnRlbnRIYXNoRnJvbVN0b3JlID0gKGFkZHJlc3MsIGlkKSA9PiB7XG4gICAgbGV0IGludGVudHMgPSBbXTtcbiAgICBjb25zdCBmZXRjaGVkSW50ZW50cyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldEludGVudEtleShhZGRyZXNzKSk7XG4gICAgaWYgKGZldGNoZWRJbnRlbnRzKSB7XG4gICAgICAgIGludGVudHMgPSBKU09OLnBhcnNlKGZldGNoZWRJbnRlbnRzKSA/PyBbXTtcbiAgICB9XG4gICAgY29uc3Qgb0xlbiA9IGludGVudHMubGVuZ3RoO1xuICAgIGludGVudHMgPSBpbnRlbnRzLmZpbHRlcigoaCkgPT4gaC5pZCAhPT0gaWQudG9OdW1iZXIoKSk7XG4gICAgaWYgKG9MZW4gIT09IGludGVudHMubGVuZ3RoKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldEludGVudEtleShhZGRyZXNzKSwgSlNPTi5zdHJpbmdpZnkoaW50ZW50cykpO1xuICAgIH1cbn07XG5jb25zdCBnZXRFeHBpcmVkSW50ZW50cyA9IChhZGRyZXNzKSA9PiB7XG4gICAgbGV0IGludGVudHMgPSBbXTtcbiAgICBjb25zdCBmZXRjaGVkSW50ZW50cyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldEludGVudEtleShhZGRyZXNzKSk7XG4gICAgaWYgKGZldGNoZWRJbnRlbnRzKSB7XG4gICAgICAgIGludGVudHMgPSBKU09OLnBhcnNlKGZldGNoZWRJbnRlbnRzKSA/PyBbXTtcbiAgICB9XG4gICAgbG9nZ2VyJGouZGVidWcoJ2dldEV4cGlyZWRJbnRlbnRzJywgeyBpbnRlbnRzIH0pO1xuICAgIGNvbnN0IGV4cGlyZWRJbnRlbnRzID0gW107XG4gICAgY29uc3Qgbm9uRXhwaXJlZEludGVudHMgPSBbXTtcbiAgICBjb25zdCBURU5fTUlOVVRFU19CRUZPUkUgPSBEYXRlLm5vdygpIC0gNjAwMDAwO1xuICAgIGZvciAoY29uc3QgaW50ZW50IG9mIGludGVudHMpIHtcbiAgICAgICAgaWYgKGludGVudC5jcmVhdGVkQXQgPCBURU5fTUlOVVRFU19CRUZPUkUpIHtcbiAgICAgICAgICAgIGV4cGlyZWRJbnRlbnRzLnB1c2goaW50ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vbkV4cGlyZWRJbnRlbnRzLnB1c2goaW50ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRJbnRlbnRLZXkoYWRkcmVzcyksIEpTT04uc3RyaW5naWZ5KG5vbkV4cGlyZWRJbnRlbnRzKSk7XG4gICAgcmV0dXJuIGV4cGlyZWRJbnRlbnRzO1xufTtcbmNvbnN0IHJlZnVuZEV4cGlyZWRJbnRlbnRzID0gYXN5bmMgKGFkZHJlc3MsIGNvc21vc1VSTCwgd2FsbGV0KSA9PiB7XG4gICAgbG9nZ2VyJGouZGVidWcoJ1N0YXJ0aW5nIGNoZWNrIGZvciBleHBpcmVkIGludGVudHMgYXQgJywgbmV3IERhdGUoKSk7XG4gICAgY29uc3QgZXhwSW50ZW50cyA9IGdldEV4cGlyZWRJbnRlbnRzKGFkZHJlc3MpO1xuICAgIGNvbnN0IGZhaWxlZFJlZnVuZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGludGVudCBvZiBleHBJbnRlbnRzKSB7XG4gICAgICAgIGxvZ2dlciRqLmRlYnVnKGBTdGFydGluZyByZWZ1bmQgZm9yOiAke2ludGVudC5pZH1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNvc21vc1JlZnVuZEludGVudChjb3Ntb3NVUkwsIGludGVudC5pZCwgd2FsbGV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyJGouZGVidWcoJ1JlZnVuZCBmYWlsZWQnLCBlKTtcbiAgICAgICAgICAgIGZhaWxlZFJlZnVuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBpbnRlbnQuY3JlYXRlZEF0LFxuICAgICAgICAgICAgICAgIGlkOiBpbnRlbnQuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmFpbGVkUmVmdW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmFpbGVkIG9mIGZhaWxlZFJlZnVuZHMpIHtcbiAgICAgICAgICAgIHN0b3JlSW50ZW50SGFzaFRvU3RvcmUoYWRkcmVzcywgZmFpbGVkLmlkLCBmYWlsZWQuY3JlYXRlZEF0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBlcXVhbEZvbGQgPSAoYSwgYikgPT4ge1xuICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhLnRvTG93ZXJDYXNlKCkgPT09IGIudG9Mb3dlckNhc2UoKTtcbn07XG5jb25zdCBjcmVhdGVSZXF1ZXN0RnVlbFNpZ25hdHVyZSA9IGFzeW5jIChmdWVsVmF1bHRBZGRyZXNzLCBwcm92aWRlciwgY29ubmVjdG9yLCBmdWVsUkZGKSA9PiB7XG4gICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IGNvbm5lY3Rvci5jdXJyZW50QWNjb3VudCgpO1xuICAgIGlmICghYWNjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1ZWwgY29ubmVjdG9yIGlzIG5vdCBjb25uZWN0ZWQuJyk7XG4gICAgfVxuICAgIGNvbnN0IHZhdWx0ID0gbmV3IEFyY2FuYVZhdWx0KGhleGxpZnkoZnVlbFZhdWx0QWRkcmVzcyksIHByb3ZpZGVyKTtcbiAgICBjb25zdCB7IHZhbHVlOiBoYXNoIH0gPSBhd2FpdCB2YXVsdC5mdW5jdGlvbnMuaGFzaF9yZXF1ZXN0KGZ1ZWxSRkYpLmdldCgpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rvci5zaWduTWVzc2FnZShhY2NvdW50LCB7XG4gICAgICAgIHBlcnNvbmFsU2lnbjogYXJyYXlpZnkoaGFzaCksXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcmVxdWVzdEhhc2g6IGhhc2gsIHNpZ25hdHVyZTogYXJyYXlpZnkoc2lnbmF0dXJlKSB9O1xufTtcbmNvbnN0IGdldEV4cGxvcmVyVVJMID0gKGJhc2VVUkwsIGlkKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBVUkwoYC9pbnRlbnQvJHtpZC50b051bWJlcigpfWAsIGJhc2VVUkwpLnRvU3RyaW5nKCk7XG59O1xuLyoqXG4gKiBAcGFyYW0gaW5wdXRcbiAqIEBwYXJhbSBkZWNpbWFsc1xuICogQHJldHVybnMgaW5wdXQgLyAoMTAqKmRlY2ltYWxzKVxuICovXG5jb25zdCBkaXZEZWNpbWFscyA9IChpbnB1dCwgZGVjaW1hbHMpID0+IHtcbiAgICByZXR1cm4gbmV3IERlY2ltYWwoaW5wdXQudG9TdHJpbmcoKSkuZGl2KERlY2ltYWwucG93KDEwLCBkZWNpbWFscykpO1xufTtcbi8qKlxuICogQHBhcmFtIGlucHV0XG4gKiBAcGFyYW0gZGVjaW1hbHNcbiAqIEByZXR1cm5zIEJpZ0ludChpbnB1dCAqICgxMCoqZGVjaW1hbHMpKVxuICovXG5jb25zdCBtdWxEZWNpbWFscyA9IChpbnB1dCwgZGVjaW1hbHMpID0+IHtcbiAgICByZXR1cm4gQmlnSW50KG5ldyBEZWNpbWFsKGlucHV0KS5tdWwoRGVjaW1hbC5wb3coMTAsIGRlY2ltYWxzKSkudG9GaXhlZCgwLCBEZWNpbWFsLlJPVU5EX0NFSUwpKTtcbn07XG5jb25zdCBjb252ZXJ0SW50ZW50ID0gKGludGVudCwgdG9rZW4sIGNoYWluTGlzdCkgPT4ge1xuICAgIGNvbnNvbGUudGltZSgnY29udmVydEludGVudCcpO1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBsZXQgc291cmNlc1RvdGFsID0gbmV3IERlY2ltYWwoMCk7XG4gICAgZm9yIChjb25zdCBzIG9mIGludGVudC5zb3VyY2VzKSB7XG4gICAgICAgIGNvbnN0IGNoYWluSW5mbyA9IGNoYWluTGlzdC5nZXRDaGFpbkJ5SUQocy5jaGFpbklEKTtcbiAgICAgICAgaWYgKCFjaGFpbkluZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hhaW4gbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZXMucHVzaCh7XG4gICAgICAgICAgICBhbW91bnQ6IHMuYW1vdW50LnRvRml4ZWQoKSxcbiAgICAgICAgICAgIGNoYWluSUQ6IGNoYWluSW5mby5pZCxcbiAgICAgICAgICAgIGNoYWluTG9nbzogY2hhaW5JbmZvLmN1c3RvbS5pY29uLFxuICAgICAgICAgICAgY2hhaW5OYW1lOiBjaGFpbkluZm8ubmFtZSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogcy50b2tlbkNvbnRyYWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgc291cmNlc1RvdGFsID0gc291cmNlc1RvdGFsLnBsdXMocy5hbW91bnQpO1xuICAgIH1cbiAgICBjb25zdCBhbGxTb3VyY2VzID0gW107XG4gICAgZm9yIChjb25zdCBzIG9mIGludGVudC5hbGxTb3VyY2VzKSB7XG4gICAgICAgIGNvbnN0IGNoYWluSW5mbyA9IGNoYWluTGlzdC5nZXRDaGFpbkJ5SUQocy5jaGFpbklEKTtcbiAgICAgICAgaWYgKCFjaGFpbkluZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hhaW4gbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGFsbFNvdXJjZXMucHVzaCh7XG4gICAgICAgICAgICBhbW91bnQ6IHMuYW1vdW50LnRvRml4ZWQoKSxcbiAgICAgICAgICAgIGNoYWluSUQ6IGNoYWluSW5mby5pZCxcbiAgICAgICAgICAgIGNoYWluTG9nbzogY2hhaW5JbmZvLmN1c3RvbS5pY29uLFxuICAgICAgICAgICAgY2hhaW5OYW1lOiBjaGFpbkluZm8ubmFtZSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogcy50b2tlbkNvbnRyYWN0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZGVzdGluYXRpb25DaGFpbkluZm8gPSBjaGFpbkxpc3QuZ2V0Q2hhaW5CeUlEKGludGVudC5kZXN0aW5hdGlvbi5jaGFpbklEKTtcbiAgICBpZiAoIWRlc3RpbmF0aW9uQ2hhaW5JbmZvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2hhaW4gbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHtcbiAgICAgICAgYW1vdW50OiBpbnRlbnQuZGVzdGluYXRpb24uYW1vdW50LnRvRml4ZWQoKSxcbiAgICAgICAgY2hhaW5JRDogaW50ZW50LmRlc3RpbmF0aW9uLmNoYWluSUQsXG4gICAgICAgIGNoYWluTG9nbzogZGVzdGluYXRpb25DaGFpbkluZm8/LmN1c3RvbS5pY29uLFxuICAgICAgICBjaGFpbk5hbWU6IGRlc3RpbmF0aW9uQ2hhaW5JbmZvPy5uYW1lLFxuICAgIH07XG4gICAgY29uc29sZS50aW1lRW5kKCdjb252ZXJ0SW50ZW50Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWxsU291cmNlcyxcbiAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgIGZlZXM6IHtcbiAgICAgICAgICAgIGNhR2FzOiBEZWNpbWFsLnN1bShpbnRlbnQuZmVlcy5jb2xsZWN0aW9uLCBpbnRlbnQuZmVlcy5mdWxmaWxtZW50KS50b0ZpeGVkKHRva2VuLmRlY2ltYWxzKSxcbiAgICAgICAgICAgIGdhc1N1cHBsaWVkOiBuZXcgRGVjaW1hbChpbnRlbnQuZmVlcy5nYXNTdXBwbGllZCkudG9GaXhlZCgpLFxuICAgICAgICAgICAgcHJvdG9jb2w6IG5ldyBEZWNpbWFsKGludGVudC5mZWVzLnByb3RvY29sKS50b0ZpeGVkKCksXG4gICAgICAgICAgICBzb2x2ZXI6IG5ldyBEZWNpbWFsKGludGVudC5mZWVzLnNvbHZlcikudG9GaXhlZCgpLFxuICAgICAgICAgICAgdG90YWw6IERlY2ltYWwuc3VtKGludGVudC5mZWVzLmNvbGxlY3Rpb24sIGludGVudC5mZWVzLnNvbHZlciwgaW50ZW50LmZlZXMucHJvdG9jb2wsIGludGVudC5mZWVzLmZ1bGZpbG1lbnQsIGludGVudC5mZWVzLmdhc1N1cHBsaWVkKS50b0ZpeGVkKHRva2VuLmRlY2ltYWxzKSxcbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlcyxcbiAgICAgICAgc291cmNlc1RvdGFsOiBzb3VyY2VzVG90YWwudG9GaXhlZCh0b2tlbi5kZWNpbWFscyksXG4gICAgICAgIHRva2VuOiB7XG4gICAgICAgICAgICBkZWNpbWFsczogdG9rZW4uZGVjaW1hbHMsXG4gICAgICAgICAgICBsb2dvOiB0b2tlbi5sb2dvLFxuICAgICAgICAgICAgbmFtZTogdG9rZW4ubmFtZSxcbiAgICAgICAgICAgIHN5bWJvbDogdG9rZW4uc3ltYm9sLnRvVXBwZXJDYXNlKCksXG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5jb25zdCBnZXRTdXBwb3J0ZWRDaGFpbnMgPSAoZW52ID0gRW52aXJvbm1lbnQuQ09SQUwpID0+IHtcbiAgICBjb25zdCBjaGFpbkxpc3QgPSBuZXcgQ2hhaW5MaXN0KGVudik7XG4gICAgcmV0dXJuIGNoYWluTGlzdC5jaGFpbnMubWFwKChjaGFpbikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGNoYWluLmlkLFxuICAgICAgICAgICAgbG9nbzogY2hhaW4uY3VzdG9tLmljb24sXG4gICAgICAgICAgICBuYW1lOiBjaGFpbi5uYW1lLFxuICAgICAgICAgICAgdG9rZW5zOiBbLi4uY2hhaW4uY3VzdG9tLmtub3duVG9rZW5zXSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5jb25zdCBpc0FyY2FuYVdhbGxldCA9IChwKSA9PiB7XG4gICAgaWYgKCdpc0FyY2FuYScgaW4gcCAmJiBwLmlzQXJjYW5hKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgY3JlYXRlUmVxdWVzdEVWTVNpZ25hdHVyZSA9IGFzeW5jIChldm1SRkYsIGV2bUFkZHJlc3MsIGNsaWVudCkgPT4ge1xuICAgIGxvZ2dlciRqLmRlYnVnKCdjcmVhdGVSZXFFVk1TaWduYXR1cmUnLCB7IGV2bVJGRiB9KTtcbiAgICBjb25zdCBhYmkgPSBnZXRBYmlJdGVtKHsgYWJpOiBFVk1WYXVsdEFCSSwgbmFtZTogJ2RlcG9zaXQnIH0pO1xuICAgIGNvbnN0IG1zZyA9IGVuY29kZUFiaVBhcmFtZXRlcnMoYWJpLmlucHV0c1swXS5jb21wb25lbnRzLCBbXG4gICAgICAgIGV2bVJGRi5zb3VyY2VzLFxuICAgICAgICBldm1SRkYuZGVzdGluYXRpb25Vbml2ZXJzZSxcbiAgICAgICAgZXZtUkZGLmRlc3RpbmF0aW9uQ2hhaW5JRCxcbiAgICAgICAgZXZtUkZGLmRlc3RpbmF0aW9ucyxcbiAgICAgICAgZXZtUkZGLm5vbmNlLFxuICAgICAgICBldm1SRkYuZXhwaXJ5LFxuICAgICAgICBldm1SRkYucGFydGllcyxcbiAgICBdKTtcbiAgICBjb25zdCBoYXNoID0ga2VjY2FrMjU2KG1zZywgJ2J5dGVzJyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdG9CeXRlcyhhd2FpdCBjbGllbnQuc2lnbk1lc3NhZ2Uoe1xuICAgICAgICBhY2NvdW50OiBldm1BZGRyZXNzLFxuICAgICAgICBtZXNzYWdlOiB7IHJhdzogaGFzaCB9LFxuICAgIH0pKTtcbiAgICByZXR1cm4geyByZXF1ZXN0SGFzaDogaGFzaE1lc3NhZ2UoeyByYXc6IGhhc2ggfSksIHNpZ25hdHVyZSB9O1xufTtcbmNvbnN0IGNvbnZlcnRHYXNUb1Rva2VuID0gKHRva2VuLCBvcmFjbGVQcmljZXMsIGRlc3RpbmF0aW9uQ2hhaW5JRCwgZGVzdGluYXRpb25Vbml2ZXJzZSwgZ2FzKSA9PiB7XG4gICAgaWYgKGlzTmF0aXZlQWRkcmVzcyQxKGRlc3RpbmF0aW9uVW5pdmVyc2UsIHRva2VuLmNvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIGdhcztcbiAgICB9XG4gICAgY29uc3QgZ2FzVG9rZW5JblVTRCA9IG9yYWNsZVByaWNlc1xuICAgICAgICAuZmluZCgocmF0ZSkgPT4gcmF0ZS5jaGFpbklkID09PSBkZXN0aW5hdGlvbkNoYWluSUQgJiZcbiAgICAgICAgKGVxdWFsRm9sZChyYXRlLnRva2VuQWRkcmVzcywgWkVST19BRERSRVNTKSB8fFxuICAgICAgICAgICAgZXF1YWxGb2xkKHJhdGUudG9rZW5BZGRyZXNzLCBGVUVMX0JBU0VfQVNTRVRfSUQpKSlcbiAgICAgICAgPy5wcmljZVVzZC50b0ZpeGVkKCkgPz8gJzAnO1xuICAgIGNvbnN0IHRyYW5zZmVyVG9rZW5JblVTRCA9IG9yYWNsZVByaWNlc1xuICAgICAgICAuZmluZCgocmF0ZSkgPT4gcmF0ZS5jaGFpbklkID09PSBkZXN0aW5hdGlvbkNoYWluSUQgJiYgZXF1YWxGb2xkKHJhdGUudG9rZW5BZGRyZXNzLCB0b2tlbi5jb250cmFjdEFkZHJlc3MpKVxuICAgICAgICA/LnByaWNlVXNkLnRvRml4ZWQoKTtcbiAgICBpZiAoIXRyYW5zZmVyVG9rZW5JblVTRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCBmaW5kIHRva2VuIGluIHByaWNlIG9yYWNsZScpO1xuICAgIH1cbiAgICBjb25zdCB1c2RWYWx1ZSA9IGdhcy5tdWwoZ2FzVG9rZW5JblVTRCk7XG4gICAgY29uc3QgdG9rZW5FcXVpdmFsZW50ID0gdXNkVmFsdWUuZGl2KHRyYW5zZmVyVG9rZW5JblVTRCk7XG4gICAgcmV0dXJuIHRva2VuRXF1aXZhbGVudC50b0RQKHRva2VuLmRlY2ltYWxzLCBEZWNpbWFsLlJPVU5EX0NFSUwpO1xufTtcbmNvbnN0IGV2bVdhaXRGb3JGaWxsID0gYXN5bmMgKHZhdWx0Q29udHJhY3RBZGRyZXNzLCBwdWJsaWNDbGllbnQsIHJlcXVlc3RIYXNoLCBpbnRlbnRJRCwgZ3JwY1VSTCwgY29zbW9zVVJMKSA9PiB7XG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgd2FpdEZvckludGVudEZ1bGZpbG1lbnQocHVibGljQ2xpZW50LCB2YXVsdENvbnRyYWN0QWRkcmVzcywgcmVxdWVzdEhhc2gsIGFjKSxcbiAgICAgICAgcmVxdWVzdFRpbWVvdXQoMywgYWMpLFxuICAgICAgICBjb3Ntb3NGaWxsQ2hlY2soaW50ZW50SUQsIGdycGNVUkwsIGNvc21vc1VSTCwgYWMpLFxuICAgIF0pO1xufTtcbmNvbnN0IGNvbnZlcnRUbzMyQnl0ZXMkMSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2JpZ2ludCcgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdG9CeXRlcyh2YWx1ZSwge1xuICAgICAgICAgICAgc2l6ZTogMzIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGFkKHRvQnl0ZXModmFsdWUpLCB7XG4gICAgICAgICAgICBkaXI6ICdsZWZ0JyxcbiAgICAgICAgICAgIHNpemU6IDMyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbn07XG5jb25zdCBjb252ZXJ0VG8zMkJ5dGVzSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgYnl0ZXMgPSBjb252ZXJ0VG8zMkJ5dGVzJDEodmFsdWUpO1xuICAgIHJldHVybiB0b0hleChieXRlcyk7XG59O1xuY29uc3QgY29udmVydFRvSGV4QWRkcmVzc0J5VW5pdmVyc2UgPSAoYWRkcmVzcywgdW5pdmVyc2UpID0+IHtcbiAgICBpZiAodW5pdmVyc2UgPT09IFVuaXZlcnNlLkZVRUwpIHtcbiAgICAgICAgaWYgKGFkZHJlc3MubGVuZ3RoID09PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1ZWw6IGludmFsaWQgYWRkcmVzcyBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1bml2ZXJzZSA9PT0gVW5pdmVyc2UuRVRIRVJFVU0pIHtcbiAgICAgICAgaWYgKGFkZHJlc3MubGVuZ3RoID09PSAyMCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWRkcmVzcy5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgICAgICBpZiAoIWFkZHJlc3Muc3ViYXJyYXkoMCwgMTIpLmV2ZXJ5KChiKSA9PiBiID09PSAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXZtOiBub24temVyby1wYWRkZWQgMzItYnl0ZSBhZGRyZXNzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNUb0hleChhZGRyZXNzLnN1YmFycmF5KDEyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V2bTogaW52YWxpZCBhZGRyZXNzIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHVuaXZlcnNlJyk7XG4gICAgfVxufTtcbmNvbnN0IGNyZWF0ZURlcG9zaXREb3VibGVDaGVja1R4ID0gKGNoYWluSUQsIGNvc21vcywgaW50ZW50SUQsIG5ldHdvcmspID0+IHtcbiAgICBjb25zdCBtc2cgPSBNc2dEb3VibGVDaGVja1R4LmNyZWF0ZSh7XG4gICAgICAgIGNyZWF0b3I6IGNvc21vcy5hZGRyZXNzLFxuICAgICAgICBwYWNrZXQ6IHtcbiAgICAgICAgICAgICRjYXNlOiAnZGVwb3NpdFBhY2tldCcsXG4gICAgICAgICAgICB2YWx1ZTogRGVwb3NpdFZFUGFja2V0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZ2FzUmVmdW5kZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlkOiBpbnRlbnRJRCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9LFxuICAgICAgICB0eENoYWluSUQ6IGNoYWluSUQsXG4gICAgICAgIHR4VW5pdmVyc2U6IFVuaXZlcnNlLkVUSEVSRVVNLFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb3Ntb3NDcmVhdGVEb3VibGVDaGVja1R4JDEoe1xuICAgICAgICAgICAgYWRkcmVzczogY29zbW9zLmFkZHJlc3MsXG4gICAgICAgICAgICBjb3Ntb3NVUkw6IG5ldHdvcmsuQ09TTU9TX1VSTCxcbiAgICAgICAgICAgIG1zZyxcbiAgICAgICAgICAgIHdhbGxldDogY29zbW9zLndhbGxldCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5jb25zdCBnZXRTREtDb25maWcgPSAoYykgPT4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgZGVidWc6IGMuZGVidWcgPz8gZmFsc2UsXG4gICAgICAgIG5ldHdvcms6IEVudmlyb25tZW50LkNPUkFMLFxuICAgIH07XG4gICAgc3dpdGNoIChjLm5ldHdvcmspIHtcbiAgICAgICAgY2FzZSAndGVzdG5ldCc6IHtcbiAgICAgICAgICAgIGNvbmZpZy5uZXR3b3JrID0gRW52aXJvbm1lbnQuRk9MTFk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtYWlubmV0Jzoge1xuICAgICAgICAgICAgY29uZmlnLm5ldHdvcmsgPSBFbnZpcm9ubWVudC5DT1JBTDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG59O1xuY29uc3QgZ2V0VHhPcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgYnJpZGdlOiBmYWxzZSxcbiAgICAgICAgZ2FzOiAwbixcbiAgICAgICAgc2tpcFR4OiBmYWxzZSxcbiAgICAgICAgc291cmNlQ2hhaW5zOiBbXSxcbiAgICB9O1xuICAgIGlmIChvcHRpb25zPy5icmlkZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZhdWx0T3B0aW9ucy5icmlkZ2UgPSBvcHRpb25zLmJyaWRnZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LmdhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmF1bHRPcHRpb25zLmdhcyA9IG9wdGlvbnMuZ2FzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucz8uc2tpcFR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmYXVsdE9wdGlvbnMuc2tpcFR4ID0gb3B0aW9ucy5za2lwVHg7XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5zb3VyY2VDaGFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZhdWx0T3B0aW9ucy5zb3VyY2VDaGFpbnMgPSBvcHRpb25zLnNvdXJjZUNoYWlucztcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRPcHRpb25zO1xufTtcbmNsYXNzIFVzZXJBc3NldCB7XG4gICAgZ2V0IGJhbGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmJhbGFuY2U7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0QmFsYW5jZU9uQ2hhaW4oY2hhaW5JRCwgdG9rZW5BZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZS5icmVha2Rvd24uZmluZCgoYikgPT4ge1xuICAgICAgICAgICAgaWYgKHRva2VuQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBiLmNoYWluLmlkID09PSBjaGFpbklEICYmIGVxdWFsRm9sZChiLmNvbnRyYWN0QWRkcmVzcywgdG9rZW5BZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiLmNoYWluLmlkID09PSBjaGFpbklEO1xuICAgICAgICB9KT8uYmFsYW5jZSA/PyAnMCcpO1xuICAgIH1cbiAgICBpc0RlcG9zaXQodG9rZW5BZGRyZXNzLCB1bml2ZXJzZSkge1xuICAgICAgICBpZiAodW5pdmVyc2UgPT09IFVuaXZlcnNlLkVUSEVSRVVNKSB7XG4gICAgICAgICAgICByZXR1cm4gZXF1YWxGb2xkKHRva2VuQWRkcmVzcywgWkVST19BRERSRVNTKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdmVyc2UgPT09IFVuaXZlcnNlLkZVRUwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXRlcmF0ZShmZWVTdG9yZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5icmVha2Rvd25cbiAgICAgICAgICAgIC5maWx0ZXIoKGIpID0+IG5ldyBEZWNpbWFsKGIuYmFsYW5jZSkuZ3QoMCkpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEuY2hhaW4uaWQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiLmNoYWluLmlkID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERlY2ltYWwuc3ViKGIuYmFsYW5jZSwgYS5iYWxhbmNlKS50b051bWJlcigpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgoYikgPT4ge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBuZXcgRGVjaW1hbChiLmJhbGFuY2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEZXBvc2l0KGIuY29udHJhY3RBZGRyZXNzLCBiLnVuaXZlcnNlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25GZWUgPSBmZWVTdG9yZS5jYWxjdWxhdGVDb2xsZWN0aW9uRmVlKHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IGIuZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUNoYWluSUQ6IGIuY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVRva2VuQWRkcmVzczogYi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGVzdGltYXRlZEdhc0ZvckRlcG9zaXQgPSBjb2xsZWN0aW9uRmVlLm11bChiLmNoYWluLmlkID09PSAxID8gMiA6IDQpO1xuICAgICAgICAgICAgICAgIGlmIChiLmNvbnRyYWN0QWRkcmVzcyA9PT0gRlVFTF9CQVNFX0FTU0VUX0lEICYmIGIuY2hhaW4uaWQgPT09IENIQUlOX0lEUy5mdWVsLm1haW5uZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXN0aW1hdGluZyB0aGlzIGFtb3VudCBvZiBnYXMgaXMgcmVxdWlyZWQgZm9yIGZ1ZWwgLT4gdmF1bHRcbiAgICAgICAgICAgICAgICAgICAgZXN0aW1hdGVkR2FzRm9yRGVwb3NpdCA9IG5ldyBEZWNpbWFsKCcwLjAwMF8wMDMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ldyBEZWNpbWFsKGIuYmFsYW5jZSkubGVzc1RoYW4oZXN0aW1hdGVkR2FzRm9yRGVwb3NpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZSA9IG5ldyBEZWNpbWFsKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZSA9IG5ldyBEZWNpbWFsKGIuYmFsYW5jZSkubWludXMoZXN0aW1hdGVkR2FzRm9yRGVwb3NpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiYWxhbmNlLFxuICAgICAgICAgICAgICAgIGNoYWluSUQ6IGIuY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IGIuZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgdG9rZW5Db250cmFjdDogYi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdW5pdmVyc2U6IGIudW5pdmVyc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBVc2VyQXNzZXRzIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIGFkZChhc3NldCkge1xuICAgICAgICB0aGlzLmRhdGEucHVzaChhc3NldCk7XG4gICAgfVxuICAgIGZpbmQoc3ltYm9sKSB7XG4gICAgICAgIGZvciAoY29uc3QgYXNzZXQgb2YgdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXF1YWxGb2xkKGFzc2V0LnN5bWJvbCwgc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXNlckFzc2V0KGFzc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fzc2V0IGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIGZpbmRPbkNoYWluKGNoYWluSUQsIGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5maW5kKChhc3NldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhc3NldC5icmVha2Rvd24uZmluZEluZGV4KChiKSA9PiBiLmNoYWluLmlkID09PSBjaGFpbklEICYmIGVxdWFsRm9sZChiLmNvbnRyYWN0QWRkcmVzcywgYWRkcmVzcykpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEFzc2V0RGV0YWlscyhjaGFpbiwgYWRkcmVzcykge1xuICAgICAgICBsZXQgYXNzZXQgPSB0aGlzLmZpbmRPbkNoYWluKGNoYWluLmlkLCBhZGRyZXNzKTtcbiAgICAgICAgZ2V0TG9nZ2VyKCkuZGVidWcoJ2dldEFzc2V0RGV0YWlscycsIHtcbiAgICAgICAgICAgIGFzc2V0LFxuICAgICAgICAgICAgYXNzZXRzOiB0aGlzLmRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkdhc0JhbGFuY2UgPSB0aGlzLmdldE5hdGl2ZUJhbGFuY2UoY2hhaW4pO1xuICAgICAgICBjb25zdCBjaGFpbnNXaXRoQmFsYW5jZSA9IHRoaXMuZ2V0Q2hhaW5Db3VudFdpdGhCYWxhbmNlKGFzc2V0KTtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25Bc3NldEJhbGFuY2UgPSBhc3NldD8uYnJlYWtkb3duLmZpbmQoKGIpID0+IGIuY2hhaW4uaWQgPT09IGNoYWluLmlkKT8uYmFsYW5jZSA/PyAnMCc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFpbnNXaXRoQmFsYW5jZSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uQXNzZXRCYWxhbmNlLFxuICAgICAgICAgICAgZGVzdGluYXRpb25HYXNCYWxhbmNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRCYWxhbmNlSW5GaWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhXG4gICAgICAgICAgICAucmVkdWNlKCh0b3RhbCwgYXNzZXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbC5hZGQoYXNzZXQuYmFsYW5jZUluRmlhdCk7XG4gICAgICAgIH0sIG5ldyBEZWNpbWFsKDApKVxuICAgICAgICAgICAgLnRvRGVjaW1hbFBsYWNlcygyKVxuICAgICAgICAgICAgLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIGdldENoYWluQ291bnRXaXRoQmFsYW5jZShhc3NldCkge1xuICAgICAgICByZXR1cm4gYXNzZXQ/LmJyZWFrZG93bi5maWx0ZXIoKGIpID0+IG5ldyBEZWNpbWFsKGIuYmFsYW5jZSkuZ3QoMCkpLmxlbmd0aCA/PyAwO1xuICAgIH1cbiAgICBnZXROYXRpdmVCYWxhbmNlKGNoYWluKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gdGhpcy5kYXRhLmZpbmQoKGEpID0+IGVxdWFsRm9sZChhLnN5bWJvbCwgY2hhaW4ubmF0aXZlQ3VycmVuY3kuc3ltYm9sKSk7XG4gICAgICAgIGlmIChhc3NldCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzc2V0LmJyZWFrZG93bi5maW5kKChiKSA9PiBiLmNoYWluLmlkID09PSBjaGFpbi5pZCk/LmJhbGFuY2UgPz8gJzAnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIHNvcnQoKSB7XG4gICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKChhc3NldCkgPT4ge1xuICAgICAgICAgICAgYXNzZXQuYnJlYWtkb3duLnNvcnQoKGEsIGIpID0+IGIuYmFsYW5jZUluRmlhdCAtIGEuYmFsYW5jZUluRmlhdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRhdGEuc29ydCgoYSwgYikgPT4gYi5iYWxhbmNlSW5GaWF0IC0gYS5iYWxhbmNlSW5GaWF0KTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudmFsdWVzKCk7XG4gICAgfVxufVxuXG5jb25zdCBsb2dnZXIkaSA9IGdldExvZ2dlcigpO1xubGV0IGNvc21vc1F1ZXJ5Q2xpZW50ID0gbnVsbDtcbmNvbnN0IGdldENvc21vc1F1ZXJ5Q2xpZW50ID0gKGdycGNVUkwpID0+IHtcbiAgICBpZiAoIWNvc21vc1F1ZXJ5Q2xpZW50KSB7XG4gICAgICAgIGNvbnN0IHJwYyA9IG5ldyBHcnBjV2ViSW1wbChncnBjVVJMLCB7fSk7XG4gICAgICAgIGNvc21vc1F1ZXJ5Q2xpZW50ID0gbmV3IFF1ZXJ5Q2xpZW50SW1wbChycGMpO1xuICAgIH1cbiAgICByZXR1cm4gY29zbW9zUXVlcnlDbGllbnQ7XG59O1xuY29uc3QgUEFHRV9MSU1JVCA9IDEwMDtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoTXlJbnRlbnRzKGFkZHJlc3MsIGdycGNVUkwsIHBhZ2UgPSAxKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRDb3Ntb3NRdWVyeUNsaWVudChncnBjVVJMKS5SZXF1ZXN0Rm9yRnVuZHNCeUFkZHJlc3Moe1xuICAgICAgICAgICAgYWNjb3VudDogYWRkcmVzcyxcbiAgICAgICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICAgICAgICBsaW1pdDogUEFHRV9MSU1JVCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IChwYWdlIC0gMSkgKiBQQUdFX0xJTUlULFxuICAgICAgICAgICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGludGVudFRyYW5zZm9ybShyZXNwb25zZS5yZXF1ZXN0Rm9yRnVuZHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyJGkuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBpbnRlbnRzJywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBpbnRlbnRzJyk7XG4gICAgfVxufVxuY29uc3QgaW50ZW50VHJhbnNmb3JtID0gKGlucHV0KSA9PiB7XG4gICAgcmV0dXJuIGlucHV0Lm1hcCgocmZmKSA9PiAoe1xuICAgICAgICBkZXBvc2l0ZWQ6IHJmZi5kZXBvc2l0ZWQsXG4gICAgICAgIGRlc3RpbmF0aW9uQ2hhaW5JRDogYnl0ZXNUb051bWJlcihyZmYuZGVzdGluYXRpb25DaGFpbklEKSxcbiAgICAgICAgZGVzdGluYXRpb25zOiByZmYuZGVzdGluYXRpb25zLm1hcCgoZCkgPT4gKHtcbiAgICAgICAgICAgIHRva2VuQWRkcmVzczogY29udmVydFRvSGV4QWRkcmVzc0J5VW5pdmVyc2UoZC50b2tlbkFkZHJlc3MsIHJmZi5kZXN0aW5hdGlvblVuaXZlcnNlKSxcbiAgICAgICAgICAgIHZhbHVlOiBieXRlc1RvQmlnSW50KGQudmFsdWUpLFxuICAgICAgICB9KSksXG4gICAgICAgIGRlc3RpbmF0aW9uVW5pdmVyc2U6IFVuaXZlcnNlW3JmZi5kZXN0aW5hdGlvblVuaXZlcnNlXSxcbiAgICAgICAgZXhwaXJ5OiByZmYuZXhwaXJ5LnRvTnVtYmVyKCksXG4gICAgICAgIGZ1bGZpbGxlZDogcmZmLmZ1bGZpbGxlZCxcbiAgICAgICAgaWQ6IHJmZi5pZC50b051bWJlcigpLFxuICAgICAgICByZWZ1bmRlZDogcmZmLnJlZnVuZGVkLFxuICAgICAgICBzb3VyY2VzOiByZmYuc291cmNlcy5tYXAoKHMpID0+ICh7XG4gICAgICAgICAgICBjaGFpbklEOiBieXRlc1RvTnVtYmVyKHMuY2hhaW5JRCksXG4gICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGNvbnZlcnRUb0hleEFkZHJlc3NCeVVuaXZlcnNlKHMudG9rZW5BZGRyZXNzLCBzLnVuaXZlcnNlKSxcbiAgICAgICAgICAgIHVuaXZlcnNlOiBVbml2ZXJzZVtzLnVuaXZlcnNlXSxcbiAgICAgICAgICAgIHZhbHVlOiBieXRlc1RvQmlnSW50KHMudmFsdWUpLFxuICAgICAgICB9KSksXG4gICAgfSkpO1xufTtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoUHJvdG9jb2xGZWVzKGdycGNVUkwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldENvc21vc1F1ZXJ5Q2xpZW50KGdycGNVUkwpLlByb3RvY29sRmVlcyh7XG4gICAgICAgICAgICBVbml2ZXJzZTogVW5pdmVyc2UuRlVFTCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlciRpLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcHJvdG9jb2wgZmVlcycsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcHJvdG9jb2wgZmVlcycpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoU29sdmVyRGF0YShncnBjVVJMKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRDb3Ntb3NRdWVyeUNsaWVudChncnBjVVJMKS5Tb2x2ZXJEYXRhQWxsKHt9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyJGkuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBzb2x2ZXIgZGF0YScsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggc29sdmVyIGRhdGEnKTtcbiAgICB9XG59XG5jb25zdCBmZXRjaFByaWNlT3JhY2xlID0gYXN5bmMgKGdycGNVUkwpID0+IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0Q29zbW9zUXVlcnlDbGllbnQoZ3JwY1VSTCkuUHJpY2VPcmFjbGVEYXRhKHt9KTtcbiAgICBpZiAoZGF0YS5QcmljZU9yYWNsZURhdGE/LnByaWNlRGF0YT8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG9yYWNsZVJhdGVzID0gZGF0YS5QcmljZU9yYWNsZURhdGE/LnByaWNlRGF0YS5tYXAoKGRhdGEpID0+ICh7XG4gICAgICAgICAgICBjaGFpbklkOiBieXRlc1RvTnVtYmVyKGRhdGEuY2hhaW5JRCksXG4gICAgICAgICAgICBwcmljZVVzZDogbmV3IERlY2ltYWwoYnl0ZXNUb051bWJlcihkYXRhLnByaWNlKSkuZGl2KERlY2ltYWwucG93KDEwLCBkYXRhLmRlY2ltYWxzKSksXG4gICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGNvbnZlcnRBZGRyZXNzQnlVbml2ZXJzZSh0b0hleChkYXRhLnRva2VuQWRkcmVzcyksIGRhdGEudW5pdmVyc2UpLFxuICAgICAgICAgICAgdG9rZW5zUGVyVXNkOiBuZXcgRGVjaW1hbCgxKS5kaXYobmV3IERlY2ltYWwoYnl0ZXNUb051bWJlcihkYXRhLnByaWNlKSkuZGl2KERlY2ltYWwucG93KDEwLCBkYXRhLmRlY2ltYWxzKSkpLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBvcmFjbGVSYXRlcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbEVycm9yOiBObyBwcmljZSBkYXRhIGZvdW5kLicpO1xufTtcbmNsYXNzIEZlZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUNvbGxlY3Rpb25GZWUoeyBkZWNpbWFscywgc291cmNlQ2hhaW5JRCwgc291cmNlVG9rZW5BZGRyZXNzLCB9KSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25GZWUgPSB0aGlzLmRhdGEuZmVlLmNvbGxlY3Rpb24uZmluZCgoZikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihmLmNoYWluSUQpID09PSBzb3VyY2VDaGFpbklEICYmIGVxdWFsRm9sZChmLnRva2VuQWRkcmVzcywgc291cmNlVG9rZW5BZGRyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY29sbGVjdGlvbkZlZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXZEZWNpbWFscyhjb2xsZWN0aW9uRmVlLmZlZSA/PyAwLCBkZWNpbWFscyk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUZ1bGZpbG1lbnRGZWUoeyBkZWNpbWFscywgZGVzdGluYXRpb25DaGFpbklELCBkZXN0aW5hdGlvblRva2VuQWRkcmVzcywgfSkge1xuICAgICAgICBjb25zdCBmdWxmaWxtZW50RmVlQmFzaXMgPSB0aGlzLmRhdGEuZmVlLmZ1bGZpbG1lbnQuZmluZCgoZikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoZi5jaGFpbklEKSA9PT0gZGVzdGluYXRpb25DaGFpbklEICYmXG4gICAgICAgICAgICAgICAgZXF1YWxGb2xkKGYudG9rZW5BZGRyZXNzLCBkZXN0aW5hdGlvblRva2VuQWRkcmVzcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFmdWxmaWxtZW50RmVlQmFzaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwoZnVsZmlsbWVudEZlZUJhc2lzLmZlZSA/PyAwKS5kaXYoRGVjaW1hbC5wb3coMTAsIGRlY2ltYWxzKSk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZVByb3RvY29sRmVlKGJvcnJvdykge1xuICAgICAgICBjb25zdCBwcm90b2NvbEZlZUJhc2lzID0gbmV3IERlY2ltYWwodGhpcy5kYXRhLmZlZS5wcm90b2NvbC5mZWVCUCA/PyAwKS5kaXYoRGVjaW1hbC5wb3coMTAsIDQpKTtcbiAgICAgICAgcmV0dXJuIGJvcnJvdy5tdWwocHJvdG9jb2xGZWVCYXNpcyk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZVNvbHZlckZlZSh7IGJvcnJvd0Ftb3VudCwgZGVjaW1hbHMsIGRlc3RpbmF0aW9uQ2hhaW5JRCwgZGVzdGluYXRpb25Ub2tlbkFkZHJlc3MsIHNvdXJjZUNoYWluSUQsIHNvdXJjZVRva2VuQWRkcmVzcywgfSkge1xuICAgICAgICBjb25zdCBzb2x2ZXJGZWVCUCA9IHRoaXMuZGF0YS5zb2x2ZXJSb3V0ZXMuZmluZCgoZikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoZi5zb3VyY2VDaGFpbklEKSA9PT0gc291cmNlQ2hhaW5JRCAmJlxuICAgICAgICAgICAgICAgIE51bWJlcihmLmRlc3RpbmF0aW9uQ2hhaW5JRCkgPT09IGRlc3RpbmF0aW9uQ2hhaW5JRCAmJlxuICAgICAgICAgICAgICAgIGVxdWFsRm9sZChmLnNvdXJjZVRva2VuQWRkcmVzcywgc291cmNlVG9rZW5BZGRyZXNzKSAmJlxuICAgICAgICAgICAgICAgIGVxdWFsRm9sZChmLmRlc3RpbmF0aW9uVG9rZW5BZGRyZXNzLCBkZXN0aW5hdGlvblRva2VuQWRkcmVzcykpO1xuICAgICAgICB9KT8uZmVlQlAgPz8gMDtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsKHNvbHZlckZlZUJQID8/IDApXG4gICAgICAgICAgICAuZGl2KERlY2ltYWwucG93KDEwLCA0KSlcbiAgICAgICAgICAgIC5tdWwoYm9ycm93QW1vdW50KVxuICAgICAgICAgICAgLnRvRFAoZGVjaW1hbHMsIERlY2ltYWwuUk9VTkRfQ0VJTCk7XG4gICAgfVxufVxuY29uc3QgZ2V0RmVlU3RvcmUgPSBhc3luYyAoZ3JwY1VSTCkgPT4ge1xuICAgIGNvbnN0IGZlZURhdGEgPSB7XG4gICAgICAgIGZlZToge1xuICAgICAgICAgICAgY29sbGVjdGlvbjogW10sXG4gICAgICAgICAgICBmdWxmaWxtZW50OiBbXSxcbiAgICAgICAgICAgIHByb3RvY29sOiB7XG4gICAgICAgICAgICAgICAgZmVlQlA6ICcwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHNvbHZlclJvdXRlczogW10sXG4gICAgfTtcbiAgICBjb25zdCBbcCwgc10gPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW2ZldGNoUHJvdG9jb2xGZWVzKGdycGNVUkwpLCBmZXRjaFNvbHZlckRhdGEoZ3JwY1VSTCldKTtcbiAgICBpZiAocC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICAgIGxvZ2dlciRpLmRlYnVnKCdnZXRGZWVTdG9yZScsIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb246IHAudmFsdWUuUHJvdG9jb2xGZWVzPy5jb2xsZWN0aW9uRmVlcyxcbiAgICAgICAgICAgIGZ1bGZpbG1lbnQ6IHAudmFsdWUuUHJvdG9jb2xGZWVzPy5mdWxmaWxtZW50RmVlcyxcbiAgICAgICAgICAgIHByb3RvY29sOiBwLnZhbHVlLlByb3RvY29sRmVlcz8uZmVlQlAsXG4gICAgICAgIH0pO1xuICAgICAgICBmZWVEYXRhLmZlZS5wcm90b2NvbC5mZWVCUCA9IHAudmFsdWUuUHJvdG9jb2xGZWVzPy5mZWVCUC50b1N0cmluZygxMCkgPz8gJzAnO1xuICAgICAgICBmZWVEYXRhLmZlZS5jb2xsZWN0aW9uID1cbiAgICAgICAgICAgIHAudmFsdWUuUHJvdG9jb2xGZWVzPy5jb2xsZWN0aW9uRmVlcy5tYXAoKGZlZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSUQ6IGJ5dGVzVG9OdW1iZXIoZmVlLmNoYWluSUQpLFxuICAgICAgICAgICAgICAgICAgICBmZWU6IGJ5dGVzVG9OdW1iZXIoZmVlLmZlZSksXG4gICAgICAgICAgICAgICAgICAgIHRva2VuQWRkcmVzczogY29udmVydEFkZHJlc3NCeVVuaXZlcnNlKHRvSGV4KGZlZS50b2tlbkFkZHJlc3MpLCBmZWUudW5pdmVyc2UpLFxuICAgICAgICAgICAgICAgICAgICB1bml2ZXJzZTogZmVlLnVuaXZlcnNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSA/PyBbXTtcbiAgICAgICAgZmVlRGF0YS5mZWUuZnVsZmlsbWVudCA9XG4gICAgICAgICAgICBwLnZhbHVlLlByb3RvY29sRmVlcz8uZnVsZmlsbWVudEZlZXMubWFwKChmZWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklEOiBieXRlc1RvTnVtYmVyKGZlZS5jaGFpbklEKSxcbiAgICAgICAgICAgICAgICAgICAgZmVlOiBieXRlc1RvTnVtYmVyKGZlZS5mZWUpLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGNvbnZlcnRBZGRyZXNzQnlVbml2ZXJzZSh0b0hleChmZWUudG9rZW5BZGRyZXNzKSwgZmVlLnVuaXZlcnNlKSxcbiAgICAgICAgICAgICAgICAgICAgdW5pdmVyc2U6IGZlZS51bml2ZXJzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkgPz8gW107XG4gICAgfVxuICAgIGlmIChzLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgZmVlRGF0YS5zb2x2ZXJSb3V0ZXMgPVxuICAgICAgICAgICAgcy52YWx1ZS5zb2x2ZXJEYXRhWzBdPy5hZHZlcnRpc2VkRmVlcy5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkNoYWluSUQ6IGJ5dGVzVG9OdW1iZXIocy5kZXN0aW5hdGlvbkNoYWluSUQpLFxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvblRva2VuQWRkcmVzczogY29udmVydEFkZHJlc3NCeVVuaXZlcnNlKHRvSGV4KHMuZGVzdGluYXRpb25Ub2tlbkFkZHJlc3MpLCBzLmRlc3RpbmF0aW9uVW5pdmVyc2UpLFxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvblVuaXZlcnNlOiBzLmRlc3RpbmF0aW9uVW5pdmVyc2UsXG4gICAgICAgICAgICAgICAgICAgIGZlZUJQOiBzLmZlZUJQLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VDaGFpbklEOiBieXRlc1RvTnVtYmVyKHMuc291cmNlQ2hhaW5JRCksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVRva2VuQWRkcmVzczogY29udmVydEFkZHJlc3NCeVVuaXZlcnNlKHRvSGV4KHMuc291cmNlVG9rZW5BZGRyZXNzKSwgcy5zb3VyY2VVbml2ZXJzZSksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVVuaXZlcnNlOiBzLnNvdXJjZVVuaXZlcnNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSB8fCBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGZWVTdG9yZShmZWVEYXRhKTtcbn07XG5jb25zdCBnZXRWU0NVUkwgPSAodnNjRG9tYWluLCBwcm90b2NvbCkgPT4ge1xuICAgIHJldHVybiBgJHtwcm90b2NvbH06Ly8ke3ZzY0RvbWFpbn1gO1xufTtcbmxldCB2c2NSZXEgPSBudWxsO1xuY29uc3QgZ2V0VnNjUmVxID0gKHZzY0RvbWFpbikgPT4ge1xuICAgIGlmICghdnNjUmVxKSB7XG4gICAgICAgIHZzY1JlcSA9IGF4aW9zLmNyZWF0ZSh7XG4gICAgICAgICAgICBiYXNlVVJMOiBuZXcgVVJMKCcvYXBpL3YxJywgZ2V0VlNDVVJMKHZzY0RvbWFpbiwgJ2h0dHBzJykpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vbXNncGFjaycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICAgICAgdHJhbnNmb3JtUmVxdWVzdDogW1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChkYXRhLCBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ2dldCcsICdoZWFkJ10uaW5jbHVkZXModGhpcy5tZXRob2QudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL21zZ3BhY2snO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFjayhkYXRhKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBbKGRhdGEpID0+IHVucGFjayhkYXRhKV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdnNjUmVxO1xufTtcbmNvbnN0IGdldEJhbGFuY2VzRnJvbVZTQyA9IGFzeW5jICh2c2NEb21haW4sIGFkZHJlc3MsIG5hbWVzcGFjZSA9ICdFVEhFUkVVTScpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldFZzY1JlcSh2c2NEb21haW4pLmdldChgL2dldC1iYWxhbmNlLyR7bmFtZXNwYWNlfS8ke2FkZHJlc3N9YCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuYmFsYW5jZXM7XG59O1xuY29uc3QgZ2V0RVZNQmFsYW5jZXNGb3JBZGRyZXNzID0gYXN5bmMgKHZzY0RvbWFpbiwgYWRkcmVzcykgPT4ge1xuICAgIHJldHVybiBnZXRCYWxhbmNlc0Zyb21WU0ModnNjRG9tYWluLCBhZGRyZXNzKTtcbn07XG5jb25zdCBnZXRGdWVsQmFsYW5jZXNGb3JBZGRyZXNzID0gYXN5bmMgKHZzY0RvbWFpbiwgYWRkcmVzcykgPT4ge1xuICAgIHJldHVybiBnZXRCYWxhbmNlc0Zyb21WU0ModnNjRG9tYWluLCBhZGRyZXNzLCAnRlVFTCcpO1xufTtcbmNvbnN0IHZzY0NyZWF0ZUZlZUdyYW50ID0gYXN5bmMgKHZzY0RvbWFpbiwgYWRkcmVzcykgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0VnNjUmVxKHZzY0RvbWFpbikucG9zdChgL2NyZWF0ZS1mZWVncmFudGAsIHtcbiAgICAgICAgY29zbW9zX2FkZHJlc3M6IGFkZHJlc3MsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbmNvbnN0IHZzY1B1Ymxpc2hSRkYgPSBhc3luYyAodnNjRG9tYWluLCBpZCkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0VnNjUmVxKHZzY0RvbWFpbikucG9zdCgnL3B1Ymxpc2gtcmZmJywge1xuICAgICAgICBpZDogaWQudG9OdW1iZXIoKSxcbiAgICB9KTtcbiAgICBsb2dnZXIkaS5kZWJ1ZygncHVibGlzaFJGRicsIHsgcmVzcG9uc2UgfSk7XG4gICAgcmV0dXJuIHsgaWQgfTtcbn07XG5jb25zdCB2c2NDcmVhdGVTcG9uc29yZWRBcHByb3ZhbHMgPSBhc3luYyAodnNjRG9tYWluLCBpbnB1dCwgbXNkKSA9PiB7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGNvbm5lY3QobmV3IFVSTCgnL2FwaS92MS9jcmVhdGUtc3BvbnNvcmVkLWFwcHJvdmFscycsIGdldFZTQ1VSTCh2c2NEb21haW4sICd3c3MnKSkudG9TdHJpbmcoKSk7XG4gICAgYXdhaXQgY29ubmVjdGlvbi5jb25uZWN0ZWQoKTtcbiAgICB0cnkge1xuICAgICAgICBjb25uZWN0aW9uLnNvY2tldC5zZW5kKHBhY2soaW5wdXQpKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCByZXNwIG9mIGNvbm5lY3Rpb24uc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdW5wYWNrKHJlc3ApO1xuICAgICAgICAgICAgbG9nZ2VyJGkuZGVidWcoJ3ZzY0NyZWF0ZVNwb25zb3JlZEFwcHJvdmFscycsIHsgZGF0YSB9KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3JlZCcgaW4gZGF0YSAmJiBkYXRhLmVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiBkYXRhICYmIGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5tc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1zZCkge1xuICAgICAgICAgICAgICAgIG1zZChBTExPV0FOQ0VfQVBQUk9WQUxfTUlORUQoYnl0ZXNUb051bWJlcihpbnB1dFtkYXRhLnBhcnRfaWR4XS5jaGFpbl9pZCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICBpZiAoY291bnQgPT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdvayc7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxufTtcbmNvbnN0IHZzY0NyZWF0ZVJGRiA9IGFzeW5jICh2c2NEb21haW4sIGlkLCBtc2QsIGV4cGVjdGVkQ29sbGVjdGlvbkluZGV4ZXMpID0+IHtcbiAgICBjb25zdCByZWNlaXZlZENvbGxlY3Rpb25zQUNLcyA9IFtdO1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBjb25uZWN0KG5ldyBVUkwoJy9hcGkvdjEvY3JlYXRlLXJmZicsIGdldFZTQ1VSTCh2c2NEb21haW4sICd3c3MnKSkudG9TdHJpbmcoKSk7XG4gICAgYXdhaXQgY29ubmVjdGlvbi5jb25uZWN0ZWQoKTtcbiAgICBsb2dnZXIkaS5kZWJ1ZygndnNjQ3JlYXRlUkZGJywge1xuICAgICAgICBleHBlY3RlZENvbGxlY3Rpb25JbmRleGVzLFxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbm5lY3Rpb24uc29ja2V0LnNlbmQocGFjayh7IGlkOiBpZC50b051bWJlcigpIH0pKTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCByZXNwIG9mIGNvbm5lY3Rpb24uc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdW5wYWNrKHJlc3ApO1xuICAgICAgICAgICAgbG9nZ2VyJGkuZGVidWcoJ3ZzY0NyZWF0ZVJGRjpyZXNwb25zZScsIHsgZGF0YSB9KTtcbiAgICAgICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gMjU1KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkQ29sbGVjdGlvbkluZGV4ZXMubGVuZ3RoID09PSByZWNlaXZlZENvbGxlY3Rpb25zQUNLcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbXNkKElOVEVOVF9DT0xMRUNUSU9OX0NPTVBMRVRFKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkaS5kZWJ1ZygnKHZzYyljcmVhdGUtcmZmOmNvbGxlY3Rpb25zIGZhaWxlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkQ29sbGVjdGlvbkluZGV4ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZENvbGxlY3Rpb25zQUNLcyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignKHZzYyljcmVhdGUtcmZmOiBjb2xsZWN0aW9ucyBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLnN0YXR1cyA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWRDb2xsZWN0aW9uSW5kZXhlcy5pbmNsdWRlcyhkYXRhLmlkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWRDb2xsZWN0aW9uc0FDS3MucHVzaChkYXRhLmlkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1zZChJTlRFTlRfQ09MTEVDVElPTihyZWNlaXZlZENvbGxlY3Rpb25zQUNLcy5sZW5ndGgpLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1lZDogcmVjZWl2ZWRDb2xsZWN0aW9uc0FDS3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbDogZXhwZWN0ZWRDb2xsZWN0aW9uSW5kZXhlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWRDb2xsZWN0aW9uSW5kZXhlcy5pbmNsdWRlcyhkYXRhLmlkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAodnNjKWNyZWF0ZS1yZmY6ICR7ZGF0YS5lcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciRpLmRlYnVnKCd2c2NDcmVhdGVSRkY6RXhwZWN0ZWRFcnJvcjppZ25vcmUnLCB7IGRhdGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxufTtcbmNvbnN0IGNoZWNrSW50ZW50RmlsbGVkID0gYXN5bmMgKGludGVudElELCBncnBjVVJMKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRDb3Ntb3NRdWVyeUNsaWVudChncnBjVVJMKS5SZXF1ZXN0Rm9yRnVuZHMoe1xuICAgICAgICBpZDogaW50ZW50SUQsXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnJlcXVlc3RGb3JGdW5kcz8uZnVsZmlsbGVkKSB7XG4gICAgICAgIHJldHVybiAnb2snO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBmaWxsZWQgeWV0Jyk7XG59O1xuXG5jb25zdCBsb2dnZXIkaCA9IGdldExvZ2dlcigpO1xuY29uc3QgZ2V0U291cmNlc0FuZERlc3RpbmF0aW9uc0ZvclJGRiA9IChpbnRlbnQsIGNoYWluTGlzdCwgZGVzdGluYXRpb25Vbml2ZXJzZSkgPT4ge1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBjb25zdCB1bml2ZXJzZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qgc291cmNlQ291bnRzID0ge1xuICAgICAgICBbVW5pdmVyc2UuRVRIRVJFVU1dOiAwLFxuICAgICAgICBbVW5pdmVyc2UuRlVFTF06IDAsXG4gICAgICAgIFtVbml2ZXJzZS5TT0xBTkFdOiAwLFxuICAgICAgICBbVW5pdmVyc2UuVU5SRUNPR05JWkVEXTogMCxcbiAgICB9O1xuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIGludGVudC5zb3VyY2VzKSB7XG4gICAgICAgIGlmIChzb3VyY2UuY2hhaW5JRCA9PSBpbnRlbnQuZGVzdGluYXRpb24uY2hhaW5JRCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW4gPSBjaGFpbkxpc3QuZ2V0VG9rZW5CeUFkZHJlc3Moc291cmNlLmNoYWluSUQsIHNvdXJjZS50b2tlbkNvbnRyYWN0KTtcbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgbG9nZ2VyJGguZXJyb3IoJ1Rva2VuIG5vdCBmb3VuZCcsIHsgc291cmNlIH0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b2tlbiBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VDb3VudHNbc291cmNlLnVuaXZlcnNlXSArPSAxO1xuICAgICAgICB1bml2ZXJzZXMuYWRkKHNvdXJjZS51bml2ZXJzZSk7XG4gICAgICAgIHNvdXJjZXMucHVzaCh7XG4gICAgICAgICAgICBjaGFpbklEOiBCaWdJbnQoc291cmNlLmNoYWluSUQpLFxuICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KHNvdXJjZS50b2tlbkNvbnRyYWN0KSxcbiAgICAgICAgICAgIHVuaXZlcnNlOiBzb3VyY2UudW5pdmVyc2UsXG4gICAgICAgICAgICB2YWx1ZTogbXVsRGVjaW1hbHMoc291cmNlLmFtb3VudCwgdG9rZW4uZGVjaW1hbHMpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5pdmVyc2VzLmFkZChpbnRlbnQuZGVzdGluYXRpb24udW5pdmVyc2UpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9ucyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KGludGVudC5kZXN0aW5hdGlvbi50b2tlbkNvbnRyYWN0KSxcbiAgICAgICAgICAgIHVuaXZlcnNlOiBpbnRlbnQuZGVzdGluYXRpb24udW5pdmVyc2UsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KGludGVudC5kZXN0aW5hdGlvbi5hbW91bnRcbiAgICAgICAgICAgICAgICAubXVsKERlY2ltYWwucG93KDEwLCBpbnRlbnQuZGVzdGluYXRpb24uZGVjaW1hbHMpKVxuICAgICAgICAgICAgICAgIC50b0ZpeGVkKDAsIERlY2ltYWwuUk9VTkRfRkxPT1IpKSxcbiAgICAgICAgfSxcbiAgICBdO1xuICAgIGlmIChpbnRlbnQuZGVzdGluYXRpb24uZ2FzICE9IDBuKSB7XG4gICAgICAgIGlmIChpc05hdGl2ZUFkZHJlc3MkMShpbnRlbnQuZGVzdGluYXRpb24udW5pdmVyc2UsIGludGVudC5kZXN0aW5hdGlvbi50b2tlbkNvbnRyYWN0KSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25zWzBdLnZhbHVlID0gZGVzdGluYXRpb25zWzBdLnZhbHVlICsgaW50ZW50LmRlc3RpbmF0aW9uLmdhcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGNvbnZlcnRUbzMyQnl0ZXNIZXgoZGVzdGluYXRpb25Vbml2ZXJzZSA9PT0gVW5pdmVyc2UuRlVFTCA/IEZVRUxfQkFTRV9BU1NFVF9JRCA6IFpFUk9fQUREUkVTUyksXG4gICAgICAgICAgICAgICAgdW5pdmVyc2U6IGludGVudC5kZXN0aW5hdGlvbi51bml2ZXJzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW50ZW50LmRlc3RpbmF0aW9uLmdhcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGRlc3RpbmF0aW9ucywgc291cmNlQ291bnRzLCBzb3VyY2VzLCB1bml2ZXJzZXMgfTtcbn07XG5jb25zdCBjcmVhdGVSRkZyb21JbnRlbnQgPSBhc3luYyAoaW50ZW50LCBvcHRpb25zLCBkZXN0aW5hdGlvblVuaXZlcnNlKSA9PiB7XG4gICAgY29uc3QgeyBkZXN0aW5hdGlvbnMsIHNvdXJjZXMsIHVuaXZlcnNlcyB9ID0gZ2V0U291cmNlc0FuZERlc3RpbmF0aW9uc0ZvclJGRihpbnRlbnQsIG9wdGlvbnMuY2hhaW5MaXN0LCBkZXN0aW5hdGlvblVuaXZlcnNlKTtcbiAgICBjb25zdCBwYXJ0aWVzID0gW107XG4gICAgZm9yIChjb25zdCB1bml2ZXJzZSBvZiB1bml2ZXJzZXMpIHtcbiAgICAgICAgaWYgKHVuaXZlcnNlID09PSBVbml2ZXJzZS5FVEhFUkVVTSkge1xuICAgICAgICAgICAgcGFydGllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KG9wdGlvbnMuZXZtLmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgIHVuaXZlcnNlOiB1bml2ZXJzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml2ZXJzZSA9PT0gVW5pdmVyc2UuRlVFTCkge1xuICAgICAgICAgICAgcGFydGllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KG9wdGlvbnMuZnVlbC5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICB1bml2ZXJzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ2dlciRoLmRlYnVnKCdwcm9jZXNzUkZGOjEnLCB7XG4gICAgICAgIGRlc3RpbmF0aW9ucyxcbiAgICAgICAgcGFydGllcyxcbiAgICAgICAgc291cmNlcyxcbiAgICAgICAgdW5pdmVyc2VzLFxuICAgIH0pO1xuICAgIGNvbnN0IG9tbml2ZXJzYWxSRkYgPSBuZXcgT21uaXZlcnNhbFJGRih7XG4gICAgICAgIGRlc3RpbmF0aW9uQ2hhaW5JRDogY29udmVydFRvMzJCeXRlcyQxKGludGVudC5kZXN0aW5hdGlvbi5jaGFpbklEKSxcbiAgICAgICAgZGVzdGluYXRpb25zOiBkZXN0aW5hdGlvbnMubWFwKChkZXN0KSA9PiAoe1xuICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiB0b0J5dGVzKGRlc3QudG9rZW5BZGRyZXNzKSxcbiAgICAgICAgICAgIHZhbHVlOiB0b0J5dGVzKGRlc3QudmFsdWUpLFxuICAgICAgICB9KSksXG4gICAgICAgIGRlc3RpbmF0aW9uVW5pdmVyc2U6IGludGVudC5kZXN0aW5hdGlvbi51bml2ZXJzZSxcbiAgICAgICAgZXhwaXJ5OiBMb25nLmZyb21TdHJpbmcoKEJpZ0ludChEYXRlLm5vdygpICsgSU5URU5UX0VYUElSWSkgLyAxMDAwbikudG9TdHJpbmcoKSksXG4gICAgICAgIG5vbmNlOiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgzMikpLFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHNpZ25hdHVyZURhdGE6IHBhcnRpZXMubWFwKChwKSA9PiAoe1xuICAgICAgICAgICAgYWRkcmVzczogdG9CeXRlcyhwLmFkZHJlc3MpLFxuICAgICAgICAgICAgdW5pdmVyc2U6IHAudW5pdmVyc2UsXG4gICAgICAgIH0pKSxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBzb3VyY2VzOiBzb3VyY2VzLm1hcCgoc291cmNlKSA9PiAoe1xuICAgICAgICAgICAgY2hhaW5JRDogY29udmVydFRvMzJCeXRlcyQxKHNvdXJjZS5jaGFpbklEKSxcbiAgICAgICAgICAgIHRva2VuQWRkcmVzczogY29udmVydFRvMzJCeXRlcyQxKHNvdXJjZS50b2tlbkFkZHJlc3MpLFxuICAgICAgICAgICAgdW5pdmVyc2U6IHNvdXJjZS51bml2ZXJzZSxcbiAgICAgICAgICAgIHZhbHVlOiB0b0J5dGVzKHNvdXJjZS52YWx1ZSksXG4gICAgICAgIH0pKSxcbiAgICB9KTtcbiAgICBjb25zdCBzaWduYXR1cmVEYXRhID0gW107XG4gICAgZm9yIChjb25zdCB1bml2ZXJzZSBvZiB1bml2ZXJzZXMpIHtcbiAgICAgICAgaWYgKHVuaXZlcnNlID09PSBVbml2ZXJzZS5FVEhFUkVVTSkge1xuICAgICAgICAgICAgY29uc3QgeyByZXF1ZXN0SGFzaCwgc2lnbmF0dXJlIH0gPSBhd2FpdCBjcmVhdGVSZXF1ZXN0RVZNU2lnbmF0dXJlKG9tbml2ZXJzYWxSRkYuYXNFVk1SRkYoKSwgb3B0aW9ucy5ldm0uYWRkcmVzcywgb3B0aW9ucy5ldm0uY2xpZW50KTtcbiAgICAgICAgICAgIHNpZ25hdHVyZURhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogY29udmVydFRvMzJCeXRlcyQxKG9wdGlvbnMuZXZtLmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RIYXNoLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICB1bml2ZXJzZTogVW5pdmVyc2UuRVRIRVJFVU0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdmVyc2UgPT09IFVuaXZlcnNlLkZVRUwpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5mdWVsPy5hZGRyZXNzIHx8ICFvcHRpb25zLmZ1ZWw/LnByb3ZpZGVyIHx8ICFvcHRpb25zLmZ1ZWw/LmNvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRoLmVycm9yKCd1bml2ZXJzZSBoYXMgZnVlbCBidXQgbm90IGV4cGVjdGVkIGlucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICBmdWVsSW5wdXQ6IG9wdGlvbnMuZnVlbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaXZlcnNlIGhhcyBmdWVsIGJ1dCBub3QgZXhwZWN0ZWQgaW5wdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWVzdEhhc2gsIHNpZ25hdHVyZSB9ID0gYXdhaXQgY3JlYXRlUmVxdWVzdEZ1ZWxTaWduYXR1cmUob3B0aW9ucy5jaGFpbkxpc3QuZ2V0VmF1bHRDb250cmFjdEFkZHJlc3MoQ0hBSU5fSURTLmZ1ZWwubWFpbm5ldCksIG9wdGlvbnMuZnVlbC5wcm92aWRlciwgb3B0aW9ucy5mdWVsLmNvbm5lY3Rvciwgb21uaXZlcnNhbFJGRi5hc0Z1ZWxSRkYoKSk7XG4gICAgICAgICAgICBzaWduYXR1cmVEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRvQnl0ZXMob3B0aW9ucy5mdWVsLmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RIYXNoLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICB1bml2ZXJzZTogVW5pdmVyc2UuRlVFTCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1zZ0Jhc2ljQ29zbW9zID0gTXNnQ3JlYXRlUmVxdWVzdEZvckZ1bmRzLmNyZWF0ZSh7XG4gICAgICAgIGRlc3RpbmF0aW9uQ2hhaW5JRDogb21uaXZlcnNhbFJGRi5wcm90b2J1ZlJGRi5kZXN0aW5hdGlvbkNoYWluSUQsXG4gICAgICAgIGRlc3RpbmF0aW9uczogb21uaXZlcnNhbFJGRi5wcm90b2J1ZlJGRi5kZXN0aW5hdGlvbnMsXG4gICAgICAgIGRlc3RpbmF0aW9uVW5pdmVyc2U6IG9tbml2ZXJzYWxSRkYucHJvdG9idWZSRkYuZGVzdGluYXRpb25Vbml2ZXJzZSxcbiAgICAgICAgZXhwaXJ5OiBvbW5pdmVyc2FsUkZGLnByb3RvYnVmUkZGLmV4cGlyeSxcbiAgICAgICAgbm9uY2U6IG9tbml2ZXJzYWxSRkYucHJvdG9idWZSRkYubm9uY2UsXG4gICAgICAgIHNpZ25hdHVyZURhdGE6IHNpZ25hdHVyZURhdGEubWFwKChzKSA9PiAoe1xuICAgICAgICAgICAgYWRkcmVzczogcy5hZGRyZXNzLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBzLnNpZ25hdHVyZSxcbiAgICAgICAgICAgIHVuaXZlcnNlOiBzLnVuaXZlcnNlLFxuICAgICAgICB9KSksXG4gICAgICAgIHNvdXJjZXM6IG9tbml2ZXJzYWxSRkYucHJvdG9idWZSRkYuc291cmNlcyxcbiAgICAgICAgdXNlcjogb3B0aW9ucy5jb3Ntb3MuYWRkcmVzcyxcbiAgICB9KTtcbiAgICBsb2dnZXIkaC5kZWJ1ZygncHJvY2Vzc1JGRjoyJywge1xuICAgICAgICBtc2dCYXNpY0Nvc21vcyxcbiAgICAgICAgb21uaXZlcnNhbFJGRixcbiAgICAgICAgc2lnbmF0dXJlRGF0YSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtc2dCYXNpY0Nvc21vcyxcbiAgICAgICAgb21uaXZlcnNhbFJGRixcbiAgICAgICAgc2lnbmF0dXJlRGF0YSxcbiAgICAgICAgc291cmNlcyxcbiAgICAgICAgdW5pdmVyc2VzLFxuICAgIH07XG59O1xuXG5jb25zdCBLQUlBX0NIQUlOX0lEID0gODIxNztcbmNvbnN0IFNPUEhPTl9DSEFJTl9JRCA9IDUwMTA0O1xuY29uc3QgSFlQRVJFVk1fQ0hBSU5fSUQgPSAweDNlNztcbmNvbnN0IE1PTkFEX1RFU1RORVRfQ0hBSU5fSUQgPSAxMDE0MztcbmNvbnN0IEZVRUxfTkVUV09SS19VUkwgPSAnaHR0cHM6Ly9tYWlubmV0LmZ1ZWwubmV0d29yay92MS9ncmFwaHFsJztcbmNvbnN0IFN5bWJvbFRvTG9nbyA9IHtcbiAgICBCTkI6ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy84MjUvbGFyZ2UvYm5iLWljb24yXzJ4LnBuZycsXG4gICAgQVZBWDogJ2h0dHBzOi8vYXNzZXRzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzEyNTU5L3N0YW5kYXJkL0F2YWxhbmNoZV9DaXJjbGVfUmVkV2hpdGVfVHJhbnMucG5nJyxcbiAgICBFVEg6ICdodHRwczovL2NvaW4taW1hZ2VzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzI3OS9sYXJnZS9ldGhlcmV1bS5wbmcnLFxuICAgIEtBSUE6ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8zOTkwMS9sYXJnZS9LQUlBLnBuZycsXG4gICAgTUFUSUM6ICdodHRwczovL2NvaW4taW1hZ2VzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzMyNDQwL3N0YW5kYXJkL3BvbHlnb24ucG5nJyxcbiAgICBNT046ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8zODkyNy9sYXJnZS9tb25hZC5qcGcnLFxuICAgIFBPTDogJ2h0dHBzOi8vY29pbi1pbWFnZXMuY29pbmdlY2tvLmNvbS9jb2lucy9pbWFnZXMvMzI0NDAvc3RhbmRhcmQvcG9seWdvbi5wbmcnLFxuICAgIFNPUEg6ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8zODY4MC9sYXJnZS9zb3Bob25fbG9nb18yMDAucG5nJyxcbiAgICBVU0RDOiAnaHR0cHM6Ly9jb2luLWltYWdlcy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy82MzE5L2xhcmdlL3VzZGMucG5nJyxcbiAgICBVU0RUOiAnaHR0cHM6Ly9jb2luLWltYWdlcy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8zNTAyMy9sYXJnZS9VU0RULnBuZycsXG4gICAgV0VUSDogJ2h0dHBzOi8vY29pbi1pbWFnZXMuY29pbmdlY2tvLmNvbS9jb2lucy9pbWFnZXMvMjUxOC9zdGFuZGFyZC93ZXRoLnBuZycsXG4gICAgSFlQRTogJ2h0dHBzOi8vYXNzZXRzLmNvaW5nZWNrby5jb20vY29pbnMvaW1hZ2VzLzUwODgyL2xhcmdlL2h5cGVybGlxdWlkLmpwZycsXG59O1xuY29uc3QgRlVFTF9CQVNFX0FTU0VUX0lEID0gJzB4ZjhmOGI2MjgzZDdmYTViNjcyYjUzMGNiYjg0ZmNjY2I0ZmY4ZGM0MGY4MTc2ZWY0NTQ0ZGRiMWYxOTUyYWQwNyc7XG5jb25zdCBnZXRMb2dvRnJvbVN5bWJvbCA9IChzeW1ib2wpID0+IHtcbiAgICBjb25zdCBsb2dvID0gU3ltYm9sVG9Mb2dvW3N5bWJvbF07XG4gICAgaWYgKCFsb2dvKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGxvZ287XG59O1xuY29uc3QgaXNOYXRpdmVBZGRyZXNzJDEgPSAodW5pdmVyc2UsIGFkZHJlc3MpID0+IHtcbiAgICBpZiAodW5pdmVyc2UgPT09IFVuaXZlcnNlLkVUSEVSRVVNKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzID09PSBaRVJPX0FERFJFU1MgfHwgYWRkcmVzcyA9PT0gWkVST19BRERSRVNTX0ZVRUw7XG4gICAgfVxuICAgIGlmICh1bml2ZXJzZSA9PT0gVW5pdmVyc2UuRlVFTCkge1xuICAgICAgICByZXR1cm4gYWRkcmVzcyA9PT0gRlVFTF9CQVNFX0FTU0VUX0lEO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgb3RoZXIgdW5pdmVyc2VzIG9yIHJldHVybiBmYWxzZSBieSBkZWZhdWx0XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IElOVEVOVF9FWFBJUlkgPSAxNSAqIDYwICogMTAwMDtcbmNvbnN0IEFhdmVUb2tlbkNvbnRyYWN0cyA9IHtcbiAgICAxOiB7XG4gICAgICAgIFVTREM6ICcweDk4QzIzRTlkOGYzNEZFRmIxQjdCRDZhOTFCN0ZGMTIyRjRlMTZGNWMnLFxuICAgICAgICBVU0RUOiAnMHgyMzg3ODkxNEVGRTM4ZDI3QzRENjdBYjgzZWQxYjkzQTc0RDQwODZhJyxcbiAgICAgICAgV0VUSDogJzB4NGQ1RjQ3RkE2QTc0NzU3ZjM1QzE0ZkQzYTZFZjhFM0M5QkM1MTRFOCcsXG4gICAgfSxcbiAgICAxMDoge1xuICAgICAgICBVU0RDOiAnMHgzOGQ2OTNjRTFkRjVBYURGN2JDNjI1OTVBMzdENjY3YUQ1NzkyMmU1JyxcbiAgICAgICAgVVNEVDogJzB4NmFiNzA3QWNhOTUzZURBZUZCYzRmRDIzYkE3MzI5NDI0MTQ5MDYyMCcsXG4gICAgICAgIFdFVEg6ICcweGU1MGZBOWIzYzU2RmZCMTU5Y0IwRkNBNjFGNWM5RDc1MGU4MTI4YzgnLFxuICAgIH0sXG4gICAgMTExNTU0MjA6IHtcbiAgICAgICAgVVNEQzogJzB4YTgxOEYxQjU3YzIwMUUwOTJDNEEyMDE3QTkxODE1MDM0MzI2RWZkMScsXG4gICAgfSxcbiAgICAxMzc6IHtcbiAgICAgICAgVVNEQzogJzB4QTREOTQwMTk5MzREODMzM0VmODgwQUJGRmJGMkZEZDYxMUM3NjJCRCcsXG4gICAgICAgIFVTRFQ6ICcweDZhYjcwN0FjYTk1M2VEQWVGQmM0ZkQyM2JBNzMyOTQyNDE0OTA2MjAnLFxuICAgICAgICBXRVRIOiAnMHhlNTBmQTliM2M1NkZmQjE1OWNCMEZDQTYxRjVjOUQ3NTBlODEyOGM4JyxcbiAgICB9LFxuICAgIDQyMTYxOiB7XG4gICAgICAgIFVTREM6ICcweDcyNGRjODA3YjA0NTU1YjcxZWQ0OGE2ODk2YjZGNDE1OTNiOEM2MzcnLFxuICAgICAgICBVU0RUOiAnMHg2YWI3MDdBY2E5NTNlREFlRkJjNGZEMjNiQTczMjk0MjQxNDkwNjIwJyxcbiAgICAgICAgV0VUSDogJzB4ZTUwZkE5YjNjNTZGZkIxNTljQjBGQ0E2MUY1YzlENzUwZTgxMjhjOCcsXG4gICAgfSxcbiAgICAvLyBUZXN0bmV0IGNoYWluc1xuICAgIDQyMTYxNDoge1xuICAgICAgICBVU0RDOiAnMHg0NjBiOTdCRDQ5OEUxMTU3NTMwQUViMzA4NjMwMWQ1MjI1YjkxMjE2JyxcbiAgICB9LFxuICAgIDQzMTE0OiB7XG4gICAgICAgIFVTREM6ICcweDYyNUU3NzA4ZjMwY0E3NWJmZDkyNTg2ZTE3MDc3NTkwQzYwZWI0Y0QnLFxuICAgICAgICBVU0RUOiAnMHg2YWI3MDdBY2E5NTNlREFlRkJjNGZEMjNiQTczMjk0MjQxNDkwNjIwJyxcbiAgICAgICAgV0VUSDogJzB4ZTUwZkE5YjNjNTZGZkIxNTljQjBGQ0E2MUY1YzlENzUwZTgxMjhjOCcsXG4gICAgfSxcbiAgICA1MzQzNTI6IHtcbiAgICAgICAgVVNEQzogJzB4MUQ3MzhhMzQzNkE4QzQ5Q2VmRmJhQjdmYkYwNEI2NjBmYjUyOENiRCcsXG4gICAgICAgIFdFVEg6ICcweGYzMDE4MDViRTFEZjgxMTAyQzk1N2Y2ZDRDZTI5ZDJCOGMwNTZCMmEnLFxuICAgIH0sXG4gICAgNTY6IHtcbiAgICAgICAgVVNEQzogJzB4MDA5MDFhMDc2Nzg1ZTA5MDZkMTAyOGM3ZDYzNzJkMjQ3YmVjN2Q2MScsXG4gICAgICAgIFVTRFQ6ICcweGE5MjUxY2E5REU5MDlDQjcxNzgzNzIzNzEzQjIxRTQyMzNmYmYxQjEnLFxuICAgIH0sXG4gICAgNTkxNDQ6IHtcbiAgICAgICAgVVNEQzogJzB4Mzc0RDc4NjBjNGYyZjYwNERlMDE5MTI5OGREMzkzNzAzQ2NlODRmMycsXG4gICAgICAgIFVTRFQ6ICcweDg4MjMxZGZFQzcxRDRGRjVjMWU0NjZEMDhDMzIxOTQ0QTdhZEM2NzMnLFxuICAgICAgICBXRVRIOiAnMHg3ODc4OTdkRjkyNzAzQkIzRmM0ZDlFZTk4ZTE1QzBiODEzMEJmMTYzJyxcbiAgICB9LFxuICAgIDg0NTM6IHtcbiAgICAgICAgVVNEQzogJzB4NGU2NWZFNERiQTkyNzkwNjk2ZDA0MGFjMjRBYTQxNDcwOEY1YzBBQicsXG4gICAgICAgIFdFVEg6ICcweDdDMzA3ZTEyOGVmQTMxRjU0MEYyRTJkOTc2Qzk5NUUwQjY1RjUxRjYnLFxuICAgIH0sXG4gICAgODQ1MzI6IHtcbiAgICAgICAgVVNEQzogJzB4MTBGMUE5RDExQ0RmNTAwNDFmM2Y4Y0I3MTkxQ0JFMmYzMTc1MEFDQycsXG4gICAgICAgIFVTRFQ6ICcweGNFM0NBYWU1RWQxN0E3QWFmQ0VFYmM4OTdERTg0M2ZBNkNDMGMwMTgnLFxuICAgIH0sXG59O1xuY29uc3QgVE9LRU5fTUlOVEVSX0NPTlRSQUNUUyA9IHtcbiAgICA1MzQzNTI6IHtcbiAgICAgICAgVVNEVDogJzB4ZTJiNDc5NTAzOTUxNzY1M2M1YWU4YzJhOWJmZGQ3ODNiNDhmNDQ3YScsXG4gICAgfSxcbiAgICA1OTE0NDoge1xuICAgICAgICBVU0RDOiAnMHhBMkVlNkZjZTRBQ0I2MkQ5NTQ0ODcyOWNEYjc4MWUzQkViNjI1MDRBJyxcbiAgICAgICAgVVNEVDogJzB4MzUzMDEyZGM0YTlBNmNGNTVjOTQxYkFEQzI2N2Y4MjAwNEE4Y2VCOScsXG4gICAgfSxcbiAgICA4NDUzOiB7XG4gICAgICAgIFVTRFQ6ICcweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAnLFxuICAgIH0sXG59O1xuY29uc3QgVE9QX09XTkVSID0ge1xuICAgIFtTT1BIT05fQ0hBSU5fSURdOiB7XG4gICAgICAgIEVUSDogJzB4MzUzQjM1YTMzNjJEZmY4MTc0Y2Q5Njc5QkM0YTQ2MzY1Q2NENGRBNycsXG4gICAgICAgIFVTREM6ICcweDYxYTg3ZmE2RGQ4OWEyM2M3OEYwNzU0RUYzMzcyZDM1Y2NkZTU5MzUnLFxuICAgICAgICBVU0RUOiAnMHg2MWE4N2ZhNkRkODlhMjNjNzhGMDc1NEVGMzM3MmQzNWNjZGU1OTM1JyxcbiAgICB9LFxufTtcbmNvbnN0IFpFUk9fQUREUkVTUyA9ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnO1xuY29uc3QgWkVST19BRERSRVNTX0ZVRUwgPSBjb252ZXJ0VG8zMkJ5dGVzSGV4KFpFUk9fQUREUkVTUyk7XG5cbmNsYXNzIENoYWluTGlzdCB7XG4gICAgY29uc3RydWN0b3IoZW52KSB7XG4gICAgICAgIHN3aXRjaCAoZW52KSB7XG4gICAgICAgICAgICBjYXNlIEVudmlyb25tZW50LkNFUklTRTpcbiAgICAgICAgICAgIGNhc2UgRW52aXJvbm1lbnQuQ09SQUw6XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFpbnMgPSBNQUlOTkVUX0NIQUlOUztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRW52aXJvbm1lbnQuRk9MTFk6XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFpbnMgPSBURVNUTkVUX0NIQUlOUztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRW52aXJvbm1lbnQuSkFERTpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0phZGUgZW52aXJvbm1lbnQgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVudmlyb25tZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52Y20gPSBnZXRWYXVsdENvbnRyYWN0TWFwKGVudik7XG4gICAgfVxuICAgIGdldENoYWluQnlJRChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbnMuZmluZCgoYykgPT4gYy5pZCA9PT0gaWQpO1xuICAgIH1cbiAgICBnZXROYXRpdmVUb2tlbihjaGFpbklEKSB7XG4gICAgICAgIGNvbnN0IGNoYWluID0gdGhpcy5nZXRDaGFpbkJ5SUQoY2hhaW5JRCk7XG4gICAgICAgIGlmICghY2hhaW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hhaW4gbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogWkVST19BRERSRVNTLFxuICAgICAgICAgICAgZGVjaW1hbHM6IGNoYWluLm5hdGl2ZUN1cnJlbmN5LmRlY2ltYWxzLFxuICAgICAgICAgICAgbG9nbzogY2hhaW4uY3VzdG9tLmljb24sXG4gICAgICAgICAgICBuYW1lOiBjaGFpbi5uYXRpdmVDdXJyZW5jeS5uYW1lLFxuICAgICAgICAgICAgc3ltYm9sOiBjaGFpbi5uYXRpdmVDdXJyZW5jeS5zeW1ib2wsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFRva2VuQnlBZGRyZXNzKGNoYWluSUQsIGFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgY2hhaW4gPSB0aGlzLmdldENoYWluQnlJRChjaGFpbklEKTtcbiAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbiA9IGNoYWluLmN1c3RvbS5rbm93blRva2Vucy5maW5kKCh0KSA9PiBlcXVhbEZvbGQodC5jb250cmFjdEFkZHJlc3MsIGFkZHJlc3MpKTtcbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgaWYgKGVxdWFsRm9sZChhZGRyZXNzLCBaRVJPX0FERFJFU1MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlVG9rZW4oY2hhaW5JRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICBnZXRUb2tlbkluZm9CeVN5bWJvbChjaGFpbklELCBzeW1ib2wpIHtcbiAgICAgICAgY29uc3QgY2hhaW4gPSB0aGlzLmdldENoYWluQnlJRChjaGFpbklEKTtcbiAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbiA9IGNoYWluLmN1c3RvbS5rbm93blRva2Vucy5maW5kKCh0KSA9PiBlcXVhbEZvbGQodC5zeW1ib2wsIHN5bWJvbCkpO1xuICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICBpZiAoZXF1YWxGb2xkKGNoYWluLm5hdGl2ZUN1cnJlbmN5LnN5bWJvbCwgc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogWkVST19BRERSRVNTLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogY2hhaW4ubmF0aXZlQ3VycmVuY3kuZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgICAgIGxvZ286IGNoYWluLmN1c3RvbS5pY29uLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjaGFpbi5uYXRpdmVDdXJyZW5jeS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IGNoYWluLm5hdGl2ZUN1cnJlbmN5LnN5bWJvbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgZ2V0VmF1bHRDb250cmFjdEFkZHJlc3MoY2hhaW5JRCkge1xuICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuZ2V0Q2hhaW5CeUlEKGNoYWluSUQpO1xuICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYWluIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbW5pdmVyc2FsQ2hhaW5JRCA9IG5ldyBPbW5pdmVyc2FsQ2hhaW5JRChjaGFpbi51bml2ZXJzZSwgY2hhaW5JRCk7XG4gICAgICAgIGNvbnN0IHZjID0gdGhpcy52Y20uZ2V0KG9tbml2ZXJzYWxDaGFpbklEKTtcbiAgICAgICAgaWYgKCF2Yykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXVsdCBjb250cmFjdCBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvSGV4QWRkcmVzc0J5VW5pdmVyc2UodmMsIGNoYWluLnVuaXZlcnNlKTtcbiAgICB9XG4gICAgZ2V0QW5rck5hbWVMaXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbnMubWFwKChjKSA9PiBjLmFua3JOYW1lKS5maWx0ZXIoKG4pID0+IG4gIT09ICcnKTtcbiAgICB9XG59XG5jb25zdCBURVNUTkVUX0NIQUlOUyA9IFtcbiAgICB7XG4gICAgICAgIGJsb2NrRXhwbG9yZXJzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0FyYml0cnVtIFNlcG9saWEgRXhwbG9yZXInLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vc2Vwb2xpYS5hcmJpc2Nhbi5pby8nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tOiB7XG4gICAgICAgICAgICBpY29uOiAnL2ltYWdlcy9sb2dvcy9hcmJpdHJ1bS5zdmcnLFxuICAgICAgICAgICAga25vd25Ub2tlbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4NzVmYWYxMTRlYWZiMUJEYmUyRjAzMTZERjg5M2ZkNThDRTQ2QUE0ZCcsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnVVNEQycpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVVNEIENvaW4nLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6ICdVU0RDJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiAnMHhGOTU0ZDRBNTg1OWIzN0RlODhhOTFiZGJiOEFkMzA5MDU2RkIwNEIxJyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnVVNEVCcpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVGVzdGluZyBVU0QnLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6ICdVU0RUJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IDQyMTYxNCxcbiAgICAgICAgbmFtZTogJ0FyYml0cnVtIFNlcG9saWEnLFxuICAgICAgICBhbmtyTmFtZTogJycsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7XG4gICAgICAgICAgICBkZWNpbWFsczogMTgsXG4gICAgICAgICAgICBuYW1lOiAnRXRoZXInLFxuICAgICAgICAgICAgc3ltYm9sOiAnRVRIJyxcbiAgICAgICAgfSxcbiAgICAgICAgcnBjVXJsczoge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGh0dHA6IFsnaHR0cHM6Ly9hcmItc2Vwb2xpYS5nLmFsY2hlbXkuY29tL3YyL1BmYXN3cktxMHJqT3JmWVdIZkU5dUxRS2hpRDRKQ2RxJ10sXG4gICAgICAgICAgICAgICAgcHVibGljSHR0cDogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9wdWJsaWMuc3RhY2t1cC5zaC9hcGkvdjEvbm9kZS9hcmJpdHJ1bS1zZXBvbGlhJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZW5kcG9pbnRzLm9tbmlhdGVjaC5pby92MS9hcmJpdHJ1bS9zZXBvbGlhL3B1YmxpYycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2FyYml0cnVtLXNlcG9saWEuZ2F0ZXdheS50ZW5kZXJseS5jbycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2FwaS56YW4udG9wL2FyYi1zZXBvbGlhJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdlYlNvY2tldDogWyd3c3M6Ly9hcmItc2Vwb2xpYS5nLmFsY2hlbXkuY29tL3YyL1BmYXN3cktxMHJqT3JmWVdIZkU5dUxRS2hpRDRKQ2RxJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB1bml2ZXJzZTogVW5pdmVyc2UuRVRIRVJFVU0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGJsb2NrRXhwbG9yZXJzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ09QIFNlcG9saWEgRXhwbG9yZXInLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vc2Vwb2xpYS1vcHRpbWlzbS5ldGhlcnNjYW4uaW8vJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbToge1xuICAgICAgICAgICAgaWNvbjogJy9pbWFnZXMvbG9nb3Mvb3B0aW1pc20uc3ZnJyxcbiAgICAgICAgICAgIGtub3duVG9rZW5zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6ICcweDVmZDg0MjU5ZDY2Q2Q0NjEyMzU0MDc2NkJlOTNERkU2RDQzMTMwRDcnLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogNixcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogZ2V0TG9nb0Zyb21TeW1ib2woJ1VTREMnKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1VTRCBDb2luJyxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiAnVVNEQycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4NjQ2MjY5M2MyRjIxQUMwRTUxN2YxMjY0MUQ0MDQ4OTUwMzBGNzQyNicsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogZ2V0TG9nb0Zyb21TeW1ib2woJ1VTRFQnKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1Rlc3RpbmcgVVNEJyxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiAnVVNEVCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIGlkOiAxMTE1NTQyMCxcbiAgICAgICAgbmFtZTogJ09QIFNlcG9saWEnLFxuICAgICAgICBhbmtyTmFtZTogJycsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7XG4gICAgICAgICAgICBkZWNpbWFsczogMTgsXG4gICAgICAgICAgICBuYW1lOiAnRXRoZXInLFxuICAgICAgICAgICAgc3ltYm9sOiAnRVRIJyxcbiAgICAgICAgfSxcbiAgICAgICAgcnBjVXJsczoge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGh0dHA6IFsnaHR0cHM6Ly9vcHQtc2Vwb2xpYS5nLmFsY2hlbXkuY29tL3YyL1BmYXN3cktxMHJqT3JmWVdIZkU5dUxRS2hpRDRKQ2RxJ10sXG4gICAgICAgICAgICAgICAgcHVibGljSHR0cDogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9hcGkuemFuLnRvcC9vcHQtc2Vwb2xpYScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2VuZHBvaW50cy5vbW5pYXRlY2guaW8vdjEvb3Avc2Vwb2xpYS9wdWJsaWMnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9vcHRpbWlzbS1zZXBvbGlhLmdhdGV3YXkudGVuZGVybHkuY28nLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9vcHRpbWlzbS1zZXBvbGlhLmFwaS5vbmZpbmFsaXR5LmlvL3B1YmxpYycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3ZWJTb2NrZXQ6IFsnd3NzOi8vb3B0LXNlcG9saWEuZy5hbGNoZW15LmNvbS92Mi9QZmFzd3JLcTByak9yZllXSGZFOXVMUUtoaUQ0SkNkcSddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdW5pdmVyc2U6IFVuaXZlcnNlLkVUSEVSRVVNLFxuICAgIH0sXG4gICAge1xuICAgICAgICBibG9ja0V4cGxvcmVyczoge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdBbW95IFBvbHlnb24gRXhwbG9yZXInLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vYW1veS5wb2x5Z29uc2Nhbi5jb20vJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbToge1xuICAgICAgICAgICAgaWNvbjogJy9pbWFnZXMvbG9nb3MvcG9seWdvbi5zdmcnLFxuICAgICAgICAgICAga25vd25Ub2tlbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4NDFFOTRFYjAxOUMwNzYyZjlCZmNmOUZiMUU1ODcyNUJmQjBlNzU4MicsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnVVNEQycpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVVNEIENvaW4nLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6ICdVU0RDJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IDgwMDAyLFxuICAgICAgICBuYW1lOiAnQW1veScsXG4gICAgICAgIGFua3JOYW1lOiAnJyxcbiAgICAgICAgbmF0aXZlQ3VycmVuY3k6IHtcbiAgICAgICAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgIG5hbWU6ICdQT0wnLFxuICAgICAgICAgICAgc3ltYm9sOiAnUE9MJyxcbiAgICAgICAgfSxcbiAgICAgICAgcnBjVXJsczoge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGh0dHA6IFsnaHR0cHM6Ly9wb2x5Z29uLWFtb3kuZy5hbGNoZW15LmNvbS92Mi9QZmFzd3JLcTByak9yZllXSGZFOXVMUUtoaUQ0SkNkcSddLFxuICAgICAgICAgICAgICAgIHB1YmxpY0h0dHA6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vcG9seWdvbi1hbW95LWJvci1ycGMucHVibGljbm9kZS5jb20nLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9ycGMtYW1veS5wb2x5Z29uLnRlY2hub2xvZ3knLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9wb2x5Z29uLWFtb3kuZ2F0ZXdheS50ZW5kZXJseS5jbycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3BvbHlnb24tYW1veS5kcnBjLm9yZycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3ZWJTb2NrZXQ6IFsnd3NzOi8vcG9seWdvbi1hbW95LmcuYWxjaGVteS5jb20vdjIvUGZhc3dyS3EwcmpPcmZZV0hmRTl1TFFLaGlENEpDZHEnXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHVuaXZlcnNlOiBVbml2ZXJzZS5FVEhFUkVVTSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYmxvY2tFeHBsb3JlcnM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnQmFzZXNjYW4nLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vc2Vwb2xpYS5iYXNlc2Nhbi5vcmcvJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbToge1xuICAgICAgICAgICAgaWNvbjogJy9pbWFnZXMvbG9nb3MvYmFzZS5zdmcnLFxuICAgICAgICAgICAga25vd25Ub2tlbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4MDM2Q2JENTM4NDJjNTQyNjYzNGU3OTI5NTQxZUMyMzE4ZjNkQ0Y3ZScsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnVVNEQycpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVVNEIENvaW4nLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6ICdVU0RDJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IDg0NTMyLFxuICAgICAgICBuYW1lOiAnQmFzZSBTZXBvbGlhJyxcbiAgICAgICAgYW5rck5hbWU6ICcnLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeToge1xuICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgbmFtZTogJ0V0aGVyJyxcbiAgICAgICAgICAgIHN5bWJvbDogJ0VUSCcsXG4gICAgICAgIH0sXG4gICAgICAgIHJwY1VybHM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBodHRwOiBbJ2h0dHBzOi8vYmFzZS1zZXBvbGlhLmcuYWxjaGVteS5jb20vdjIvUGZhc3dyS3EwcmpPcmZZV0hmRTl1TFFLaGlENEpDZHEnXSxcbiAgICAgICAgICAgICAgICBwdWJsaWNIdHRwOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3JwYy5ub3RhZGVnZW4uY29tL2Jhc2Uvc2Vwb2xpYScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3B1YmxpYy5zdGFja3VwLnNoL2FwaS92MS9ub2RlL2Jhc2Utc2Vwb2xpYScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2Jhc2Utc2Vwb2xpYS5nYXRld2F5LnRlbmRlcmx5LmNvJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYmFzZS1zZXBvbGlhLmRycGMub3JnJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdlYlNvY2tldDogWyd3c3M6Ly9iYXNlLXNlcG9saWEuZy5hbGNoZW15LmNvbS92Mi9QZmFzd3JLcTByak9yZllXSGZFOXVMUUtoaUQ0SkNkcSddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdW5pdmVyc2U6IFVuaXZlcnNlLkVUSEVSRVVNLFxuICAgIH0sXG4gICAge1xuICAgICAgICBibG9ja0V4cGxvcmVyczoge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdNb25hZCBUZXN0bmV0IEV4cGxvcmVyJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3Rlc3RuZXQubW9uYWRleHBsb3Jlci5jb20nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tOiB7XG4gICAgICAgICAgICBpY29uOiAnL2ltYWdlcy9sb2dvcy9iYXNlLnN2ZycsXG4gICAgICAgICAgICBrbm93blRva2VuczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiAnMHhmODE3MjU3ZmVkMzc5ODUzY0RlMGZhNEY5N0FCOTg3MTgxQjFFNUVhJyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDYsXG4gICAgICAgICAgICAgICAgICAgIGxvZ286IGdldExvZ29Gcm9tU3ltYm9sKCdVU0RDJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdVU0QgQ29pbicsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ1VTREMnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6ICcweDFjNTZGMTc2RDY3MzU4ODhmYkI2ZjhiRDlBREFkOEFkN2EwMjNhMGInLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogMTgsXG4gICAgICAgICAgICAgICAgICAgIGxvZ286IGdldExvZ29Gcm9tU3ltYm9sKCdVU0RUJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdUZXN0aW5nIFVTRFQnLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6ICdVU0RUJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IE1PTkFEX1RFU1RORVRfQ0hBSU5fSUQsXG4gICAgICAgIG5hbWU6ICdNb25hZCBUZXN0bmV0JyxcbiAgICAgICAgYW5rck5hbWU6ICcnLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeToge1xuICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgbmFtZTogJ01vbmFkJyxcbiAgICAgICAgICAgIHN5bWJvbDogJ01PTicsXG4gICAgICAgIH0sXG4gICAgICAgIHJwY1VybHM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBodHRwOiBbJ2h0dHBzOi8vbGIuZHJwYy5vcmcvbW9uYWQtdGVzdG5ldC9BbTVuRU5vSm1FdW92cXVpOF9MTXh6cDRDaEp6VzdrUjhKZlBycVJoZjBmRSddLFxuICAgICAgICAgICAgICAgIHB1YmxpY0h0dHA6IFsnaHR0cHM6Ly9tb25hZC10ZXN0bmV0LmRycGMub3JnJywgJ2h0dHBzOi8vcnBjLmFua3IuY29tL21vbmFkX3Rlc3RuZXQnXSxcbiAgICAgICAgICAgICAgICB3ZWJTb2NrZXQ6IFsnd3NzOi8vbGIuZHJwYy5vcmcvbW9uYWQtdGVzdG5ldC9BbTVuRU5vSm1FdW92cXVpOF9MTXh6cDRDaEp6VzdrUjhKZlBycVJoZjBmRSddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdW5pdmVyc2U6IFVuaXZlcnNlLkVUSEVSRVVNLFxuICAgIH0sXG4gICAge1xuICAgICAgICBibG9ja0V4cGxvcmVyczoge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdFdGhlcnNjYW4gU2Vwb2xpYScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9zZXBvbGlhLmV0aGVyc2Nhbi5pby8nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tOiB7XG4gICAgICAgICAgICBpY29uOiAnL2ltYWdlcy9sb2dvcy9iYXNlLnN2ZycsXG4gICAgICAgICAgICBrbm93blRva2VuczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiAnMHgxYzdENEIxOTZDYjBDN0IwMWQ3NDNGYmM2MTE2YTkwMjM3OUM3MjM4JyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDYsXG4gICAgICAgICAgICAgICAgICAgIGxvZ286IGdldExvZ29Gcm9tU3ltYm9sKCdVU0RDJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdVU0QgQ29pbicsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ1VTREMnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBpZDogMTExNTUxMTEsXG4gICAgICAgIG5hbWU6ICdFdGhlcmV1bSBTZXBvbGlhJyxcbiAgICAgICAgYW5rck5hbWU6ICcnLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeToge1xuICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgbmFtZTogJ0V0aGVyJyxcbiAgICAgICAgICAgIHN5bWJvbDogJ0VUSCcsXG4gICAgICAgIH0sXG4gICAgICAgIHJwY1VybHM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBodHRwOiBbJ2h0dHBzOi8vc2Vwb2xpYS5kcnBjLm9yZyddLFxuICAgICAgICAgICAgICAgIHB1YmxpY0h0dHA6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLnphbi50b3AvZXRoLXNlcG9saWEnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9ldGhlcmV1bS1zZXBvbGlhLXB1YmxpYy5ub2RpZXMuYXBwJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdlYlNvY2tldDogWyd3c3M6Ly9zZXBvbGlhLmRycGMub3JnJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB1bml2ZXJzZTogVW5pdmVyc2UuRVRIRVJFVU0sXG4gICAgfSxcbl07XG5jb25zdCBNQUlOTkVUX0NIQUlOUyA9IFtcbiAgICB7XG4gICAgICAgIGJsb2NrRXhwbG9yZXJzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0Z1ZWwgTmV0d29yayBFeHBsb3JlcicsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9hcHAuZnVlbC5uZXR3b3JrLycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBjdXN0b206IHtcbiAgICAgICAgICAgIGljb246ICdodHRwczovL2F2YXRhcnMuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3UvNTU5OTMxODMnLFxuICAgICAgICAgICAga25vd25Ub2tlbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogRlVFTF9CQVNFX0FTU0VUX0lELFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogOSxcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogZ2V0TG9nb0Zyb21TeW1ib2woJ0VUSCcpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRXRoZXInLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6ICdFVEgnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6ICcweDI4NmM0NzlkYTQwZGM5NTNiZGRjM2JiNGM0NTNiNjA4YmJhMmUwYWM0ODNiMDc3YmQ0NzUxNzQxMTUzOTVlNmInLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogNixcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogZ2V0TG9nb0Zyb21TeW1ib2woJ1VTREMnKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1VTRCBDb2luJyxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiAnVVNEQycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4YTAyNjVmYjVjMzJmNmU4ZGIzMTk3YWYzYzdlYjA1YzQ4YWUzNzM2MDViODE2NWI2ZjRhNTFjNWIwYmE0ODEyZScsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnVVNEVCcpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVGV0aGVyIFVTRCcsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ1VTRFQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBpZDogQ0hBSU5fSURTLmZ1ZWwubWFpbm5ldCxcbiAgICAgICAgbmFtZTogJ0Z1ZWwgTmV0d29yaycsXG4gICAgICAgIGFua3JOYW1lOiAnJyxcbiAgICAgICAgbmF0aXZlQ3VycmVuY3k6IHtcbiAgICAgICAgICAgIGRlY2ltYWxzOiA5LFxuICAgICAgICAgICAgbmFtZTogJ0V0aGVyJyxcbiAgICAgICAgICAgIHN5bWJvbDogJ0VUSCcsXG4gICAgICAgIH0sXG4gICAgICAgIHJwY1VybHM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBodHRwOiBbRlVFTF9ORVRXT1JLX1VSTF0sXG4gICAgICAgICAgICAgICAgd2ViU29ja2V0OiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHVuaXZlcnNlOiBVbml2ZXJzZS5GVUVMLFxuICAgIH0sXG4gICAge1xuICAgICAgICBibG9ja0V4cGxvcmVyczoge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdTb3Boc2NhbicsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9zb3Boc2Nhbi54eXonLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tOiB7XG4gICAgICAgICAgICBpY29uOiAnaHR0cHM6Ly9hc3NldHMuY29pbmdlY2tvLmNvbS9jb2lucy9pbWFnZXMvMzg2ODAvbGFyZ2Uvc29waG9uX2xvZ29fMjAwLnBuZycsXG4gICAgICAgICAgICBrbm93blRva2VuczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiAnMHg2Mzg2ZGE3MzU0NWFlNGUyYjJlMDM5MzY4OGZhOGI2NWJiOWE3MTY5JyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDYsXG4gICAgICAgICAgICAgICAgICAgIGxvZ286IGdldExvZ29Gcm9tU3ltYm9sKCdVU0RUJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdUZXRoZXIgVVNEJyxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiAnVVNEVCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4OWFhMGY3MjM5MmI1Nzg0YWQ4NmM2ZjNlODk5YmNjMDUzZDAwZGI0ZicsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnVVNEQycpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVVNEIENvaW4nLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6ICdVU0RDJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiAnMHg3MmFmOWYxNjliNjE5ZDg1YTQ3ZGZhOGZlZmJjZDM5ZGU1NWM1NjdkJyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnRVRIJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdFdGhlcicsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ0VUSCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIGlkOiBTT1BIT05fQ0hBSU5fSUQsXG4gICAgICAgIG5hbWU6ICdTb3Bob24nLFxuICAgICAgICBhbmtyTmFtZTogJycsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7XG4gICAgICAgICAgICBkZWNpbWFsczogMTgsXG4gICAgICAgICAgICBuYW1lOiAnU29waG9uJyxcbiAgICAgICAgICAgIHN5bWJvbDogJ1NPUEgnLFxuICAgICAgICB9LFxuICAgICAgICBycGNVcmxzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgaHR0cDogWydodHRwczovL3NvcGhvbi5nYXRld2F5LnRlbmRlcmx5LmNvLzFkNFNURlQ3em1HMHZNNVFvd2liQ3cnXSxcbiAgICAgICAgICAgICAgICBwdWJsaWNIdHRwOiBbJ2h0dHBzOi8vcnBjLXF1aWNrbm9kZS5zb3Bob24ueHl6J10sXG4gICAgICAgICAgICAgICAgd2ViU29ja2V0OiBbJ3dzczovL3NvcGhvbi5nYXRld2F5LnRlbmRlcmx5LmNvLzFkNFNURlQ3em1HMHZNNVFvd2liQ3cnXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHVuaXZlcnNlOiBVbml2ZXJzZS5FVEhFUkVVTSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYmxvY2tFeHBsb3JlcnM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnS2FpYVNjYW4nLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8va2FpYXNjYW4uaW8nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tOiB7XG4gICAgICAgICAgICBpY29uOiAnaHR0cHM6Ly9hc3NldHMuY29pbmdlY2tvLmNvbS9hc3NldF9wbGF0Zm9ybXMvaW1hZ2VzLzk2NzIvbGFyZ2Uva2FpYS5wbmcnLFxuICAgICAgICAgICAga25vd25Ub2tlbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4ZDA3N2E0MDA5Njg4OTBlYWNjNzVjZGM5MDFmMDM1NmM5NDNlNGZkYicsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnVVNEVCcpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVGV0aGVyIFVTRCcsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ1VTRFQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBpZDogS0FJQV9DSEFJTl9JRCxcbiAgICAgICAgbmFtZTogJ0thaWEgTWFpbm5ldCcsXG4gICAgICAgIGFua3JOYW1lOiAnJyxcbiAgICAgICAgbmF0aXZlQ3VycmVuY3k6IHtcbiAgICAgICAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgIG5hbWU6ICdLYWlhJyxcbiAgICAgICAgICAgIHN5bWJvbDogJ0tBSUEnLFxuICAgICAgICB9LFxuICAgICAgICBycGNVcmxzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgaHR0cDogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9sYi5kcnBjLm9yZy9rbGF5dG4vQW01bkVOb0ptRXVvdnF1aThfTE14enA0Q2hKelc3a1I4SmZQcnFSaGYwZkUnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9nby5nZXRibG9jay5pby9kNzA5NGRiZDgwYWI0NzRiYTcwNDI2MDNmZTkxMjMzMicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBwdWJsaWNIdHRwOiBbJ2h0dHBzOi8vZ28uZ2V0YmxvY2suaW8vZDcwOTRkYmQ4MGFiNDc0YmE3MDQyNjAzZmU5MTIzMzInXSxcbiAgICAgICAgICAgICAgICB3ZWJTb2NrZXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgJ3dzczovL2xiLmRycGMub3JnL2tsYXl0bi9BbTVuRU5vSm1FdW92cXVpOF9MTXh6cDRDaEp6VzdrUjhKZlBycVJoZjBmRScsXG4gICAgICAgICAgICAgICAgICAgICd3c3M6Ly9nby5nZXRibG9jay5pby85MmQ2ZTMxZDZhNDc0MjdkOTMzNzc1M2IzZDQ4YjkzZScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHVuaXZlcnNlOiBVbml2ZXJzZS5FVEhFUkVVTSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYmxvY2tFeHBsb3JlcnM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnRXRoZXJzY2FuJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2V0aGVyc2Nhbi5pbycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBjdXN0b206IHtcbiAgICAgICAgICAgIGljb246ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2Fzc2V0X3BsYXRmb3Jtcy9pbWFnZXMvMjc5L2xhcmdlL2V0aGVyZXVtLnBuZz8xNzA2NjA2ODAzJyxcbiAgICAgICAgICAgIGtub3duVG9rZW5zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6ICcweGRhYzE3Zjk1OGQyZWU1MjNhMjIwNjIwNjk5NDU5N2MxM2Q4MzFlYzcnLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogNixcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogZ2V0TG9nb0Zyb21TeW1ib2woJ1VTRFQnKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1RldGhlciBVU0QnLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6ICdVU0RUJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiAnMHhhMGI4Njk5MWM2MjE4YjM2YzFkMTlkNGEyZTllYjBjZTM2MDZlYjQ4JyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDYsXG4gICAgICAgICAgICAgICAgICAgIGxvZ286IGdldExvZ29Gcm9tU3ltYm9sKCdVU0RDJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdVU0QgQ29pbicsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ1VTREMnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBpZDogMSxcbiAgICAgICAgbmFtZTogJ0V0aGVyZXVtIE1haW5uZXQnLFxuICAgICAgICBhbmtyTmFtZTogJ2V0aCcsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7XG4gICAgICAgICAgICBkZWNpbWFsczogMTgsXG4gICAgICAgICAgICBuYW1lOiAnRXRoZXInLFxuICAgICAgICAgICAgc3ltYm9sOiAnRVRIJyxcbiAgICAgICAgfSxcbiAgICAgICAgcnBjVXJsczoge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGh0dHA6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vbGIuZHJwYy5vcmcvZXRoZXJldW0vQW01bkVOb0ptRXVvdnF1aThfTE14enA0Q2hKelc3a1I4SmZQcnFSaGYwZkUnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9ldGhlcmV1bS5ibG9ja3BpLm5ldHdvcmsvdjEvcnBjLzc0M2YxMjZlMTcyMGQ3OTAzM2JhNzBhOTJjOWVhMzcyNDM4MGQ2YmQnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcHVibGljSHR0cDogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9jbG91ZGZsYXJlLWV0aC5jb20nLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly8xcnBjLmlvL2V0aCcsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2V0aGVyZXVtLXJwYy5wdWJsaWNub2RlLmNvbScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3JwYy5hbmtyLmNvbS9ldGgnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9ldGhlcmV1bS5ibG9ja3BpLm5ldHdvcmsvdjEvcnBjL3B1YmxpYycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3JwYy5tZXZibG9ja2VyLmlvJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vcnBjLm1ldmJsb2NrZXIuaW8vZmFzdCcsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3ZWJTb2NrZXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgJ3dzczovL2xiLmRycGMub3JnL2V0aGVyZXVtL0FtNW5FTm9KbUV1b3ZxdWk4X0xNeHpwNENoSnpXN2tSOEpmUHJxUmhmMGZFJyxcbiAgICAgICAgICAgICAgICAgICAgJ3dzczovL2V0aC5sbGFtYXJwYy5jb20nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB1bml2ZXJzZTogVW5pdmVyc2UuRVRIRVJFVU0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGJsb2NrRXhwbG9yZXJzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ09wdGltaXNtIEV0aGVyc2NhbicsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9vcHRpbWlzdGljLmV0aGVyc2Nhbi5pbycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBjdXN0b206IHtcbiAgICAgICAgICAgIGljb246ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8yNTI0NC9sYXJnZS9PcHRpbWlzbS5wbmc/MTY5NjUyNDM4NScsXG4gICAgICAgICAgICBrbm93blRva2VuczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiAnMHg5NGIwMDhhYTAwNTc5YzEzMDdiMGVmMmM0OTlhZDk4YThjZTU4ZTU4JyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDYsXG4gICAgICAgICAgICAgICAgICAgIGxvZ286IGdldExvZ29Gcm9tU3ltYm9sKCdVU0RUJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdUZXRoZXIgVVNEJyxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiAnVVNEVCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4MGIyYzYzOWM1MzM4MTNmNGFhOWQ3ODM3Y2FmNjI2NTNkMDk3ZmY4NScsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnVVNEQycpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVVNEIENvaW4nLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6ICdVU0RDJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IDEwLFxuICAgICAgICBuYW1lOiAnT1AgTWFpbm5ldCcsXG4gICAgICAgIGFua3JOYW1lOiAnb3B0aW1pc20nLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeToge1xuICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgbmFtZTogJ0V0aGVyJyxcbiAgICAgICAgICAgIHN5bWJvbDogJ0VUSCcsXG4gICAgICAgIH0sXG4gICAgICAgIHJwY1VybHM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBodHRwOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2xiLmRycGMub3JnL29wdGltaXNtL0FtNW5FTm9KbUV1b3ZxdWk4X0xNeHpwNENoSnpXN2tSOEpmUHJxUmhmMGZFJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vb3B0LW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9QZmFzd3JLcTByak9yZllXSGZFOXVMUUtoaUQ0SkNkcScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBwdWJsaWNIdHRwOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL21haW5uZXQub3B0aW1pc20uaW8nLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly8xcnBjLmlvL29wJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vb3B0aW1pc20tcnBjLnB1YmxpY25vZGUuY29tJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vcnBjLmFua3IuY29tL29wdGltaXNtJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vb3B0aW1pc20uYmxvY2twaS5uZXR3b3JrL3YxL3JwYy9wdWJsaWMnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9vcHRpbWlzbS5sbGFtYXJwYy5jb20nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2ViU29ja2V0OiBbXG4gICAgICAgICAgICAgICAgICAgICd3c3M6Ly9sYi5kcnBjLm9yZy9vcHRpbWlzbS9BbTVuRU5vSm1FdW92cXVpOF9MTXh6cDRDaEp6VzdrUjhKZlBycVJoZjBmRScsXG4gICAgICAgICAgICAgICAgICAgICd3c3M6Ly9vcHQtbWFpbm5ldC5nLmFsY2hlbXkuY29tL3YyL1BmYXN3cktxMHJqT3JmWVdIZkU5dUxRS2hpRDRKQ2RxJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdW5pdmVyc2U6IFVuaXZlcnNlLkVUSEVSRVVNLFxuICAgIH0sXG4gICAge1xuICAgICAgICBibG9ja0V4cGxvcmVyczoge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdQb2x5Z29uc2NhbicsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9wb2x5Z29uc2Nhbi5jb20nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tOiB7XG4gICAgICAgICAgICBpY29uOiAnaHR0cHM6Ly9hc3NldHMuY29pbmdlY2tvLmNvbS9hc3NldF9wbGF0Zm9ybXMvaW1hZ2VzLzE1L2xhcmdlL3BvbHlnb25fcG9zLnBuZz8xNzA2NjA2NjQ1JyxcbiAgICAgICAgICAgIGtub3duVG9rZW5zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6ICcweGMyMTMyZDA1ZDMxYzkxNGE4N2M2NjExYzEwNzQ4YWViMDRiNThlOGYnLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogNixcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogZ2V0TG9nb0Zyb21TeW1ib2woJ1VTRFQnKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1RldGhlciBVU0QnLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6ICdVU0RUJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiAnMHgzYzQ5OWM1NDJjZWY1ZTM4MTFlMTE5MmNlNzBkOGNjMDNkNWMzMzU5JyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDYsXG4gICAgICAgICAgICAgICAgICAgIGxvZ286IGdldExvZ29Gcm9tU3ltYm9sKCdVU0RDJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdVU0QgQ29pbicsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ1VTREMnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBpZDogMTM3LFxuICAgICAgICBuYW1lOiAnUG9seWdvbiBQb1MnLFxuICAgICAgICBhbmtyTmFtZTogJ3BvbHlnb24nLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeToge1xuICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgbmFtZTogJ1BPTCcsXG4gICAgICAgICAgICBzeW1ib2w6ICdQT0wnLFxuICAgICAgICB9LFxuICAgICAgICBycGNVcmxzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgaHR0cDogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9sYi5kcnBjLm9yZy9wb2x5Z29uL0FtNW5FTm9KbUV1b3ZxdWk4X0xNeHpwNENoSnpXN2tSOEpmUHJxUmhmMGZFJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vcG9seWdvbi1tYWlubmV0LmcuYWxjaGVteS5jb20vdjIvUGZhc3dyS3EwcmpPcmZZV0hmRTl1TFFLaGlENEpDZHEnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9wb2x5Z29uLmJsb2NrcGkubmV0d29yay92MS9ycGMvMDdmZWY1MTQ2ZDg4NWNjMGZlMDdhZTY3NjBkNDg2YjMxZTQ1ZGNjNycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBwdWJsaWNIdHRwOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3BvbHlnb24tcnBjLmNvbScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovLzFycGMuaW8vbWF0aWMnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9wb2x5Z29uLWJvci1ycGMucHVibGljbm9kZS5jb20nLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9ycGMuYW5rci5jb20vcG9seWdvbicsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3BvbHlnb24uYmxvY2twaS5uZXR3b3JrL3YxL3JwYy9wdWJsaWMnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9wb2x5Z29uLmxsYW1hcnBjLmNvbScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3ZWJTb2NrZXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgJ3dzczovL2xiLmRycGMub3JnL3BvbHlnb24vQW01bkVOb0ptRXVvdnF1aThfTE14enA0Q2hKelc3a1I4SmZQcnFSaGYwZkUnLFxuICAgICAgICAgICAgICAgICAgICAnd3NzOi8vcG9seWdvbi1tYWlubmV0LmcuYWxjaGVteS5jb20vdjIvUGZhc3dyS3EwcmpPcmZZV0hmRTl1TFFLaGlENEpDZHEnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB1bml2ZXJzZTogVW5pdmVyc2UuRVRIRVJFVU0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGJsb2NrRXhwbG9yZXJzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0Jhc2VzY2FuJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2Jhc2VzY2FuLm9yZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBjdXN0b206IHtcbiAgICAgICAgICAgIGljb246ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2Fzc2V0X3BsYXRmb3Jtcy9pbWFnZXMvMTMxL2xhcmdlL2Jhc2UtbmV0d29yay5wbmc/MTcyMDUzMzAzOScsXG4gICAgICAgICAgICBrbm93blRva2VuczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiAnMHg4MzM1ODlmY2Q2ZWRiNmUwOGY0YzdjMzJkNGY3MWI1NGJkYTAyOTEzJyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDYsXG4gICAgICAgICAgICAgICAgICAgIGxvZ286IGdldExvZ29Gcm9tU3ltYm9sKCdVU0RDJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdVU0QgQ29pbicsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ1VTREMnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBpZDogODQ1MyxcbiAgICAgICAgbmFtZTogJ0Jhc2UnLFxuICAgICAgICBhbmtyTmFtZTogJ2Jhc2UnLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeToge1xuICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgbmFtZTogJ0V0aGVyJyxcbiAgICAgICAgICAgIHN5bWJvbDogJ0VUSCcsXG4gICAgICAgIH0sXG4gICAgICAgIHJwY1VybHM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBodHRwOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2xiLmRycGMub3JnL2Jhc2UvQW01bkVOb0ptRXVvdnF1aThfTE14enA0Q2hKelc3a1I4SmZQcnFSaGYwZkUnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9iYXNlLW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9QZmFzd3JLcTByak9yZllXSGZFOXVMUUtoaUQ0SkNkcScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2Jhc2UuYmxvY2twaS5uZXR3b3JrL3YxL3JwYy9kZWMyYTg0YjU3Yzc3NzljOGIwOTJhN2NhOTgxN2U2ODU1YWEwOGM2JyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHB1YmxpY0h0dHA6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vbWFpbm5ldC5iYXNlLm9yZycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovLzFycGMuaW8vYmFzZScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2Jhc2UtcnBjLnB1YmxpY25vZGUuY29tJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vcnBjLmFua3IuY29tL2Jhc2UnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9iYXNlLmJsb2NrcGkubmV0d29yay92MS9ycGMvcHVibGljJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYmFzZS5sbGFtYXJwYy5jb20nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2ViU29ja2V0OiBbXG4gICAgICAgICAgICAgICAgICAgICd3c3M6Ly9sYi5kcnBjLm9yZy9iYXNlL0FtNW5FTm9KbUV1b3ZxdWk4X0xNeHpwNENoSnpXN2tSOEpmUHJxUmhmMGZFJyxcbiAgICAgICAgICAgICAgICAgICAgJ3dzczovL2Jhc2UtbWFpbm5ldC5nLmFsY2hlbXkuY29tL3YyL1BmYXN3cktxMHJqT3JmWVdIZkU5dUxRS2hpRDRKQ2RxJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdW5pdmVyc2U6IFVuaXZlcnNlLkVUSEVSRVVNLFxuICAgIH0sXG4gICAge1xuICAgICAgICBibG9ja0V4cGxvcmVyczoge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdBcmJpc2NhbicsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9hcmJpc2Nhbi5pbycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBjdXN0b206IHtcbiAgICAgICAgICAgIGljb246ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2NvaW5zL2ltYWdlcy8xNjU0Ny9sYXJnZS9hcmIuanBnPzE3MjEzNTgyNDInLFxuICAgICAgICAgICAga25vd25Ub2tlbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4ZmQwODZiYzdjZDVjNDgxZGNjOWM4NWViZTQ3OGExYzBiNjlmY2JiOScsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnVVNEVCcpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVGV0aGVyIFVTRCcsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ1VTRFQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6ICcweGFmODhkMDY1ZTc3YzhjYzIyMzkzMjdjNWVkYjNhNDMyMjY4ZTU4MzEnLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogNixcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogZ2V0TG9nb0Zyb21TeW1ib2woJ1VTREMnKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1VTRCBDb2luJyxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiAnVVNEQycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIGlkOiA0MjE2MSxcbiAgICAgICAgbmFtZTogJ0FyYml0cnVtIE9uZScsXG4gICAgICAgIGFua3JOYW1lOiAnYXJiaXRydW0nLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeToge1xuICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgbmFtZTogJ0VUSCcsXG4gICAgICAgICAgICBzeW1ib2w6ICdFVEgnLFxuICAgICAgICB9LFxuICAgICAgICBycGNVcmxzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgaHR0cDogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9sYi5kcnBjLm9yZy9hcmJpdHJ1bS9BbTVuRU5vSm1FdW92cXVpOF9MTXh6cDRDaEp6VzdrUjhKZlBycVJoZjBmRScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2FyYi1tYWlubmV0LmcuYWxjaGVteS5jb20vdjIvUGZhc3dyS3EwcmpPcmZZV0hmRTl1TFFLaGlENEpDZHEnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9hcmJpdHJ1bS5ibG9ja3BpLm5ldHdvcmsvdjEvcnBjL2E4Y2NkNDNjZGM4NDBjMmIyZDIwYzI0YTA1ODUxNGEyMTMwMjM3NmQnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcHVibGljSHR0cDogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9hcmIxLmFyYml0cnVtLmlvL3JwYycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovLzFycGMuaW8vYXJiJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXJiaXRydW0tb25lLXJwYy5wdWJsaWNub2RlLmNvbScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3JwYy5hbmtyLmNvbS9hcmJpdHJ1bScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2FyYml0cnVtLmJsb2NrcGkubmV0d29yay92MS9ycGMvcHVibGljJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdlYlNvY2tldDogW1xuICAgICAgICAgICAgICAgICAgICAnd3NzOi8vbGIuZHJwYy5vcmcvYXJiaXRydW0vQW01bkVOb0ptRXVvdnF1aThfTE14enA0Q2hKelc3a1I4SmZQcnFSaGYwZkUnLFxuICAgICAgICAgICAgICAgICAgICAnd3NzOi8vYXJiLW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9QZmFzd3JLcTByak9yZllXSGZFOXVMUUtoaUQ0SkNkcScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHVuaXZlcnNlOiBVbml2ZXJzZS5FVEhFUkVVTSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYmxvY2tFeHBsb3JlcnM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU2Nyb2xsc2NhbicsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9zY3JvbGxzY2FuLmNvbScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBjdXN0b206IHtcbiAgICAgICAgICAgIGljb246ICdodHRwczovL2Fzc2V0cy5jb2luZ2Vja28uY29tL2Fzc2V0X3BsYXRmb3Jtcy9pbWFnZXMvMTUzL2xhcmdlL3Njcm9sbC5qcGVnPzE3MDY2MDY3ODInLFxuICAgICAgICAgICAga25vd25Ub2tlbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4ZjU1YmVjOWNhZmRiZTg3MzBmMDk2YWE1NWRhZDZkMjJkNDQwOTlkZicsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnVVNEVCcpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVGV0aGVyIFVTRCcsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ1VTRFQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6ICcweDA2ZWZkYmZmMmExNGE3YzhlMTU5NDRkMWY0YTQ4ZjlmOTVmNjYzYTQnLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogNixcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogZ2V0TG9nb0Zyb21TeW1ib2woJ1VTREMnKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1VTRCBDb2luJyxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiAnVVNEQycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIGlkOiA1MzQzNTIsXG4gICAgICAgIG5hbWU6ICdTY3JvbGwnLFxuICAgICAgICBhbmtyTmFtZTogJ3Njcm9sbCcsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7XG4gICAgICAgICAgICBkZWNpbWFsczogMTgsXG4gICAgICAgICAgICBuYW1lOiAnRXRoZXInLFxuICAgICAgICAgICAgc3ltYm9sOiAnRVRIJyxcbiAgICAgICAgfSxcbiAgICAgICAgcnBjVXJsczoge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGh0dHA6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vbGIuZHJwYy5vcmcvc2Nyb2xsL0FtNW5FTm9KbUV1b3ZxdWk4X0xNeHpwNENoSnpXN2tSOEpmUHJxUmhmMGZFJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vc2Nyb2xsLW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9QZmFzd3JLcTByak9yZllXSGZFOXVMUUtoaUQ0SkNkcScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBwdWJsaWNIdHRwOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3JwYy5zY3JvbGwuaW8nLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly8xcnBjLmlvL3Njcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3JwYy5hbmtyLmNvbS9zY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9zY3JvbGwtbWFpbm5ldC5wdWJsaWMuYmxhc3RhcGkuaW8nLFxuICAgICAgICAgICAgICAgICAgICAvLyBcImh0dHBzOi8vc2Nyb2xsLmJsb2NrcGkubmV0d29yay92MS9ycGMvcHVibGljXCIsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3Njcm9sbC1ycGMucHVibGljbm9kZS5jb20nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgd2ViU29ja2V0OiBbXG4gICAgICAgICAgICAgICAgICAgICd3c3M6Ly9sYi5kcnBjLm9yZy9zY3JvbGwvQW01bkVOb0ptRXVvdnF1aThfTE14enA0Q2hKelc3a1I4SmZQcnFSaGYwZkUnLFxuICAgICAgICAgICAgICAgICAgICAnd3NzOi8vc2Nyb2xsLW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9QZmFzd3JLcTByak9yZllXSGZFOXVMUUtoaUQ0SkNkcScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHVuaXZlcnNlOiBVbml2ZXJzZS5FVEhFUkVVTSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYmxvY2tFeHBsb3JlcnM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU25vd3NjYW4nLFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vc25vd3NjYW4ueHl6JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbToge1xuICAgICAgICAgICAgaWNvbjogJ2h0dHBzOi8vYXNzZXRzLmNvaW5nZWNrby5jb20vYXNzZXRfcGxhdGZvcm1zL2ltYWdlcy8xMi9sYXJnZS9hdmFsYW5jaGUucG5nJyxcbiAgICAgICAgICAgIGtub3duVG9rZW5zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6ICcweGI5N2VmOWVmODczNGM3MTkwNGQ4MDAyZjhiNmJjNjZkZDljNDhhNmUnLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogNixcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogZ2V0TG9nb0Zyb21TeW1ib2woJ1VTREMnKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1VTRCBDb2luJyxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiAnVVNEQycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4OTcwMjIzMGE4ZWE1MzYwMWY1Y2QyZGMwMGZkYmMxM2Q0ZGY0YThjNycsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnVVNEVCcpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVGV0aGVyIFVTRCcsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ1VTRFQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBpZDogNDMxMTQsXG4gICAgICAgIGFua3JOYW1lOiAnYXZhbGFuY2hlJyxcbiAgICAgICAgbmFtZTogJ0F2YWxhbmNoZSBDLUNoYWluJyxcbiAgICAgICAgbmF0aXZlQ3VycmVuY3k6IHtcbiAgICAgICAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgIG5hbWU6ICdBVkFYJyxcbiAgICAgICAgICAgIHN5bWJvbDogJ0FWQVgnLFxuICAgICAgICB9LFxuICAgICAgICBycGNVcmxzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgaHR0cDogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9sYi5kcnBjLm9yZy9hdmFsYW5jaGUvQW01bkVOb0ptRXVvdnF1aThfTE14enA0Q2hKelc3a1I4SmZQcnFSaGYwZkUnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9hdmF4LW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9QZmFzd3JLcTByak9yZllXSGZFOXVMUUtoaUQ0SkNkcScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBwdWJsaWNIdHRwOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovLzFycGMuaW8vYXZheC9jJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXZhbGFuY2hlLWMtY2hhaW4tcnBjLnB1YmxpY25vZGUuY29tJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXZhLW1haW5uZXQucHVibGljLmJsYXN0YXBpLmlvL2V4dC9iYy9DL3JwYycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3JwYy5hbmtyLmNvbS9hdmFsYW5jaGUnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9hdmFsYW5jaGUtbWFpbm5ldC5nYXRld2F5LnRlbmRlcmx5LmNvJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdlYlNvY2tldDogW1xuICAgICAgICAgICAgICAgICAgICAnd3NzOi8vbGIuZHJwYy5vcmcvYXZhbGFuY2hlL0FtNW5FTm9KbUV1b3ZxdWk4X0xNeHpwNENoSnpXN2tSOEpmUHJxUmhmMGZFJyxcbiAgICAgICAgICAgICAgICAgICAgJ3dzczovL2F2YXgtbWFpbm5ldC5nLmFsY2hlbXkuY29tL3YyL1BmYXN3cktxMHJqT3JmWVdIZkU5dUxRS2hpRDRKQ2RxJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdW5pdmVyc2U6IFVuaXZlcnNlLkVUSEVSRVVNLFxuICAgIH0sXG4gICAge1xuICAgICAgICBibG9ja0V4cGxvcmVyczoge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdCc2NTY2FuJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2JzY3NjYW4uY29tJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbToge1xuICAgICAgICAgICAgaWNvbjogJ2h0dHBzOi8vYXNzZXRzLmNvaW5nZWNrby5jb20vYXNzZXRfcGxhdGZvcm1zL2ltYWdlcy8xL2xhcmdlL2JuYl9zbWFydF9jaGFpbi5wbmcnLFxuICAgICAgICAgICAga25vd25Ub2tlbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4OEFDNzZhNTFjYzk1MGQ5ODIyRDY4YjgzZkUxQWQ5N0IzMkNkNTgwZCcsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogZ2V0TG9nb0Zyb21TeW1ib2woJ1VTREMnKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1VTRCBDb2luJyxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiAnVVNEQycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogJzB4NTVkMzk4MzI2Zjk5MDU5ZkY3NzU0ODUyNDY5OTkwMjdCMzE5Nzk1NScsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogZ2V0TG9nb0Zyb21TeW1ib2woJ1VTRFQnKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1RldGhlciBVU0QnLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6ICdVU0RUJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiAnMHgyMTcwRWQwODgwYWM5QTc1NWZkMjlCMjY4ODk1NkJEOTU5RjkzM0Y4JyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBnZXRMb2dvRnJvbVN5bWJvbCgnRVRIJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdFdGhlcicsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ0VUSCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIGlkOiAweDM4LFxuICAgICAgICBuYW1lOiAnQk5CIFNtYXJ0IENoYWluJyxcbiAgICAgICAgYW5rck5hbWU6ICdic2MnLFxuICAgICAgICBuYXRpdmVDdXJyZW5jeToge1xuICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgbmFtZTogJ0JOQicsXG4gICAgICAgICAgICBzeW1ib2w6ICdCTkInLFxuICAgICAgICB9LFxuICAgICAgICBycGNVcmxzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgaHR0cDogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9sYi5kcnBjLm9yZy9ic2MvQW01bkVOb0ptRXVvdnF1aThfTE14enA0Q2hKelc3a1I4SmZQcnFSaGYwZkUnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9ibmItbWFpbm5ldC5nLmFsY2hlbXkuY29tL3YyL1BmYXN3cktxMHJqT3JmWVdIZkU5dUxRS2hpRDRKQ2RxJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHB1YmxpY0h0dHA6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vMXJwYy5pby9ibmInLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9ic2MtcnBjLnB1YmxpY25vZGUuY29tJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYnNjLW1haW5uZXQucHVibGljLmJsYXN0YXBpLmlvJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYnNjLmRycGMub3JnJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYnNjLmJsb2NrcmF6b3IueHl6JyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHdlYlNvY2tldDogW1xuICAgICAgICAgICAgICAgICAgICAnd3NzOi8vbGIuZHJwYy5vcmcvYnNjL0FtNW5FTm9KbUV1b3ZxdWk4X0xNeHpwNENoSnpXN2tSOEpmUHJxUmhmMGZFJyxcbiAgICAgICAgICAgICAgICAgICAgJ3dzczovL2JuYi1tYWlubmV0LmcuYWxjaGVteS5jb20vdjIvUGZhc3dyS3EwcmpPcmZZV0hmRTl1TFFLaGlENEpDZHEnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB1bml2ZXJzZTogVW5pdmVyc2UuRVRIRVJFVU0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGJsb2NrRXhwbG9yZXJzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0h5cGVyc2NhbicsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9oeXBlcnNjYW4uY29tJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbToge1xuICAgICAgICAgICAgaWNvbjogJ2h0dHBzOi8vYXNzZXRzLmNvaW5nZWNrby5jb20vYXNzZXRfcGxhdGZvcm1zL2ltYWdlcy8yNDMvbGFyZ2UvaHlwZXJsaXF1aWQucG5nJyxcbiAgICAgICAgICAgIGtub3duVG9rZW5zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6ICcweEI4Q0U1OUZDMzcxN2FkYTRDMDJlYURGOTY4MkE5ZTkzNEY2MjVlYmInLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogNixcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogZ2V0TG9nb0Zyb21TeW1ib2woJ1VTRFQnKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1RldGhlciBVU0QnLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6ICdVU0RUJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiAnMHhiODgzMzlDQjcxOTliNzdFMjNEQjZFODkwMzUzRTIyNjMyQmE2MzBmJyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDYsXG4gICAgICAgICAgICAgICAgICAgIGxvZ286IGdldExvZ29Gcm9tU3ltYm9sKCdVU0RDJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdVU0QgQ29pbicsXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ1VTREMnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBpZDogSFlQRVJFVk1fQ0hBSU5fSUQsXG4gICAgICAgIGFua3JOYW1lOiAnJyxcbiAgICAgICAgbmFtZTogJ0h5cGVyRVZNJyxcbiAgICAgICAgbmF0aXZlQ3VycmVuY3k6IHtcbiAgICAgICAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgIG5hbWU6ICdIWVBFJyxcbiAgICAgICAgICAgIHN5bWJvbDogJ0hZUEUnLFxuICAgICAgICB9LFxuICAgICAgICBycGNVcmxzOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgaHR0cDogW1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgc3VwcG9ydGVkIGJ5IEFsY2hlbXlcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vaHlwZXJsaXF1aWQuZHJwYy5vcmcnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9sYi5kcnBjLm9yZy9oeXBlcmxpcXVpZC9BbTVuRU5vSm1FdW92cXVpOF9MTXh6cDRDaEp6VzdrUjhKZlBycVJoZjBmRScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBwdWJsaWNIdHRwOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2h5cGVybGlxdWlkLWpzb24tcnBjLnN0YWtlbHkuaW8nLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9ycGMuaHlwZXJsZW5kLmZpbmFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9ycGMuaHlwdXJyc2Nhbi5pbycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB3ZWJTb2NrZXQ6IFsnd3NzOi8vaHlwZXJsaXF1aWQuZHJwYy5vcmcnXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHVuaXZlcnNlOiBVbml2ZXJzZS5FVEhFUkVVTSxcbiAgICB9LFxuXTtcblxuLy8gVGVzdG5ldCB3aXRoIG1haW5uZXQgdG9rZW5zXG5jb25zdCBDT1JBTF9DT05GSUcgPSB7XG4gICAgQ09TTU9TX1VSTDogJ2h0dHBzOi8vY29zbW9zMDEtdGVzdG5ldC5hcmNhbmEubmV0d29yaycsXG4gICAgRVhQTE9SRVJfVVJMOiAnaHR0cHM6Ly9leHBsb3Jlci5uZXh1cy5hdmFpbHByb2plY3Qub3JnJyxcbiAgICBGQVVDRVRfVVJMOiAnaHR0cHM6Ly9nYXRld2F5MDAxLXRlc3RuZXQuYXJjYW5hLm5ldHdvcmsvYXBpL3YxL2ZhdWNldCcsXG4gICAgR1JQQ19VUkw6ICdodHRwczovL2dycGNwcm94eS10ZXN0bmV0LmFyY2FuYS5uZXR3b3JrJyxcbiAgICBORVRXT1JLX0hJTlQ6IEVudmlyb25tZW50LkNPUkFMLFxuICAgIFNJTVVMQVRJT05fVVJMOiAnaHR0cHM6Ly9jYS1zaW0tdGVzdG5ldC5hcmNhbmEubmV0d29yaycsXG4gICAgVlNDX0RPTUFJTjogJ3ZzYzEtdGVzdG5ldC5hcmNhbmEubmV0d29yaycsXG59O1xuLy8gRGV2IHdpdGggbWFpbm5ldCB0b2tlbnNcbmNvbnN0IENFUklTRV9DT05GSUcgPSB7XG4gICAgQ09TTU9TX1VSTDogJ2h0dHBzOi8vY29zbW9zMDEtZGV2LmFyY2FuYS5uZXR3b3JrJyxcbiAgICBFWFBMT1JFUl9VUkw6ICdodHRwczovL2V4cGxvcmVyLm5leHVzLWNlcmlzZS5hdmFpbHByb2plY3Qub3JnJyxcbiAgICBGQVVDRVRfVVJMOiAnaHR0cHM6Ly9nYXRld2F5LWRldi5hcmNhbmEubmV0d29yay9hcGkvdjEvZmF1Y2V0JyxcbiAgICBHUlBDX1VSTDogJ2h0dHBzOi8vbWltb3NhLWRhc2gtZ3JwYy5hcmNhbmEubmV0d29yaycsXG4gICAgTkVUV09SS19ISU5UOiBFbnZpcm9ubWVudC5DRVJJU0UsXG4gICAgU0lNVUxBVElPTl9VUkw6ICdodHRwczovL2NhLXNpbS1kZXYuYXJjYW5hLm5ldHdvcmsnLFxuICAgIFZTQ19ET01BSU46ICdtaW1vc2EtZGFzaC12c2MuYXJjYW5hLm5ldHdvcmsnLFxufTtcbi8vIERldiB3aXRoIHRlc3RuZXQgdG9rZW5zXG5jb25zdCBGT0xMWV9DT05GSUcgPSB7XG4gICAgQ09TTU9TX1VSTDogJ2h0dHBzOi8vY29zbW9zMDQtZGV2LmFyY2FuYS5uZXR3b3JrJyxcbiAgICBFWFBMT1JFUl9VUkw6ICdodHRwczovL2V4cGxvcmVyLm5leHVzLWZvbGx5LmF2YWlscHJvamVjdC5vcmcnLFxuICAgIEZBVUNFVF9VUkw6ICdodHRwczovL2dhdGV3YXktZGV2LmFyY2FuYS5uZXR3b3JrL2FwaS92MS9mYXVjZXQnLFxuICAgIEdSUENfVVJMOiAnaHR0cHM6Ly9ncnBjLWZvbGx5LmFyY2FuYS5uZXR3b3JrJyxcbiAgICBORVRXT1JLX0hJTlQ6IEVudmlyb25tZW50LkZPTExZLFxuICAgIFNJTVVMQVRJT05fVVJMOiAnaHR0cHM6Ly9jYS1zaW0tZGV2LmFyY2FuYS5uZXR3b3JrJyxcbiAgICBWU0NfRE9NQUlOOiAndnNjMS1mb2xseS5hcmNhbmEubmV0d29yaycsXG59O1xuY29uc3QgaXNOZXR3b3JrQ29uZmlnID0gKGNvbmZpZykgPT4ge1xuICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghKGNvbmZpZy5WU0NfRE9NQUlOICYmXG4gICAgICAgIGNvbmZpZy5DT1NNT1NfVVJMICYmXG4gICAgICAgIGNvbmZpZy5TSU1VTEFUSU9OX1VSTCAmJlxuICAgICAgICBjb25maWcuRkFVQ0VUX1VSTCAmJlxuICAgICAgICBjb25maWcuRVhQTE9SRVJfVVJMICYmXG4gICAgICAgIGNvbmZpZy5HUlBDX1VSTCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLk5FVFdPUktfSElOVCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgZ2V0TmV0d29ya0NvbmZpZyA9IChuZXR3b3JrKSA9PiB7XG4gICAgaWYgKGlzTmV0d29ya0NvbmZpZyhuZXR3b3JrKSkge1xuICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICB9XG4gICAgc3dpdGNoIChuZXR3b3JrKSB7XG4gICAgICAgIGNhc2UgRW52aXJvbm1lbnQuQ0VSSVNFOlxuICAgICAgICAgICAgcmV0dXJuIENFUklTRV9DT05GSUc7XG4gICAgICAgIGNhc2UgRW52aXJvbm1lbnQuRk9MTFk6XG4gICAgICAgICAgICByZXR1cm4gRk9MTFlfQ09ORklHO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIENPUkFMX0NPTkZJRztcbiAgICB9XG59O1xuXG5jbGFzcyBBbGxvd2FuY2VRdWVyeSB7XG4gICAgY29uc3RydWN0b3Iod2FsbGV0Q2xpZW50LCBuZXR3b3JrQ29uZmlnLCBjaGFpbkxpc3QpIHtcbiAgICAgICAgdGhpcy53YWxsZXRDbGllbnQgPSB3YWxsZXRDbGllbnQ7XG4gICAgICAgIHRoaXMubmV0d29ya0NvbmZpZyA9IG5ldHdvcmtDb25maWc7XG4gICAgICAgIHRoaXMuY2hhaW5MaXN0ID0gY2hhaW5MaXN0O1xuICAgIH1cbiAgICBhc3luYyBnZXQoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gYXdhaXQgdGhpcy53YWxsZXRDbGllbnQuZ2V0QWRkcmVzc2VzKCk7XG4gICAgICAgIGlmICghYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2NvdW50IGNvbm5lY3RlZCB3aXRoIHdhbGxldCBjbGllbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYWRkcmVzc2VzWzBdO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBpbnB1dC50b2tlbnMgPz8gWydVU0RUJywgJ1VTREMnXTtcbiAgICAgICAgY29uc3QgY2hhaW5JRCA9IGlucHV0LmNoYWluSUQgPyBbaW5wdXQuY2hhaW5JRF0gOiB0aGlzLmNoYWluTGlzdC5jaGFpbnMubWFwKChjKSA9PiBjLmlkKTtcbiAgICAgICAgY29uc3QgaW5wID0gW107XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2hhaW5JRCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0IG9mIHRva2Vucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5jaGFpbkxpc3QuZ2V0VG9rZW5JbmZvQnlTeW1ib2woYywgdCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluID0gdGhpcy5jaGFpbkxpc3QuZ2V0Q2hhaW5CeUlEKGMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYWluIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnAucHVzaChnZXRBbGxvd2FuY2UoY2hhaW4sIGFkZHJlc3MsIHRva2VuLmNvbnRyYWN0QWRkcmVzcywgdGhpcy5jaGFpbkxpc3QpLnRoZW4oKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93YW5jZTogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSUQ6IGMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaW5wKS50aGVuKCgpID0+IG91dCk7XG4gICAgfVxuICAgIGFzeW5jIHJldm9rZShpbnB1dCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNldCh7IC4uLmlucHV0LCBhbW91bnQ6IDBuIH0pO1xuICAgIH1cbiAgICBhc3luYyBzZXQoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LnRva2VucyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdG9rZW4gcGFyYW0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQuYW1vdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBhbW91bnQgcGFyYW0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQuY2hhaW5JRCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhaW5JRCBwYXJhbScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYWluID0gdGhpcy5jaGFpbkxpc3QuZ2V0Q2hhaW5CeUlEKGlucHV0LmNoYWluSUQpO1xuICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYWluIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hhaW5JRCA9IGF3YWl0IHRoaXMud2FsbGV0Q2xpZW50LmdldENoYWluSWQoKTtcbiAgICAgICAgaWYgKGlucHV0LmNoYWluSUQgJiYgaW5wdXQuY2hhaW5JRCAhPT0gY2hhaW5JRCkge1xuICAgICAgICAgICAgYXdhaXQgc3dpdGNoQ2hhaW4odGhpcy53YWxsZXRDbGllbnQsIGNoYWluKTtcbiAgICAgICAgICAgIGNoYWluSUQgPSBpbnB1dC5jaGFpbklEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuQWRkcmVzc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBpbnB1dC50b2tlbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gY2hhaW4uY3VzdG9tLmtub3duVG9rZW5zLmZpbmQoKGt0KSA9PiBlcXVhbEZvbGQoa3Quc3ltYm9sLCB0KSk7XG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3Nlcy5wdXNoKHRva2VuLmNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b2tlbkFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgc3VwcGxpZWQgdG9rZW4gc3ltYm9scyBhcmUgcmVjb2duaXNlZCBvbiB0aGlzIGNoYWluJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgc2V0QWxsb3dhbmNlcyh0b2tlbkFkZHJlc3NlcywgdGhpcy53YWxsZXRDbGllbnQsIHRoaXMubmV0d29ya0NvbmZpZywgdGhpcy5jaGFpbkxpc3QsIGNoYWluLCBpbnB1dC5hbW91bnQpO1xuICAgIH1cbn1cblxuY2xhc3MgQnJpZGdlUXVlcnkge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0LCBpbml0LCBzd2l0Y2hDaGFpbiwgY3JlYXRlRVZNSGFuZGxlciwgY3JlYXRlRnVlbEhhbmRsZXIsIGFkZHJlc3MsIGNoYWluTGlzdCwgZnVlbEFjY291bnQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xuICAgICAgICB0aGlzLnN3aXRjaENoYWluID0gc3dpdGNoQ2hhaW47XG4gICAgICAgIHRoaXMuY3JlYXRlRVZNSGFuZGxlciA9IGNyZWF0ZUVWTUhhbmRsZXI7XG4gICAgICAgIHRoaXMuY3JlYXRlRnVlbEhhbmRsZXIgPSBjcmVhdGVGdWVsSGFuZGxlcjtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5jaGFpbkxpc3QgPSBjaGFpbkxpc3Q7XG4gICAgICAgIHRoaXMuZnVlbEFjY291bnQgPSBmdWVsQWNjb3VudDtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5leGVjID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhIG5vdCBhcHBsaWNhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLnByb2Nlc3MoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaW11bGF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYSBub3QgYXBwbGljYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmhhbmRsZXIuYnVpbGRJbnRlbnQodGhpcy5pbnB1dC5zb3VyY2VDaGFpbnMgPz8gW10pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Egbm90IGFwcGxpY2FibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW50ZW50OiBjb252ZXJ0SW50ZW50KHJlc3BvbnNlLmludGVudCwgcmVzcG9uc2UudG9rZW4sIHRoaXMuY2hhaW5MaXN0KSxcbiAgICAgICAgICAgICAgICB0b2tlbjogcmVzcG9uc2UudG9rZW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBpbml0SGFuZGxlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgICAgICAgICAgaWYgKGlucHV0LnRva2VuICYmIGlucHV0LmFtb3VudCAmJiBpbnB1dC5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmNoYWluTGlzdC5nZXRUb2tlbkluZm9CeVN5bWJvbChpbnB1dC5jaGFpbklkLCBpbnB1dC50b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBjaGFpbi4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYnJpZGdlQW1vdW50ID0gbXVsRGVjaW1hbHMoaW5wdXQuYW1vdW50LCB0b2tlbi5kZWNpbWFscyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYWluSWQgPT09IENIQUlOX0lEUy5mdWVsLm1haW5uZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZnVlbEFjY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5mdWVsQWNjb3VudC5jcmVhdGVUcmFuc2ZlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJhbmRvbSBhZGRyZXNzLCBzaW5jZSBicmlkZ2Ugd29uJ3QgY2FsbCB0aGUgZmluYWwgdHhcbiAgICAgICAgICAgICAgICAgICAgICAgICcweEU3ODY1NURmQWQ1NTJmYzM2NThjMDFiZmI0MjdiOUVBYjBjNjI4RjU0ZTYwYjU0ZkRBMTZjOTVhYUFkRTc5N0EnLCBibihicmlkZ2VBbW91bnQudG9TdHJpbmcoKSksIHRva2VuLmNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNyZWF0ZUZ1ZWxIYW5kbGVyKHR4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJpZGdlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhczogaW5wdXQuZ2FzID8/IDBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUeDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlclJlc3BvbnNlPy5oYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdWVsIGNvbm5lY3RvciBpcyBub3Qgc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc3dpdGNoQ2hhaW4oaW5wdXQuY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc05hdGl2ZSA9IGVxdWFsRm9sZCh0b2tlbi5jb250cmFjdEFkZHJlc3MsIFpFUk9fQUREUkVTUyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC52YWx1ZSA9IHRvSGV4KGJyaWRnZUFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5nYXMgPSAwbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAudG8gPSB0b2tlbi5jb250cmFjdEFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmRhdGEgPSBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFiaTogQUJJLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmFkZHJlc3MsIEJpZ0ludChicmlkZ2VBbW91bnQudG9TdHJpbmcoKSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3RyYW5zZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJSZXNwb25zZSA9IGF3YWl0IHRoaXMuY3JlYXRlRVZNSGFuZGxlcihwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmlkZ2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXM6IGlucHV0LmdhcyA/PyAwbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUeDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNoYWluczogaW5wdXQuc291cmNlQ2hhaW5zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlclJlc3BvbnNlPy5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JyaWRnZTogbWlzc2luZyBwYXJhbXMnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgbG9nZ2VyJGcgPSBnZXRMb2dnZXIoKTtcbmNsYXNzIFRyYW5zZmVyUXVlcnkge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0LCBpbml0LCBzd2l0Y2hDaGFpbiwgY3JlYXRlRVZNSGFuZGxlciwgY3JlYXRlRnVlbEhhbmRsZXIsIGV2bUFkZHJlc3MsIGNoYWluTGlzdCwgZnVlbEFjY291bnQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xuICAgICAgICB0aGlzLnN3aXRjaENoYWluID0gc3dpdGNoQ2hhaW47XG4gICAgICAgIHRoaXMuY3JlYXRlRVZNSGFuZGxlciA9IGNyZWF0ZUVWTUhhbmRsZXI7XG4gICAgICAgIHRoaXMuY3JlYXRlRnVlbEhhbmRsZXIgPSBjcmVhdGVGdWVsSGFuZGxlcjtcbiAgICAgICAgdGhpcy5ldm1BZGRyZXNzID0gZXZtQWRkcmVzcztcbiAgICAgICAgdGhpcy5jaGFpbkxpc3QgPSBjaGFpbkxpc3Q7XG4gICAgICAgIHRoaXMuZnVlbEFjY291bnQgPSBmdWVsQWNjb3VudDtcbiAgICAgICAgdGhpcy5oYW5kbGVyUmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmV4ZWMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFuZGxlclJlc3BvbnNlPy5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYSBub3QgYXBwbGljYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV4cGxvcmVyVVJMID0gJyc7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmhhbmRsZXJSZXNwb25zZS5oYW5kbGVyLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBleHBsb3JlclVSTCA9IHJlc3VsdC5leHBsb3JlclVSTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlciRnLmRlYnVnKCdUcmFuc2ZlclF1ZXJ5OkV4ZWMnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdwcm9jZXNzaW5nIGNvbXBsZXRlZCwgZ29pbmcgdG8gcHJvY2Vzc1R4KCknLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gKGF3YWl0IHRoaXMuaGFuZGxlclJlc3BvbnNlLnByb2Nlc3NUeCgpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgICAgICAgICBleHBsb3JlclVSTCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2ltdWxhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFuZGxlclJlc3BvbnNlPy5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYSBub3QgYXBwbGljYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmhhbmRsZXJSZXNwb25zZS5oYW5kbGVyLmJ1aWxkSW50ZW50KHRoaXMuaW5wdXQuc291cmNlQ2hhaW5zID8/IFtdKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhIG5vdCBhcHBsaWNhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGludGVudDogY29udmVydEludGVudChyZXNwb25zZS5pbnRlbnQsIHJlc3BvbnNlLnRva2VuLCB0aGlzLmNoYWluTGlzdCksXG4gICAgICAgICAgICAgICAgdG9rZW46IHJlc3BvbnNlLnRva2VuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgaW5pdEhhbmRsZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYW5kbGVyUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgICAgICAgICAgbG9nZ2VyJGcuZGVidWcoJ1NlbmRRdWVyeUJ1aWxkZXIuZXhlYycsIHtcbiAgICAgICAgICAgICAgICBjOiBpbnB1dC5jaGFpbklkLFxuICAgICAgICAgICAgICAgIHA6IGlucHV0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5wdXQudG8gJiYgaW5wdXQuYW1vdW50ICE9PSB1bmRlZmluZWQgJiYgaW5wdXQudG9rZW4gJiYgaW5wdXQuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuSW5mbyA9IHRoaXMuY2hhaW5MaXN0LmdldFRva2VuSW5mb0J5U3ltYm9sKGlucHV0LmNoYWluSWQsIGlucHV0LnRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuSW5mbykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBjaGFpbi4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYW1vdW50ID0gbXVsRGVjaW1hbHMoaW5wdXQuYW1vdW50LCB0b2tlbkluZm8uZGVjaW1hbHMpO1xuICAgICAgICAgICAgICAgIGxvZ2dlciRnLmRlYnVnKCd0cmFuc2ZlcjoyJywgeyBhbW91bnQsIHRva2VuSW5mbyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhaW5JZCA9PT0gQ0hBSU5fSURTLmZ1ZWwubWFpbm5ldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mdWVsQWNjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmZ1ZWxBY2NvdW50LmNyZWF0ZVRyYW5zZmVyKGlucHV0LnRvLCBibihhbW91bnQudG9TdHJpbmcoKSksIHRva2VuSW5mby5jb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNyZWF0ZUZ1ZWxIYW5kbGVyKHR4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJpZGdlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXM6IDBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUeDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVlbCBjb25uZWN0b3IgaXMgbm90IHNldCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN3aXRjaENoYWluKGlucHV0LmNoYWluSWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc05hdGl2ZSA9IGVxdWFsRm9sZCh0b2tlbkluZm8uY29udHJhY3RBZGRyZXNzLCBaRVJPX0FERFJFU1MpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdGhpcy5ldm1BZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IGlucHV0LnRvLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAudmFsdWUgPSBgMHgke2Ftb3VudC50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAudG8gPSB0b2tlbkluZm8uY29udHJhY3RBZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5kYXRhID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYmk6IEFCSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbaW5wdXQudG8sIGFtb3VudF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAndHJhbnNmZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNyZWF0ZUVWTUhhbmRsZXIocCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJpZGdlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhczogMG4sXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwVHg6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ2hhaW5zOiBpbnB1dC5zb3VyY2VDaGFpbnMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zZmVyOiBtaXNzaW5nIHBhcmFtcycpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBsb2dnZXIkZiA9IGdldExvZ2dlcigpO1xuY29uc3Qgc2ltdWxhdGUgPSBhc3luYyAodHgsIGFkZHJlc3MsIHByb3ZpZGVyLCBjaGFpbkxpc3QpID0+IHtcbiAgICBjb25zdCBvdXRwdXRzID0gdHgub3V0cHV0cz8uZmlsdGVyKChvKSA9PiBvLnR5cGUgPT09IE91dHB1dFR5cGUuQ29pbikgPz8gW107XG4gICAgY29uc3QgdG9rZW5zID0gb3V0cHV0c1xuICAgICAgICAubWFwKChvKSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gY2hhaW5MaXN0LmdldFRva2VuQnlBZGRyZXNzKENIQUlOX0lEUy5mdWVsLm1haW5uZXQsIG8uYXNzZXRJZCk7XG4gICAgICAgIGlmICghdG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IGhleGxpZnkoYWRkcmVzcykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIHRvOiBoZXhsaWZ5KG8udG8pLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICB0b2tlbjoge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGhleGxpZnkoby5hc3NldElkKSxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IGRpdkRlY2ltYWxzKG8uYW1vdW50LnRvU3RyaW5nKCksIHRva2VuLmRlY2ltYWxzKSxcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogdG9rZW4uZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgbG9nbzogdG9rZW4ubG9nbyxcbiAgICAgICAgICAgICAgICBuYW1lOiB0b2tlbi5uYW1lLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogdG9rZW4uc3ltYm9sLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKChvKSA9PiAhIW8pXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgbykgPT4ge1xuICAgICAgICBjb25zdCBleGlzdGluZ0NvaW4gPSBhY2MuZmluZCgoYSkgPT4gby5mcm9tID09PSBhLmZyb20gJiYgby50b2tlbi5hZGRyZXNzID09PSBhLnRva2VuLmNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgIGlmIChleGlzdGluZ0NvaW4pIHtcbiAgICAgICAgICAgIGV4aXN0aW5nQ29pbi50b2tlbi5hbW91bnQgPSBuZXcgRGVjaW1hbChleGlzdGluZ0NvaW4udG9rZW4uYW1vdW50KS5wbHVzKG8udG9rZW4uYW1vdW50KTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH1cbiAgICAgICAgYWNjLnB1c2goe1xuICAgICAgICAgICAgZnJvbTogby5mcm9tLFxuICAgICAgICAgICAgdG86IG8udG8sXG4gICAgICAgICAgICB0b2tlbjoge1xuICAgICAgICAgICAgICAgIGFtb3VudDogbmV3IERlY2ltYWwoby50b2tlbi5hbW91bnQpLFxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogby50b2tlbi5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBvLnRva2VuLmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgIGxvZ286IG8udG9rZW4ubG9nbyxcbiAgICAgICAgICAgICAgICBuYW1lOiBvLnRva2VuLm5hbWUsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBvLnRva2VuLnN5bWJvbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gKG5ldyBEZWNpbWFsKGEudG9rZW4uYW1vdW50KS5sZXNzVGhhbihiLnRva2VuLmFtb3VudCkgPyAxIDogLTEpKTtcbiAgICBjb25zdCB7IGFzc2VtYmxlZFJlcXVlc3QgfSA9IGF3YWl0IHByb3ZpZGVyLmFzc2VtYmxlVHgoe1xuICAgICAgICBmZWVQYXllckFjY291bnQ6IG5ldyBBY2NvdW50KGFkZHJlc3MpLFxuICAgICAgICByZXF1ZXN0OiB0eCxcbiAgICB9KTtcbiAgICBsb2dnZXIkZi5kZWJ1ZygnRnVlbCBTaW11bGF0ZTogbWFwcGVkT3V0cHV0c1RvSW5wdXRzJywge1xuICAgICAgICBhc3NlbWJsZWRSZXF1ZXN0LFxuICAgIH0pO1xuICAgIGNvbnN0IGNvaW4gPSB0b2tlbnM/Lmxlbmd0aCA/IHRva2Vuc1swXSA6IG51bGw7XG4gICAgaWYgKCFjb2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyJGYuZGVidWcoJ0Z1ZWxTaW11bGF0ZScsIHtcbiAgICAgICAgYW1vdW50OiBjb2luLnRva2VuLmFtb3VudC50b0ZpeGVkKCksXG4gICAgICAgIGNvaW46IGNvaW4sXG4gICAgfSk7XG4gICAgY29uc3QgeyBhbW91bnQsIC4uLnRva2VuIH0gPSBjb2luLnRva2VuO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgICBnYXM6IEJpZ0ludCgwKSxcbiAgICAgICAgZ2FzRmVlOiBkaXZEZWNpbWFscyhCaWdJbnQoYXNzZW1ibGVkUmVxdWVzdC5tYXhGZWUudG9TdHJpbmcoKSkgKiAybiwgOSksXG4gICAgICAgIHRva2VuOiB7IC4uLnRva2VuLCB0eXBlOiAnc3JjMjAnIH0sXG4gICAgfTtcbn07XG5jb25zdCBmaXhUeCA9IGFzeW5jIChhZGRyZXNzLCB0eCwgcHJvdmlkZXIpID0+IHtcbiAgICBkZWxldGUgdHguaW5wdXRzO1xuICAgIGNvbnN0IG91dHB1dFF1YW50aXRpZXMgPSB0eC5vdXRwdXRzXG4gICAgICAgID8uZmlsdGVyKChvKSA9PiBvLnR5cGUgPT09IE91dHB1dFR5cGUuQ29pbilcbiAgICAgICAgLm1hcCgoeyBhbW91bnQsIGFzc2V0SWQgfSkgPT4gKHtcbiAgICAgICAgYW1vdW50OiBibihhbW91bnQpLFxuICAgICAgICBhc3NldElkOiBTdHJpbmcoYXNzZXRJZCksXG4gICAgfSkpO1xuICAgIGNvbnN0IGFSZXNwb25zZSA9IGF3YWl0IHByb3ZpZGVyLmFzc2VtYmxlVHgoe1xuICAgICAgICBhY2NvdW50Q29pblF1YW50aXRpZXM6IG91dHB1dFF1YW50aXRpZXMsXG4gICAgICAgIGVzdGltYXRlUHJlZGljYXRlczogdHJ1ZSxcbiAgICAgICAgZmVlUGF5ZXJBY2NvdW50OiBuZXcgQWNjb3VudChhZGRyZXNzKSxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXF1ZXN0OiB0eCxcbiAgICB9KTtcbiAgICBsb2dnZXIkZi5kZWJ1ZygnZml4VHg6c2VuZFRyYW5zYWN0aW9uOjMnLCB7XG4gICAgICAgIGFzc2VtYmxlVHhSZXNwb25zZTogYVJlc3BvbnNlLFxuICAgICAgICByZXF1ZXN0OiB0eCxcbiAgICB9KTtcbiAgICByZXR1cm4gYVJlc3BvbnNlLmFzc2VtYmxlZFJlcXVlc3Q7XG59O1xuY29uc3QgaXNGdWVsTmF0aXZlVHJhbnNmZXIgPSAodHgpID0+IHtcbiAgICByZXR1cm4gdHgub3V0cHV0cz8uZXZlcnkoKG8pID0+IHtcbiAgICAgICAgcmV0dXJuICdhc3NldElkJyBpbiBvICYmIG8uYXNzZXRJZCA9PT0gRlVFTF9CQVNFX0FTU0VUX0lEO1xuICAgIH0pO1xufTtcblxuY29uc3QgbG9nZ2VyJGUgPSBnZXRMb2dnZXIoKTtcbmNvbnN0IGdldEZ1ZWxQcm92aWRlciA9IChnZXRCYWxhbmNlcywgYWRkcmVzcywgY2hhaW4pID0+IHtcbiAgICByZXR1cm4gbmV3IChjbGFzcyBQcm92aWRlciQxIGV4dGVuZHMgUHJvdmlkZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcih1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHN1cGVyKHVybCwgeyAuLi5vcHRpb25zLCByZXNvdXJjZUNhY2hlVFRMOiAtMSB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBhc3NlbWJsZVR4KHBhcmFtcykge1xuICAgICAgICAgICAgY29uc3QgeyByZXF1ZXN0IH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBsb2dnZXIkZS5kZWJ1ZygnZmZQcm92aWRlcicsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gbmV3IEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlcyA9IGF3YWl0IGdldEJhbGFuY2VzKCk7XG4gICAgICAgICAgICBjb25zdCBhc3NldElkc09uRnVlbCA9IGNoYWluLmN1c3RvbS5rbm93blRva2Vucy5tYXAoKGMpID0+IGMuY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEFzc2V0TGlzdCA9IHJlcXVlc3Qub3V0cHV0cy5maWx0ZXIoKG8pID0+IG8udHlwZSA9PT0gT3V0cHV0VHlwZS5Db2luKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbEFzc2V0U3VwcG9ydGVkID0gb3V0cHV0QXNzZXRMaXN0LmV2ZXJ5KChhKSA9PiBhc3NldElkc09uRnVlbC5pbmNsdWRlcyhoZXhsaWZ5KGEuYXNzZXRJZCkpKTtcbiAgICAgICAgICAgIGxvZ2dlciRlLmRlYnVnKCdGdWVsUHJvdmlkZToxJywge1xuICAgICAgICAgICAgICAgIGFsbEFzc2V0U3VwcG9ydGVkLFxuICAgICAgICAgICAgICAgIGFzc2V0SWRzT25GdWVsLFxuICAgICAgICAgICAgICAgIG91dHB1dEFzc2V0TGlzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFhbGxBc3NldFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5hc3NlbWJsZVR4KHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBmZWVQYXllckFjY291bnQ6IG5ldyBBY2NvdW50KGFkZHIpLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWwgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYSBvZiBhc3NldElkc09uRnVlbCkge1xuICAgICAgICAgICAgICAgIGlmICghb3V0cHV0QXNzZXRMaXN0Lm1hcCgoYWwpID0+IGFsLmFzc2V0SWQpLmluY2x1ZGVzKGEpICYmIGEgIT09IEZVRUxfQkFTRV9BU1NFVF9JRCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzZXQgPSBiYWxhbmNlcy5maW5kKChhc3NldCkgPT4gYXNzZXQuYnJlYWtkb3duLmZpbmQoKGIpID0+IGVxdWFsRm9sZChiLmNvbnRyYWN0QWRkcmVzcywgaGV4bGlmeShhKSkgJiYgYi51bml2ZXJzZSA9PT0gVW5pdmVyc2UuRlVFTCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluQXNzZXQgPSBhc3NldD8uYnJlYWtkb3duLmZpbmQoKGIpID0+IGVxdWFsRm9sZChiLmNvbnRyYWN0QWRkcmVzcywgaGV4bGlmeShhKSkgJiYgYi51bml2ZXJzZSA9PT0gVW5pdmVyc2UuRlVFTCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJGUuZGVidWcoJ0Z1ZWxQcm92aWRlcjoyJywge1xuICAgICAgICAgICAgICAgICAgICBhc3NldCxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5Bc3NldCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYXNzZXQgJiYgY2hhaW5Bc3NldCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IGVxdWFsRm9sZChGVUVMX0JBU0VfQVNTRVRfSUQsIGNoYWluQXNzZXQuY29udHJhY3RBZGRyZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyA5XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFzc2V0LmRlY2ltYWxzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbW91bnQgPSBuZXcgQk4obXVsRGVjaW1hbHMoYXNzZXQuYmFsYW5jZSwgZGVjaW1hbHMpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkZS5kZWJ1ZygnRnVlbFByb3ZpZGVyOjMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NldElkOiBoZXhsaWZ5KGEpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWwucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NldElkOiBoZXhsaWZ5KGEpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0LmFkZFJlc291cmNlcyhnZW5lcmF0ZUZha2VSZXNvdXJjZXMoYWwsIG5ldyBBZGRyZXNzKGFkZHJlc3MpKSk7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRDb2luUXVhbnRpdGllcywgLi4ucmVzdCB9ID0gcGFyYW1zO1xuICAgICAgICAgICAgbG9nZ2VyJGUuZGVidWcoJ0Z1ZWxQcm92aWRlcjo0Jywge1xuICAgICAgICAgICAgICAgIGFjY291bnRDb2luUXVhbnRpdGllcyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHsgLi4ucGFyYW1zIH0sXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICByZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN1cGVyLmFzc2VtYmxlVHgoe1xuICAgICAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9nZ2VyJGUuZGVidWcoJ0Z1ZWxQcm92aWRlcjo0Jywge1xuICAgICAgICAgICAgICAgIGFjY291bnRDb2luUXVhbnRpdGllcyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHsgLi4ucGFyYW1zIH0sXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgfSkoRlVFTF9ORVRXT1JLX1VSTCk7XG59O1xuY29uc3QgZ2VuZXJhdGVGYWtlUmVzb3VyY2VzID0gKGNvaW5zLCBhZGRyZXNzKSA9PiB7XG4gICAgcmV0dXJuIGNvaW5zLm1hcCgoY29pbikgPT4gKHtcbiAgICAgICAgYmxvY2tDcmVhdGVkOiBibigxKSxcbiAgICAgICAgaWQ6IGhleGxpZnkocmFuZG9tQnl0ZXMoVVRYT19JRF9MRU4pKSxcbiAgICAgICAgb3duZXI6IGFkZHJlc3MsXG4gICAgICAgIHR4Q3JlYXRlZElkeDogYm4oMSksXG4gICAgICAgIC4uLmNvaW4sXG4gICAgfSkpO1xufTtcblxuY29uc3QgaXNFUkMyMFRva2VuVHJhbnNmZXIgPSAoaW5wdXQpID0+IHtcbiAgICBpZiAoaW5wdXQuZXZtLnR4KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgdG8gfSA9IGlucHV0LmV2bS50eDtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW4gPSBpbnB1dC5jaGFpbkxpc3QuZ2V0VG9rZW5CeUFkZHJlc3MoaW5wdXQuY2hhaW4uaWQsIHRvKTtcbiAgICAgICAgY29uc3QgaXNUb2tlblN1cHBvcnRlZCA9ICEhdG9rZW47XG4gICAgICAgIGlmIChpc1Rva2VuU3VwcG9ydGVkICYmIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZnVuY3Rpb25OYW1lIH0gPSBnZXRUb2tlblR4RnVuY3Rpb24oZGF0YSk7XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25OYW1lID09PSAndHJhbnNmZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGlzTmF0aXZlVG9rZW5UcmFuc2ZlciA9IChpbnB1dCkgPT4ge1xuICAgIGlmIChpbnB1dC5ldm0udHgpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gaW5wdXQuZXZtLnR4O1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkgPiAwbjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3Qgc2ltdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIChjaGFpbklELCBzaW11bGF0aW9ucywgYmFzZVVSTCkgPT4ge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXCIvc2ltdWxhdGVcIiwgYmFzZVVSTCkudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gYXdhaXQgYXhpb3MucG9zdCh1cmwsIHtcbiAgICAgICAgY2hhaW5JRCxcbiAgICAgICAgc2ltdWxhdGlvbnMsXG4gICAgfSwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfSxcbiAgICB9KTtcbn07XG5cbmNvbnN0IEVBRERSRVNTID0gJzB4RWVlZWVFZWVlRWVFZWVFZUVlRWVlRUVFZWVlZUVlZWVlZWVlRUVlRSc7XG5jb25zdCBTV0VFUEVSX0FERFJFU1MgPSAnMHgwMDAwMDAwMDAwMjk2ZTdhODg2ZjQwZjdiYzYwRDJFMzY1MzIxNmE2JztcbmNvbnN0IFpFUk9fQllURVNfMzIgPSBuZXcgVWludDhBcnJheSgzMik7XG5jb25zdCBaRVJPX0JZVEVTXzIwID0gbmV3IFVpbnQ4QXJyYXkoMjApO1xuY29uc3QgQ0FMSUJVUl9BRERSRVNTID0gJzB4MDAwMDAwMDA1NTdBMGRhRjI2NTljYmI2QTQ1ZjJiZUI2MDgxZTZBRSc7XG5jb25zdCBDQUxJQlVSX0VJUDcxMiA9IHtcbiAgICBuYW1lOiAnQ2FsaWJ1cicsXG4gICAgc2FsdDogY29udmVydFRvMzJCeXRlc0hleChDQUxJQlVSX0FERFJFU1MpLFxuICAgIHZlcnNpb246ICcxLjAuMCcsXG59O1xuY29uc3QgTElGSV9BUElfS0VZID0gJ2JjYjc5ODFkLWVhMjYtNGFkZi04OTI2LTk1ZDNhZGY0YzAwMS4yM2JjYzBkNy03ZGY3LTRjODYtYmIzNy1hZTlmZmMyNWJiOTUnO1xuY29uc3QgQkVCT1BfQVBJX0tFWSA9ICdhZTI2MmRiZi1lNGQwLTRiNjYtYWFlYy01N2ExYjQ1ODE0NDAnO1xuXG52YXIgQ2FsaWJ1ckFCSSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0bycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RydWN0IENhbGxbXScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjYWxscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZVtdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdyZXZlcnRPbkZhaWx1cmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICdzdHJ1Y3QgQmF0Y2hlZENhbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2JhdGNoZWRDYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ25vbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYnl0ZXMzMicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAna2V5SGFzaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMzMicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2V4ZWN1dG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZGVhZGxpbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnc3RydWN0IFNpZ25lZEJhdGNoZWRDYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2lnbmVkQmF0Y2hlZENhbGwnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0dXBsZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnd3JhcHBlZFNpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6ICdleGVjdXRlJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3BheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICBuYW1lOiAnYXBwcm92ZU5hdGl2ZScsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbCcsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYm9vbCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbmFtZTogJ25hdGl2ZUFsbG93YW5jZScsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2FsbG93YW5jZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgfSxcbl07XG5cbmNvbnN0IFNXRUVQX0FCSSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0b2tlbicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ1NhZmVFUkMyMEZhaWxlZE9wZXJhdGlvbicsXG4gICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2NvbnRyYWN0IElFUkMyMCcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Rva2VuJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0bycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ3N3ZWVwRVJDMjAnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0bycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogJ3N3ZWVwRVJDNzkxNCcsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuXTtcblxuY29uc3QgbG9nZ2VyJGQgPSBnZXRMb2dnZXIoKTtcbmNvbnN0IGNyZWF0ZUJhdGNoZWRDYWxsU2lnbmF0dXJlID0gKGJhdGNoZWRDYWxscywgbm9uY2UsIGNoYWluLCBhZGRyZXNzLCBhY2NvdW50KSA9PiB7XG4gICAgcmV0dXJuIGFjY291bnQuc2lnblR5cGVkRGF0YSh7XG4gICAgICAgIGRvbWFpbjoge1xuICAgICAgICAgICAgY2hhaW5JZDogY2hhaW4sXG4gICAgICAgICAgICBuYW1lOiBDQUxJQlVSX0VJUDcxMi5uYW1lLFxuICAgICAgICAgICAgc2FsdDogQ0FMSUJVUl9FSVA3MTIuc2FsdCxcbiAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBhZGRyZXNzLFxuICAgICAgICAgICAgdmVyc2lvbjogQ0FMSUJVUl9FSVA3MTIudmVyc2lvbixcbiAgICAgICAgfSxcbiAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgYmF0Y2hlZENhbGw6IHtcbiAgICAgICAgICAgICAgICBjYWxsczogYmF0Y2hlZENhbGxzLFxuICAgICAgICAgICAgICAgIHJldmVydE9uRmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWFkbGluZTogbWF4VWludDI1NixcbiAgICAgICAgICAgIGV4ZWN1dG9yOiB0b0hleChaRVJPX0JZVEVTXzIwKSxcbiAgICAgICAgICAgIGtleUhhc2g6IHRvSGV4KFpFUk9fQllURVNfMzIpLFxuICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgIH0sXG4gICAgICAgIHByaW1hcnlUeXBlOiAnU2lnbmVkQmF0Y2hlZENhbGwnLFxuICAgICAgICB0eXBlczogQ2FsaWJ1clNCQ1R5cGVzLFxuICAgIH0pO1xufTtcbmNvbnN0IHdhaXRGb3JTQkNUeFJlY2VpcHQgPSAob3BzLCBjaGFpbkxpc3QsIHB1YmxpY0NsaWVudExpc3QpID0+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwob3BzLm1hcCgob3ApID0+IHtcbiAgICAgICAgY29uc3QgY2hhaW4gPSBjaGFpbkxpc3QuZ2V0Q2hhaW5CeUlEKE51bWJlcihvcFswXSkpO1xuICAgICAgICBjb25zdCBleHBsb3JlclVSTCA9IG5ldyBVUkwoYC90eC8ke29wWzFdfWAsIGNoYWluLmJsb2NrRXhwbG9yZXJzPy5kZWZhdWx0LnVybCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHsgZXhwbG9yZXJVUkw6IGV4cGxvcmVyVVJMLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgIHJldHVybiB3YWl0Rm9yVHhSZWNlaXB0KG9wWzFdLCBwdWJsaWNDbGllbnRMaXN0LmdldChjaGFpbi5pZCksIDIpO1xuICAgIH0pKTtcbn07XG5jb25zdCBjaGVja0F1dGhDb2RlU2V0ID0gYXN5bmMgKGNoYWluSUQsIGFkZHJlc3MsIGNhY2hlKSA9PiB7XG4gICAgcmV0dXJuIGlzQXV0aG9yaXphdGlvbkNvZGVTZXQoY2hhaW5JRCwgYWRkcmVzcywgY2FjaGUpO1xufTtcbmNvbnN0IGNyZWF0ZVNCQ1R4RnJvbUNhbGxzID0gYXN5bmMgKHsgY2FjaGUsIGNhbGxzLCBjaGFpbklELCBlcGhlbWVyYWxBZGRyZXNzLCBlcGhlbWVyYWxXYWxsZXQsIHB1YmxpY0NsaWVudCwgfSkgPT4ge1xuICAgIGNvbnN0IG5vbmNlID0gYnl0ZXNUb0JpZ0ludCh3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgyNCkpKSA8PCA2NG47XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY3JlYXRlQmF0Y2hlZENhbGxTaWduYXR1cmUoY2FsbHMsIG5vbmNlLCBCaWdJbnQoY2hhaW5JRCksIGVwaGVtZXJhbEFkZHJlc3MsIGVwaGVtZXJhbFdhbGxldCk7XG4gICAgbGV0IGF1dGhvcml6YXRpb24gPSBudWxsO1xuICAgIGlmICghKGF3YWl0IGlzQXV0aG9yaXphdGlvbkNvZGVTZXQoY2hhaW5JRCwgZXBoZW1lcmFsQWRkcmVzcywgY2FjaGUpKSkge1xuICAgICAgICBjb25zdCBub25jZSA9IGF3YWl0IHB1YmxpY0NsaWVudC5nZXRUcmFuc2FjdGlvbkNvdW50KHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGVwaGVtZXJhbEFkZHJlc3MsXG4gICAgICAgICAgICBibG9ja1RhZzogJ3BlbmRpbmcnLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY3JlYXRlIGF1dGhvcml6YXRpb24gZm9yIGNhbGlidXJcbiAgICAgICAgYXV0aG9yaXphdGlvbiA9IGF3YWl0IGVwaGVtZXJhbFdhbGxldC5zaWduQXV0aG9yaXphdGlvbih7XG4gICAgICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JRCksXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IENBTElCVVJfQUREUkVTUyxcbiAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgYWRkcmVzczogY29udmVydFRvMzJCeXRlcyhlcGhlbWVyYWxBZGRyZXNzKSxcbiAgICAgICAgYXV0aG9yaXphdGlvbl9saXN0OiBbXSxcbiAgICAgICAgY2FsbHM6IGNhbGxzLm1hcCgoYykgPT4gKHtcbiAgICAgICAgICAgIGRhdGE6IHRvQnl0ZXMoYy5kYXRhKSxcbiAgICAgICAgICAgIHRvX2FkZHI6IHRvQnl0ZXMoYy50byksXG4gICAgICAgICAgICB2YWx1ZTogY29udmVydFRvMzJCeXRlcyhjLnZhbHVlKSxcbiAgICAgICAgfSkpLFxuICAgICAgICBjaGFpbl9pZDogY29udmVydFRvMzJCeXRlcyhjaGFpbklEKSxcbiAgICAgICAgZGVhZGxpbmU6IHRvQnl0ZXMobWF4VWludDI1NiksXG4gICAgICAgIGtleV9oYXNoOiBaRVJPX0JZVEVTXzMyLFxuICAgICAgICBub25jZTogY29udmVydFRvMzJCeXRlcyhub25jZSksXG4gICAgICAgIHJldmVydF9vbl9mYWlsdXJlOiB0cnVlLFxuICAgICAgICBzaWduYXR1cmU6IHRvQnl0ZXMocGFja1NpZ25hdHVyZUFuZEhvb2tEYXRhKHNpZ25hdHVyZSkpLFxuICAgICAgICB1bml2ZXJzZTogVW5pdmVyc2UuRVRIRVJFVU0sXG4gICAgfTtcbiAgICBpZiAoYXV0aG9yaXphdGlvbikge1xuICAgICAgICByZXF1ZXN0LmF1dGhvcml6YXRpb25fbGlzdC5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHRvQnl0ZXMoQ0FMSUJVUl9BRERSRVNTKSxcbiAgICAgICAgICAgIGNoYWluX2lkOiBjb252ZXJ0VG8zMkJ5dGVzKGF1dGhvcml6YXRpb24uY2hhaW5JZCksXG4gICAgICAgICAgICBub25jZTogYXV0aG9yaXphdGlvbi5ub25jZSxcbiAgICAgICAgICAgIHNpZ19yOiB0b0J5dGVzKGF1dGhvcml6YXRpb24uciksXG4gICAgICAgICAgICBzaWdfczogdG9CeXRlcyhhdXRob3JpemF0aW9uLnMpLFxuICAgICAgICAgICAgc2lnX3Y6IE51bWJlcihhdXRob3JpemF0aW9uLnlQYXJpdHkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9nZ2VyJGQuZGVidWcoJ2NyZWF0ZVNCQ1R4RnJvbUNhbGxzJywge1xuICAgICAgICByZXF1ZXN0LFxuICAgIH0pO1xuICAgIHJldHVybiByZXF1ZXN0O1xufTtcbmNvbnN0IGNhbGlidXJFeGVjdXRlID0gYXN5bmMgKHsgYWN0dWFsQWRkcmVzcywgYWN0dWFsV2FsbGV0LCBjYWxscywgY2hhaW4sIGVwaGVtZXJhbEFkZHJlc3MsIGVwaGVtZXJhbFdhbGxldCwgdmFsdWUsIH0pID0+IHtcbiAgICBjb25zdCBub25jZSA9IGJ5dGVzVG9CaWdJbnQod2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMjQpKSkgPDwgNjRuO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNyZWF0ZUJhdGNoZWRDYWxsU2lnbmF0dXJlKGNhbGxzLCBub25jZSwgQmlnSW50KGNoYWluLmlkKSwgZXBoZW1lcmFsQWRkcmVzcywgZXBoZW1lcmFsV2FsbGV0KTtcbiAgICByZXR1cm4gYWN0dWFsV2FsbGV0LndyaXRlQ29udHJhY3Qoe1xuICAgICAgICBhYmk6IENhbGlidXJBQkksXG4gICAgICAgIGFjY291bnQ6IGFjdHVhbEFkZHJlc3MsXG4gICAgICAgIGFkZHJlc3M6IGVwaGVtZXJhbEFkZHJlc3MsXG4gICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVkQ2FsbDoge1xuICAgICAgICAgICAgICAgICAgICBjYWxscyxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0T25GYWlsdXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVhZGxpbmU6IG1heFVpbnQyNTYsXG4gICAgICAgICAgICAgICAgZXhlY3V0b3I6IHRvSGV4KFpFUk9fQllURVNfMjApLFxuICAgICAgICAgICAgICAgIGtleUhhc2g6IHRvSGV4KFpFUk9fQllURVNfMzIpLFxuICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhY2tTaWduYXR1cmVBbmRIb29rRGF0YShzaWduYXR1cmUpLFxuICAgICAgICBdLFxuICAgICAgICBjaGFpbixcbiAgICAgICAgZnVuY3Rpb25OYW1lOiAnZXhlY3V0ZScsXG4gICAgICAgIHZhbHVlLFxuICAgIH0pO1xufTtcbmNvbnN0IHBhY2tTaWduYXR1cmVBbmRIb29rRGF0YSA9IChzaWduYXR1cmUsIGhvb2tEYXRhID0gJzB4JykgPT4ge1xuICAgIHJldHVybiBlbmNvZGVBYmlQYXJhbWV0ZXJzKFtcbiAgICAgICAgeyBuYW1lOiAnc2lnbmF0dXJlJywgdHlwZTogJ2J5dGVzJyB9LFxuICAgICAgICB7IG5hbWU6ICdob29rRGF0YScsIHR5cGU6ICdieXRlcycgfSxcbiAgICBdLCBbc2lnbmF0dXJlLCBob29rRGF0YV0pO1xufTtcblxuY29uc3QgU1dBUF9TVEFSVCA9IHtcbiAgICBjb21wbGV0ZWQ6IHRydWUsXG4gICAgdHlwZTogJ1NXQVBfU1RBUlQnLFxuICAgIHR5cGVJRDogJ1NXQVBfU1RBUlQnLFxufTtcbmNvbnN0IERFVEVSTUlOSU5HX1NXQVAgPSAoY29tcGxldGVkID0gZmFsc2UpID0+ICh7XG4gICAgY29tcGxldGVkLFxuICAgIHR5cGU6ICdERVRFUk1JTklOR19TV0FQJyxcbiAgICB0eXBlSUQ6IERFVEVSTUlOSU5HX1NXQVAsXG59KTtcbmNvbnN0IENSRUFURV9QRVJNSVRfRk9SX1NPVVJDRV9TV0FQID0gKGNvbXBsZXRlZCwgc3ltYm9sLCBjaGFpbikgPT4gKHtcbiAgICBjaGFpbjoge1xuICAgICAgICBpZDogY2hhaW4uaWQsXG4gICAgICAgIG5hbWU6IGNoYWluLm5hbWUsXG4gICAgfSxcbiAgICBjb21wbGV0ZWQsXG4gICAgc3ltYm9sLFxuICAgIHR5cGU6ICdDUkVBVEVfUEVSTUlUX0ZPUl9TT1VSQ0VfU1dBUCcsXG4gICAgdHlwZUlEOiBgQ1JFQVRFX1BFUk1JVF9GT1JfU09VUkNFX1NXQVBfJHtjaGFpbi5pZH1fJHtzeW1ib2x9YCxcbn0pO1xuY29uc3QgU09VUkNFX1NXQVBfSEFTSCA9IChvcHMsIGNoYWluTGlzdCkgPT4ge1xuICAgIGNvbnN0IGNoYWluSUQgPSBvcHNbMF07XG4gICAgY29uc3QgY2hhaW4gPSBjaGFpbkxpc3QuZ2V0Q2hhaW5CeUlEKE51bWJlcihvcHNbMF0pKTtcbiAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjaGFpbjogJHtvcHNbMF19YCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNoYWluOiB7XG4gICAgICAgICAgICBpZDogY2hhaW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBjaGFpbi5uYW1lLFxuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZWQ6IHRydWUsXG4gICAgICAgIGV4cGxvcmVyVVJMOiBuZXcgVVJMKGAvdHgvJHtvcHNbMV19YCwgY2hhaW4uYmxvY2tFeHBsb3JlcnM/LmRlZmF1bHQudXJsKS50b1N0cmluZygpLFxuICAgICAgICB0eXBlOiAnU09VUkNFX1NXQVBfSEFTSCcsXG4gICAgICAgIHR5cGVJRDogYFNPVVJDRV9TV0FQX0hBU0hfJHtjaGFpbklEfWAsXG4gICAgfTtcbn07XG5jb25zdCBSRkZfSUQgPSAoaWQpID0+ICh7XG4gICAgY29tcGxldGVkOiB0cnVlLFxuICAgIGRhdGE6IGlkLFxuICAgIHR5cGU6ICdSRkZfSUQnLFxuICAgIHR5cGVJRDogJ1JGRl9JRCcsXG59KTtcbmNvbnN0IERFU1RJTkFUSU9OX1NXQVBfQkFUQ0hfVFggPSAoY29tcGxldGVkKSA9PiAoe1xuICAgIGNvbXBsZXRlZCxcbiAgICB0eXBlOiAnREVTVElOQVRJT05fU1dBUF9CQVRDSF9UWCcsXG4gICAgdHlwZUlEOiAnREVTVElOQVRJT05fU1dBUF9CQVRDSF9UWCcsXG59KTtcbmNvbnN0IFNXQVBfQ09NUExFVEUgPSB7XG4gICAgY29tcGxldGVkOiB0cnVlLFxuICAgIHR5cGU6ICdTV0FQX0NPTVBMRVRFJyxcbiAgICB0eXBlSUQ6ICdTV0FQX0NPTVBMRVRFJyxcbn07XG5jb25zdCBERVNUSU5BVElPTl9TV0FQX0hBU0ggPSAob3AsIGNoYWluTGlzdCkgPT4ge1xuICAgIGNvbnN0IGNoYWluID0gY2hhaW5MaXN0LmdldENoYWluQnlJRChOdW1iZXIob3BbMF0pKTtcbiAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjaGFpbjogJHtvcFswXX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhaW46IHtcbiAgICAgICAgICAgIGlkOiBjaGFpbi5pZCxcbiAgICAgICAgICAgIG5hbWU6IGNoYWluLm5hbWUsXG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlZDogdHJ1ZSxcbiAgICAgICAgZXhwbG9yZXJVUkw6IG5ldyBVUkwoYC90eC8ke29wWzFdfWAsIGNoYWluLmJsb2NrRXhwbG9yZXJzPy5kZWZhdWx0LnVybCkudG9TdHJpbmcoKSxcbiAgICAgICAgdHlwZTogJ0RFU1RJTkFUSU9OX1NXQVBfSEFTSCcsXG4gICAgICAgIHR5cGVJRDogYERFU1RJTkFUSU9OX1NXQVBfSEFTSF8ke2NoYWluLmlkfWAsXG4gICAgfTtcbn07XG5cbmNvbnN0IGxvZ2dlciRjID0gZ2V0TG9nZ2VyKCk7XG5jb25zdCBjb252ZXJ0VG8zMkJ5dGVzID0gKGlucHV0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRvQnl0ZXMocGFkKGlucHV0LCB7IGRpcjogJ2xlZnQnLCBzaXplOiAzMiB9KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRvQnl0ZXMoaW5wdXQsIHtcbiAgICAgICAgICAgIHNpemU6IDMyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZChpbnB1dCwgeyBkaXI6ICdsZWZ0Jywgc2l6ZTogMzIgfSk7XG59O1xuY29uc3QgRUFERFJFU1NfMzJfQllURVMgPSBjb252ZXJ0VG8zMkJ5dGVzKEVBRERSRVNTKTtcbmNvbnN0IGNvbnZlcnRUb0VWTUFkZHJlc3MgPSAoYWRkcmVzcykgPT4ge1xuICAgIGlmICh0eXBlb2YgYWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWRkcmVzcyA9IHRvQnl0ZXMoYWRkcmVzcyk7XG4gICAgfVxuICAgIGlmIChhZGRyZXNzLmxlbmd0aCA9PT0gMjApIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4KGFkZHJlc3MpO1xuICAgIH1cbiAgICBpZiAoYWRkcmVzcy5sZW5ndGggPT0gMzIpIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4KGFkZHJlc3Muc3ViYXJyYXkoMTIpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbn07XG5jb25zdCBieXRlc0VxdWFsID0gKGJ5dGVzMSwgYnl0ZXMyKSA9PiB7XG4gICAgbG9nZ2VyJGMuZGVidWcoJ2J5dGVzRXF1YWwnLCB7XG4gICAgICAgIGJ5dGVzMSxcbiAgICAgICAgYnl0ZXMyLFxuICAgIH0pO1xuICAgIGlmIChieXRlczEubGVuZ3RoICE9PSBieXRlczIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlczEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGJ5dGVzMVtpXSAhPT0gYnl0ZXMyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgQW5rckNoYWluSWRNYXBwaW5nID0gbmV3IE1hcChbXG4gICAgWydhcmJpdHJ1bScsIDQyMTYxXSxcbiAgICBbJ2F2YWxhbmNoZV9mdWppJywgNDMxMTNdLFxuICAgIFsnYXZhbGFuY2hlJywgNDMxMTRdLFxuICAgIFsnYmFzZV9zZXBvbGlhJywgODQ1MzJdLFxuICAgIFsnYmFzZScsIDg0NTNdLFxuICAgIFsnYnNjJywgNTZdLFxuICAgIFsnZXRoX2hvbGVza3knLCAxNzAwMF0sXG4gICAgWydldGhfc2Vwb2xpYScsIDExMTU1MTExXSxcbiAgICBbJ2V0aCcsIDFdLFxuICAgIFsnZmFudG9tJywgMjUwXSxcbiAgICBbJ2ZsYXJlJywgMTRdLFxuICAgIFsnZ25vc2lzJywgMTAwXSxcbiAgICBbJ2xpbmVhJywgNTkxNDRdLFxuICAgIFsnb3B0aW1pc21fdGVzdG5ldCcsIDExMTU1NDIwXSxcbiAgICBbJ29wdGltaXNtJywgMTBdLFxuICAgIFsncG9seWdvbl9hbW95JywgODAwMDJdLFxuICAgIFsncG9seWdvbl96a2V2bScsIDExMDFdLFxuICAgIFsncG9seWdvbicsIDEzN10sXG4gICAgWydyb2xsdXgnLCA1NzBdLFxuICAgIFsnc2Nyb2xsJywgNTM0MzUyXSxcbiAgICBbJ3N0b3J5X3Rlc3RuZXQnLCAxNTEzXSxcbiAgICBbJ3N0b3J5JywgMTUxNF0sXG4gICAgWydzeXNjb2luJywgNTddLFxuICAgIFsndGVsb3MnLCA0MF0sXG4gICAgWyd4YWknLCA2NjAyNzldLFxuICAgIFsneGxheWVyJywgMTk2XSxcbl0pO1xuY29uc3QgY3JlYXRlUGVybWl0U2lnbmF0dXJlID0gYXN5bmMgKGNvbnRyYWN0QWRkcmVzcywgY2xpZW50LCBzcGVuZGVyLCB3YWxsZXRBZGRyZXNzLCB2YXJpYW50LCB2ZXJzaW9uKSA9PiB7XG4gICAgY29uc3QgY29udHJhY3QgPSBnZXRDb250cmFjdCh7XG4gICAgICAgIGFiaTogRVJDMjBBQkksXG4gICAgICAgIGFkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY2xpZW50LFxuICAgIH0pO1xuICAgIGNvbnN0IFtuYW1lLCBjaGFpbklELCBub25jZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGNvbnRyYWN0LnJlYWQubmFtZSgpLFxuICAgICAgICBjbGllbnQucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9jaGFpbklkJyB9LCB7IGRlZHVwZTogdHJ1ZSB9KSxcbiAgICAgICAgY29udHJhY3QucmVhZC5ub25jZXMoW3dhbGxldEFkZHJlc3NdKSxcbiAgICBdKTtcbiAgICBsb2dnZXIkYy5kZWJ1ZygnY3JlYXRlUGVybWl0U2lnUGFyYW1zJywge1xuICAgICAgICBhY2NvdW50OiB3YWxsZXRBZGRyZXNzLFxuICAgICAgICBkb21haW46IHtcbiAgICAgICAgICAgIGNoYWluSWQ6IGhleFRvQmlnSW50KGNoYWluSUQpLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB9LFxuICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICBkZWFkbGluZTogbWF4VWludDI1NixcbiAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgb3duZXI6IHdhbGxldEFkZHJlc3MsXG4gICAgICAgICAgICBzcGVuZGVyOiBzcGVuZGVyLFxuICAgICAgICAgICAgdmFsdWU6IG1heFVpbnQyNTYsXG4gICAgICAgIH0sXG4gICAgICAgIHByaW1hcnlUeXBlOiAnUGVybWl0JyxcbiAgICAgICAgdHlwZXM6IEVSQzIwUGVybWl0RUlQNzEyVHlwZSxcbiAgICB9KTtcbiAgICBzd2l0Y2ggKHZhcmlhbnQpIHtcbiAgICAgICAgY2FzZSBQZXJtaXRWYXJpYW50LkVJUDI2MTJDYW5vbmljYWw6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBhd2FpdCBjbGllbnQuc2lnblR5cGVkRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6IHdhbGxldEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogaGV4VG9CaWdJbnQoY2hhaW5JRCksXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb24udG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVhZGxpbmU6IG1heFVpbnQyNTYsXG4gICAgICAgICAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB3YWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlbmRlcjogc3BlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXhVaW50MjU2LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VHlwZTogJ1Blcm1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzOiBFUkMyMFBlcm1pdEVJUDcxMlR5cGUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdmFyaWFudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBQZXJtaXRWYXJpYW50LlBvbHlnb25FTVQ6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBhd2FpdCBjbGllbnQuc2lnblR5cGVkRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6IHdhbGxldEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbHQ6IHBhZChjaGFpbklELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMzIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBjb250cmFjdC5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbi50b1N0cmluZygxMCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHdhbGxldEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblNpZ25hdHVyZTogcGFja0VSQzIwQXBwcm92ZShzcGVuZGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VHlwZTogJ01ldGFUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzOiBFUkMyMFBlcm1pdEVJUDI2MTJQb2x5Z29uVHlwZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB2YXJpYW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIE5vdCBzdXBwb3J0ZWQ6ICgyNjEyIGRldGFpbHMgbm90IGZvdW5kKScpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHZzY1NCQ1R4ID0gYXN5bmMgKGlucHV0LCB2c2NEb21haW4pID0+IHtcbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gY29ubmVjdChuZXcgVVJMKCcvYXBpL3YxL2NyZWF0ZS1zYmMtdHgnLCBnZXRWU0NVUkwodnNjRG9tYWluLCAnd3NzJykpLnRvU3RyaW5nKCkpO1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY29ubmVjdGVkKCk7XG4gICAgICAgIGNvbm5lY3Rpb24uc29ja2V0LnNlbmQocGFjayhpbnB1dCkpO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHJlc3BvbnNlIG9mIGNvbm5lY3Rpb24uc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdW5wYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxvZ2dlciRjLmRlYnVnKCd2c2NTQkNUeCcsIHsgZGF0YSB9KTtcbiAgICAgICAgICAgIGlmIChkYXRhLmVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGluIFZTQyBTQkMgVHgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wcy5wdXNoKFtieXRlc1RvQmlnSW50KGlucHV0W2RhdGEucGFydF9pZHhdLmNoYWluX2lkKSwgdG9IZXgoZGF0YS50eF9oYXNoKV0pO1xuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbn07XG5jb25zdCBjb3Ntb3NDcmVhdGVSRkYgPSBhc3luYyAoeyBhZGRyZXNzLCBjb3Ntb3NVUkwsIG1zZywgd2FsbGV0LCB9KSA9PiB7XG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgY3JlYXRlQ29zbW9zQ2xpZW50KHdhbGxldCwgZ2V0Q29zbW9zVVJMKGNvc21vc1VSTCwgJ3JwYycpLCB7XG4gICAgICAgIGJyb2FkY2FzdFBvbGxJbnRlcnZhbE1zOiAyNTAsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LnNpZ25BbmRCcm9hZGNhc3QoYWRkcmVzcywgW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlVXJsOiAnL3hhcmNoYWluLmNoYWluYWJzdHJhY3Rpb24uTXNnQ3JlYXRlUmVxdWVzdEZvckZ1bmRzJyxcbiAgICAgICAgICAgIHZhbHVlOiBtc2csXG4gICAgICAgIH0sXG4gICAgXSwge1xuICAgICAgICBhbW91bnQ6IFtdLFxuICAgICAgICBnYXM6IDEwMDAwMG4udG9TdHJpbmcoMTApLFxuICAgIH0pO1xuICAgIGlmIChpc0RlbGl2ZXJUeEZhaWx1cmUocmVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNyZWF0aW5nIFJGRicpO1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVkID0gTXNnQ3JlYXRlUmVxdWVzdEZvckZ1bmRzUmVzcG9uc2UuZGVjb2RlKHJlcy5tc2dSZXNwb25zZXNbMF0udmFsdWUpO1xuICAgIHJldHVybiBkZWNvZGVkLmlkO1xufTtcbmNvbnN0IGNvc21vc0NyZWF0ZURvdWJsZUNoZWNrVHggPSBhc3luYyAoeyBhZGRyZXNzLCBjb3Ntb3NVUkwsIG1zZywgd2FsbGV0LCB9KSA9PiB7XG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgY3JlYXRlQ29zbW9zQ2xpZW50KHdhbGxldCwgZ2V0Q29zbW9zVVJMKGNvc21vc1VSTCwgJ3JwYycpLCB7XG4gICAgICAgIGJyb2FkY2FzdFBvbGxJbnRlcnZhbE1zOiAyNTAsXG4gICAgfSk7XG4gICAgbG9nZ2VyJGMuZGVidWcoJ2Nvc21vc0NyZWF0ZURvdWJsZUNoZWNrVHg6MScsIHsgZG91YmxlQ2hlY2tNc2c6IG1zZyB9KTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQuc2lnbkFuZEJyb2FkY2FzdChhZGRyZXNzLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGVVcmw6ICcveGFyY2hhaW4uY2hhaW5hYnN0cmFjdGlvbi5Nc2dEb3VibGVDaGVja1R4JyxcbiAgICAgICAgICAgIHZhbHVlOiBtc2csXG4gICAgICAgIH0sXG4gICAgXSwge1xuICAgICAgICBhbW91bnQ6IFtdLFxuICAgICAgICBnYXM6IDEwMDAwMG4udG9TdHJpbmcoMTApLFxuICAgIH0pO1xuICAgIGlmIChpc0RlbGl2ZXJUeEZhaWx1cmUocmVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNyZWF0aW5nIE1zZ0RvdWJsZUNoZWNrVHgnKTtcbiAgICB9XG4gICAgbG9nZ2VyJGMuZGVidWcoJ2Nvc21vc0NyZWF0ZURvdWJsZUNoZWNrVHg6MicsIHsgZG91YmxlQ2hlY2tUeDogcmVzIH0pO1xufTtcbmNvbnN0IEVYUEVDVEVEX0NBTElCVVJfQ09ERSA9IGNvbmNhdChbJzB4ZWYwMTAwJywgQ0FMSUJVUl9BRERSRVNTXSk7XG5jb25zdCBpc0F1dGhvcml6YXRpb25Db2RlU2V0ID0gYXN5bmMgKGNoYWluSUQsIGFkZHJlc3MsIGNhY2hlKSA9PiB7XG4gICAgY29uc3QgY29kZSA9IGNhY2hlLmdldENvZGUoe1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklELFxuICAgIH0pO1xuICAgIGxvZ2dlciRjLmRlYnVnKCdpc0F1dGhvcml6YXRpb25Db2RlU2V0JywgeyBjb2RlLCBFWFBFQ1RFRF9DQUxJQlVSX0NPREUgfSk7XG4gICAgaWYgKCFjb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGUgIT0gJzB4JyAmJiBlcXVhbEZvbGQoY29kZSwgRVhQRUNURURfQ0FMSUJVUl9DT0RFKTtcbn07XG5jb25zdCBpc05hdGl2ZUFkZHJlc3MgPSAoY29udHJhY3RBZGRyZXNzKSA9PiBlcXVhbEZvbGQoY29udHJhY3RBZGRyZXNzLCBaRVJPX0FERFJFU1MpIHx8IGVxdWFsRm9sZChjb250cmFjdEFkZHJlc3MsIEVBRERSRVNTKTtcbi8qKlxuICogQ3JlYXRlcyBFSVAyNjEyIHNpZ25hdHVyZSBvciBleGVjdXRlcyBub24gc3BvbnNvcmVkIGFwcHJvdmFsIGFuZCB0cmFuc2ZlckZyb20gVHhcbiAqL1xuY29uc3QgY3JlYXRlUGVybWl0QW5kVHJhbnNmZXJGcm9tVHggPSBhc3luYyAoeyBhbW91bnQsIGFwcHJvdmFsLCBjYWNoZSwgY2hhaW4sIGNvbnRyYWN0QWRkcmVzcywgb3duZXIsIG93bmVyV2FsbGV0LCBwdWJsaWNDbGllbnQsIHNwZW5kZXIsIH0pID0+IHtcbiAgICBjb25zdCB0eExpc3QgPSBbXTtcbiAgICBhd2FpdCBvd25lcldhbGxldC5zd2l0Y2hDaGFpbih7XG4gICAgICAgIGlkOiBjaGFpbi5pZCxcbiAgICB9KTtcbiAgICBsb2dnZXIkYy5kZWJ1ZygnY3JlYXRlUGVybWl0Q2FsbHMnLCB7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgRUFERFJFU1MsXG4gICAgfSk7XG4gICAgbGV0IGFsbG93YW5jZSA9IGNhY2hlLmdldEFsbG93YW5jZSh7XG4gICAgICAgIGNoYWluSUQ6IGNoYWluLmlkLFxuICAgICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgIG93bmVyLFxuICAgICAgICBzcGVuZGVyLFxuICAgIH0pO1xuICAgIGlmIChhbGxvd2FuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2dnZXIkYy5kZWJ1ZygnY3JlYXRlUGVybWl0Q2FsbHM6IGFsbG93YW5jZSBub3QgZm91bmQgaW4gY2FjaGUnLCB7XG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICBzcGVuZGVyLFxuICAgICAgICB9KTtcbiAgICAgICAgYWxsb3dhbmNlID0gYXdhaXQgcHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICBhYmk6IEVSQzIwQUJJLFxuICAgICAgICAgICAgYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgYXJnczogW293bmVyLCBzcGVuZGVyXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ2FsbG93YW5jZScsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2dnZXIkYy5kZWJ1ZygnY3JlYXRlUGVybWl0VHgnLCB7IGFsbG93YW5jZSwgYW1vdW50IH0pO1xuICAgIGlmIChhbGxvd2FuY2UgPCBhbW91bnQpIHtcbiAgICAgICAgY29uc3QgeyB2YXJpYW50LCB2ZXJzaW9uIH0gPSBnZXRUb2tlblZlcnNpb24oY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgaWYgKHZhcmlhbnQgPT09IFBlcm1pdFZhcmlhbnQuVW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWVzdCB9ID0gYXdhaXQgcHVibGljQ2xpZW50LnNpbXVsYXRlQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgIGFiaTogRVJDMjBBQkksXG4gICAgICAgICAgICAgICAgYWNjb3VudDogb3duZXIsXG4gICAgICAgICAgICAgICAgYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtzcGVuZGVyLCBtYXhVaW50MjU2XSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdhcHByb3ZlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IG93bmVyV2FsbGV0LndyaXRlQ29udHJhY3QocmVxdWVzdCk7XG4gICAgICAgICAgICBhd2FpdCB3YWl0Rm9yVHhSZWNlaXB0KGhhc2gsIHB1YmxpY0NsaWVudCwgMSk7XG4gICAgICAgICAgICAvLyBPbiByZXRyeSB0aGUgdmFsdWUgd2lsbCBiZSBwcmVzZW50LCBzbyBubyBuZWVkIHRvIHJlZmV0Y2ggYWxsb3dhbmNlXG4gICAgICAgICAgICBjYWNoZS5hZGRBbGxvd2FuY2VWYWx1ZSh7XG4gICAgICAgICAgICAgICAgY2hhaW5JRDogY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgICAgIHNwZW5kZXIsXG4gICAgICAgICAgICB9LCBtYXhVaW50MjU2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFwcHJvdmFsVHggPSBhcHByb3ZhbCA/P1xuICAgICAgICAgICAgICAgIChhd2FpdCBjcmVhdGVQZXJtaXRBcHByb3ZhbFR4KHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICAgICAgb3duZXJXYWxsZXQsXG4gICAgICAgICAgICAgICAgICAgIHNwZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhbnQsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdHhMaXN0LnB1c2goYXBwcm92YWxUeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHhMaXN0LnB1c2goe1xuICAgICAgICBkYXRhOiBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBFUkMyMEFCSSxcbiAgICAgICAgICAgIGFyZ3M6IFtvd25lciwgc3BlbmRlciwgYW1vdW50XSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3RyYW5zZmVyRnJvbScsXG4gICAgICAgIH0pLFxuICAgICAgICB0bzogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICB2YWx1ZTogMG4sXG4gICAgfSk7XG4gICAgcmV0dXJuIHR4TGlzdDtcbn07XG5jb25zdCBjcmVhdGVQZXJtaXRBcHByb3ZhbFR4ID0gYXN5bmMgKHsgY29udHJhY3RBZGRyZXNzLCBvd25lciwgb3duZXJXYWxsZXQsIHNwZW5kZXIsIHZhcmlhbnQsIHZlcnNpb24sIH0pID0+IHtcbiAgICBjb25zdCB7IHNpZ25hdHVyZSB9ID0gYXdhaXQgY3JlYXRlUGVybWl0U2lnbmF0dXJlKGNvbnRyYWN0QWRkcmVzcywgb3duZXJXYWxsZXQsIHNwZW5kZXIsIG93bmVyLCB2YXJpYW50LCB2ZXJzaW9uKTtcbiAgICBjb25zdCB7IHIsIHMsIHYgfSA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgaWYgKCF2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWduYXR1cmU6IHYgaXMgbm90IHByZXNlbnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogdmFyaWFudCA9PT0gUGVybWl0VmFyaWFudC5Qb2x5Z29uRU1UXG4gICAgICAgICAgICA/IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICAgICAgYWJpOiBFUkMyMFBlcm1pdEFCSSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbb3duZXIsIHBhY2tFUkMyMEFwcHJvdmUoc3BlbmRlciksIHIsIHMsIE51bWJlcih2KV0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnZXhlY3V0ZU1ldGFUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgICAgIGFiaTogRVJDMjBQZXJtaXRBQkksXG4gICAgICAgICAgICAgICAgYXJnczogW293bmVyLCBzcGVuZGVyLCBtYXhVaW50MjU2LCBtYXhVaW50MjU2LCBOdW1iZXIodiksIHIsIHNdLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3Blcm1pdCcsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgdG86IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgdmFsdWU6IDBuLFxuICAgIH07XG59O1xuY29uc3QgcGFja0VSQzIwQXBwcm92ZSA9IChzcGVuZGVyLCBhbW91bnQgPSBtYXhVaW50MjU2KSA9PiB7XG4gICAgcmV0dXJuIGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgIGFiaTogRVJDMjBBQkksXG4gICAgICAgIGFyZ3M6IFtzcGVuZGVyLCBhbW91bnRdLFxuICAgICAgICBmdW5jdGlvbk5hbWU6ICdhcHByb3ZlJyxcbiAgICB9KTtcbn07XG5jb25zdCBtdWx0aXBsaWVyQnlDaGFpbiA9IChjaGFpbklEKSA9PiB7XG4gICAgc3dpdGNoIChjaGFpbklEKSB7XG4gICAgICAgIGNhc2UgNTM0MzUyOlxuICAgICAgICAgICAgcmV0dXJuIDEwMG47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gM247XG4gICAgfVxufTtcbmNvbnN0IGdldEFua3JCYWxhbmNlcyA9IGFzeW5jICh3YWxsZXRBZGRyZXNzLCBjaGFpbkxpc3QsIHJlbW92ZVRyYW5zZmVyRmVlID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBwdWJsaWNDbGllbnRzID0ge307XG4gICAgY29uc3QgcmVzID0gYXdhaXQgYXhpb3MucG9zdCgnaHR0cHM6Ly9ycGMuYW5rci5jb20vbXVsdGljaGFpbi8yNjllNTQxZGQ1NzczZGFjMzIwNDgzMWUyOWI5NTM4Mjg0ZGQzZTk1OTFkMmI3Y2IyYWM0N2Q4NWVhZTIxM2I5LycsIHtcbiAgICAgICAgaWQ6IERlY2ltYWwucmFuZG9tKDIpLm11bCgxMDApLnRvTnVtYmVyKCksXG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICdhbmtyX2dldEFjY291bnRCYWxhbmNlJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBibG9ja2NoYWluOiBjaGFpbkxpc3QuZ2V0QW5rck5hbWVMaXN0KCksXG4gICAgICAgICAgICBvbmx5V2hpdGVsaXN0ZWQ6IHRydWUsXG4gICAgICAgICAgICBwYWdlU2l6ZTogNTAwLFxuICAgICAgICAgICAgd2FsbGV0QWRkcmVzczogd2FsbGV0QWRkcmVzcyxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5kYXRhPy5yZXN1bHQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFsYW5jZXMgY2Fubm90IGJlIHJldHJpZXZlZCcpO1xuICAgIGNvbnN0IGZpbHRlcmVkQXNzZXRzID0gcmVzLmRhdGEucmVzdWx0LmFzc2V0cy5maWx0ZXIoKGFzc2V0KSA9PiBBbmtyQ2hhaW5JZE1hcHBpbmcuaGFzKGFzc2V0LmJsb2NrY2hhaW4pICYmXG4gICAgICAgICFuZXcgRGVjaW1hbChhc3NldC50b2tlblByaWNlPy50cmltKCkgfHwgMCkuZXF1YWxzKDApKTtcbiAgICBjb25zdCBhc3NldHMgPSBbXTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgYXNzZXQgb2YgZmlsdGVyZWRBc3NldHMpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBhc3NldC5iYWxhbmNlO1xuICAgICAgICAgICAgaWYgKHJlbW92ZVRyYW5zZmVyRmVlICYmIGFzc2V0LnRva2VuVHlwZSA9PT0gJ05BVElWRScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklEID0gQW5rckNoYWluSWRNYXBwaW5nLmdldChhc3NldC5ibG9ja2NoYWluKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbiA9IGNoYWluTGlzdC5nZXRDaGFpbkJ5SUQoQW5rckNoYWluSWRNYXBwaW5nLmdldChhc3NldC5ibG9ja2NoYWluKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwdWJsaWNDbGllbnRzW2NoYWluSURdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IGh0dHAoY2hhaW4ucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHVibGljQ2xpZW50c1tjaGFpbklEXSA9IGNsaWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmVlID0gYXdhaXQgcHVibGljQ2xpZW50c1tjaGFpbklEXS5lc3RpbWF0ZUZlZXNQZXJHYXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtdWx0aXBsZXIgPSBtdWx0aXBsaWVyQnlDaGFpbihOdW1iZXIoY2hhaW5JRCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVyRmVlID0gZGl2RGVjaW1hbHMoZmVlLm1heEZlZVBlckdhcyAqIDE1MDAwMDBuICogbXVsdGlwbGVyLCBjaGFpbi5uYXRpdmVDdXJyZW5jeS5kZWNpbWFscyk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJGMuZGVidWcoJ2dldEFua3JCYWxhbmNlcycsIHtcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZTogYXNzZXQuYmFsYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JRCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXJGZWU6IHRyYW5zZmVyRmVlLnRvRml4ZWQoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBiYWxhbmNlID0gbmV3IERlY2ltYWwoYXNzZXQuYmFsYW5jZSkuZ3QodHJhbnNmZXJGZWUpXG4gICAgICAgICAgICAgICAgICAgID8gRGVjaW1hbC5zdWIoYXNzZXQuYmFsYW5jZSwgdHJhbnNmZXJGZWUpLnRvRml4ZWQoYXNzZXQudG9rZW5EZWNpbWFscywgRGVjaW1hbC5ST1VORF9GTE9PUilcbiAgICAgICAgICAgICAgICAgICAgOiAnMCc7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJGMuZGVidWcoJ2dldEFua3JCYWxhbmNlcycsIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JRCxcbiAgICAgICAgICAgICAgICAgICAgbmV3QmFsYW5jZTogYmFsYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgb2xkQmFsYW5jZTogYXNzZXQuYmFsYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXJGZWU6IHRyYW5zZmVyRmVlLnRvRml4ZWQoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2V0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBiYWxhbmNlLFxuICAgICAgICAgICAgICAgIGJhbGFuY2VVU0Q6IGFzc2V0LmJhbGFuY2VVc2QsXG4gICAgICAgICAgICAgICAgY2hhaW5JRDogQW5rckNoYWluSWRNYXBwaW5nLmdldChhc3NldC5ibG9ja2NoYWluKSxcbiAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGFzc2V0LnRva2VuVHlwZSA9PT0gJ0VSQzIwJyA/IGFzc2V0LmNvbnRyYWN0QWRkcmVzcyA6IFpFUk9fQUREUkVTUyxcbiAgICAgICAgICAgICAgICB0b2tlbkRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IGFzc2V0LnRva2VuRGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgICAgIGljb246IGFzc2V0LnRodW1ibmFpbCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYXNzZXQudG9rZW5OYW1lLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IGdldFRva2VuU3ltYm9sKGFzc2V0LnRva2VuU3ltYm9sKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVuaXZlcnNlOiBVbml2ZXJzZS5FVEhFUkVVTSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpKTtcbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIHJldHVybiBhc3NldHM7XG59O1xuZnVuY3Rpb24gZ2V0VG9rZW5TeW1ib2woc3ltYm9sKSB7XG4gICAgaWYgKFsnVVNE4oKuJywgJ1VTROKCrjAnLCAnVVNEdCddLmluY2x1ZGVzKHN5bWJvbCkpIHtcbiAgICAgICAgcmV0dXJuICdVU0RUJztcbiAgICB9XG4gICAgcmV0dXJuIHN5bWJvbDtcbn1cbmNvbnN0IHRvRmxhdEJhbGFuY2UgPSAoYXNzZXRzLCBjdXJyZW50Q2hhaW5JRCwgc2VsZWN0ZWRUb2tlbkFkZHJlc3MpID0+IHtcbiAgICBsb2dnZXIkYy5kZWJ1ZygndG9GbGF0QmFsYW5jZScsIHtcbiAgICAgICAgYXNzZXRzLFxuICAgIH0pO1xuICAgIHJldHVybiBhc3NldHNcbiAgICAgICAgLm1hcCgoYSkgPT4gYS5icmVha2Rvd24ubWFwKChiKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbW91bnQ6IGIuYmFsYW5jZSxcbiAgICAgICAgICAgIGNoYWluSUQ6IGIuY2hhaW4uaWQsXG4gICAgICAgICAgICBkZWNpbWFsczogYS5kZWNpbWFscyxcbiAgICAgICAgICAgIHN5bWJvbDogYS5zeW1ib2wsXG4gICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGNvbnZlcnRUbzMyQnl0ZXNIZXgoYi5jb250cmFjdEFkZHJlc3MgPT09IFpFUk9fQUREUkVTUyA/IEVBRERSRVNTIDogYi5jb250cmFjdEFkZHJlc3MpLFxuICAgICAgICAgICAgdW5pdmVyc2U6IGIudW5pdmVyc2UsXG4gICAgICAgICAgICB2YWx1ZTogYi5iYWxhbmNlSW5GaWF0LFxuICAgICAgICB9O1xuICAgIH0pKVxuICAgICAgICAuZmxhdCgpXG4gICAgICAgIC5maWx0ZXIoKGIpID0+IHtcbiAgICAgICAgcmV0dXJuICEoYi5jaGFpbklEID09PSBjdXJyZW50Q2hhaW5JRCAmJiBlcXVhbEZvbGQoYi50b2tlbkFkZHJlc3MsIHNlbGVjdGVkVG9rZW5BZGRyZXNzKSk7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcigoYikgPT4gYi51bml2ZXJzZSA9PT0gVW5pdmVyc2UuRVRIRVJFVU0gJiZcbiAgICAgICAgbmV3IERlY2ltYWwoYi5hbW91bnQpLmd0KDApICYmXG4gICAgICAgIG5ldyBEZWNpbWFsKGIudmFsdWUpLmd0KDApKTtcbn07XG5jb25zdCBiYWxhbmNlc1RvQXNzZXRzID0gKGFua3JCYWxhbmNlcywgZXZtQmFsYW5jZXMsIGZ1ZWxCYWxhbmNlcywgY2hhaW5MaXN0KSA9PiB7XG4gICAgY29uc3QgYXNzZXRzID0gW107XG4gICAgY29uc3QgdnNjQmFsYW5jZXMgPSBldm1CYWxhbmNlcy5jb25jYXQoZnVlbEJhbGFuY2VzKTtcbiAgICBsb2dnZXIkYy5kZWJ1ZygnYmFsYW5jZVRvQXNzZXRzJywge1xuICAgICAgICBhbmtyQmFsYW5jZXMsXG4gICAgICAgIGV2bUJhbGFuY2VzLFxuICAgICAgICBmdWVsQmFsYW5jZXMsXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBiYWxhbmNlIG9mIHZzY0JhbGFuY2VzKSB7XG4gICAgICAgIGZvciAoY29uc3QgY3VycmVuY3kgb2YgYmFsYW5jZS5jdXJyZW5jaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbiA9IGNoYWluTGlzdC5nZXRDaGFpbkJ5SUQoYnl0ZXNUb051bWJlcihiYWxhbmNlLmNoYWluX2lkKSk7XG4gICAgICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b2tlbkFkZHJlc3MgPSBjb252ZXJ0QWRkcmVzc0J5VW5pdmVyc2UodG9IZXgoY3VycmVuY3kudG9rZW5fYWRkcmVzcyksIGJhbGFuY2UudW5pdmVyc2UpO1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBjaGFpbkxpc3QuZ2V0VG9rZW5CeUFkZHJlc3MoY2hhaW4uaWQsIHRva2VuQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IHRva2VuID8gdG9rZW4uZGVjaW1hbHMgOiBjaGFpbi5uYXRpdmVDdXJyZW5jeS5kZWNpbWFscztcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzc2V0ID0gYXNzZXRzLmZpbmQoKHMpID0+IHMuc3ltYm9sID09PSB0b2tlbi5zeW1ib2wpO1xuICAgICAgICAgICAgICAgIGlmIChhc3NldCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NldC5iYWxhbmNlID0gbmV3IERlY2ltYWwoYXNzZXQuYmFsYW5jZSkuYWRkKGN1cnJlbmN5LmJhbGFuY2UpLnRvRml4ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXQuYmFsYW5jZUluRmlhdCA9IG5ldyBEZWNpbWFsKGFzc2V0LmJhbGFuY2VJbkZpYXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkKGN1cnJlbmN5LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvRGVjaW1hbFBsYWNlcygyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2V0LmJyZWFrZG93bi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2U6IGN1cnJlbmN5LmJhbGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlSW5GaWF0OiBuZXcgRGVjaW1hbChjdXJyZW5jeS52YWx1ZSkudG9EZWNpbWFsUGxhY2VzKDIpLnRvTnVtYmVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBieXRlc1RvTnVtYmVyKGJhbGFuY2UuY2hhaW5faWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ286IGNoYWluLmN1c3RvbS5pY29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGNoYWluLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXZlcnNlOiBiYWxhbmNlLnVuaXZlcnNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2V0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic3RyYWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlOiBjdXJyZW5jeS5iYWxhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFsYW5jZUluRmlhdDogbmV3IERlY2ltYWwoY3VycmVuY3kudmFsdWUpLnRvRGVjaW1hbFBsYWNlcygyKS50b051bWJlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtkb3duOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlOiBjdXJyZW5jeS5iYWxhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlSW5GaWF0OiBuZXcgRGVjaW1hbChjdXJyZW5jeS52YWx1ZSkudG9EZWNpbWFsUGxhY2VzKDIpLnRvTnVtYmVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogYnl0ZXNUb051bWJlcihiYWxhbmNlLmNoYWluX2lkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ286IGNoYWluLmN1c3RvbS5pY29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogY2hhaW4ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml2ZXJzZTogYmFsYW5jZS51bml2ZXJzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiB0b2tlbi5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IGdldExvZ29Gcm9tU3ltYm9sKHRva2VuLnN5bWJvbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IHRva2VuLnN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXNzZXQgb2YgYW5rckJhbGFuY2VzKSB7XG4gICAgICAgIGlmIChuZXcgRGVjaW1hbChhc3NldC5iYWxhbmNlKS5lcXVhbHMoMCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGQgPSBjaGFpbkRhdGEuZ2V0KGFzc2V0LmNoYWluSUQpO1xuICAgICAgICBpZiAoIWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYWluID0gY2hhaW5MaXN0LmdldENoYWluQnlJRChhc3NldC5jaGFpbklEKTtcbiAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhpc3RpbmdBc3NldCA9IGFzc2V0cy5maW5kKChhKSA9PiBlcXVhbEZvbGQoYS5zeW1ib2wsIGFzc2V0LnRva2VuRGF0YS5zeW1ib2wpKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nQXNzZXQpIHtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdBc3NldC5icmVha2Rvd24uZmluZCgodCkgPT4gdC5jaGFpbi5pZCA9PT0gY2hhaW4uaWQgJiYgZXF1YWxGb2xkKHQuY29udHJhY3RBZGRyZXNzLCBhc3NldC50b2tlbkFkZHJlc3MpKSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nQXNzZXQuYmFsYW5jZSA9IERlY2ltYWwuYWRkKGV4aXN0aW5nQXNzZXQuYmFsYW5jZSwgYXNzZXQuYmFsYW5jZSkudG9GaXhlZCgpO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nQXNzZXQuYmFsYW5jZUluRmlhdCA9IERlY2ltYWwuYWRkKGV4aXN0aW5nQXNzZXQuYmFsYW5jZUluRmlhdCwgYXNzZXQuYmFsYW5jZVVTRClcbiAgICAgICAgICAgICAgICAgICAgLnRvRGVjaW1hbFBsYWNlcygyKVxuICAgICAgICAgICAgICAgICAgICAudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0Fzc2V0LmJyZWFrZG93bi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZTogYXNzZXQuYmFsYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZUluRmlhdDogbmV3IERlY2ltYWwoYXNzZXQuYmFsYW5jZVVTRCkudG9EZWNpbWFsUGxhY2VzKDIpLnRvTnVtYmVyKCksXG4gICAgICAgICAgICAgICAgICAgIGNoYWluOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dvOiBjaGFpbi5jdXN0b20uaWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGNoYWluLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogYXNzZXQudG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogYXNzZXQudG9rZW5EYXRhLmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgICAgICB1bml2ZXJzZTogYXNzZXQudW5pdmVyc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NldHMucHVzaCh7XG4gICAgICAgICAgICAgICAgYWJzdHJhY3RlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBiYWxhbmNlOiBhc3NldC5iYWxhbmNlLFxuICAgICAgICAgICAgICAgIGJhbGFuY2VJbkZpYXQ6IG5ldyBEZWNpbWFsKGFzc2V0LmJhbGFuY2VVU0QpLnRvRGVjaW1hbFBsYWNlcygyKS50b051bWJlcigpLFxuICAgICAgICAgICAgICAgIGJyZWFrZG93bjogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlOiBhc3NldC5iYWxhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFsYW5jZUluRmlhdDogbmV3IERlY2ltYWwoYXNzZXQuYmFsYW5jZVVTRCkudG9EZWNpbWFsUGxhY2VzKDIpLnRvTnVtYmVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaGFpbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dvOiBjaGFpbi5jdXN0b20uaWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBjaGFpbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogYXNzZXQudG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IGFzc2V0LnRva2VuRGF0YS5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXZlcnNlOiBhc3NldC51bml2ZXJzZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBhc3NldC50b2tlbkRhdGEuZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgaWNvbjogYXNzZXQudG9rZW5EYXRhLmljb24sXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBhc3NldC50b2tlbkRhdGEuc3ltYm9sLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXRzLmZvckVhY2goKGFzc2V0KSA9PiB7XG4gICAgICAgIGFzc2V0LmJyZWFrZG93bi5zb3J0KChhLCBiKSA9PiBiLmJhbGFuY2VJbkZpYXQgLSBhLmJhbGFuY2VJbkZpYXQpO1xuICAgIH0pO1xuICAgIGFzc2V0cy5zb3J0KChhLCBiKSA9PiBiLmJhbGFuY2VJbkZpYXQgLSBhLmJhbGFuY2VJbkZpYXQpO1xuICAgIHJldHVybiBhc3NldHM7XG59O1xuY2xhc3MgQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpY0NsaWVudExpc3QpIHtcbiAgICAgICAgdGhpcy5wdWJsaWNDbGllbnRMaXN0ID0gcHVibGljQ2xpZW50TGlzdDtcbiAgICAgICAgdGhpcy5hbGxvd2FuY2VWYWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2V0Q29kZVZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbGxvd2FuY2VRdWVyaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLm5hdGl2ZUFsbG93YW5jZVF1ZXJpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuc2V0Q29kZVF1ZXJpZXMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGFkZEFsbG93YW5jZVF1ZXJ5KGlucHV0KSB7XG4gICAgICAgIHRoaXMuYWxsb3dhbmNlUXVlcmllcy5hZGQoaW5wdXQpO1xuICAgIH1cbiAgICBhZGRBbGxvd2FuY2VWYWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5hbGxvd2FuY2VWYWx1ZXMuc2V0KGdldEFsbG93YW5jZUNhY2hlS2V5KGlucHV0KSwgdmFsdWUpO1xuICAgIH1cbiAgICBhZGROYXRpdmVBbGxvd2FuY2VRdWVyeShpbnB1dCkge1xuICAgICAgICB0aGlzLm5hdGl2ZUFsbG93YW5jZVF1ZXJpZXMuYWRkKGlucHV0KTtcbiAgICB9XG4gICAgYWRkU2V0Q29kZVF1ZXJ5KGlucHV0KSB7XG4gICAgICAgIHRoaXMuc2V0Q29kZVF1ZXJpZXMuYWRkKGlucHV0KTtcbiAgICB9XG4gICAgYWRkU2V0Q29kZVZhbHVlKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldENvZGVWYWx1ZXMuc2V0KGdldFNldENvZGVLZXkoaW5wdXQpLCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldEFsbG93YW5jZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxvd2FuY2VWYWx1ZXMuZ2V0KGdldEFsbG93YW5jZUNhY2hlS2V5KGlucHV0KSk7XG4gICAgfVxuICAgIGdldENvZGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q29kZVZhbHVlcy5nZXQoZ2V0U2V0Q29kZUtleShpbnB1dCkpO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzKCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NOYXRpdmVBbGxvd2FuY2VSZXF1ZXN0cygpLFxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQWxsb3dhbmNlUmVxdWVzdHMoKSxcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0dldENvZGVSZXF1ZXN0cygpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc05hdGl2ZUFsbG93YW5jZVJlcXVlc3RzKCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIHRoaXMubmF0aXZlQWxsb3dhbmNlUXVlcmllcykge1xuICAgICAgICAgICAgY29uc3QgcHVibGljQ2xpZW50ID0gdGhpcy5wdWJsaWNDbGllbnRMaXN0LmdldChpbnB1dC5jaGFpbklEKTtcbiAgICAgICAgICAgIHJlcXVlc3RzLnB1c2gocHVibGljQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogaW5wdXQuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFiaTogQ2FsaWJ1ckFCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICduYXRpdmVBbGxvd2FuY2UnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtpbnB1dC5zcGVuZGVyXSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbG93YW5jZVZhbHVlcy5zZXQoZ2V0QWxsb3dhbmNlQ2FjaGVLZXkoaW5wdXQpLCBjb2RlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0cyk7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NBbGxvd2FuY2VSZXF1ZXN0cygpIHtcbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgcXVlcnkgbGlzdCBpcyBzbWFsbCBzbyBkb24ndCBjYXJlIGFib3V0IHBlcmZvcm1hbmNlIGhlcmUgKGZvciBub3cpXG4gICAgICAgIGNvbnN0IHVucHJvY2Vzc2VkSW5wdXQgPSBbLi4udGhpcy5hbGxvd2FuY2VRdWVyaWVzXS5maWx0ZXIoKHYpID0+IHRoaXMuZ2V0QWxsb3dhbmNlKHYpID09PSB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBpbnB1dEJ5Q2hhaW5JRCA9IE1hcC5ncm91cEJ5KHVucHJvY2Vzc2VkSW5wdXQsIChpKSA9PiBpLmNoYWluSUQpO1xuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtjaGFpbklELCBpbnB1dHNdIG9mIGlucHV0QnlDaGFpbklEKSB7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNDbGllbnQgPSB0aGlzLnB1YmxpY0NsaWVudExpc3QuZ2V0KGNoYWluSUQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0cy5wdXNoKGVxdWFsRm9sZChpbnB1dC5jb250cmFjdEFkZHJlc3MsIEVBRERSRVNTKVxuICAgICAgICAgICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZSh0aGlzLmFsbG93YW5jZVZhbHVlcy5zZXQoZ2V0QWxsb3dhbmNlQ2FjaGVLZXkoaW5wdXQpLCBtYXhVaW50MjU2KSlcbiAgICAgICAgICAgICAgICAgICAgOiBwdWJsaWNDbGllbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJpOiBFUkMyMEFCSSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGlucHV0LmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtpbnB1dC5vd25lciwgaW5wdXQuc3BlbmRlcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdhbGxvd2FuY2UnLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGFsbG93YW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGxvd2FuY2VWYWx1ZXMuc2V0KGdldEFsbG93YW5jZUNhY2hlS2V5KGlucHV0KSwgYWxsb3dhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3RzKTtcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc0dldENvZGVSZXF1ZXN0cygpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiB0aGlzLnNldENvZGVRdWVyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNDbGllbnQgPSB0aGlzLnB1YmxpY0NsaWVudExpc3QuZ2V0KGlucHV0LmNoYWluSUQpO1xuICAgICAgICAgICAgcmVxdWVzdHMucHVzaChwdWJsaWNDbGllbnRcbiAgICAgICAgICAgICAgICAuZ2V0Q29kZSh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogaW5wdXQuYWRkcmVzcyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvZGVWYWx1ZXMuc2V0KGdldFNldENvZGVLZXkoaW5wdXQpLCBjb2RlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0cyk7XG4gICAgfVxufVxuLy8gVG8gcmVtb3ZlIGR1cGxpY2F0aW9uIG9mIHB1YmxpY0NsaWVudHNcbmNsYXNzIFB1YmxpY0NsaWVudExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKGNoYWluTGlzdCkge1xuICAgICAgICB0aGlzLmNoYWluTGlzdCA9IGNoYWluTGlzdDtcbiAgICAgICAgdGhpcy5saXN0ID0ge307XG4gICAgfVxuICAgIGdldChjaGFpbklEKSB7XG4gICAgICAgIGxldCBjbGllbnQgPSB0aGlzLmxpc3RbTnVtYmVyKGNoYWluSUQpXTtcbiAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluID0gdGhpcy5jaGFpbkxpc3QuZ2V0Q2hhaW5CeUlEKE51bWJlcihjaGFpbklEKSk7XG4gICAgICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGFpbiBub3QgZm91bmQ6ICR7Y2hhaW5JRH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiBodHRwKGNoYWluLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5saXN0W051bWJlcihjaGFpbklEKV0gPSBjbGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG59XG5jb25zdCBnZXRBbGxvd2FuY2VDYWNoZUtleSA9ICh7IGNoYWluSUQsIGNvbnRyYWN0QWRkcmVzcywgb3duZXIsIHNwZW5kZXIsIH0pID0+ICgnYScgKyBjb250cmFjdEFkZHJlc3MgKyBjaGFpbklEICsgb3duZXIgKyBzcGVuZGVyKS50b0xvd2VyQ2FzZSgpO1xuY29uc3QgZ2V0U2V0Q29kZUtleSA9IChpbnB1dCkgPT4gKCdhJyArIGlucHV0LmNoYWluSUQgKyBpbnB1dC5hZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuLy8gY29uc3QgQVBQUk9WRV9HQVNfTElNSVQgPSA2M18wMDBuO1xuLy8gZXhwb3J0IGNvbnN0IHN3YXBUb0dhc0lmUG9zc2libGUgPSBhc3luYyAoe1xuLy8gICBhY3R1YWxBZGRyZXNzLFxuLy8gICBhZ2dyZWdhdG9ycyxcbi8vICAgYXNzZXRzVXNlZCxcbi8vICAgYmFsYW5jZXMsXG4vLyAgIGNoYWluTGlzdCxcbi8vICAgZXBoZW1lcmFsQWRkcmVzcyxcbi8vICAgb3JhY2xlUHJpY2VzLFxuLy8gfToge1xuLy8gICBhY3R1YWxBZGRyZXNzOiBCeXRlcztcbi8vICAgYWdncmVnYXRvcnM6IEFnZ3JlZ2F0b3JbXTtcbi8vICAgYXNzZXRzVXNlZDoge1xuLy8gICAgIGFtb3VudDogc3RyaW5nO1xuLy8gICAgIGNoYWluSUQ6IG51bWJlcjtcbi8vICAgICBjb250cmFjdEFkZHJlc3M6IGAweCR7c3RyaW5nfWA7XG4vLyAgIH1bXTtcbi8vICAgYmFsYW5jZXM6IEJhbGFuY2VzO1xuLy8gICBjaGFpbkxpc3Q6IENoYWluTGlzdDtcbi8vICAgZXBoZW1lcmFsQWRkcmVzczogQnl0ZXM7XG4vLyAgIGdycGNVUkw6IHN0cmluZztcbi8vICAgb3JhY2xlUHJpY2VzOiBPcmFjbGVQcmljZVJlc3BvbnNlO1xuLy8gfSkgPT4ge1xuLy8gICBjb25zdCBhY2k6IENyZWF0ZUFsbG93YW5jZUNhY2hlSW5wdXQgPSBuZXcgU2V0KCk7XG4vLyAgIGNvbnN0IGJsYWNrbGlzdDogSGV4W10gPSBbXTtcbi8vICAgY29uc3QgZGF0YToge1xuLy8gICAgIFtrOiBudW1iZXJdOiB7XG4vLyAgICAgICBhbW91bnQ6IGJpZ2ludDtcbi8vICAgICAgIGNvbnRyYWN0QWRkcmVzczogSGV4O1xuLy8gICAgICAgdHhzOiBUeFtdO1xuLy8gICAgICAgdW5zdXBwb3J0ZWRUb2tlbnM6IEhleFtdO1xuLy8gICAgIH07XG4vLyAgIH0gPSB7fTtcbi8vICAgbGV0IHJlcXVvdGUgPSBmYWxzZTtcbi8vICAgY29uc3QgY2hhaW5Ub1Vuc3VwcG9ydGVkVG9rZW5zOiBSZWNvcmQ8bnVtYmVyLCBIZXhbXT4gPSB7fTtcbi8vICAgY29uc3QgYXNzZXRzR3JvdXBlZEJ5Q2hhaW4gPSBNYXAuZ3JvdXBCeShcbi8vICAgICBhc3NldHNVc2VkLFxuLy8gICAgIChhc3NldCkgPT4gYXNzZXQuY2hhaW5JRCxcbi8vICAgKTtcbi8vICAgZm9yIChjb25zdCBbY2hhaW5JRCwgc3dhcFF1b3Rlc10gb2YgYXNzZXRzR3JvdXBlZEJ5Q2hhaW4pIHtcbi8vICAgICBmb3IgKGNvbnN0IHNRdW90ZSBvZiBzd2FwUXVvdGVzKSB7XG4vLyAgICAgICBpZiAoIWlzRUlQMjYxMlN1cHBvcnRlZChzUXVvdGUuY29udHJhY3RBZGRyZXNzLCBCaWdJbnQoY2hhaW5JRCkpKSB7XG4vLyAgICAgICAgIGlmICghY2hhaW5Ub1Vuc3VwcG9ydGVkVG9rZW5zW051bWJlcihjaGFpbklEKV0pIHtcbi8vICAgICAgICAgICBjaGFpblRvVW5zdXBwb3J0ZWRUb2tlbnNbTnVtYmVyKGNoYWluSUQpXSA9IFtdO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGFjaS5hZGQoe1xuLy8gICAgICAgICAgIGNoYWluSUQ6IE51bWJlcihjaGFpbklEKSxcbi8vICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHNRdW90ZS5jb250cmFjdEFkZHJlc3MsXG4vLyAgICAgICAgICAgb3duZXI6IGNvbnZlcnRUb0VWTUFkZHJlc3MoYWN0dWFsQWRkcmVzcyksXG4vLyAgICAgICAgICAgc3BlbmRlcjogY29udmVydFRvRVZNQWRkcmVzcyhlcGhlbWVyYWxBZGRyZXNzKSxcbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIGNoYWluVG9VbnN1cHBvcnRlZFRva2Vuc1tOdW1iZXIoY2hhaW5JRCldLnB1c2goc1F1b3RlLmNvbnRyYWN0QWRkcmVzcyk7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIGxvZ2dlci5kZWJ1ZyhcImNoZWNrQW5kU3VwcGx5R2FzRm9yQXBwcm92YWw6MVwiLCB7XG4vLyAgICAgYXNzZXRzR3JvdXBlZEJ5Q2hhaW4sXG4vLyAgICAgY2hhaW5Ub1Vuc3VwcG9ydGVkVG9rZW5zLFxuLy8gICB9KTtcbi8vICAgY29uc3QgYWxsb3dhbmNlQ2FjaGUgPSBhd2FpdCBjcmVhdGVBbGxvd2FuY2VDYWNoZShhY2ksIGNoYWluTGlzdCk7XG4vLyAgIGlmIChPYmplY3Qua2V5cyhjaGFpblRvVW5zdXBwb3J0ZWRUb2tlbnMpLmxlbmd0aCA9PT0gMCkge1xuLy8gICAgIHJldHVybiB7IGJsYWNrbGlzdCwgZGF0YSwgcmVxdW90ZTogZmFsc2UgfTtcbi8vICAgfVxuLy8gICBmb3IgKGNvbnN0IGNoYWluSUQgaW4gY2hhaW5Ub1Vuc3VwcG9ydGVkVG9rZW5zKSB7XG4vLyAgICAgY29uc3QgdG9rZW5zOiBIZXhbXSA9IFtdO1xuLy8gICAgIGZvciAoY29uc3QgdG9rZW4gb2YgY2hhaW5Ub1Vuc3VwcG9ydGVkVG9rZW5zW2NoYWluSURdKSB7XG4vLyAgICAgICBjb25zdCBhbGxvd2FuY2UgPSBhbGxvd2FuY2VDYWNoZS5nZ2V0KHtcbi8vICAgICAgICAgY2hhaW5JRDogTnVtYmVyKGNoYWluSUQpLFxuLy8gICAgICAgICBvd25lcjogY29udmVydFRvRVZNQWRkcmVzcyhhY3R1YWxBZGRyZXNzKSxcbi8vICAgICAgICAgc3BlbmRlcjogY29udmVydFRvRVZNQWRkcmVzcyhlcGhlbWVyYWxBZGRyZXNzKSxcbi8vICAgICAgICAgdG9rZW5BZGRyZXNzOiB0b2tlbixcbi8vICAgICAgIH0pO1xuLy8gICAgICAgaWYgKCFhbGxvd2FuY2UgfHwgYWxsb3dhbmNlIDwgMTAwMDAwMDAwbikge1xuLy8gICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XG4vLyAgICAgICBjaGFpblRvVW5zdXBwb3J0ZWRUb2tlbnNbY2hhaW5JRF0gPSB0b2tlbnM7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIGRlbGV0ZSBjaGFpblRvVW5zdXBwb3J0ZWRUb2tlbnNbY2hhaW5JRF07XG4vLyAgICAgfVxuLy8gICAgIGNvbnN0IHF1b3RlcyA9IGFzc2V0c0dyb3VwZWRCeUNoYWluLmdldChOdW1iZXIoY2hhaW5JRCkpO1xuLy8gICAgIGNvbnN0IGJhbGFuY2VzT25DaGFpbiA9IGJhbGFuY2VzLmZpbHRlcihcbi8vICAgICAgIChiKSA9PlxuLy8gICAgICAgICBiLmNoYWluX2lkID09PSBOdW1iZXIoY2hhaW5JRCkgJiZcbi8vICAgICAgICAgaXNFSVAyNjEyU3VwcG9ydGVkKGIudG9rZW5fYWRkcmVzcywgQmlnSW50KGNoYWluSUQpKSxcbi8vICAgICApO1xuLy8gICAgIGNvbnN0IGNoYWluID0gY2hhaW5MaXN0LmdldENoYWluQnlJRChOdW1iZXIoY2hhaW5JRCkpO1xuLy8gICAgIGlmICghY2hhaW4pIHtcbi8vICAgICAgIHRocm93IG5ldyBFcnJvcihgY2hhaW4gbm90IGZvdW5kOiAke2NoYWluSUR9YCk7XG4vLyAgICAgfVxuLy8gICAgIGNvbnN0IHB1YmxpY0NsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4vLyAgICAgICB0cmFuc3BvcnQ6IGh0dHAoY2hhaW4ucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0pLFxuLy8gICAgIH0pO1xuLy8gICAgIGNvbnN0IGdhc1ByaWNlID0gYXdhaXQgcHVibGljQ2xpZW50LmVzdGltYXRlRmVlc1BlckdhcygpO1xuLy8gICAgIGNvbnN0IGdhcyA9XG4vLyAgICAgICBBUFBST1ZFX0dBU19MSU1JVCAqXG4vLyAgICAgICBnYXNQcmljZS5tYXhGZWVQZXJHYXMgKlxuLy8gICAgICAgQmlnSW50KGNoYWluVG9VbnN1cHBvcnRlZFRva2Vuc1tjaGFpbklEXS5sZW5ndGgpICpcbi8vICAgICAgIDNuO1xuLy8gICAgIGNvbnN0IG5hdGl2ZUJhbGFuY2UgPSBiYWxhbmNlcy5maW5kKFxuLy8gICAgICAgKGIpID0+XG4vLyAgICAgICAgIGIuY2hhaW5faWQgPT09IE51bWJlcihjaGFpbklEKSAmJiBlcXVhbEZvbGQoYi50b2tlbl9hZGRyZXNzLCBFQUREUkVTUyksXG4vLyAgICAgKTtcbi8vICAgICBsb2dnZXIuZGVidWcoXCJjaGVja0FuZFN1cHBseUdhc0ZvckFwcHJvdmFsOjJcIiwge1xuLy8gICAgICAgZ2FzLFxuLy8gICAgICAgZ2FzUHJpY2UsXG4vLyAgICAgICBuYXRpdmVCYWxhbmNlLFxuLy8gICAgIH0pO1xuLy8gICAgIGlmIChuZXcgRGVjaW1hbChuYXRpdmVCYWxhbmNlPy5hbW91bnQgPz8gMCkuZ3RlKGdhcykpIHtcbi8vICAgICAgIGRhdGFbTnVtYmVyKGNoYWluSUQpXSA9IHtcbi8vICAgICAgICAgLy8gU2luY2UgdHhzLmxlbmd0aCA9PSAwLCBhbW91bnQgYW5kIGNvbnRyYWN0QWRkcmVzcyBzaG91bGQgbm90IGdldCB1c2VkLCBvbmx5IHVuc3VwcG9ydGVkIHRva2VuXG4vLyAgICAgICAgIGFtb3VudDogMG4sXG4vLyAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogXCIweFwiLFxuLy8gICAgICAgICB0eHM6IFtdLFxuLy8gICAgICAgICB1bnN1cHBvcnRlZFRva2VuczogY2hhaW5Ub1Vuc3VwcG9ydGVkVG9rZW5zW2NoYWluSURdLFxuLy8gICAgICAgfTtcbi8vICAgICAgIGNvbnRpbnVlO1xuLy8gICAgIH1cbi8vICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuLy8gICAgIC8vIFNwbGl0IGJldHdlZW4gc291cmNlcyBpbmNsdWRlZCBhbmQgZXhjbHVkZWQgaW4gc291cmNlIHN3YXBzXG4vLyAgICAgY29uc3Qgc3BsaXQgPSBzcGxpdEJhbGFuY2VCeVF1b3RlcyhiYWxhbmNlc09uQ2hhaW4sIHF1b3RlcyEpO1xuLy8gICAgIGxvZ2dlci5kZWJ1ZyhcImNoZWNrQW5kU3VwcGx5R2FzRm9yQXBwcm92YWw6M1wiLCB7XG4vLyAgICAgICBjaGFpbklELFxuLy8gICAgICAgc3BsaXQsXG4vLyAgICAgfSk7XG4vLyAgICAgZm9yIChjb25zdCBzIG9mIHNwbGl0LmV4Y2x1ZGVkKSB7XG4vLyAgICAgICBjb25zdCBnYXNJblRva2VuID0gY29udmVydEdhc1RvVG9rZW4oXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHMudG9rZW5fYWRkcmVzcyxcbi8vICAgICAgICAgICBkZWNpbWFsczogcy5kZWNpbWFscyxcbi8vICAgICAgICAgICBwcmljZVVTRDogcy5wcmljZVVTRCxcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAgb3JhY2xlUHJpY2VzLFxuLy8gICAgICAgICBjaGFpbi5pZCxcbi8vICAgICAgICAgZGl2RGVjaW1hbHMoZ2FzLCBjaGFpbi5uYXRpdmVDdXJyZW5jeS5kZWNpbWFscyksXG4vLyAgICAgICApO1xuLy8gICAgICAgbG9nZ2VyLmRlYnVnKFwiY2hlY2tBbmRTdXBwbHlHYXNGb3JBcHByb3ZhbDozOmV4Y2x1ZGVkXCIsIHtcbi8vICAgICAgICAgYW1vdW50OiBzLmFtb3VudCxcbi8vICAgICAgICAgZ2FzSW5Ub2tlbjogZ2FzSW5Ub2tlbi50b0ZpeGVkKCksXG4vLyAgICAgICAgIHRva2VuOiBzLFxuLy8gICAgICAgfSk7XG4vLyAgICAgICBpZiAoZ2FzSW5Ub2tlbi5sdChzLmFtb3VudCkpIHtcbi8vICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgc3dhcFRvR2FzUXVvdGUoXG4vLyAgICAgICAgICAgZXBoZW1lcmFsQWRkcmVzcyxcbi8vICAgICAgICAgICBhY3R1YWxBZGRyZXNzLFxuLy8gICAgICAgICAgIG5ldyBPbW5pdmVyc2FsQ2hhaW5JRChVbml2ZXJzZS5FVEhFUkVVTSwgY2hhaW5JRCksXG4vLyAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiBFQUREUkVTU18zMl9CWVRFUyxcbi8vICAgICAgICAgICB9LFxuLy8gICAgICAgICAgIGFnZ3JlZ2F0b3JzLFxuLy8gICAgICAgICAgIHtcbi8vICAgICAgICAgICAgIGFtb3VudDogbXVsRGVjaW1hbHMoZ2FzSW5Ub2tlbiwgcy5kZWNpbWFscyksXG4vLyAgICAgICAgICAgICBkZWNpbWFsczogcy5kZWNpbWFscyxcbi8vICAgICAgICAgICAgIHRva2VuQWRkcmVzczogY29udmVydFRvMzJCeXRlcyhzLnRva2VuX2FkZHJlc3MpLFxuLy8gICAgICAgICAgIH0sXG4vLyAgICAgICAgICk7XG4vLyAgICAgICAgIGlmIChyZXMucXVvdGUpIHtcbi8vICAgICAgICAgICBjb25zdCB0eHMgPSBnZXRUeHNGcm9tUXVvdGUoXG4vLyAgICAgICAgICAgICByZXMuYWdncmVnYXRvcixcbi8vICAgICAgICAgICAgIHJlcy5xdW90ZSxcbi8vICAgICAgICAgICAgIGNvbnZlcnRUbzMyQnl0ZXMocy50b2tlbl9hZGRyZXNzKSxcbi8vICAgICAgICAgICApO1xuLy8gICAgICAgICAgIGRhdGFbTnVtYmVyKGNoYWluSUQpXSA9IHtcbi8vICAgICAgICAgICAgIGFtb3VudDogbXVsRGVjaW1hbHMoZ2FzSW5Ub2tlbiwgcy5kZWNpbWFscyksXG4vLyAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHMudG9rZW5fYWRkcmVzcyxcbi8vICAgICAgICAgICAgIHR4czogW3R4cy5hcHByb3ZhbCEsIHR4cy5zd2FwXSxcbi8vICAgICAgICAgICAgIHVuc3VwcG9ydGVkVG9rZW5zOiBjaGFpblRvVW5zdXBwb3J0ZWRUb2tlbnNbY2hhaW5JRF0sXG4vLyAgICAgICAgICAgfTtcbi8vICAgICAgICAgICBkb25lID0gdHJ1ZTtcbi8vICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgfVxuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgICBpZiAoIWRvbmUpIHtcbi8vICAgICAgIGZvciAoY29uc3QgcyBvZiBzcGxpdC5pbmNsdWRlZCkge1xuLy8gICAgICAgICBjb25zdCBnYXNJblRva2VuID0gY29udmVydEdhc1RvVG9rZW4oXG4vLyAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBzLnRva2VuX2FkZHJlc3MsXG4vLyAgICAgICAgICAgICBkZWNpbWFsczogcy5kZWNpbWFscyxcbi8vICAgICAgICAgICAgIHByaWNlVVNEOiBzLnByaWNlVVNELFxuLy8gICAgICAgICAgIH0sXG4vLyAgICAgICAgICAgb3JhY2xlUHJpY2VzLFxuLy8gICAgICAgICAgIGNoYWluLmlkLFxuLy8gICAgICAgICAgIGRpdkRlY2ltYWxzKGdhcywgY2hhaW4ubmF0aXZlQ3VycmVuY3kuZGVjaW1hbHMpLFxuLy8gICAgICAgICApO1xuLy8gICAgICAgICBsb2dnZXIuZGVidWcoXCJjaGVja0FuZFN1cHBseUdhc0ZvckFwcHJvdmFsOjM6aW5jbHVkZWRcIiwge1xuLy8gICAgICAgICAgIGFtb3VudDogcy5hbW91bnQsXG4vLyAgICAgICAgICAgZ2FzSW5Ub2tlbjogZ2FzSW5Ub2tlbi50b0ZpeGVkKCksXG4vLyAgICAgICAgIH0pO1xuLy8gICAgICAgICBpZiAoZ2FzSW5Ub2tlbi5ndGUocy5hbW91bnQpKSB7XG4vLyAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgc3dhcFRvR2FzUXVvdGUoXG4vLyAgICAgICAgICAgICBlcGhlbWVyYWxBZGRyZXNzLFxuLy8gICAgICAgICAgICAgYWN0dWFsQWRkcmVzcyxcbi8vICAgICAgICAgICAgIG5ldyBPbW5pdmVyc2FsQ2hhaW5JRChVbml2ZXJzZS5FVEhFUkVVTSwgY2hhaW5JRCksXG4vLyAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgIHRva2VuQWRkcmVzczogRUFERFJFU1NfMzJfQllURVMsXG4vLyAgICAgICAgICAgICB9LFxuLy8gICAgICAgICAgICAgYWdncmVnYXRvcnMsXG4vLyAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgIGFtb3VudDogbXVsRGVjaW1hbHMoZ2FzSW5Ub2tlbiwgcy5kZWNpbWFscyksXG4vLyAgICAgICAgICAgICAgIGRlY2ltYWxzOiBzLmRlY2ltYWxzLFxuLy8gICAgICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGNvbnZlcnRUbzMyQnl0ZXMocy50b2tlbl9hZGRyZXNzKSxcbi8vICAgICAgICAgICAgIH0sXG4vLyAgICAgICAgICAgKTtcbi8vICAgICAgICAgICBpZiAocmVzLnF1b3RlKSB7XG4vLyAgICAgICAgICAgICBjb25zdCB0eHMgPSBnZXRUeHNGcm9tUXVvdGUoXG4vLyAgICAgICAgICAgICAgIHJlcy5hZ2dyZWdhdG9yLFxuLy8gICAgICAgICAgICAgICByZXMucXVvdGUsXG4vLyAgICAgICAgICAgICAgIGNvbnZlcnRUbzMyQnl0ZXMocy50b2tlbl9hZGRyZXNzKSxcbi8vICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICBkYXRhW051bWJlcihjaGFpbklEKV0gPSB7XG4vLyAgICAgICAgICAgICAgIGFtb3VudDogbXVsRGVjaW1hbHMoZ2FzSW5Ub2tlbiwgcy5kZWNpbWFscyksXG4vLyAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogcy50b2tlbl9hZGRyZXNzLFxuLy8gICAgICAgICAgICAgICB0eHM6IFt0eHMuYXBwcm92YWwhLCB0eHMuc3dhcF0sXG4vLyAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkVG9rZW5zOiBjaGFpblRvVW5zdXBwb3J0ZWRUb2tlbnNbY2hhaW5JRF0sXG4vLyAgICAgICAgICAgICB9O1xuLy8gICAgICAgICAgICAgLy8gc2luY2Ugd2UgaGFkIHRvIHVzZSBzb3VyY2Ugc3dhcCB0b2tlbiBmb3IgZ2FzXG4vLyAgICAgICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiB3ZSBoYXZlIGVub3VnaCBpZiB3ZSBzd2FwIGZvciBnYXMgb3RoZXJ3aXNlIHRocm93IGVycm9yXG4vLyAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbi8vICAgICAgICAgICAgIHJlcXVvdGUgPSB0cnVlO1xuLy8gICAgICAgICAgICAgYnJlYWs7XG4vLyAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIGlmICghZG9uZSkge1xuLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb3VsZCBub3Qgc3dhcCB0b2tlbiBmb3IgZ2FzIG9uIGNoYWluOiAke2NoYWluSUR9YCk7XG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIHJldHVybiB7XG4vLyAgICAgYmxhY2tsaXN0LFxuLy8gICAgIGRhdGEsXG4vLyAgICAgcmVxdW90ZSxcbi8vICAgfTtcbi8vIH07XG4vLyBjb25zdCBjb252ZXJ0R2FzVG9Ub2tlbiA9IChcbi8vICAgdG9rZW46IHsgY29udHJhY3RBZGRyZXNzOiBIZXg7IGRlY2ltYWxzOiBudW1iZXI7IHByaWNlVVNEOiBzdHJpbmcgfSxcbi8vICAgb3JhY2xlUHJpY2VzOiBPcmFjbGVQcmljZVJlc3BvbnNlLFxuLy8gICBkZXN0aW5hdGlvbkNoYWluSUQ6IG51bWJlcixcbi8vICAgZ2FzOiBEZWNpbWFsLFxuLy8gKSA9PiB7XG4vLyAgIGNvbnN0IGdhc1Rva2VuUGVyVVNEID1cbi8vICAgICBvcmFjbGVQcmljZXNcbi8vICAgICAgIC5maW5kKFxuLy8gICAgICAgICAocmF0ZSkgPT5cbi8vICAgICAgICAgICByYXRlLmNoYWluSWQgPT09IGRlc3RpbmF0aW9uQ2hhaW5JRCAmJlxuLy8gICAgICAgICAgIGVxdWFsRm9sZChyYXRlLnRva2VuQWRkcmVzcywgWkVST19BRERSRVNTKSxcbi8vICAgICAgIClcbi8vICAgICAgID8udG9rZW5zUGVyVXNkLnRvU3RyaW5nKCkgPz8gXCIwXCI7XG4vLyAgIGNvbnN0IHRyYW5zZmVyVG9rZW5QZXJVU0QgPSBEZWNpbWFsLmRpdigxLCB0b2tlbi5wcmljZVVTRCk7XG4vLyAgIGxvZ2dlci5kZWJ1ZyhcImNvbnZlcnRHYXNUb1Rva2VuXCIsIHtcbi8vICAgICBnYXM6IGdhcy50b0ZpeGVkKCksXG4vLyAgICAgZ2FzVG9rZW5QZXJVU0QsXG4vLyAgICAgdHJhbnNmZXJUb2tlblBlclVTRCxcbi8vICAgfSk7XG4vLyAgIGNvbnN0IGdhc0luVVNEID0gbmV3IERlY2ltYWwoMSkuZGl2KGdhc1Rva2VuUGVyVVNEKS5tdWwoZ2FzKTtcbi8vICAgY29uc3QgdG90YWxSZXF1aXJlZCA9IG5ldyBEZWNpbWFsKGdhc0luVVNEKS5kaXYodHJhbnNmZXJUb2tlblBlclVTRCk7XG4vLyAgIHJldHVybiB0b3RhbFJlcXVpcmVkLnRvRFAodG9rZW4uZGVjaW1hbHMsIERlY2ltYWwuUk9VTkRfQ0VJTCk7XG4vLyB9O1xuY29uc3QgZ2V0VHhzRnJvbVF1b3RlID0gKGFnZ3JlZ2F0b3IsIHF1b3RlLCBpbnB1dFRva2VuLCBjcmVhdGVBcHByb3ZhbCA9IHRydWUpID0+IHtcbiAgICBsb2dnZXIkYy5kZWJ1ZygnZ2V0VHhzRnJvbVF1b3RlJywge1xuICAgICAgICBhZ2dyZWdhdG9yLFxuICAgICAgICBjcmVhdGVBcHByb3ZhbCxcbiAgICAgICAgaW5wdXRUb2tlbixcbiAgICAgICAgcXVvdGUsXG4gICAgfSk7XG4gICAgaWYgKGFnZ3JlZ2F0b3IgaW5zdGFuY2VvZiBMaUZpQWdncmVnYXRvcikge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFJlc3BvbnNlID0gcXVvdGUub3JpZ2luYWxSZXNwb25zZTtcbiAgICAgICAgY29uc3QgdHggPSBvcmlnaW5hbFJlc3BvbnNlLnRyYW5zYWN0aW9uUmVxdWVzdDtcbiAgICAgICAgbG9nZ2VyJGMuZGVidWcoJ2dldFR4c0Zyb21RdW90ZScsIHtcbiAgICAgICAgICAgICdhcHByb3ZhbC5hbW91bnQnOiBxdW90ZS5pbnB1dEFtb3VudCxcbiAgICAgICAgICAgICdhcHByb3ZhbC50YXJnZXQnOiBvcmlnaW5hbFJlc3BvbnNlLmVzdGltYXRlLmFwcHJvdmFsQWRkcmVzcyxcbiAgICAgICAgICAgIHR4OiB0eCxcbiAgICAgICAgICAgICd0eC5hbW91bnQnOiBxdW90ZS5pbnB1dEFtb3VudCxcbiAgICAgICAgICAgICd0eC5pbnB1dFRva2VuJzogaW5wdXRUb2tlbixcbiAgICAgICAgICAgICd0eC5vdXRwdXRBbW91bnQnOiBxdW90ZS5vdXRwdXRBbW91bnRNaW5pbXVtLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdmFsID0ge1xuICAgICAgICAgICAgYW1vdW50OiBxdW90ZS5pbnB1dEFtb3VudCxcbiAgICAgICAgICAgIGFwcHJvdmFsOiBudWxsLFxuICAgICAgICAgICAgaW5wdXRUb2tlbixcbiAgICAgICAgICAgIG91dHB1dEFtb3VudDogcXVvdGUub3V0cHV0QW1vdW50TWluaW11bSxcbiAgICAgICAgICAgIHN3YXA6IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHRvOiB0eC50byxcbiAgICAgICAgICAgICAgICB2YWx1ZTogQmlnSW50KHR4LnZhbHVlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjcmVhdGVBcHByb3ZhbCkge1xuICAgICAgICAgICAgdmFsLmFwcHJvdmFsID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHBhY2tFUkMyMEFwcHJvdmUob3JpZ2luYWxSZXNwb25zZS5lc3RpbWF0ZS5hcHByb3ZhbEFkZHJlc3MsIHF1b3RlLmlucHV0QW1vdW50KSxcbiAgICAgICAgICAgICAgICB0bzogY29udmVydFRvRVZNQWRkcmVzcyhpbnB1dFRva2VuKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMG4sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFnZ3JlZ2F0b3IgaW5zdGFuY2VvZiBCZWJvcEFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxSZXNwb25zZSA9IHF1b3RlLm9yaWdpbmFsUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IHR4ID0gb3JpZ2luYWxSZXNwb25zZS5xdW90ZS50eDtcbiAgICAgICAgbG9nZ2VyJGMuZGVidWcoJ2dldFR4c0Zyb21RdW90ZScsIHtcbiAgICAgICAgICAgICdhcHByb3ZhbC5hbW91bnQnOiBxdW90ZS5pbnB1dEFtb3VudCxcbiAgICAgICAgICAgICdhcHByb3ZhbC50YXJnZXQnOiBvcmlnaW5hbFJlc3BvbnNlLnF1b3RlLmFwcHJvdmFsVGFyZ2V0LFxuICAgICAgICAgICAgdHg6IHR4LFxuICAgICAgICAgICAgJ3R4LmFtb3VudCc6IHF1b3RlLmlucHV0QW1vdW50LFxuICAgICAgICAgICAgJ3R4LmlucHV0VG9rZW4nOiBpbnB1dFRva2VuLFxuICAgICAgICAgICAgJ3R4Lm91dHB1dEFtb3VudCc6IHF1b3RlLm91dHB1dEFtb3VudE1pbmltdW0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB2YWwgPSB7XG4gICAgICAgICAgICBhbW91bnQ6IHF1b3RlLmlucHV0QW1vdW50LFxuICAgICAgICAgICAgYXBwcm92YWw6IG51bGwsXG4gICAgICAgICAgICBpbnB1dFRva2VuLFxuICAgICAgICAgICAgb3V0cHV0QW1vdW50OiBxdW90ZS5vdXRwdXRBbW91bnRNaW5pbXVtLFxuICAgICAgICAgICAgc3dhcDoge1xuICAgICAgICAgICAgICAgIGRhdGE6IHR4LmRhdGEsXG4gICAgICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQodHgudmFsdWUpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNyZWF0ZUFwcHJvdmFsKSB7XG4gICAgICAgICAgICB2YWwuYXBwcm92YWwgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogcGFja0VSQzIwQXBwcm92ZShvcmlnaW5hbFJlc3BvbnNlLnF1b3RlLmFwcHJvdmFsVGFyZ2V0LCBxdW90ZS5pbnB1dEFtb3VudCksXG4gICAgICAgICAgICAgICAgdG86IGNvbnZlcnRUb0VWTUFkZHJlc3MoaW5wdXRUb2tlbiksXG4gICAgICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYWdncmVnYXRvcicpO1xufTtcbmNvbnN0IGNyZWF0ZVN3YXBJbnRlbnQgPSAoc291cmNlcywgZGVzdGluYXRpb24sIGNoYWluTGlzdCkgPT4ge1xuICAgIGNvbnN0IGNoYWluID0gY2hhaW5MaXN0LmdldENoYWluQnlJRChkZXN0aW5hdGlvbi5jaGFpbklEKTtcbiAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2hhaW4gbm90IGZvdW5kOiAke2Rlc3RpbmF0aW9uLmNoYWluSUR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGludGVudCA9IHtcbiAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICAgIGFtb3VudDogZGVzdGluYXRpb24uYW1vdW50LFxuICAgICAgICAgICAgY2hhaW46IHtcbiAgICAgICAgICAgICAgICBpZDogY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgbG9nbzogY2hhaW4uY3VzdG9tLmljb24sXG4gICAgICAgICAgICAgICAgbmFtZTogY2hhaW4ubmFtZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2tlbjoge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogZGVzdGluYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBkZXN0aW5hdGlvbi5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IGRlc3RpbmF0aW9uLnN5bWJvbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZXM6IFtdLFxuICAgIH07XG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICBjb25zdCBjaGFpbiA9IGNoYWluTGlzdC5nZXRDaGFpbkJ5SUQoc291cmNlLmNoYWluSUQpO1xuICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNoYWluIG5vdCBmb3VuZDogJHtzb3VyY2UuY2hhaW5JRH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlbnQuc291cmNlcy5wdXNoKHtcbiAgICAgICAgICAgIGFtb3VudDogc291cmNlLmFtb3VudCxcbiAgICAgICAgICAgIGNoYWluOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGNoYWluLmlkLFxuICAgICAgICAgICAgICAgIGxvZ286IGNoYWluLmN1c3RvbS5pY29uLFxuICAgICAgICAgICAgICAgIG5hbWU6IGNoYWluLm5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9rZW46IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHNvdXJjZS5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IHNvdXJjZS5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IHNvdXJjZS5zeW1ib2wsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVudDtcbn07XG5jb25zdCBnZXRUb2tlbkluZm8gPSBhc3luYyAoY29udHJhY3RBZGRyZXNzLCBwdWJsaWNDbGllbnQsIGNoYWluKSA9PiB7XG4gICAgaWYgKGlzTmF0aXZlQWRkcmVzcyhjb250cmFjdEFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IFpFUk9fQUREUkVTUyxcbiAgICAgICAgICAgIGRlY2ltYWxzOiBjaGFpbi5uYXRpdmVDdXJyZW5jeS5kZWNpbWFscyxcbiAgICAgICAgICAgIHN5bWJvbDogY2hhaW4ubmF0aXZlQ3VycmVuY3kuc3ltYm9sLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgW2RlY2ltYWxzLCBzeW1ib2xdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgcHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWJpOiBFUkMyMEFCSSxcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnZGVjaW1hbHMnLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwdWJsaWNDbGllbnQucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBhYmk6IEVSQzIwQUJJLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdzeW1ib2wnLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4geyBjb250cmFjdEFkZHJlc3MsIGRlY2ltYWxzLCBzeW1ib2wgfTtcbiAgICB9XG59O1xuY29uc3QgbWV0YWRhdGFBeGlvcyA9IG1zZ3BhY2thYmxlQXhpb3MuY3JlYXRlKHtcbiAgICBiYXNlVVJMOiAnaHR0cHM6Ly9tZXRhZGF0YS1jZXJpc2UuYXJjYW5hLm5ldHdvcmsnLFxufSk7XG5jb25zdCB0eXBlcyA9IHtcbiAgICBSZWNvcmQ6IFtcbiAgICAgICAgeyBuYW1lOiAncmZmX2lkJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgIHsgbmFtZTogJ2hhc194Y3MnLCB0eXBlOiAnYm9vbCcgfSxcbiAgICAgICAgeyBuYW1lOiAnc3JjJywgdHlwZTogJ1RyYW5zYWN0aW9uW10nIH0sXG4gICAgICAgIHsgbmFtZTogJ2RzdCcsIHR5cGU6ICdUcmFuc2FjdGlvbicgfSxcbiAgICBdLFxuICAgIFRyYW5zYWN0aW9uOiBbXG4gICAgICAgIHsgbmFtZTogJ3VuaXYnLCB0eXBlOiAndWludDgnIH0sXG4gICAgICAgIHsgbmFtZTogJ2NoaWQnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgICAgeyBuYW1lOiAndHhfaGFzaCcsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgICB7IG5hbWU6ICdzd2FwcycsIHR5cGU6ICdYQ1NTd2FwW10nIH0sXG4gICAgXSxcbiAgICBYQ1NTd2FwOiBbXG4gICAgICAgIHsgbmFtZTogJ2lucHV0X2NvbnRyYWN0JywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICAgIHsgbmFtZTogJ2lucHV0X2FtdCcsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgICAgICB7IG5hbWU6ICdpbnB1dF9kZWNpbWFscycsIHR5cGU6ICd1aW50OCcgfSxcbiAgICAgICAgeyBuYW1lOiAnb3V0cHV0X2NvbnRyYWN0JywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICAgIHsgbmFtZTogJ291dHB1dF9hbXQnLCB0eXBlOiAndWludDI1NicgfSxcbiAgICAgICAgeyBuYW1lOiAnb3V0cHV0X2RlY2ltYWxzJywgdHlwZTogJ3VpbnQ4JyB9LFxuICAgICAgICB7IG5hbWU6ICdhZ2cnLCB0eXBlOiAndWludDgnIH0sXG4gICAgXSxcbn07XG5jb25zdCBjb252ZXJ0U3dhcE1ldGFUb1N3YXAgPSAoc3JjKSA9PiB7XG4gICAgY29uc3Qgc3dhcHMgPSBzcmMuc3dhcHMubWFwKChzKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dEFtb3VudDogYnl0ZXNUb0JpZ0ludChzLmlucHV0X2FtdCksXG4gICAgICAgICAgICBpbnB1dENvbnRyYWN0OiBjb252ZXJ0VG9FVk1BZGRyZXNzKHMuaW5wdXRfY29udHJhY3QpLFxuICAgICAgICAgICAgaW5wdXREZWNpbWFsczogcy5pbnB1dF9kZWNpbWFscyxcbiAgICAgICAgICAgIG91dHB1dEFtb3VudDogYnl0ZXNUb0JpZ0ludChzLm91dHB1dF9hbXQpLFxuICAgICAgICAgICAgb3V0cHV0Q29udHJhY3Q6IGNvbnZlcnRUb0VWTUFkZHJlc3Mocy5vdXRwdXRfY29udHJhY3QpLFxuICAgICAgICAgICAgb3V0cHV0RGVjaW1hbHM6IHMub3V0cHV0X2RlY2ltYWxzLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoYWluSWQ6IGJ5dGVzVG9OdW1iZXIoc3JjLmNoaWQpLFxuICAgICAgICBzd2FwcyxcbiAgICAgICAgdHhIYXNoOiB0b0hleChzcmMudHhfaGFzaCksXG4gICAgfTtcbn07XG5jb25zdCBjb252ZXJ0TWV0YWRhdGFUb1N3YXBSZXN1bHQgPSAobWV0YWRhdGEsIGJhc2VVUkwpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2VTd2FwczogbWV0YWRhdGEuc3JjLm1hcChjb252ZXJ0U3dhcE1ldGFUb1N3YXApLFxuICAgICAgICBleHBsb3JlclVSTDogZ2V0RXhwbG9yZXJVUkwoYmFzZVVSTCwgTG9uZy5mcm9tQmlnSW50KG1ldGFkYXRhLnJmZl9pZCkpLFxuICAgICAgICBkZXN0aW5hdGlvblN3YXA6IGNvbnZlcnRTd2FwTWV0YVRvU3dhcChtZXRhZGF0YS5kc3QpLFxuICAgIH07XG59O1xuZnVuY3Rpb24gbXN3YXAyZWlwNzEyc3dhcChpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFnZzogaW5wdXQuYWdnLFxuICAgICAgICBpbnB1dF9hbXQ6IGJ5dGVzVG9CaWdJbnQoaW5wdXQuaW5wdXRfYW10KSxcbiAgICAgICAgaW5wdXRfY29udHJhY3Q6IHRvSGV4KGlucHV0LmlucHV0X2NvbnRyYWN0KSxcbiAgICAgICAgaW5wdXRfZGVjaW1hbHM6IGlucHV0LmlucHV0X2RlY2ltYWxzLFxuICAgICAgICBvdXRwdXRfYW10OiBieXRlc1RvQmlnSW50KGlucHV0Lm91dHB1dF9hbXQpLFxuICAgICAgICBvdXRwdXRfY29udHJhY3Q6IHRvSGV4KGlucHV0Lm91dHB1dF9jb250cmFjdCksXG4gICAgICAgIG91dHB1dF9kZWNpbWFsczogaW5wdXQub3V0cHV0X2RlY2ltYWxzLFxuICAgIH07XG59XG5jb25zdCBjYWxjdWxhdGVWYWx1ZSA9IChhbW91bnQsIHZhbHVlLCBuZXdBbW91bnQpID0+IHtcbiAgICByZXR1cm4gRGVjaW1hbC5kaXYodmFsdWUsIGFtb3VudCkubXVsKG5ld0Ftb3VudCk7XG59O1xuZnVuY3Rpb24gbXR4MmVpcDcxMnR4KGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpZDogdG9IZXgoaW5wdXQuY2hpZCksXG4gICAgICAgIHN3YXBzOiBpbnB1dC5zd2Fwcy5tYXAobXN3YXAyZWlwNzEyc3dhcCksXG4gICAgICAgIHR4X2hhc2g6IHRvSGV4KGlucHV0LnR4X2hhc2gpLFxuICAgICAgICB1bml2OiBpbnB1dC51bml2LFxuICAgIH07XG59XG5jb25zdCBwb3N0U3dhcCA9IGFzeW5jICh7IG1ldGFkYXRhLCB3YWxsZXQsIH0pID0+IHtcbiAgICBsb2dnZXIkYy5kZWJ1ZygnbWV0YWRhdGEnLCB7XG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBtc2c6IHtcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgZHN0OiBtdHgyZWlwNzEydHgobWV0YWRhdGEuZHN0KSxcbiAgICAgICAgICAgIHNyYzogbWV0YWRhdGEuc3JjLm1hcChtdHgyZWlwNzEydHgpLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHdhbGxldC5zaWduVHlwZWREYXRhKHtcbiAgICAgICAgZG9tYWluOiB7XG4gICAgICAgICAgICBjaGFpbklkOiAxbixcbiAgICAgICAgICAgIG5hbWU6ICdDQSBNZXRhZGF0YScsXG4gICAgICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogWkVST19BRERSRVNTLFxuICAgICAgICAgICAgdmVyc2lvbjogJzAuMC4xJyxcbiAgICAgICAgfSxcbiAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICBkc3Q6IG10eDJlaXA3MTJ0eChtZXRhZGF0YS5kc3QpLFxuICAgICAgICAgICAgc3JjOiBtZXRhZGF0YS5zcmMubWFwKG10eDJlaXA3MTJ0eCksXG4gICAgICAgIH0sXG4gICAgICAgIHByaW1hcnlUeXBlOiAnUmVjb3JkJyxcbiAgICAgICAgdHlwZXMsXG4gICAgfSk7XG4gICAgbG9nZ2VyJGMuZGVidWcoJ21ldGFkYXRhJywge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICByZWNvcmQ6IG1ldGFkYXRhLFxuICAgICAgICAgICAgcmZmX2lkOiBOdW1iZXIobWV0YWRhdGEucmZmX2lkKSxcbiAgICAgICAgICAgIHNpZzogdG9CeXRlcyhzaWduYXR1cmUpLFxuICAgICAgICB9LFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgfSk7XG4gICAgY29uc3QgcmZmSUROID0gTnVtYmVyKG1ldGFkYXRhLnJmZl9pZCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGRlbGV0ZSBtZXRhZGF0YS5yZmZfaWQ7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgbWV0YWRhdGFBeGlvcyh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHJlY29yZDogbWV0YWRhdGEsXG4gICAgICAgICAgICByZmZfaWQ6IHJmZklETixcbiAgICAgICAgICAgIHNpZzogdG9CeXRlcyhzaWduYXR1cmUpLFxuICAgICAgICB9LFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgdXJsOiBgL2FwaS92MS9zYXZlLW1ldGFkYXRhLyR7cmZmSUROID09PSAwID8gJ3VubGlua2VkJyA6ICdsaW5rZWQnfWAsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJmZklETiA9PT0gMCA/IHJlcy5kYXRhLnZhbHVlIDogcmZmSUROO1xufTtcbmNvbnN0IGNyZWF0ZVN3ZWVwZXJUeHMgPSAoeyBjYWNoZSwgY2hhaW5JRCwgQ09UQ3VycmVuY3lJRCwgcmVjZWl2ZXIsIHNlbmRlciwgdG9rZW5BZGRyZXNzLCB9KSA9PiB7XG4gICAgY29uc3QgdHhzID0gW107XG4gICAgaWYgKCF0b2tlbkFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgY3VycmVuY3kgPSBDaGFpbmRhdGFNYXAuZ2V0KG5ldyBPbW5pdmVyc2FsQ2hhaW5JRChVbml2ZXJzZS5FVEhFUkVVTSwgY2hhaW5JRCkpLkN1cnJlbmNpZXMuZmluZCgoYykgPT4gYy5jdXJyZW5jeUlEID09PSBDT1RDdXJyZW5jeUlEKTtcbiAgICAgICAgaWYgKCFjdXJyZW5jeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb3Qgbm90IGZvdW5kIG9uIGNoYWluICR7Y2hhaW5JRH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbkFkZHJlc3MgPSBjb252ZXJ0VG9FVk1BZGRyZXNzKGN1cnJlbmN5LnRva2VuQWRkcmVzcyk7XG4gICAgfVxuICAgIGlmIChpc05hdGl2ZUFkZHJlc3ModG9rZW5BZGRyZXNzKSkge1xuICAgICAgICBjb25zdCBuYXRpdmVBbGxvd2FuY2UgPSBjYWNoZS5nZXRBbGxvd2FuY2Uoe1xuICAgICAgICAgICAgY2hhaW5JRDogTnVtYmVyKGNoYWluSUQpLFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBzZW5kZXIsXG4gICAgICAgICAgICBvd25lcjogU1dFRVBFUl9BRERSRVNTLFxuICAgICAgICAgICAgc3BlbmRlcjogU1dFRVBFUl9BRERSRVNTLFxuICAgICAgICB9KTtcbiAgICAgICAgbG9nZ2VyJGMuZGVidWcoJ2NyZWF0ZVN3ZWVwZXJUeHMnLCB7XG4gICAgICAgICAgICBuYXRpdmVBbGxvd2FuY2UsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW5hdGl2ZUFsbG93YW5jZSB8fCBuYXRpdmVBbGxvd2FuY2UgPT09IDBuKSB7XG4gICAgICAgICAgICB0eHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdG86IHNlbmRlcixcbiAgICAgICAgICAgICAgICBkYXRhOiBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgICAgICAgICBhYmk6IENhbGlidXJBQkksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ2FwcHJvdmVOYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbU1dFRVBFUl9BRERSRVNTLCBtYXhVaW50MjU2XSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMG4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0eHMucHVzaCh7XG4gICAgICAgICAgICBkYXRhOiBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgICAgIGFiaTogU1dFRVBfQUJJLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtyZWNlaXZlcl0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnc3dlZXBFUkM3OTE0JyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdG86IFNXRUVQRVJfQUREUkVTUyxcbiAgICAgICAgICAgIHZhbHVlOiAwbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzd2VlcGVyQWxsb3dhbmNlID0gY2FjaGUuZ2V0QWxsb3dhbmNlKHtcbiAgICAgICAgICAgIGNoYWluSUQ6IE51bWJlcihjaGFpbklEKSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udmVydFRvRVZNQWRkcmVzcyh0b2tlbkFkZHJlc3MpLFxuICAgICAgICAgICAgb3duZXI6IHNlbmRlcixcbiAgICAgICAgICAgIHNwZW5kZXI6IFNXRUVQRVJfQUREUkVTUyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc3dlZXBlckFsbG93YW5jZSB8fCBzd2VlcGVyQWxsb3dhbmNlID09PSAwbikge1xuICAgICAgICAgICAgdHhzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRhdGE6IHBhY2tFUkMyMEFwcHJvdmUoU1dFRVBFUl9BRERSRVNTKSxcbiAgICAgICAgICAgICAgICB0bzogY29udmVydFRvRVZNQWRkcmVzcyh0b2tlbkFkZHJlc3MpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHR4cy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGE6IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICAgICAgYWJpOiBTV0VFUF9BQkksXG4gICAgICAgICAgICAgICAgYXJnczogW2NvbnZlcnRUb0VWTUFkZHJlc3ModG9rZW5BZGRyZXNzKSwgcmVjZWl2ZXJdLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3N3ZWVwRVJDMjAnLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0bzogU1dFRVBFUl9BRERSRVNTLFxuICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHR4cztcbn07XG5jb25zdCBwZXJmb3JtRGVzdGluYXRpb25Td2FwID0gYXN5bmMgKHsgYWN0dWFsQWRkcmVzcywgY2FjaGUsIGNhbGxzLCBjaGFpbiwgY2hhaW5MaXN0LCBDT1QsIGVtaXR0ZXIsIGVwaGVtZXJhbEFkZHJlc3MsIGVwaGVtZXJhbFdhbGxldCwgaGFzRGVzdGluYXRpb25Td2FwLCBwdWJsaWNDbGllbnRMaXN0LCB2c2NEb21haW4sIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBJZiBkZXN0aW5hdGlvbiBzd2FwIHRva2VuIGlzIENPVCB0aGVuIGNhbGxzIGlzIGFuIGVtcHR5IGFycmF5LFxuICAgICAgICAvLyBzd2VlcGVyIHR4cyB3aWxsIHNlbmQgZnJvbSBlcGhlbWVyYWwgLT4gZW9hLCBvdGhlciBjYXNlcyBpdCBzd2VlcHMgdGhlIGR1c3RcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHJldHJ5KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNiY1R4ID0gYXdhaXQgY3JlYXRlU0JDVHhGcm9tQ2FsbHMoe1xuICAgICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICAgIGNhbGxzOiBjYWxscy5jb25jYXQoY3JlYXRlU3dlZXBlclR4cyh7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklEOiBjaGFpbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgQ09UQ3VycmVuY3lJRDogQ09ULFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlcjogYWN0dWFsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiBlcGhlbWVyYWxBZGRyZXNzLFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICBjaGFpbklEOiBjaGFpbi5pZCxcbiAgICAgICAgICAgICAgICBlcGhlbWVyYWxBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGVwaGVtZXJhbFdhbGxldCxcbiAgICAgICAgICAgICAgICBwdWJsaWNDbGllbnQ6IHB1YmxpY0NsaWVudExpc3QuZ2V0KGNoYWluLmlkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnZGVzdGluYXRpb24tc3dhcC1zdGFydCcpO1xuICAgICAgICAgICAgY29uc3Qgb3BzID0gYXdhaXQgdnNjU0JDVHgoW3NiY1R4XSwgdnNjRG9tYWluKTtcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ2Rlc3RpbmF0aW9uLXN3YXAtZW5kJyk7XG4gICAgICAgICAgICBpZiAoaGFzRGVzdGluYXRpb25Td2FwKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KERFU1RJTkFUSU9OX1NXQVBfSEFTSChvcHNbMF0sIGNoYWluTGlzdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnZGVzdGluYXRpb24tc3dhcC1taW5pbmctc3RhcnQnKTtcbiAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JTQkNUeFJlY2VpcHQob3BzLCBjaGFpbkxpc3QsIHB1YmxpY0NsaWVudExpc3QpO1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnZGVzdGluYXRpb24tc3dhcC1taW5pbmctZW5kJyk7XG4gICAgICAgICAgICByZXR1cm4gb3BzWzBdWzFdO1xuICAgICAgICB9LCAyKTtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlciRjLmVycm9yKCdkZXN0aW5hdGlvbiBzd2FwIGZhaWxlZCB0d2ljZSwgc3dlZXBpbmcgdG8gZW9hJywgZSk7XG4gICAgICAgIGF3YWl0IHZzY1NCQ1R4KFtcbiAgICAgICAgICAgIGF3YWl0IGNyZWF0ZVNCQ1R4RnJvbUNhbGxzKHtcbiAgICAgICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgICAgICBjYWxsczogY3JlYXRlU3dlZXBlclR4cyh7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklEOiBjaGFpbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgQ09UQ3VycmVuY3lJRDogQ09ULFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlcjogYWN0dWFsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiBlcGhlbWVyYWxBZGRyZXNzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNoYWluSUQ6IGNoYWluLmlkLFxuICAgICAgICAgICAgICAgIGVwaGVtZXJhbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZXBoZW1lcmFsV2FsbGV0LFxuICAgICAgICAgICAgICAgIHB1YmxpY0NsaWVudDogcHVibGljQ2xpZW50TGlzdC5nZXQoY2hhaW4uaWQpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF0sIHZzY0RvbWFpbikuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlciRjLmVycm9yKCdlcnJvciBkdXJpbmcgZGVzdGluYXRpb24gc3dlZXAnLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufTtcbmNvbnN0IGdldFN3YXBTdXBwb3J0ZWRDaGFpbnMgPSAoY2hhaW5MaXN0KSA9PiB7XG4gICAgY29uc3QgY2hhaW5zID0gW107XG4gICAgZm9yIChjb25zdCBjIG9mIGNoYWluRGF0YS5rZXlzKCkpIHtcbiAgICAgICAgY29uc3QgY2hhaW4gPSBjaGFpbkxpc3QuZ2V0Q2hhaW5CeUlEKGMpO1xuICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgaWQ6IGNoYWluLmlkLFxuICAgICAgICAgICAgbG9nbzogY2hhaW4uY3VzdG9tLmljb24sXG4gICAgICAgICAgICBuYW1lOiBjaGFpbi5uYW1lLFxuICAgICAgICAgICAgdG9rZW5zOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gY2hhaW5EYXRhLmdldChjKTtcbiAgICAgICAgaWYgKCF0b2tlbnMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICBpZiAodC5QZXJtaXRWYXJpYW50ICE9PSBQZXJtaXRWYXJpYW50LlVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udmVydFRvRVZNQWRkcmVzcyh0LlRva2VuQ29udHJhY3RBZGRyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IHQuVG9rZW5EZWNpbWFscyxcbiAgICAgICAgICAgICAgICAgICAgbG9nbzogJycsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHQuTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiB0Lk5hbWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGFpbnMucHVzaChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYWlucztcbn07XG5cbnZhciBDdXJyZW5jeUlEO1xuKGZ1bmN0aW9uIChDdXJyZW5jeUlEKSB7XG4gICAgQ3VycmVuY3lJRFtDdXJyZW5jeUlEW1wiQVZBWFwiXSA9IDVdID0gXCJBVkFYXCI7XG4gICAgQ3VycmVuY3lJRFtDdXJyZW5jeUlEW1wiREFJXCJdID0gNl0gPSBcIkRBSVwiO1xuICAgIEN1cnJlbmN5SURbQ3VycmVuY3lJRFtcIkVUSFwiXSA9IDNdID0gXCJFVEhcIjtcbiAgICBDdXJyZW5jeUlEW0N1cnJlbmN5SURbXCJIWVBFXCJdID0gMTZdID0gXCJIWVBFXCI7XG4gICAgQ3VycmVuY3lJRFtDdXJyZW5jeUlEW1wiS0FJQVwiXSA9IDE3XSA9IFwiS0FJQVwiO1xuICAgIEN1cnJlbmN5SURbQ3VycmVuY3lJRFtcIlBPTFwiXSA9IDRdID0gXCJQT0xcIjtcbiAgICBDdXJyZW5jeUlEW0N1cnJlbmN5SURbXCJVU0RDXCJdID0gMV0gPSBcIlVTRENcIjtcbiAgICBDdXJyZW5jeUlEW0N1cnJlbmN5SURbXCJVU0RTXCJdID0gOTldID0gXCJVU0RTXCI7XG4gICAgQ3VycmVuY3lJRFtDdXJyZW5jeUlEW1wiVVNEVFwiXSA9IDJdID0gXCJVU0RUXCI7XG4gICAgQ3VycmVuY3lJRFtDdXJyZW5jeUlEW1wiV0VUSFwiXSA9IDddID0gXCJXRVRIXCI7XG59KShDdXJyZW5jeUlEIHx8IChDdXJyZW5jeUlEID0ge30pKTtcbmNvbnN0IGNoYWluRGF0YSA9IG5ldyBNYXAoW1xuICAgIFtcbiAgICAgICAgMTAsXG4gICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBDdXJyZW5jeUlEOiBDdXJyZW5jeUlELlVTREMsXG4gICAgICAgICAgICAgICAgSXNHYXNUb2tlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgTmFtZTogQ3VycmVuY3lJRFtDdXJyZW5jeUlELlVTRENdLFxuICAgICAgICAgICAgICAgIFBlcm1pdENvbnRyYWN0VmVyc2lvbjogMixcbiAgICAgICAgICAgICAgICBQZXJtaXRWYXJpYW50OiBQZXJtaXRWYXJpYW50LkVJUDI2MTJDYW5vbmljYWwsXG4gICAgICAgICAgICAgICAgVG9rZW5Db250cmFjdEFkZHJlc3M6IGNvbnZlcnRUbzMyQnl0ZXNIZXgoJzB4YjJjNjM5YzUzMzgxM2Y0YWE5ZDc4MzdjYWY2MjY1M2QwOTdmZjg1JyksXG4gICAgICAgICAgICAgICAgVG9rZW5EZWNpbWFsczogNixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQ3VycmVuY3lJRDogQ3VycmVuY3lJRC5VU0RULFxuICAgICAgICAgICAgICAgIElzR2FzVG9rZW46IGZhbHNlLFxuICAgICAgICAgICAgICAgIE5hbWU6IEN1cnJlbmN5SURbQ3VycmVuY3lJRC5VU0RUXSxcbiAgICAgICAgICAgICAgICBQZXJtaXRDb250cmFjdFZlcnNpb246IDAsXG4gICAgICAgICAgICAgICAgUGVybWl0VmFyaWFudDogUGVybWl0VmFyaWFudC5VbnN1cHBvcnRlZCxcbiAgICAgICAgICAgICAgICBUb2tlbkNvbnRyYWN0QWRkcmVzczogY29udmVydFRvMzJCeXRlc0hleCgnMHg5NGIwMDhhYTAwNTc5YzEzMDdiMGVmMmM0OTlhZDk4YThjZTU4ZTU4JyksXG4gICAgICAgICAgICAgICAgVG9rZW5EZWNpbWFsczogNixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQ3VycmVuY3lJRDogQ3VycmVuY3lJRC5VU0RULFxuICAgICAgICAgICAgICAgIElzR2FzVG9rZW46IGZhbHNlLFxuICAgICAgICAgICAgICAgIE5hbWU6IEN1cnJlbmN5SURbQ3VycmVuY3lJRC5VU0RUXSxcbiAgICAgICAgICAgICAgICBQZXJtaXRDb250cmFjdFZlcnNpb246IDEsXG4gICAgICAgICAgICAgICAgUGVybWl0VmFyaWFudDogUGVybWl0VmFyaWFudC5FSVAyNjEyQ2Fub25pY2FsLFxuICAgICAgICAgICAgICAgIFRva2VuQ29udHJhY3RBZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KCcweDAxYmZmNDE3OThhMGJjZjI4N2I5OTYwNDZjYTY4YjM5NWRiYzEwNzEnKSxcbiAgICAgICAgICAgICAgICBUb2tlbkRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBDdXJyZW5jeUlEOiBDdXJyZW5jeUlELkRBSSxcbiAgICAgICAgICAgICAgICBJc0dhc1Rva2VuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBOYW1lOiBDdXJyZW5jeUlEW0N1cnJlbmN5SUQuREFJXSxcbiAgICAgICAgICAgICAgICBQZXJtaXRDb250cmFjdFZlcnNpb246IDIsXG4gICAgICAgICAgICAgICAgUGVybWl0VmFyaWFudDogUGVybWl0VmFyaWFudC5FSVAyNjEyQ2Fub25pY2FsLFxuICAgICAgICAgICAgICAgIFRva2VuQ29udHJhY3RBZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KCcweGRhMTAwMDljYmQ1ZDA3ZGQwY2VjYzY2MTYxZmM5M2Q3YzkwMDBkYTEnKSxcbiAgICAgICAgICAgICAgICBUb2tlbkRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQ3VycmVuY3lJRDogQ3VycmVuY3lJRC5FVEgsXG4gICAgICAgICAgICAgICAgSXNHYXNUb2tlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBOYW1lOiBDdXJyZW5jeUlEW0N1cnJlbmN5SUQuRVRIXSxcbiAgICAgICAgICAgICAgICBQZXJtaXRDb250cmFjdFZlcnNpb246IDAsXG4gICAgICAgICAgICAgICAgUGVybWl0VmFyaWFudDogUGVybWl0VmFyaWFudC5VbnN1cHBvcnRlZCxcbiAgICAgICAgICAgICAgICBUb2tlbkNvbnRyYWN0QWRkcmVzczogY29udmVydFRvMzJCeXRlc0hleChFQUREUkVTUyksXG4gICAgICAgICAgICAgICAgVG9rZW5EZWNpbWFsczogMTgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEN1cnJlbmN5SUQ6IEN1cnJlbmN5SUQuV0VUSCxcbiAgICAgICAgICAgICAgICBJc0dhc1Rva2VuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBOYW1lOiBDdXJyZW5jeUlEW0N1cnJlbmN5SUQuV0VUSF0sXG4gICAgICAgICAgICAgICAgUGVybWl0Q29udHJhY3RWZXJzaW9uOiAwLFxuICAgICAgICAgICAgICAgIFBlcm1pdFZhcmlhbnQ6IFBlcm1pdFZhcmlhbnQuVW5zdXBwb3J0ZWQsXG4gICAgICAgICAgICAgICAgVG9rZW5Db250cmFjdEFkZHJlc3M6IGNvbnZlcnRUbzMyQnl0ZXNIZXgoJzB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNicpLFxuICAgICAgICAgICAgICAgIFRva2VuRGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAgMTM3LFxuICAgICAgICBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQ3VycmVuY3lJRDogQ3VycmVuY3lJRC5QT0wsXG4gICAgICAgICAgICAgICAgSXNHYXNUb2tlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBOYW1lOiBDdXJyZW5jeUlEW0N1cnJlbmN5SUQuUE9MXSxcbiAgICAgICAgICAgICAgICBQZXJtaXRDb250cmFjdFZlcnNpb246IDAsXG4gICAgICAgICAgICAgICAgUGVybWl0VmFyaWFudDogUGVybWl0VmFyaWFudC5VbnN1cHBvcnRlZCxcbiAgICAgICAgICAgICAgICBUb2tlbkNvbnRyYWN0QWRkcmVzczogY29udmVydFRvMzJCeXRlc0hleChFQUREUkVTUyksXG4gICAgICAgICAgICAgICAgVG9rZW5EZWNpbWFsczogMTgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEN1cnJlbmN5SUQ6IEN1cnJlbmN5SUQuVVNEQyxcbiAgICAgICAgICAgICAgICBJc0dhc1Rva2VuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBOYW1lOiBDdXJyZW5jeUlEW0N1cnJlbmN5SUQuVVNEQ10sXG4gICAgICAgICAgICAgICAgUGVybWl0Q29udHJhY3RWZXJzaW9uOiAyLFxuICAgICAgICAgICAgICAgIFBlcm1pdFZhcmlhbnQ6IFBlcm1pdFZhcmlhbnQuRUlQMjYxMkNhbm9uaWNhbCxcbiAgICAgICAgICAgICAgICBUb2tlbkNvbnRyYWN0QWRkcmVzczogY29udmVydFRvMzJCeXRlc0hleCgnMHgzYzQ5OWM1NDJjZWY1ZTM4MTFlMTE5MmNlNzBkOGNjMDNkNWMzMzU5JyksXG4gICAgICAgICAgICAgICAgVG9rZW5EZWNpbWFsczogNixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQ3VycmVuY3lJRDogQ3VycmVuY3lJRC5VU0RULFxuICAgICAgICAgICAgICAgIElzR2FzVG9rZW46IGZhbHNlLFxuICAgICAgICAgICAgICAgIE5hbWU6IEN1cnJlbmN5SURbQ3VycmVuY3lJRC5VU0RUXSxcbiAgICAgICAgICAgICAgICBQZXJtaXRDb250cmFjdFZlcnNpb246IDEsXG4gICAgICAgICAgICAgICAgUGVybWl0VmFyaWFudDogUGVybWl0VmFyaWFudC5Qb2x5Z29uRU1ULFxuICAgICAgICAgICAgICAgIFRva2VuQ29udHJhY3RBZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KCcweGMyMTMyZDA1ZDMxYzkxNGE4N2M2NjExYzEwNzQ4YWViMDRiNThlOGYnKSxcbiAgICAgICAgICAgICAgICBUb2tlbkRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAgNDIxNjEsXG4gICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBDdXJyZW5jeUlEOiBDdXJyZW5jeUlELldFVEgsXG4gICAgICAgICAgICAgICAgSXNHYXNUb2tlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgTmFtZTogQ3VycmVuY3lJRFtDdXJyZW5jeUlELldFVEhdLFxuICAgICAgICAgICAgICAgIFBlcm1pdENvbnRyYWN0VmVyc2lvbjogMSxcbiAgICAgICAgICAgICAgICBQZXJtaXRWYXJpYW50OiBQZXJtaXRWYXJpYW50LkVJUDI2MTJDYW5vbmljYWwsXG4gICAgICAgICAgICAgICAgVG9rZW5Db250cmFjdEFkZHJlc3M6IGNvbnZlcnRUbzMyQnl0ZXNIZXgoJzB4ODJhZjQ5NDQ3ZDhhMDdlM2JkOTViZDBkNTZmMzUyNDE1MjNmYmFiMScpLFxuICAgICAgICAgICAgICAgIFRva2VuRGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBDdXJyZW5jeUlEOiBDdXJyZW5jeUlELlVTREMsXG4gICAgICAgICAgICAgICAgSXNHYXNUb2tlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgTmFtZTogQ3VycmVuY3lJRFtDdXJyZW5jeUlELlVTRENdLFxuICAgICAgICAgICAgICAgIFBlcm1pdENvbnRyYWN0VmVyc2lvbjogMixcbiAgICAgICAgICAgICAgICBQZXJtaXRWYXJpYW50OiBQZXJtaXRWYXJpYW50LkVJUDI2MTJDYW5vbmljYWwsXG4gICAgICAgICAgICAgICAgVG9rZW5Db250cmFjdEFkZHJlc3M6IGNvbnZlcnRUbzMyQnl0ZXNIZXgoJzB4YWY4OGQwNjVlNzdjOGNjMjIzOTMyN2M1ZWRiM2E0MzIyNjhlNTgzMScpLFxuICAgICAgICAgICAgICAgIFRva2VuRGVjaW1hbHM6IDYsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEN1cnJlbmN5SUQ6IEN1cnJlbmN5SUQuVVNEVCxcbiAgICAgICAgICAgICAgICBJc0dhc1Rva2VuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBOYW1lOiBDdXJyZW5jeUlEW0N1cnJlbmN5SUQuVVNEVF0sXG4gICAgICAgICAgICAgICAgUGVybWl0Q29udHJhY3RWZXJzaW9uOiAxLFxuICAgICAgICAgICAgICAgIFBlcm1pdFZhcmlhbnQ6IFBlcm1pdFZhcmlhbnQuRUlQMjYxMkNhbm9uaWNhbCxcbiAgICAgICAgICAgICAgICBUb2tlbkNvbnRyYWN0QWRkcmVzczogY29udmVydFRvMzJCeXRlc0hleCgnMHhmZDA4NmJjN2NkNWM0ODFkY2M5Yzg1ZWJlNDc4YTFjMGI2OWZjYmI5JyksXG4gICAgICAgICAgICAgICAgVG9rZW5EZWNpbWFsczogNixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQ3VycmVuY3lJRDogQ3VycmVuY3lJRC5EQUksXG4gICAgICAgICAgICAgICAgSXNHYXNUb2tlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgTmFtZTogQ3VycmVuY3lJRFtDdXJyZW5jeUlELkRBSV0sXG4gICAgICAgICAgICAgICAgUGVybWl0Q29udHJhY3RWZXJzaW9uOiAyLFxuICAgICAgICAgICAgICAgIFBlcm1pdFZhcmlhbnQ6IFBlcm1pdFZhcmlhbnQuRUlQMjYxMkNhbm9uaWNhbCxcbiAgICAgICAgICAgICAgICBUb2tlbkNvbnRyYWN0QWRkcmVzczogY29udmVydFRvMzJCeXRlc0hleCgnMHhkYTEwMDA5Y2JkNWQwN2RkMGNlY2M2NjE2MWZjOTNkN2M5MDAwZGExJyksXG4gICAgICAgICAgICAgICAgVG9rZW5EZWNpbWFsczogNixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQ3VycmVuY3lJRDogQ3VycmVuY3lJRC5FVEgsXG4gICAgICAgICAgICAgICAgSXNHYXNUb2tlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBOYW1lOiBDdXJyZW5jeUlEW0N1cnJlbmN5SUQuRVRIXSxcbiAgICAgICAgICAgICAgICBQZXJtaXRDb250cmFjdFZlcnNpb246IDAsXG4gICAgICAgICAgICAgICAgUGVybWl0VmFyaWFudDogUGVybWl0VmFyaWFudC5VbnN1cHBvcnRlZCxcbiAgICAgICAgICAgICAgICBUb2tlbkNvbnRyYWN0QWRkcmVzczogY29udmVydFRvMzJCeXRlc0hleChFQUREUkVTUyksXG4gICAgICAgICAgICAgICAgVG9rZW5EZWNpbWFsczogMTgsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIF0sXG4gICAgW1xuICAgICAgICA1MzQzNTIsXG4gICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBDdXJyZW5jeUlEOiBDdXJyZW5jeUlELldFVEgsXG4gICAgICAgICAgICAgICAgSXNHYXNUb2tlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgTmFtZTogQ3VycmVuY3lJRFtDdXJyZW5jeUlELldFVEhdLFxuICAgICAgICAgICAgICAgIFBlcm1pdENvbnRyYWN0VmVyc2lvbjogMSxcbiAgICAgICAgICAgICAgICBQZXJtaXRWYXJpYW50OiBQZXJtaXRWYXJpYW50LkVJUDI2MTJDYW5vbmljYWwsXG4gICAgICAgICAgICAgICAgVG9rZW5Db250cmFjdEFkZHJlc3M6IGNvbnZlcnRUbzMyQnl0ZXNIZXgoJzB4NTMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNCcpLFxuICAgICAgICAgICAgICAgIFRva2VuRGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBDdXJyZW5jeUlEOiBDdXJyZW5jeUlELlVTREMsXG4gICAgICAgICAgICAgICAgSXNHYXNUb2tlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgTmFtZTogQ3VycmVuY3lJRFtDdXJyZW5jeUlELlVTRENdLFxuICAgICAgICAgICAgICAgIFBlcm1pdENvbnRyYWN0VmVyc2lvbjogMixcbiAgICAgICAgICAgICAgICBQZXJtaXRWYXJpYW50OiBQZXJtaXRWYXJpYW50LkVJUDI2MTJDYW5vbmljYWwsXG4gICAgICAgICAgICAgICAgVG9rZW5Db250cmFjdEFkZHJlc3M6IGNvbnZlcnRUbzMyQnl0ZXNIZXgoJzB4NmVmZGJmZjJhMTRhN2M4ZTE1OTQ0ZDFmNGE0OGY5Zjk1ZjY2M2E0JyksXG4gICAgICAgICAgICAgICAgVG9rZW5EZWNpbWFsczogNixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQ3VycmVuY3lJRDogQ3VycmVuY3lJRC5VU0RULFxuICAgICAgICAgICAgICAgIElzR2FzVG9rZW46IGZhbHNlLFxuICAgICAgICAgICAgICAgIE5hbWU6IEN1cnJlbmN5SURbQ3VycmVuY3lJRC5VU0RUXSxcbiAgICAgICAgICAgICAgICBQZXJtaXRDb250cmFjdFZlcnNpb246IDEsXG4gICAgICAgICAgICAgICAgUGVybWl0VmFyaWFudDogUGVybWl0VmFyaWFudC5FSVAyNjEyQ2Fub25pY2FsLFxuICAgICAgICAgICAgICAgIFRva2VuQ29udHJhY3RBZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KCcweGY1NWJlYzljYWZkYmU4NzMwZjA5NmFhNTVkYWQ2ZDIyZDQ0MDk5ZGYnKSxcbiAgICAgICAgICAgICAgICBUb2tlbkRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBDdXJyZW5jeUlEOiBDdXJyZW5jeUlELkRBSSxcbiAgICAgICAgICAgICAgICBJc0dhc1Rva2VuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBOYW1lOiBDdXJyZW5jeUlEW0N1cnJlbmN5SUQuREFJXSxcbiAgICAgICAgICAgICAgICBQZXJtaXRDb250cmFjdFZlcnNpb246IDEsXG4gICAgICAgICAgICAgICAgUGVybWl0VmFyaWFudDogUGVybWl0VmFyaWFudC5FSVAyNjEyQ2Fub25pY2FsLFxuICAgICAgICAgICAgICAgIFRva2VuQ29udHJhY3RBZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KCcweGNBNzdlQjNmRUZlMzcyNURjMzNiY2NCNTRlREVGYzNEOWY3NjRmOTcnKSxcbiAgICAgICAgICAgICAgICBUb2tlbkRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBDdXJyZW5jeUlEOiBDdXJyZW5jeUlELkVUSCxcbiAgICAgICAgICAgICAgICBJc0dhc1Rva2VuOiB0cnVlLFxuICAgICAgICAgICAgICAgIE5hbWU6IEN1cnJlbmN5SURbQ3VycmVuY3lJRC5FVEhdLFxuICAgICAgICAgICAgICAgIFBlcm1pdENvbnRyYWN0VmVyc2lvbjogMCxcbiAgICAgICAgICAgICAgICBQZXJtaXRWYXJpYW50OiBQZXJtaXRWYXJpYW50LlVuc3VwcG9ydGVkLFxuICAgICAgICAgICAgICAgIFRva2VuQ29udHJhY3RBZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KEVBRERSRVNTKSxcbiAgICAgICAgICAgICAgICBUb2tlbkRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgXSxcbiAgICBbXG4gICAgICAgIDg0NTMsXG4gICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBDdXJyZW5jeUlEOiBDdXJyZW5jeUlELldFVEgsXG4gICAgICAgICAgICAgICAgSXNHYXNUb2tlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgTmFtZTogQ3VycmVuY3lJRFtDdXJyZW5jeUlELldFVEhdLFxuICAgICAgICAgICAgICAgIFBlcm1pdENvbnRyYWN0VmVyc2lvbjogMCxcbiAgICAgICAgICAgICAgICBQZXJtaXRWYXJpYW50OiBQZXJtaXRWYXJpYW50LlVuc3VwcG9ydGVkLFxuICAgICAgICAgICAgICAgIFRva2VuQ29udHJhY3RBZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KCcweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYnKSxcbiAgICAgICAgICAgICAgICBUb2tlbkRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQ3VycmVuY3lJRDogQ3VycmVuY3lJRC5VU0RDLFxuICAgICAgICAgICAgICAgIElzR2FzVG9rZW46IGZhbHNlLFxuICAgICAgICAgICAgICAgIE5hbWU6IEN1cnJlbmN5SURbQ3VycmVuY3lJRC5VU0RDXSxcbiAgICAgICAgICAgICAgICBQZXJtaXRDb250cmFjdFZlcnNpb246IDIsXG4gICAgICAgICAgICAgICAgUGVybWl0VmFyaWFudDogUGVybWl0VmFyaWFudC5FSVAyNjEyQ2Fub25pY2FsLFxuICAgICAgICAgICAgICAgIFRva2VuQ29udHJhY3RBZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KCcweDgzMzU4OWZDRDZlRGI2RTA4ZjRjN0MzMkQ0ZjcxYjU0YmRBMDI5MTMnKSxcbiAgICAgICAgICAgICAgICBUb2tlbkRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBDdXJyZW5jeUlEOiBDdXJyZW5jeUlELlVTRFQsXG4gICAgICAgICAgICAgICAgSXNHYXNUb2tlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgTmFtZTogQ3VycmVuY3lJRFtDdXJyZW5jeUlELlVTRFRdLFxuICAgICAgICAgICAgICAgIFBlcm1pdENvbnRyYWN0VmVyc2lvbjogMCxcbiAgICAgICAgICAgICAgICBQZXJtaXRWYXJpYW50OiBQZXJtaXRWYXJpYW50LlVuc3VwcG9ydGVkLFxuICAgICAgICAgICAgICAgIFRva2VuQ29udHJhY3RBZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KCcweGZkZTRjOTZjODU5MzUzNmUzMWYyMjllYThmMzdiMmFkYTI2OTliYjInKSxcbiAgICAgICAgICAgICAgICBUb2tlbkRlY2ltYWxzOiA2LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBDdXJyZW5jeUlEOiBDdXJyZW5jeUlELlVTRFMsXG4gICAgICAgICAgICAgICAgSXNHYXNUb2tlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgTmFtZTogQ3VycmVuY3lJRFtDdXJyZW5jeUlELlVTRFNdLFxuICAgICAgICAgICAgICAgIFBlcm1pdENvbnRyYWN0VmVyc2lvbjogMSxcbiAgICAgICAgICAgICAgICBQZXJtaXRWYXJpYW50OiBQZXJtaXRWYXJpYW50LkVJUDI2MTJDYW5vbmljYWwsXG4gICAgICAgICAgICAgICAgVG9rZW5Db250cmFjdEFkZHJlc3M6IGNvbnZlcnRUbzMyQnl0ZXNIZXgoJzB4ODIwQzEzN2ZhNzBDODY5MWYwZTQ0RGM0MjBhNWU1M2MxNjg5MjFEYycpLFxuICAgICAgICAgICAgICAgIFRva2VuRGVjaW1hbHM6IDE4LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBDdXJyZW5jeUlEOiBDdXJyZW5jeUlELkVUSCxcbiAgICAgICAgICAgICAgICBJc0dhc1Rva2VuOiB0cnVlLFxuICAgICAgICAgICAgICAgIE5hbWU6IEN1cnJlbmN5SURbQ3VycmVuY3lJRC5FVEhdLFxuICAgICAgICAgICAgICAgIFBlcm1pdENvbnRyYWN0VmVyc2lvbjogMCxcbiAgICAgICAgICAgICAgICBQZXJtaXRWYXJpYW50OiBQZXJtaXRWYXJpYW50LlVuc3VwcG9ydGVkLFxuICAgICAgICAgICAgICAgIFRva2VuQ29udHJhY3RBZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzSGV4KEVBRERSRVNTKSxcbiAgICAgICAgICAgICAgICBUb2tlbkRlY2ltYWxzOiAxOCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgXSxcbl0pO1xuY29uc3QgZmlsdGVyU3VwcG9ydGVkVG9rZW5zID0gKHRva2VucykgPT4ge1xuICAgIHJldHVybiB0b2tlbnMuZmlsdGVyKCh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSBjaGFpbkRhdGEuZ2V0KHQuY2hhaW5JRCk7XG4gICAgICAgIGlmICghZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuID0gZC5maW5kKChkdCkgPT4gZXF1YWxGb2xkKGR0LlRva2VuQ29udHJhY3RBZGRyZXNzLCB0LnRva2VuQWRkcmVzcykpO1xuICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLklzR2FzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmICh0b2tlbi5QZXJtaXRWYXJpYW50ID09PSBQZXJtaXRWYXJpYW50LlVuc3VwcG9ydGVkKSB7XG4gICAgICAgIC8vICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufTtcbmNvbnN0IGdldFRva2VuVmVyc2lvbiA9ICh0b2tlbkFkZHJlc3MpID0+IHtcbiAgICBmb3IgKGNvbnN0IFssIHRva2Vuc10gb2YgY2hhaW5EYXRhLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCB0ID0gdG9rZW5zLmZpbmQoKHQpID0+IGVxdWFsRm9sZChjb252ZXJ0VG8zMkJ5dGVzSGV4KHRva2VuQWRkcmVzcyksIHQuVG9rZW5Db250cmFjdEFkZHJlc3MpKTtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhcmlhbnQ6IHQuUGVybWl0VmFyaWFudCwgdmVyc2lvbjogdC5QZXJtaXRDb250cmFjdFZlcnNpb24gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rva2VuIG5vdCBhdmFpbGFibGUgb3IgaGFzIG5vIHZlcnNpb24nKTtcbn07XG5jb25zdCBnZXRUb2tlbkRlY2ltYWxzID0gKGNoYWluSUQsIGNvbnRyYWN0QWRkcmVzcykgPT4ge1xuICAgIGNvbnN0IGNEYXRhID0gY2hhaW5EYXRhLmdldChOdW1iZXIoY2hhaW5JRCkpO1xuICAgIGlmICghY0RhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjaGFpbiBkYXRhIG5vdCBmb3VuZCBmb3IgY2hhaW46JHtjaGFpbklEfWApO1xuICAgIH1cbiAgICBjb25zdCB0b2tlbiA9IGNEYXRhLmZpbmQoKGMpID0+IGVxdWFsRm9sZCh0b0hleCQxKGNvbnRyYWN0QWRkcmVzcyksIGMuVG9rZW5Db250cmFjdEFkZHJlc3MpKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdG9rZW4gbm90IGZvdW5kOiAke3RvSGV4JDEoY29udHJhY3RBZGRyZXNzKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjaW1hbHM6IHRva2VuLlRva2VuRGVjaW1hbHMsXG4gICAgICAgIHN5bWJvbDogQ3VycmVuY3lJRFt0b2tlbi5DdXJyZW5jeUlEXSxcbiAgICB9O1xufTtcblxuY29uc3QgRXJyb3JDaGFpbkRhdGFOb3RGb3VuZCA9IG5ldyBFcnJvcignQ2hhaW4gZGF0YSBub3QgZm91bmQuJyk7XG5jb25zdCBFcnJvckNPVE5vdEZvdW5kID0gKGNoYWluSUQpID0+IG5ldyBFcnJvcihgQ09UIG5vdCBmb3VuZCBvbiBjaGFpbjogJHtjaGFpbklEfWApO1xuY29uc3QgRXJyb3JUb2tlbk5vdEZvdW5kID0gKGFkZHJlc3MsIGNoYWluSUQpID0+IG5ldyBFcnJvcihgVG9rZW4oJHthZGRyZXNzfSkgbm90IGZvdW5kIG9uIGNoYWluOiAke2NoYWluSUR9YCk7XG5jb25zdCBFcnJvckluc3VmZmljaWVudEJhbGFuY2UgPSAoYXZhaWxhYmxlLCByZXF1aXJlZCkgPT4gbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgYmFsYW5jZTogYXZhaWxhYmxlOiR7YXZhaWxhYmxlfSwgcmVxdWlyZWQ6JHtyZXF1aXJlZH0uYCk7XG5cbmNvbnN0IGxvZ2dlciRiID0gZ2V0TG9nZ2VyKCk7XG5jb25zdCBjcmVhdGVFbXB0eUludGVudCA9ICh7IGNoYWluSUQgfSkgPT4gKHtcbiAgICBhbGxTb3VyY2VzOiBbXSxcbiAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICBhbW91bnQ6IG5ldyBEZWNpbWFsKDApLFxuICAgICAgICBjaGFpbklELFxuICAgICAgICBkZWNpbWFsczogNixcbiAgICAgICAgZ2FzOiAwbixcbiAgICAgICAgdG9rZW5Db250cmFjdDogJzB4JyxcbiAgICAgICAgdW5pdmVyc2U6IFVuaXZlcnNlLkVUSEVSRVVNLFxuICAgIH0sXG4gICAgZmVlczoge1xuICAgICAgICBjYUdhczogJzAnLFxuICAgICAgICBjb2xsZWN0aW9uOiAnMCcsXG4gICAgICAgIGZ1bGZpbG1lbnQ6ICcwJyxcbiAgICAgICAgZ2FzU3VwcGxpZWQ6ICcwJyxcbiAgICAgICAgcHJvdG9jb2w6ICcwJyxcbiAgICAgICAgc29sdmVyOiAnMCcsXG4gICAgfSxcbiAgICBpc0F2YWlsYWJsZUJhbGFuY2VJbnN1ZmZpY2llbnQ6IGZhbHNlLFxuICAgIHNvdXJjZXM6IFtdLFxufSk7XG5jb25zdCBjcmVhdGVJbnRlbnQgPSAoeyBhc3NldHMsIGZlZVN0b3JlLCBvdXRwdXQsIH0pID0+IHtcbiAgICBjb25zdCBlb2FUb0VwaGVtZXJhbENhbGxzID0ge307XG4gICAgY29uc3QgaW50ZW50ID0gY3JlYXRlRW1wdHlJbnRlbnQoeyBjaGFpbklEOiBvdXRwdXQuY2hhaW5JRCB9KTtcbiAgICBsZXQgYm9ycm93ID0gb3V0cHV0LmFtb3VudDtcbiAgICBpbnRlbnQuZGVzdGluYXRpb24uYW1vdW50ID0gYm9ycm93O1xuICAgIGludGVudC5kZXN0aW5hdGlvbi50b2tlbkNvbnRyYWN0ID0gb3V0cHV0LnRva2VuQWRkcmVzcztcbiAgICBjb25zdCBwcm90b2NvbEZlZSA9IGZlZVN0b3JlLmNhbGN1bGF0ZVByb3RvY29sRmVlKGJvcnJvdyk7XG4gICAgYm9ycm93ID0gYm9ycm93LmFkZChwcm90b2NvbEZlZSk7XG4gICAgaW50ZW50LmZlZXMucHJvdG9jb2wgPSBwcm90b2NvbEZlZS50b0ZpeGVkKCk7XG4gICAgY29uc3QgZnVsZmlsbWVudEZlZSA9IGZlZVN0b3JlLmNhbGN1bGF0ZUZ1bGZpbG1lbnRGZWUoe1xuICAgICAgICBkZWNpbWFsczogb3V0cHV0LmRlY2ltYWxzLFxuICAgICAgICBkZXN0aW5hdGlvbkNoYWluSUQ6IG91dHB1dC5jaGFpbklELFxuICAgICAgICBkZXN0aW5hdGlvblRva2VuQWRkcmVzczogb3V0cHV0LnRva2VuQWRkcmVzcyxcbiAgICB9KTtcbiAgICBib3Jyb3cgPSBib3Jyb3cuYWRkKGZ1bGZpbG1lbnRGZWUpO1xuICAgIGludGVudC5mZWVzLmZ1bGZpbG1lbnQgPSBmdWxmaWxtZW50RmVlLnRvRml4ZWQoKTtcbiAgICBsZXQgYWNjb3VudGVkQmFsYW5jZSA9IG5ldyBEZWNpbWFsKDApO1xuICAgIGxvZ2dlciRiLmRlYnVnKCdjcmVhdGVCcmlkZ2VSRkY6MScsIHtcbiAgICAgICAgYXNzZXRzOiBhc3NldHMubWFwKChpKSA9PiAoe1xuICAgICAgICAgICAgLi4uaSxcbiAgICAgICAgICAgIGVvYUJhbGFuY2U6IGkuZW9hQmFsYW5jZS50b0ZpeGVkKCksXG4gICAgICAgICAgICBlcGhlbWVyYWxCYWxhbmNlOiBpLmVwaGVtZXJhbEJhbGFuY2UudG9GaXhlZCgpLFxuICAgICAgICB9KSksXG4gICAgICAgIGJvcnJvdzogYm9ycm93LnRvRml4ZWQoKSxcbiAgICAgICAgZnVsZmlsbWVudEZlZTogZnVsZmlsbWVudEZlZS50b0ZpeGVkKCksXG4gICAgICAgIHByb3RvY29sRmVlOiBwcm90b2NvbEZlZS50b0ZpeGVkKCksXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBhc3NldCBvZiBhc3NldHMpIHtcbiAgICAgICAgaWYgKGFzc2V0LmNoYWluSUQgPT09IG91dHB1dC5jaGFpbklEIHx8XG4gICAgICAgICAgICBEZWNpbWFsLmFkZChhc3NldC5lb2FCYWxhbmNlLCBhc3NldC5lcGhlbWVyYWxCYWxhbmNlKS5sdGUoMCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY2NvdW50ZWRCYWxhbmNlLmd0ZShib3Jyb3cpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bmFjY291bnRlZEJhbGFuY2UgPSBib3Jyb3cubWludXMoYWNjb3VudGVkQmFsYW5jZSk7XG4gICAgICAgIGNvbnN0IGVzdGltYXRlZEJvcnJvd0Zyb21UaGlzQ2hhaW4gPSBEZWNpbWFsLmFkZChhc3NldC5lb2FCYWxhbmNlLnRvU3RyaW5nKCksIGFzc2V0LmVwaGVtZXJhbEJhbGFuY2UudG9TdHJpbmcoKSkubHRlKHVuYWNjb3VudGVkQmFsYW5jZSlcbiAgICAgICAgICAgID8gRGVjaW1hbC5hZGQoYXNzZXQuZW9hQmFsYW5jZS50b1N0cmluZygpLCBhc3NldC5lcGhlbWVyYWxCYWxhbmNlLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICA6IHVuYWNjb3VudGVkQmFsYW5jZTtcbiAgICAgICAgY29uc3Qgc29sdmVyRmVlID0gZmVlU3RvcmUuY2FsY3VsYXRlU29sdmVyRmVlKHtcbiAgICAgICAgICAgIGJvcnJvd0Ftb3VudDogZXN0aW1hdGVkQm9ycm93RnJvbVRoaXNDaGFpbixcbiAgICAgICAgICAgIGRlY2ltYWxzOiBhc3NldC5kZWNpbWFscyxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uQ2hhaW5JRDogb3V0cHV0LmNoYWluSUQsXG4gICAgICAgICAgICBkZXN0aW5hdGlvblRva2VuQWRkcmVzczogb3V0cHV0LnRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgIHNvdXJjZUNoYWluSUQ6IGFzc2V0LmNoYWluSUQsXG4gICAgICAgICAgICBzb3VyY2VUb2tlbkFkZHJlc3M6IGFzc2V0LmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGludGVudC5mZWVzLnNvbHZlciA9IHNvbHZlckZlZS5hZGQoaW50ZW50LmZlZXMuc29sdmVyKS50b0ZpeGVkKCk7XG4gICAgICAgIGJvcnJvdyA9IGJvcnJvdy5hZGQoc29sdmVyRmVlKTtcbiAgICAgICAgY29uc3QgdW5hY2NvdW50ZWRCYWxhbmNlMiA9IGJvcnJvdy5taW51cyhhY2NvdW50ZWRCYWxhbmNlKTtcbiAgICAgICAgbGV0IGJvcnJvd0Zyb21UaGlzQ2hhaW4gPSBuZXcgRGVjaW1hbCgwKTtcbiAgICAgICAgaWYgKERlY2ltYWwuYWRkKGFzc2V0LmVvYUJhbGFuY2UsIGFzc2V0LmVwaGVtZXJhbEJhbGFuY2UpLmx0ZSh1bmFjY291bnRlZEJhbGFuY2UyKSkge1xuICAgICAgICAgICAgbG9nZ2VyJGIuZGVidWcoJ2NyZWF0ZUJyaWRnZVJGRjoyLjEnLCB7XG4gICAgICAgICAgICAgICAgYXNzZXRCYWxhbmNlOiBEZWNpbWFsLmFkZChhc3NldC5lb2FCYWxhbmNlLnRvU3RyaW5nKCksIGFzc2V0LmVwaGVtZXJhbEJhbGFuY2UudG9TdHJpbmcoKSkudG9GaXhlZCgpLFxuICAgICAgICAgICAgICAgIHVuYWNjb3VudGVkQmFsYW5jZTogdW5hY2NvdW50ZWRCYWxhbmNlMi50b0ZpeGVkKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJvcnJvd0Zyb21UaGlzQ2hhaW4gPSBEZWNpbWFsLmFkZChhc3NldC5lb2FCYWxhbmNlLnRvU3RyaW5nKCksIGFzc2V0LmVwaGVtZXJhbEJhbGFuY2UudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYWxsb3dhbmNlIGFuZCBkZXBvc2l0IHR4IGZvciAoYXNzZXQuZW9hQmFsYW5jZSkgZnJvbSB1c2RjKGVvYSkgLT4gdXNkYyhlcGgpXG4gICAgICAgICAgICBpZiAoIWFzc2V0LmVvYUJhbGFuY2UuZXEoMCkpIHtcbiAgICAgICAgICAgICAgICBlb2FUb0VwaGVtZXJhbENhbGxzW2Fzc2V0LmNoYWluSURdID0ge1xuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IG11bERlY2ltYWxzKGFzc2V0LmVvYUJhbGFuY2UsIGFzc2V0LmRlY2ltYWxzKSxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IGFzc2V0LmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGFzc2V0LmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9ycm93RnJvbVRoaXNDaGFpbiA9IHVuYWNjb3VudGVkQmFsYW5jZTI7XG4gICAgICAgICAgICBpZiAoYm9ycm93RnJvbVRoaXNDaGFpbi5ndChhc3NldC5lcGhlbWVyYWxCYWxhbmNlLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJGIuZGVidWcoJ2NyZWF0ZUJyaWRnZVJGRjoyLjInLCB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2V0RXBoZW1lcmFsOiBhc3NldC5lcGhlbWVyYWxCYWxhbmNlLFxuICAgICAgICAgICAgICAgICAgICBib3Jyb3dGcm9tVGhpc0NoYWluOiBib3Jyb3dGcm9tVGhpc0NoYWluLnRvRml4ZWQoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlb2FUb0VwaGVtZXJhbENhbGxzW2Fzc2V0LmNoYWluSURdID0ge1xuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IG11bERlY2ltYWxzKGJvcnJvd0Zyb21UaGlzQ2hhaW4ubWludXMoYXNzZXQuZXBoZW1lcmFsQmFsYW5jZS50b1N0cmluZygpKSwgYXNzZXQuZGVjaW1hbHMpLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogYXNzZXQuZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuQWRkcmVzczogYXNzZXQuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW50ZW50LnNvdXJjZXMucHVzaCh7XG4gICAgICAgICAgICBhbW91bnQ6IGJvcnJvd0Zyb21UaGlzQ2hhaW4sXG4gICAgICAgICAgICBjaGFpbklEOiBhc3NldC5jaGFpbklELFxuICAgICAgICAgICAgdG9rZW5Db250cmFjdDogYXNzZXQuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgdW5pdmVyc2U6IFVuaXZlcnNlLkVUSEVSRVVNLFxuICAgICAgICB9KTtcbiAgICAgICAgYWNjb3VudGVkQmFsYW5jZSA9IGFjY291bnRlZEJhbGFuY2UuYWRkKGJvcnJvd0Zyb21UaGlzQ2hhaW4pO1xuICAgIH1cbiAgICBpZiAoYWNjb3VudGVkQmFsYW5jZSA8IGJvcnJvdykge1xuICAgICAgICBpbnRlbnQuaXNBdmFpbGFibGVCYWxhbmNlSW5zdWZmaWNpZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW9hVG9FcGhlbWVyYWxDYWxscywgaW50ZW50IH07XG59O1xuY29uc3QgY3JlYXRlQnJpZGdlUkZGID0gYXN5bmMgKHsgY29uZmlnLCBpbnB1dCwgb3V0cHV0LCB9KSA9PiB7XG4gICAgbG9nZ2VyJGIuZGVidWcoJ2NyZWF0ZUJyaWRnZVJGRicsIHsgaW5wdXQsIG91dHB1dCB9KTtcbiAgICBjb25zdCBmZWVTdG9yZSA9IGF3YWl0IGdldEZlZVN0b3JlKGNvbmZpZy5uZXR3b3JrLkdSUENfVVJMKTtcbiAgICBjb25zdCBkZXBvc2l0Q2FsbHMgPSB7fTtcbiAgICBjb25zdCB7IGVvYVRvRXBoZW1lcmFsQ2FsbHMsIGludGVudCB9ID0gY3JlYXRlSW50ZW50KHtcbiAgICAgICAgYXNzZXRzOiBpbnB1dC5hc3NldHMsXG4gICAgICAgIGZlZVN0b3JlLFxuICAgICAgICBvdXRwdXQsXG4gICAgfSk7XG4gICAgaWYgKGludGVudC5pc0F2YWlsYWJsZUJhbGFuY2VJbnN1ZmZpY2llbnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3JJbnN1ZmZpY2llbnRCYWxhbmNlJDE7XG4gICAgfVxuICAgIGNvbnN0IHsgbXNnQmFzaWNDb3Ntb3MsIG9tbml2ZXJzYWxSRkYsIHNpZ25hdHVyZURhdGEsIHNvdXJjZXMgfSA9IGF3YWl0IGNyZWF0ZVJGRnJvbUludGVudChpbnRlbnQsIHtcbiAgICAgICAgY2hhaW5MaXN0OiBjb25maWcuY2hhaW5MaXN0LFxuICAgICAgICBjb3Ntb3M6IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGNvbmZpZy5jb3Ntb3MuYWRkcmVzcyxcbiAgICAgICAgICAgIGNsaWVudDogY29uZmlnLmNvc21vcy53YWxsZXQsXG4gICAgICAgIH0sXG4gICAgICAgIGV2bToge1xuICAgICAgICAgICAgYWRkcmVzczogY29uZmlnLmV2bS5hZGRyZXNzLFxuICAgICAgICAgICAgY2xpZW50OiBjb25maWcuZXZtLmNsaWVudCxcbiAgICAgICAgfSxcbiAgICB9LCBVbml2ZXJzZS5FVEhFUkVVTSk7XG4gICAgbG9nZ2VyJGIuZGVidWcoJ2NyZWF0ZUludGVudCcsIHsgaW50ZW50IH0pO1xuICAgIGxldCBpbnRlbnRJRCA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICBjb25zdCBjcmVhdGVSRkYgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGludGVudElEID0gYXdhaXQgY29zbW9zQ3JlYXRlUkZGKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGNvbmZpZy5jb3Ntb3MuYWRkcmVzcyxcbiAgICAgICAgICAgIGNvc21vc1VSTDogY29uZmlnLm5ldHdvcmsuQ09TTU9TX1VSTCxcbiAgICAgICAgICAgIG1zZzogbXNnQmFzaWNDb3Ntb3MsXG4gICAgICAgICAgICB3YWxsZXQ6IGNvbmZpZy5jb3Ntb3Mud2FsbGV0LFxuICAgICAgICB9KTtcbiAgICAgICAgc3RvcmVJbnRlbnRIYXNoVG9TdG9yZShjb25maWcuZXZtLmFkZHJlc3MsIGludGVudElELnRvTnVtYmVyKCkpO1xuICAgICAgICBjb25zdCBkb3VibGVDaGVja1R4TWFwID0ge307XG4gICAgICAgIG9tbml2ZXJzYWxSRkYucHJvdG9idWZSRkYuc291cmNlcy5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgIGRvdWJsZUNoZWNrVHhNYXBbYnl0ZXNUb051bWJlcihzLmNoYWluSUQpXSA9IGNyZWF0ZURvdWJsZUNoZWNrVHgocy5jaGFpbklELCBjb25maWcuY29zbW9zLCBpbnRlbnRJRCwgY29uZmlnLm5ldHdvcmsuQ09TTU9TX1VSTCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlRG91YmxlQ2hlY2tUeDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBkb3VibGVDaGVja1R4TWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIkYi5kZWJ1ZygnU3RhcnRpbmcgZG91YmxlIGNoZWNrIHR4JywgeyBjaGFpbjogayB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGRvdWJsZUNoZWNrVHhNYXBba10oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJGIuZXJyb3IoJ0Vycm9yIGR1cmluZyBkb3VibGUgY2hlY2sgdHgnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGludGVudElELFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgYWxsb3dhbmNlcyA9IGF3YWl0IGdldEFsbG93YW5jZXMoaW50ZW50LnNvdXJjZXMubWFwKChzKSA9PiAoe1xuICAgICAgICBjaGFpbklEOiBzLmNoYWluSUQsXG4gICAgICAgIHRva2VuQ29udHJhY3Q6IHMudG9rZW5Db250cmFjdCxcbiAgICB9KSksIGNvbmZpZy5ldm0uYWRkcmVzcywgY29uZmlnLmNoYWluTGlzdCk7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIHNvdXJjZV0gb2Ygc291cmNlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgZXZtU2lnbmF0dXJlRGF0YSA9IHNpZ25hdHVyZURhdGEuZmluZCgocykgPT4gcy51bml2ZXJzZSA9PT0gVW5pdmVyc2UuRVRIRVJFVU0pO1xuICAgICAgICBpZiAoIWV2bVNpZ25hdHVyZURhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzaWduYXR1cmUgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYWluID0gY29uZmlnLmNoYWluTGlzdC5nZXRDaGFpbkJ5SUQoTnVtYmVyKHNvdXJjZS5jaGFpbklEKSk7XG4gICAgICAgIGlmICghY2hhaW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hhaW4gbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsb3dhbmNlID0gYWxsb3dhbmNlc1tOdW1iZXIoc291cmNlLmNoYWluSUQpXTtcbiAgICAgICAgbG9nZ2VyJGIuZGVidWcoJ2FsbG93YW5jZXMnLCB7IGFsbG93YW5jZSwgY2hhaW5JRDogTnVtYmVyKHNvdXJjZS5jaGFpbklEKSB9KTtcbiAgICAgICAgaWYgKGFsbG93YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbG93YW5jZSBub3QgYXBwbGljYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4ID0gW107XG4gICAgICAgIGlmIChhbGxvd2FuY2UgPCBzb3VyY2UudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93YW5jZVR4ID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHBhY2tFUkMyMEFwcHJvdmUoY29uZmlnLmNoYWluTGlzdC5nZXRWYXVsdENvbnRyYWN0QWRkcmVzcyhOdW1iZXIoc291cmNlLmNoYWluSUQpKSksXG4gICAgICAgICAgICAgICAgdG86IGNvbnZlcnRBZGRyZXNzQnlVbml2ZXJzZShzb3VyY2UudG9rZW5BZGRyZXNzLCBVbml2ZXJzZS5FVEhFUkVVTSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHR4LnB1c2goYWxsb3dhbmNlVHgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKHtcbiAgICAgICAgICAgIGFyZ3NGb3JSRkZEZXBvc2l0OiBbXG4gICAgICAgICAgICAgICAgb21uaXZlcnNhbFJGRi5hc0VWTVJGRigpLFxuICAgICAgICAgICAgICAgIHRvSGV4KGV2bVNpZ25hdHVyZURhdGEuc2lnbmF0dXJlKSxcbiAgICAgICAgICAgICAgICBCaWdJbnQoaW5kZXgpLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHR4LnB1c2goe1xuICAgICAgICAgICAgZGF0YTogZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgICAgICBhYmk6IEVWTVZhdWx0QUJJLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtvbW5pdmVyc2FsUkZGLmFzRVZNUkZGKCksIHRvSGV4KGV2bVNpZ25hdHVyZURhdGEuc2lnbmF0dXJlKSwgQmlnSW50KGluZGV4KV0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnZGVwb3NpdCcsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRvOiBjb25maWcuY2hhaW5MaXN0LmdldFZhdWx0Q29udHJhY3RBZGRyZXNzKE51bWJlcihzb3VyY2UuY2hhaW5JRCkpLFxuICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICB9KTtcbiAgICAgICAgZGVwb3NpdENhbGxzW051bWJlcihzb3VyY2UuY2hhaW5JRCldID0ge1xuICAgICAgICAgICAgYW1vdW50OiBzb3VyY2UudmFsdWUsXG4gICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGNvbnZlcnRBZGRyZXNzQnlVbml2ZXJzZShzb3VyY2UudG9rZW5BZGRyZXNzLCBzb3VyY2UudW5pdmVyc2UpLFxuICAgICAgICAgICAgdHg6IHR4LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBjaGFpbiA9IGNvbmZpZy5jaGFpbkxpc3QuZ2V0Q2hhaW5CeUlEKE51bWJlcihvdXRwdXQuY2hhaW5JRCkpO1xuICAgIGlmICghY2hhaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRlc3RpbmF0aW9uIGNoYWluJyk7XG4gICAgfVxuICAgIGNvbnN0IHdzID0gd2ViU29ja2V0KGNoYWluLnJwY1VybHMuZGVmYXVsdC53ZWJTb2NrZXRbMF0pO1xuICAgIGNvbnN0IHBjID0gY3JlYXRlUHVibGljQ2xpZW50KHtcbiAgICAgICAgdHJhbnNwb3J0OiB3cyxcbiAgICB9KTtcbiAgICBjb25zdCB3YWl0Rm9yRmlsbCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgcyA9IHNpZ25hdHVyZURhdGEuZmluZCgocykgPT4gcy51bml2ZXJzZSA9PT0gVW5pdmVyc2UuRVRIRVJFVU0pO1xuICAgICAgICBpZiAoIXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzaWduYXR1cmUgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlciRiLmRlYnVnKGBXYWl0aW5nIGZvciBmaWxsOiAke2ludGVudElEfWApO1xuICAgICAgICBjb25zdCByID0ge1xuICAgICAgICAgICAgZmlsbGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGludGVudElELFxuICAgICAgICAgICAgcHJvbWlzZTogZXZtV2FpdEZvckZpbGwoY29uZmlnLmNoYWluTGlzdC5nZXRWYXVsdENvbnRyYWN0QWRkcmVzcyhjaGFpbi5pZCksIHBjLCBzLnJlcXVlc3RIYXNoLCBpbnRlbnRJRCwgY29uZmlnLm5ldHdvcmsuR1JQQ19VUkwsIGNvbmZpZy5uZXR3b3JrLkNPU01PU19VUkwpLFxuICAgICAgICB9O1xuICAgICAgICByLnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByLmZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICByZW1vdmVJbnRlbnRIYXNoRnJvbVN0b3JlKGNvbmZpZy5ldm0uYWRkcmVzcywgci5pbnRlbnRJRCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZVJGRixcbiAgICAgICAgZGVwb3NpdENhbGxzLFxuICAgICAgICBlb2FUb0VwaGVtZXJhbENhbGxzLFxuICAgICAgICBpbnRlbnQsXG4gICAgICAgIHdhaXRGb3JGaWxsLFxuICAgIH07XG59O1xuY29uc3QgY3JlYXRlRG91YmxlQ2hlY2tUeCA9IChjaGFpbklELCBjb3Ntb3MsIGludGVudElELCBjb3Ntb3NVUkwpID0+IHtcbiAgICBjb25zdCBtc2cgPSBNc2dEb3VibGVDaGVja1R4LmNyZWF0ZSh7XG4gICAgICAgIGNyZWF0b3I6IGNvc21vcy5hZGRyZXNzLFxuICAgICAgICBwYWNrZXQ6IHtcbiAgICAgICAgICAgICRjYXNlOiAnZGVwb3NpdFBhY2tldCcsXG4gICAgICAgICAgICB2YWx1ZTogRGVwb3NpdFZFUGFja2V0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZ2FzUmVmdW5kZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlkOiBpbnRlbnRJRCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9LFxuICAgICAgICB0eENoYWluSUQ6IGNoYWluSUQsXG4gICAgICAgIHR4VW5pdmVyc2U6IFVuaXZlcnNlLkVUSEVSRVVNLFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb3Ntb3NDcmVhdGVEb3VibGVDaGVja1R4KHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGNvc21vcy5hZGRyZXNzLFxuICAgICAgICAgICAgY29zbW9zVVJMLFxuICAgICAgICAgICAgbXNnLFxuICAgICAgICAgICAgd2FsbGV0OiBjb3Ntb3Mud2FsbGV0LFxuICAgICAgICB9KTtcbiAgICB9O1xufTtcblxuY29uc3QgbG9nZ2VyJGEgPSBnZXRMb2dnZXIoKTtcbmNvbnN0IGdldEJhbGFuY2VzID0gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgY29uc3QgcmVtb3ZlVHJhbnNmZXJGZWUgPSBpbnB1dC5yZW1vdmVUcmFuc2ZlckZlZSA/PyBmYWxzZTtcbiAgICBjb25zdCBmaWx0ZXIgPSBpbnB1dC5maWx0ZXIgPz8gdHJ1ZTtcbiAgICBjb25zdCBbYW5rckJhbGFuY2VzLCBldm1CYWxhbmNlcywgZnVlbEJhbGFuY2VzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgaW5wdXQubmV0d29ya0hpbnQgPT09IEVudmlyb25tZW50LkZPTExZXG4gICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICAgICAgICAgIDogZ2V0QW5rckJhbGFuY2VzKGlucHV0LmV2bUFkZHJlc3MsIGlucHV0LmNoYWluTGlzdCwgcmVtb3ZlVHJhbnNmZXJGZWUpLFxuICAgICAgICBnZXRFVk1CYWxhbmNlc0ZvckFkZHJlc3MoaW5wdXQudnNjRG9tYWluLCBpbnB1dC5ldm1BZGRyZXNzKSxcbiAgICAgICAgaW5wdXQuZnVlbEFkZHJlc3NcbiAgICAgICAgICAgID8gZ2V0RnVlbEJhbGFuY2VzRm9yQWRkcmVzcyhpbnB1dC52c2NEb21haW4sIGlucHV0LmZ1ZWxBZGRyZXNzKVxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoW10pLFxuICAgIF0pO1xuICAgIGNvbnN0IGFzc2V0cyA9IGJhbGFuY2VzVG9Bc3NldHMoYW5rckJhbGFuY2VzLCBldm1CYWxhbmNlcywgZnVlbEJhbGFuY2VzLCBpbnB1dC5jaGFpbkxpc3QpO1xuICAgIGxldCBiYWxhbmNlcyA9IHRvRmxhdEJhbGFuY2UoYXNzZXRzKTtcbiAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgIGJhbGFuY2VzID0gZmlsdGVyU3VwcG9ydGVkVG9rZW5zKGJhbGFuY2VzKTtcbiAgICB9XG4gICAgbG9nZ2VyJGEuZGVidWcoJ2dldEJhbGFuY2VzJywge1xuICAgICAgICBhc3NldHMsXG4gICAgICAgIGJhbGFuY2VzLFxuICAgICAgICByZW1vdmVUcmFuc2ZlckZlZSxcbiAgICB9KTtcbiAgICByZXR1cm4geyBhc3NldHMsIGJhbGFuY2VzIH07XG59O1xuY29uc3QgZGV0ZXJtaW5lU3dhcFJvdXRlID0gYXN5bmMgKGlucHV0LCBvcHRpb25zKSA9PiB7XG4gICAgbG9nZ2VyJGEuZGVidWcoJ2RldGVybWluZVN3YXBSb3V0ZScsIHtcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgfSk7XG4gICAgaWYgKGlucHV0Lm1vZGUgPT09IFN3YXBNb2RlLkVYQUNUX09VVCkge1xuICAgICAgICByZXR1cm4gX2V4YWN0T3V0Um91dGUoaW5wdXQuZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gX2V4YWN0SW5Sb3V0ZShpbnB1dC5kYXRhLCBvcHRpb25zKTtcbiAgICB9XG59O1xuY29uc3QgX2V4YWN0T3V0Um91dGUgPSBhc3luYyAoaW5wdXQsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IFtmZWVTdG9yZSwgeyBhc3NldHMsIGJhbGFuY2VzIH0sIG9yYWNsZVByaWNlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldEZlZVN0b3JlKHBhcmFtcy5uZXR3b3JrQ29uZmlnLkdSUENfVVJMKSxcbiAgICAgICAgZ2V0QmFsYW5jZXMoe1xuICAgICAgICAgICAgbmV0d29ya0hpbnQ6IHBhcmFtcy5uZXR3b3JrQ29uZmlnLk5FVFdPUktfSElOVCxcbiAgICAgICAgICAgIGV2bUFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLmVvYSxcbiAgICAgICAgICAgIGNoYWluTGlzdDogcGFyYW1zLmNoYWluTGlzdCxcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zZmVyRmVlOiB0cnVlLFxuICAgICAgICAgICAgZmlsdGVyOiB0cnVlLFxuICAgICAgICAgICAgdnNjRG9tYWluOiBwYXJhbXMubmV0d29ya0NvbmZpZy5WU0NfRE9NQUlOLFxuICAgICAgICB9KSxcbiAgICAgICAgZmV0Y2hQcmljZU9yYWNsZShwYXJhbXMubmV0d29ya0NvbmZpZy5HUlBDX1VSTCksXG4gICAgXSk7XG4gICAgLy8gQW55IGV4aXN0aW5nIENPVCBiYWxhbmNlIG9uIGRzdCBjaGFpblxuICAgIGxldCBkc3RFT0FUb0VwaFR4ID0gbnVsbDtcbiAgICBsb2dnZXIkYS5kZWJ1ZygnZGV0ZXJtaW5lU3dhcFJvdXRlJywgeyBhc3NldHMsIGJhbGFuY2VzLCBpbnB1dCB9KTtcbiAgICBjb25zdCB1c2VyQWRkcmVzc0luQnl0ZXMgPSBjb252ZXJ0VG8zMkJ5dGVzKHBhcmFtcy5hZGRyZXNzLmVwaGVtZXJhbCk7XG4gICAgY29uc3QgZHN0T21uaXZlcnNhbENoYWluSUQgPSBuZXcgT21uaXZlcnNhbENoYWluSUQoVW5pdmVyc2UuRVRIRVJFVU0sIGlucHV0LnRvQ2hhaW5JZCk7XG4gICAgbG9nZ2VyJGEuZGVidWcoJ2RldGVybWluZVN3YXBSb3V0ZTpkZXN0aW5hdGlvblN3YXBJbnB1dCcsIHtcbiAgICAgICAgZHN0T21uaXZlcnNhbENoYWluSUQsXG4gICAgICAgIHM6IHtcbiAgICAgICAgICAgIGFtb3VudDogQmlnSW50KGlucHV0LnRvQW1vdW50KSxcbiAgICAgICAgICAgIHRva2VuQWRkcmVzczogdG9CeXRlcyhpbnB1dC50b1Rva2VuQWRkcmVzcyksXG4gICAgICAgIH0sXG4gICAgICAgIHVzZXJBZGRyZXNzSW5CeXRlcyxcbiAgICB9KTtcbiAgICBjb25zdCBkc3RDaGFpbkRhdGFNYXAgPSBDaGFpbmRhdGFNYXAuZ2V0KGRzdE9tbml2ZXJzYWxDaGFpbklEKTtcbiAgICBpZiAoIWRzdENoYWluRGF0YU1hcCkge1xuICAgICAgICB0aHJvdyBFcnJvckNoYWluRGF0YU5vdEZvdW5kO1xuICAgIH1cbiAgICBjb25zdCBjb3RTeW1ib2wgPSBDdXJyZW5jeUlEJDFbcGFyYW1zLmNvdEN1cnJlbmN5SURdO1xuICAgIGNvbnN0IGRzdENoYWluQ09UID0gZHN0Q2hhaW5EYXRhTWFwLkN1cnJlbmNpZXMuZmluZCgoYykgPT4gYy5jdXJyZW5jeUlEID09PSBwYXJhbXMuY290Q3VycmVuY3lJRCk7XG4gICAgaWYgKCFkc3RDaGFpbkNPVCkge1xuICAgICAgICB0aHJvdyBFcnJvckNPVE5vdEZvdW5kKGlucHV0LnRvQ2hhaW5JZCk7XG4gICAgfVxuICAgIGNvbnN0IGRzdENoYWluQ09UQWRkcmVzcyA9IGNvbnZlcnRUb0VWTUFkZHJlc3MoZHN0Q2hhaW5DT1QudG9rZW5BZGRyZXNzKTtcbiAgICBjb25zdCBkc3RDaGFpbkNPVEJhbGFuY2UgPSBiYWxhbmNlcy5maW5kKChiKSA9PiBiLmNoYWluSUQgPT09IE51bWJlcihpbnB1dC50b0NoYWluSWQpICYmXG4gICAgICAgIGVxdWFsRm9sZChjb252ZXJ0VG9FVk1BZGRyZXNzKGIudG9rZW5BZGRyZXNzKSwgZHN0Q2hhaW5DT1RBZGRyZXNzKSk7XG4gICAgY29uc3QgZ2V0RERTID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgZGRzID0ge1xuICAgICAgICAgICAgYWdncmVnYXRvcjogcGFyYW1zLmFnZ3JlZ2F0b3JzWzBdLFxuICAgICAgICAgICAgaW5wdXRBbW91bnQ6IGRpdkRlY2ltYWxzKGlucHV0LnRvQW1vdW50LCBkc3RDaGFpbkNPVC5kZWNpbWFscyksXG4gICAgICAgICAgICBvdXRwdXRBbW91bnQ6IDBuLFxuICAgICAgICAgICAgcXVvdGU6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIG91dHB1dCB0b2tlbiBpcyBub3QgQ09UIHRoZW4gb25seSBkZXN0aW5hdGlvbiBzd2FwIHNob3VsZCBleGlzdFxuICAgICAgICBpZiAoIWVxdWFsRm9sZChpbnB1dC50b1Rva2VuQWRkcmVzcywgZHN0Q2hhaW5DT1RBZGRyZXNzKSkge1xuICAgICAgICAgICAgZGRzID0gYXdhaXQgZGV0ZXJtaW5lRGVzdGluYXRpb25Td2Fwcyh1c2VyQWRkcmVzc0luQnl0ZXMsIG51bGwsIGRzdE9tbml2ZXJzYWxDaGFpbklELCB7XG4gICAgICAgICAgICAgICAgYW1vdW50OiBCaWdJbnQoaW5wdXQudG9BbW91bnQpLFxuICAgICAgICAgICAgICAgIHRva2VuQWRkcmVzczogY29udmVydFRvMzJCeXRlcyhpbnB1dC50b1Rva2VuQWRkcmVzcyksXG4gICAgICAgICAgICB9LCBwYXJhbXMuYWdncmVnYXRvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIC8vIElmIGRlc3RpbmF0aW9uIGhhcyBDT1QgdGhlbiBuZWVkIHRvIHNlbmQgaXQgdG8gZXBoZW1lcmFsIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gc3dhcFxuICAgICAgICBpZiAobmV3IERlY2ltYWwoZHN0Q2hhaW5DT1RCYWxhbmNlPy5hbW91bnQgPz8gMCkuZ3QoMCkpIHtcbiAgICAgICAgICAgIGRzdEVPQVRvRXBoVHggPSB7XG4gICAgICAgICAgICAgICAgYW1vdW50OiBtdWxEZWNpbWFscyhkc3RDaGFpbkNPVEJhbGFuY2U/LmFtb3VudCA/PyAwLCBkc3RDaGFpbkNPVEJhbGFuY2U/LmRlY2ltYWxzID8/IDApLFxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogZHN0Q2hhaW5DT1RBZGRyZXNzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZGRzLFxuICAgICAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICAgICAgZHN0Q2hhaW5DT1Q6IGRzdENoYWluQ09ULFxuICAgICAgICAgICAgZHN0RU9BVG9FcGhUeCxcbiAgICAgICAgICAgIGlucHV0QW1vdW50V2l0aEJ1ZmZlcjogZGRzLmlucHV0QW1vdW50XG4gICAgICAgICAgICAgICAgLm11bCgxLjAyKVxuICAgICAgICAgICAgICAgIC50b0RQKGRzdENoYWluQ09ULmRlY2ltYWxzLCBEZWNpbWFsLlJPVU5EX0NFSUwpLFxuICAgICAgICAgICAgcmVxOiB7XG4gICAgICAgICAgICAgICAgY2hhaW46IGRzdE9tbml2ZXJzYWxDaGFpbklELFxuICAgICAgICAgICAgICAgIGlucHV0VG9rZW46IGRzdENoYWluQ09ULnRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBvdXRwdXRUb2tlbjogdG9CeXRlcyhpbnB1dC50b1Rva2VuQWRkcmVzcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgZGVzdGluYXRpb25Td2FwID0gYXdhaXQgZ2V0RERTKCk7XG4gICAgbG9nZ2VyJGEuZGVidWcoJ2Rlc3RpbmF0aW9uIHN3YXBzJywgZGVzdGluYXRpb25Td2FwKTtcbiAgICBjb25zdCBjb3RBc3NldCA9IGFzc2V0cy5maW5kKChhc3NldCkgPT4ge1xuICAgICAgICByZXR1cm4gYXNzZXQuYWJzdHJhY3RlZCAmJiBlcXVhbEZvbGQoYXNzZXQuc3ltYm9sLCBjb3RTeW1ib2wpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbCA9IGRlc3RpbmF0aW9uU3dhcC5pbnB1dEFtb3VudFxuICAgICAgICAubXVsKDEuMDIpXG4gICAgICAgIC50b0RQKGRzdENoYWluQ09ULmRlY2ltYWxzLCBEZWNpbWFsLlJPVU5EX0NFSUwpO1xuICAgIGxvZ2dlciRhLmRlYnVnKCdkZXRlcm1pbmVTd2FwUm91dGU6MycsIHtcbiAgICAgICAgY290QXNzZXQsXG4gICAgICAgIGRzdENoYWluQ09UQWRkcmVzcyxcbiAgICAgICAgZHN0Q2hhaW5DT1RCYWxhbmNlLFxuICAgIH0pO1xuICAgIGNvbnN0IGNvdFRvdGFsQmFsYW5jZSA9IG5ldyBEZWNpbWFsKGNvdEFzc2V0Py5iYWxhbmNlID8/ICcwJyk7XG4gICAgY29uc3QgZnVsZmlsbWVudEZlZSA9IGZlZVN0b3JlLmNhbGN1bGF0ZUZ1bGZpbG1lbnRGZWUoe1xuICAgICAgICBkZWNpbWFsczogZHN0Q2hhaW5DT1QuZGVjaW1hbHMsXG4gICAgICAgIGRlc3RpbmF0aW9uQ2hhaW5JRDogTnVtYmVyKGlucHV0LnRvQ2hhaW5JZCksXG4gICAgICAgIGRlc3RpbmF0aW9uVG9rZW5BZGRyZXNzOiBkc3RDaGFpbkNPVEFkZHJlc3MsXG4gICAgfSk7XG4gICAgY29uc3QgZmVlcyA9IGZ1bGZpbG1lbnRGZWU7XG4gICAgbG9nZ2VyJGEuZGVidWcoJ2RldGVybWluZVN3YXBSb3V0ZTo0Jywge1xuICAgICAgICBjb3RBc3NldCxcbiAgICAgICAgY290VG90YWxCYWxhbmNlOiBjb3RUb3RhbEJhbGFuY2UudG9GaXhlZCgpLFxuICAgICAgICBkaWZmOiBmZWVzLnRvRml4ZWQoKSxcbiAgICAgICAgZHN0U3dhcElucHV0QW1vdW50SW5EZWNpbWFsOiBkc3RTd2FwSW5wdXRBbW91bnRJbkRlY2ltYWwudG9GaXhlZCgpLFxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKHsgY290QXNzZXQsIGRzdENoYWluQ09UQmFsYW5jZSB9KTtcbiAgICBsZXQgc291cmNlU3dhcHMgPSBbXTtcbiAgICBsZXQgc291cmNlU3dhcHNSZXF1aXJlZCA9IGZhbHNlO1xuICAgIGlmICghZHN0Q2hhaW5DT1RCYWxhbmNlKSB7XG4gICAgICAgIHNvdXJjZVN3YXBzUmVxdWlyZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWNvdEFzc2V0IHx8IG5ldyBEZWNpbWFsKGNvdEFzc2V0LmJhbGFuY2UpLmx0KGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbCkpIHtcbiAgICAgICAgc291cmNlU3dhcHNSZXF1aXJlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzb3VyY2VTd2Fwc1JlcXVpcmVkKSB7XG4gICAgICAgIHNvdXJjZVN3YXBzID0gYXdhaXQgYXV0b1NlbGVjdFNvdXJjZXModXNlckFkZHJlc3NJbkJ5dGVzLCBiYWxhbmNlcy5tYXAoKGJhbGFuY2UpID0+ICh7XG4gICAgICAgICAgICBhbW91bnQ6IG11bERlY2ltYWxzKGJhbGFuY2UuYW1vdW50LCBiYWxhbmNlLmRlY2ltYWxzKSxcbiAgICAgICAgICAgIGNoYWluSUQ6IG5ldyBPbW5pdmVyc2FsQ2hhaW5JRChiYWxhbmNlLnVuaXZlcnNlLCBiYWxhbmNlLmNoYWluSUQpLFxuICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiB0b0J5dGVzKGJhbGFuY2UudG9rZW5BZGRyZXNzKSxcbiAgICAgICAgICAgIHZhbHVlOiBiYWxhbmNlLnZhbHVlLFxuICAgICAgICB9KSksIGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbFxuICAgICAgICAgICAgLmFkZChmZWVzKVxuICAgICAgICAgICAgLm11bCgxLjAxKVxuICAgICAgICAgICAgLm1pbnVzKGNvdEFzc2V0Py5iYWxhbmNlID8/ICcwJyksIHBhcmFtcy5hZ2dyZWdhdG9ycywgZmVlU3RvcmUuZGF0YS5mZWUuY29sbGVjdGlvbi5tYXAoKGYpID0+ICh7XG4gICAgICAgICAgICAuLi5mLFxuICAgICAgICAgICAgY2hhaW5JRDogY29udmVydFRvMzJCeXRlcyhOdW1iZXIoZi5jaGFpbklEKSksXG4gICAgICAgICAgICBmZWU6IGNvbnZlcnRUbzMyQnl0ZXMoQmlnSW50KGYuZmVlKSksXG4gICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGNvbnZlcnRUbzMyQnl0ZXMoZi50b2tlbkFkZHJlc3MpLFxuICAgICAgICB9KSkpO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VTd2FwQ3JlYXRpb25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLmxvZyh7XG4gICAgICAgIGRzdENoYWluQ09UQmFsYW5jZSxcbiAgICAgICAgaW5lcXVhbGl0eTogbmV3IERlY2ltYWwoZHN0Q2hhaW5DT1RCYWxhbmNlPy5hbW91bnQgPz8gMCkubHQoZHN0U3dhcElucHV0QW1vdW50SW5EZWNpbWFsLmFkZChmZWVzKSksXG4gICAgfSk7XG4gICAgbGV0IGJyaWRnZUlucHV0ID0gbnVsbDtcbiAgICBjb25zdCBicmlkZ2VBc3NldHMgPSBjb3RBc3NldD8uYnJlYWtkb3duLm1hcCgoYikgPT4gKHtcbiAgICAgICAgY2hhaW5JRDogYi5jaGFpbi5pZCxcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBiLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgZGVjaW1hbHM6IGIuZGVjaW1hbHMsXG4gICAgICAgIGVvYUJhbGFuY2U6IG5ldyBEZWNpbWFsKGIuYmFsYW5jZSksXG4gICAgICAgIGVwaGVtZXJhbEJhbGFuY2U6IG5ldyBEZWNpbWFsKDApLFxuICAgIH0pKSA/PyBbXTtcbiAgICBpZiAobmV3IERlY2ltYWwoZHN0Q2hhaW5DT1RCYWxhbmNlPy5hbW91bnQgPz8gMG4pLmx0KGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbC5hZGQoZmVlcykpKSB7XG4gICAgICAgIC8vIElmIHN3YXAgaGFwcGVucyB0byBDT1Qgb24gZGVzdGluYXRpb24gY2hhaW5cbiAgICAgICAgLy8gdGhlbiB0aGF0IGFtb3VudCBkb2Vzbid0IG5lZWRzIHRvIGJlIGluIFJGRlxuICAgICAgICBsZXQgZHN0Q09UU3dhcEFtb3VudCA9IG5ldyBEZWNpbWFsKDApO1xuICAgICAgICBmb3IgKGNvbnN0IHN3YXAgb2Ygc291cmNlU3dhcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJBc3NldCA9IGJyaWRnZUFzc2V0cy5maW5kKChiYSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYmEuY2hhaW5JRCA9PT0gTnVtYmVyKHN3YXAucmVxLmNoYWluLmNoYWluSUQpICYmXG4gICAgICAgICAgICAgICAgICAgIGVxdWFsRm9sZChiYS5jb250cmFjdEFkZHJlc3MsIGNvbnZlcnRUb0VWTUFkZHJlc3Moc3dhcC5yZXEub3V0cHV0VG9rZW4pKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gcGFyYW1zLmNoYWluTGlzdC5nZXRUb2tlbkJ5QWRkcmVzcyhOdW1iZXIoc3dhcC5yZXEuY2hhaW4uY2hhaW5JRCksIGNvbnZlcnRUb0VWTUFkZHJlc3Moc3dhcC5yZXEub3V0cHV0VG9rZW4pKTtcbiAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclRva2VuTm90Rm91bmQoY29udmVydFRvRVZNQWRkcmVzcyhzd2FwLnJlcS5vdXRwdXRUb2tlbiksIE51bWJlcihzd2FwLnJlcS5jaGFpbi5jaGFpbklEKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRBbW91bnQgPSBzd2FwLnF1b3RlLm91dHB1dEFtb3VudE1pbmltdW07XG4gICAgICAgICAgICBpZiAoYkFzc2V0KSB7XG4gICAgICAgICAgICAgICAgYkFzc2V0LmVwaGVtZXJhbEJhbGFuY2UgPSBEZWNpbWFsLmFkZChiQXNzZXQuZXBoZW1lcmFsQmFsYW5jZSwgZGl2RGVjaW1hbHMob3V0cHV0QW1vdW50LCB0b2tlbi5kZWNpbWFscykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJpZGdlQXNzZXRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklEOiBOdW1iZXIoc3dhcC5yZXEuY2hhaW4uY2hhaW5JRCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udmVydFRvRVZNQWRkcmVzcyhzd2FwLnJlcS5vdXRwdXRUb2tlbiksXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiB0b2tlbi5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICAgICAgZW9hQmFsYW5jZTogbmV3IERlY2ltYWwoMCksXG4gICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbEJhbGFuY2U6IGRpdkRlY2ltYWxzKG91dHB1dEFtb3VudCwgdG9rZW4uZGVjaW1hbHMpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE51bWJlcihzd2FwLnJlcS5jaGFpbi5jaGFpbklEKSA9PT0gaW5wdXQudG9DaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgZHN0Q09UU3dhcEFtb3VudCA9IGRzdENPVFN3YXBBbW91bnQucGx1cyhkaXZEZWNpbWFscyhvdXRwdXRBbW91bnQsIHRva2VuLmRlY2ltYWxzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIkYS5kZWJ1ZygnZGV0ZXJtaW5lU3dhcFJvdXRlOnNvdXJjZVN3YXAnLCB7XG4gICAgICAgICAgICAgICAgb3V0cHV0QW1vdW50TGlrZWx5OiBzd2FwLnF1b3RlLm91dHB1dEFtb3VudExpa2VseSA/PyAwLFxuICAgICAgICAgICAgICAgIG91dHB1dEFtb3VudE1pbmltdW06IHN3YXAucXVvdGUub3V0cHV0QW1vdW50TWluaW11bSA/PyAwLFxuICAgICAgICAgICAgICAgIHN3YXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBDT1QgZnJvbSBzb3VyY2Ugc3dhcCBhdCBkZXN0aW5hdGlvbiBjaGFpbiArIGV4aXN0aW5nIENPVCBhY2NvdW50c1xuICAgICAgICAvLyBmb3IgcmVxdWlyZW1lbnQgdGhlbiBSRkYgc2hvdWxkbid0IGJlIGNyZWF0ZWRcbiAgICAgICAgaWYgKG5ldyBEZWNpbWFsKGRzdENoYWluQ09UQmFsYW5jZT8uYW1vdW50ID8/IDApXG4gICAgICAgICAgICAucGx1cyhkc3RDT1RTd2FwQW1vdW50KVxuICAgICAgICAgICAgLmx0KGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbCkpIHtcbiAgICAgICAgICAgIGJyaWRnZUlucHV0ID0ge1xuICAgICAgICAgICAgICAgIGFtb3VudDogZHN0U3dhcElucHV0QW1vdW50SW5EZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgIC5taW51cyhkc3RDaGFpbkNPVEJhbGFuY2U/LmFtb3VudCA/PyAwKVxuICAgICAgICAgICAgICAgICAgICAubWludXMoZHN0Q09UU3dhcEFtb3VudCksXG4gICAgICAgICAgICAgICAgYXNzZXRzOiBicmlkZ2VBc3NldHMsXG4gICAgICAgICAgICAgICAgY2hhaW5JRDogaW5wdXQudG9DaGFpbklkLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBkc3RDaGFpbkNPVC5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGNvbnZlcnRUb0VWTUFkZHJlc3MoZHN0Q2hhaW5DT1QudG9rZW5BZGRyZXNzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXNzZXRzVXNlZCA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3dhcCBvZiBzb3VyY2VTd2Fwcykge1xuICAgICAgICBjb25zdCB7IGRlY2ltYWxzLCBzeW1ib2wgfSA9IGdldFRva2VuRGVjaW1hbHMoTnVtYmVyKHN3YXAucmVxLmNoYWluLmNoYWluSUQpLCBzd2FwLnJlcS5pbnB1dFRva2VuKTtcbiAgICAgICAgYXNzZXRzVXNlZC5wdXNoKHtcbiAgICAgICAgICAgIGFtb3VudDogZGl2RGVjaW1hbHMoc3dhcC5xdW90ZS5pbnB1dEFtb3VudCwgZGVjaW1hbHMpLnRvRml4ZWQoKSxcbiAgICAgICAgICAgIGNoYWluSUQ6IE51bWJlcihzd2FwLnJlcS5jaGFpbi5jaGFpbklEKSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udmVydFRvRVZNQWRkcmVzcyhzd2FwLnJlcS5pbnB1dFRva2VuKSxcbiAgICAgICAgICAgIGRlY2ltYWxzLFxuICAgICAgICAgICAgc3ltYm9sLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJyaWRnZUlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgZW9hVG9FcGhlbWVyYWxDYWxscyB9ID0gY3JlYXRlSW50ZW50KHtcbiAgICAgICAgICAgIGFzc2V0czogYnJpZGdlQXNzZXRzLFxuICAgICAgICAgICAgZmVlU3RvcmUsXG4gICAgICAgICAgICBvdXRwdXQ6IGJyaWRnZUlucHV0LFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBjaGFpbiBpbiBlb2FUb0VwaGVtZXJhbENhbGxzKSB7XG4gICAgICAgICAgICBhc3NldHNVc2VkLnB1c2goe1xuICAgICAgICAgICAgICAgIGFtb3VudDogZGl2RGVjaW1hbHMoZW9hVG9FcGhlbWVyYWxDYWxsc1tjaGFpbl0uYW1vdW50LCBlb2FUb0VwaGVtZXJhbENhbGxzW2NoYWluXS5kZWNpbWFscykudG9GaXhlZCgpLFxuICAgICAgICAgICAgICAgIGNoYWluSUQ6IE51bWJlcihjaGFpbiksXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBlb2FUb0VwaGVtZXJhbENhbGxzW2NoYWluXS50b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IGVvYVRvRXBoZW1lcmFsQ2FsbHNbY2hhaW5dLmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogY290U3ltYm9sLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWdncmVnYXRvcnM6IHBhcmFtcy5hZ2dyZWdhdG9ycyxcbiAgICAgICAgYXNzZXRzVXNlZCxcbiAgICAgICAgYmFsYW5jZXMsXG4gICAgICAgIGJyaWRnZUlucHV0LFxuICAgICAgICBjb3RTeW1ib2wsXG4gICAgICAgIGRlc3RpbmF0aW9uU3dhcCxcbiAgICAgICAgZ2V0RERTLFxuICAgICAgICBvcmFjbGVQcmljZXMsXG4gICAgICAgIHNvdXJjZVN3YXBDcmVhdGlvblRpbWUsXG4gICAgICAgIHNvdXJjZVN3YXBzLFxuICAgIH07XG59O1xuY29uc3QgY2FsY3VsYXRlTWF4QnJpZGdlRmVlcyA9ICh7IGFzc2V0cywgZmVlU3RvcmUsIGRzdCwgfSkgPT4ge1xuICAgIGNvbnN0IGJvcnJvdyA9IGFzc2V0cy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBhc3NldCkgPT4ge1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IuYWRkKERlY2ltYWwuYWRkKGFzc2V0LmVvYUJhbGFuY2UsIGFzc2V0LmVwaGVtZXJhbEJhbGFuY2UpKTtcbiAgICB9LCBuZXcgRGVjaW1hbCgwKSk7XG4gICAgY29uc3QgcHJvdG9jb2xGZWUgPSBmZWVTdG9yZS5jYWxjdWxhdGVQcm90b2NvbEZlZShuZXcgRGVjaW1hbChib3Jyb3cpKTtcbiAgICBsZXQgYm9ycm93V2l0aEZlZSA9IGJvcnJvdy5hZGQocHJvdG9jb2xGZWUpO1xuICAgIGNvbnN0IGZ1bGZpbG1lbnRGZWUgPSBmZWVTdG9yZS5jYWxjdWxhdGVGdWxmaWxtZW50RmVlKHtcbiAgICAgICAgZGVjaW1hbHM6IGRzdC5kZWNpbWFscyxcbiAgICAgICAgZGVzdGluYXRpb25DaGFpbklEOiBkc3QuY2hhaW5JZCxcbiAgICAgICAgZGVzdGluYXRpb25Ub2tlbkFkZHJlc3M6IGRzdC50b2tlbkFkZHJlc3MsXG4gICAgfSk7XG4gICAgYm9ycm93V2l0aEZlZSA9IGJvcnJvd1dpdGhGZWUuYWRkKGZ1bGZpbG1lbnRGZWUpO1xuICAgIGxvZ2dlciRhLmRlYnVnKCdjYWxjdWxhdGVNYXhCcmlkZ2VGZWVzOjEnLCB7XG4gICAgICAgIGJvcnJvdzogYm9ycm93LnRvRml4ZWQoKSxcbiAgICAgICAgcHJvdG9jb2xGZWU6IHByb3RvY29sRmVlLnRvRml4ZWQoKSxcbiAgICAgICAgZnVsZmlsbWVudEZlZTogZnVsZmlsbWVudEZlZS50b0ZpeGVkKCksXG4gICAgICAgIGJvcnJvd1dpdGhGZWU6IGJvcnJvd1dpdGhGZWUudG9GaXhlZCgpLFxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgYXNzZXQgb2YgYXNzZXRzKSB7XG4gICAgICAgIGNvbnN0IHNvbHZlckZlZSA9IGZlZVN0b3JlLmNhbGN1bGF0ZVNvbHZlckZlZSh7XG4gICAgICAgICAgICBib3Jyb3dBbW91bnQ6IERlY2ltYWwuYWRkKGFzc2V0LmVvYUJhbGFuY2UsIGFzc2V0LmVwaGVtZXJhbEJhbGFuY2UpLFxuICAgICAgICAgICAgZGVjaW1hbHM6IGFzc2V0LmRlY2ltYWxzLFxuICAgICAgICAgICAgZGVzdGluYXRpb25DaGFpbklEOiBkc3QuY2hhaW5JZCxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uVG9rZW5BZGRyZXNzOiBkc3QudG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgc291cmNlQ2hhaW5JRDogYXNzZXQuY2hhaW5JRCxcbiAgICAgICAgICAgIHNvdXJjZVRva2VuQWRkcmVzczogY29udmVydFRvRVZNQWRkcmVzcyhhc3NldC5jb250cmFjdEFkZHJlc3MpLFxuICAgICAgICB9KTtcbiAgICAgICAgYm9ycm93V2l0aEZlZSA9IGJvcnJvd1dpdGhGZWUuYWRkKHNvbHZlckZlZSk7XG4gICAgICAgIGxvZ2dlciRhLmRlYnVnKCdjYWxjdWxhdGVNYXhCcmlkZ2VGZWVzOjInLCB7XG4gICAgICAgICAgICBib3Jyb3c6IGJvcnJvdy50b0ZpeGVkKCksXG4gICAgICAgICAgICBib3Jyb3dXaXRoRmVlOiBib3Jyb3dXaXRoRmVlLnRvRml4ZWQoKSxcbiAgICAgICAgICAgIHNvbHZlckZlZTogc29sdmVyRmVlLnRvRml4ZWQoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBib3Jyb3dXaXRoRmVlLm1pbnVzKGJvcnJvdyk7XG59O1xuY29uc3QgX2V4YWN0SW5Sb3V0ZSA9IGFzeW5jIChpbnB1dCwgcGFyYW1zKSA9PiB7XG4gICAgbG9nZ2VyJGEuZGVidWcoJ2V4YWN0SW5Sb3V0ZScsIHtcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHBhcmFtcyxcbiAgICB9KTtcbiAgICBjb25zdCBbZmVlU3RvcmUsIGJhbGFuY2VSZXNwb25zZSwgb3JhY2xlUHJpY2VzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0RmVlU3RvcmUocGFyYW1zLm5ldHdvcmtDb25maWcuR1JQQ19VUkwpLFxuICAgICAgICBnZXRCYWxhbmNlcyh7XG4gICAgICAgICAgICBuZXR3b3JrSGludDogcGFyYW1zLm5ldHdvcmtDb25maWcuTkVUV09SS19ISU5ULFxuICAgICAgICAgICAgZXZtQWRkcmVzczogcGFyYW1zLmFkZHJlc3MuZW9hLFxuICAgICAgICAgICAgY2hhaW5MaXN0OiBwYXJhbXMuY2hhaW5MaXN0LFxuICAgICAgICAgICAgcmVtb3ZlVHJhbnNmZXJGZWU6IHRydWUsXG4gICAgICAgICAgICB2c2NEb21haW46IHBhcmFtcy5uZXR3b3JrQ29uZmlnLlZTQ19ET01BSU4sXG4gICAgICAgIH0pLFxuICAgICAgICBmZXRjaFByaWNlT3JhY2xlKHBhcmFtcy5uZXR3b3JrQ29uZmlnLkdSUENfVVJMKSxcbiAgICBdKTtcbiAgICBsZXQgeyBiYWxhbmNlcyB9ID0gYmFsYW5jZVJlc3BvbnNlO1xuICAgIGxvZ2dlciRhLmRlYnVnKCdFeGFjdElOOjEnLCB7XG4gICAgICAgIGJhbGFuY2VzLFxuICAgIH0pO1xuICAgIGNvbnN0IGFzc2V0c1VzZWQgPSBbXTtcbiAgICBsZXQgc3JjQmFsYW5jZXMgPSBbXTtcbiAgICBpZiAoaW5wdXQuZnJvbSkge1xuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgaW5wdXQuZnJvbSkge1xuICAgICAgICAgICAgY29uc3Qgc3JjQmFsYW5jZSA9IGJhbGFuY2VzLmZpbmQoKGIpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkYS5kZWJ1ZygnRXhhY3RJTjoyOmlucHV0LnNyYycsIHtcbiAgICAgICAgICAgICAgICAgICAgYTogYi50b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGI6IGNvbnZlcnRUbzMyQnl0ZXNIZXgoZi50b2tlbkFkZHJlc3MpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBrZWVwaW5nIFpFUk9fQUREUkVTUyBhcyBFQWRkcmVzcyBzbyBoYXZlIHRvIG1ha2UgdGhlIGNvbXBhcmlzb25BZGRyIGxpa2UgdGhpc1xuICAgICAgICAgICAgICAgIGxldCBjb21wYXJpc29uVG9rZW5BZGRyZXNzID0gY29udmVydFRvMzJCeXRlc0hleChmLnRva2VuQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgaWYgKGVxdWFsRm9sZChjb21wYXJpc29uVG9rZW5BZGRyZXNzLCBaRVJPX0FERFJFU1MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmlzb25Ub2tlbkFkZHJlc3MgPSBFQUREUkVTUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFsRm9sZChiLnRva2VuQWRkcmVzcywgY29tcGFyaXNvblRva2VuQWRkcmVzcykgJiYgZi5jaGFpbklkID09PSBiLmNoYWluSUQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghc3JjQmFsYW5jZSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9ySW5zdWZmaWNpZW50QmFsYW5jZShmLmFtb3VudC50b1N0cmluZygpLCAnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRCYWxhbmNlID0gZGl2RGVjaW1hbHMoZi5hbW91bnQsIHNyY0JhbGFuY2UuZGVjaW1hbHMpO1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkQmFsYW5jZS5ndChzcmNCYWxhbmNlLmFtb3VudCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvckluc3VmZmljaWVudEJhbGFuY2Uoc3JjQmFsYW5jZS5hbW91bnQsIHJlcXVpcmVkQmFsYW5jZS50b0ZpeGVkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3JjQmFsYW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgLi4uc3JjQmFsYW5jZSxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IHJlcXVpcmVkQmFsYW5jZS50b0ZpeGVkKCksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNhbGN1bGF0ZVZhbHVlKHNyY0JhbGFuY2UuYW1vdW50LCBzcmNCYWxhbmNlLnZhbHVlLCBmLmFtb3VudCkudG9OdW1iZXIoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXRzVXNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBhbW91bnQ6IHJlcXVpcmVkQmFsYW5jZS50b0ZpeGVkKCksXG4gICAgICAgICAgICAgICAgY2hhaW5JRDogc3JjQmFsYW5jZS5jaGFpbklELFxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogc3JjQmFsYW5jZS50b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGVjaW1hbHM6IHNyY0JhbGFuY2UuZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBzcmNCYWxhbmNlLnN5bWJvbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKCdzaG91bGQgaGF2ZSBnb25lIHRvIHNpbmdsZSBzb3VyY2Ugc3dhcCByb3V0ZScpO1xuICAgICAgICAvLyB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzcmNCYWxhbmNlcyA9IGJhbGFuY2VzO1xuICAgIH1cbiAgICBsb2dnZXIkYS5kZWJ1ZygnRXhhY3RJTjozJywge1xuICAgICAgICBzcmNCYWxhbmNlcyxcbiAgICAgICAgYXNzZXRzVXNlZCxcbiAgICB9KTtcbiAgICBjb25zdCB1c2VyQWRkcmVzc0luQnl0ZXMgPSBjb252ZXJ0VG8zMkJ5dGVzKHBhcmFtcy5hZGRyZXNzLmVwaGVtZXJhbCk7XG4gICAgY29uc3QgZHN0T21uaXZlcnNhbENoYWluSUQgPSBuZXcgT21uaXZlcnNhbENoYWluSUQoVW5pdmVyc2UuRVRIRVJFVU0sIGlucHV0LnRvQ2hhaW5JZCk7XG4gICAgY29uc3QgZHN0Q2hhaW5EYXRhTWFwID0gQ2hhaW5kYXRhTWFwLmdldChkc3RPbW5pdmVyc2FsQ2hhaW5JRCk7XG4gICAgaWYgKCFkc3RDaGFpbkRhdGFNYXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGFpbmRhdGFNYXAgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGNvdFN5bWJvbCA9IEN1cnJlbmN5SUQkMVtwYXJhbXMuY290Q3VycmVuY3lJRF07XG4gICAgY29uc3QgZHN0Q2hhaW5DT1QgPSBkc3RDaGFpbkRhdGFNYXAuQ3VycmVuY2llcy5maW5kKChjKSA9PiBjLmN1cnJlbmN5SUQgPT09IHBhcmFtcy5jb3RDdXJyZW5jeUlEKTtcbiAgICBpZiAoIWRzdENoYWluQ09UKSB7XG4gICAgICAgIHRocm93IEVycm9yQ09UTm90Rm91bmQoaW5wdXQudG9DaGFpbklkKTtcbiAgICB9XG4gICAgY29uc3QgZHN0Q2hhaW5DT1RBZGRyZXNzID0gY29udmVydFRvRVZNQWRkcmVzcyhkc3RDaGFpbkNPVC50b2tlbkFkZHJlc3MpO1xuICAgIGNvbnN0IGJyaWRnZUFzc2V0cyA9IFtdO1xuICAgIC8vIEZpbHRlciBvdXQgQ09UJ3MgaW4gc291cmNlc1xuICAgIGNvbnN0IGNvdFNvdXJjZXMgPSBbXTtcbiAgICBsZXQgY290Q29tYmluZWRCYWxhbmNlID0gbmV3IERlY2ltYWwoMCk7XG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc3JjQmFsYW5jZXMpIHtcbiAgICAgICAgY29uc3QgY290ID0gQ2hhaW5kYXRhTWFwLmdldChuZXcgT21uaXZlcnNhbENoYWluSUQoVW5pdmVyc2UuRVRIRVJFVU0sIHNvdXJjZS5jaGFpbklEKSk/LkN1cnJlbmNpZXMuZmluZCgoYykgPT4gYy5jdXJyZW5jeUlEID09PSBwYXJhbXMuY290Q3VycmVuY3lJRCk7XG4gICAgICAgIGlmIChjb3QgJiZcbiAgICAgICAgICAgIGVxdWFsRm9sZChjb252ZXJ0VG9FVk1BZGRyZXNzKHNvdXJjZS50b2tlbkFkZHJlc3MpLCBjb252ZXJ0VG9FVk1BZGRyZXNzKGNvdC50b2tlbkFkZHJlc3MpKSkge1xuICAgICAgICAgICAgY290U291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBjb3RDb21iaW5lZEJhbGFuY2UgPSBjb3RDb21iaW5lZEJhbGFuY2UuYWRkKHNvdXJjZS5hbW91bnQpO1xuICAgICAgICAgICAgYnJpZGdlQXNzZXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNoYWluSUQ6IHNvdXJjZS5jaGFpbklELFxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udmVydFRvRVZNQWRkcmVzcyhzb3VyY2UudG9rZW5BZGRyZXNzKSxcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogc291cmNlLmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgIGVvYUJhbGFuY2U6IG5ldyBEZWNpbWFsKHNvdXJjZS5hbW91bnQpLFxuICAgICAgICAgICAgICAgIGVwaGVtZXJhbEJhbGFuY2U6IG5ldyBEZWNpbWFsKDApLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nZ2VyJGEuZGVidWcoJ0V4YWN0SU46NCcsIHtcbiAgICAgICAgY290Q29tYmluZWRCYWxhbmNlLFxuICAgICAgICBjb3RTb3VyY2VzLFxuICAgICAgICBicmlkZ2VBc3NldHMsXG4gICAgfSk7XG4gICAgLy8gQWRkIENPVCdzIHRvIGJyaWRnZSBhc3NldCBlb2FCYWxhbmNlXG4gICAgLy8gQ2hlY2sgaWYgc291cmNlIHN3YXAgaXMgcmVxdWlyZWQgKGlmIGFsbCBzb3VyY2UgYmFsYW5jZXMgYXJlIG5vdCBDT1QgY3VycmVuY3lJRClcbiAgICBjb25zdCBpc1NyY1N3YXBSZXF1aXJlZCA9IGNvdFNvdXJjZXMubGVuZ3RoICE9PSBzcmNCYWxhbmNlcy5sZW5ndGg7XG4gICAgLy8gQ2hlY2sgaWYgYnJpZGdlIGlzIHJlcXVpcmVkIChpZiBhbGwgc291cmNlIGJhbGFuY2VzIGFyZSBub3Qgb24gZGVzdGluYXRpb24gY2hhaW4pXG4gICAgY29uc3QgaXNCcmlkZ2VSZXF1aXJlZCA9ICFzcmNCYWxhbmNlcy5ldmVyeSgoYikgPT4gYi5jaGFpbklEID09PSBpbnB1dC50b0NoYWluSWQpO1xuICAgIGxvZ2dlciRhLmRlYnVnKCdFeGFjdElOOjUnLCB7XG4gICAgICAgIGlzU3JjU3dhcFJlcXVpcmVkLFxuICAgICAgICBpc0JyaWRnZVJlcXVpcmVkLFxuICAgIH0pO1xuICAgIGxldCBzb3VyY2VTd2FwcyA9IFtdO1xuICAgIGlmIChpc1NyY1N3YXBSZXF1aXJlZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGxpcXVpZGF0ZUlucHV0SG9sZGluZ3ModXNlckFkZHJlc3NJbkJ5dGVzLCBzcmNCYWxhbmNlcy5tYXAoKGIpID0+ICh7XG4gICAgICAgICAgICBhbW91bnQ6IG11bERlY2ltYWxzKGIuYW1vdW50LCBiLmRlY2ltYWxzKSxcbiAgICAgICAgICAgIGNoYWluSUQ6IG5ldyBPbW5pdmVyc2FsQ2hhaW5JRChiLnVuaXZlcnNlLCBiLmNoYWluSUQpLFxuICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiB0b0J5dGVzKGIudG9rZW5BZGRyZXNzKSxcbiAgICAgICAgICAgIHZhbHVlOiBiLnZhbHVlLFxuICAgICAgICB9KSksIHBhcmFtcy5hZ2dyZWdhdG9ycywgZmVlU3RvcmUuZGF0YS5mZWUuY29sbGVjdGlvbi5tYXAoKGYpID0+ICh7XG4gICAgICAgICAgICBjaGFpbklEOiBjb252ZXJ0VG8zMkJ5dGVzKE51bWJlcihmLmNoYWluSUQpKSxcbiAgICAgICAgICAgIGZlZTogY29udmVydFRvMzJCeXRlcyhCaWdJbnQoZi5mZWUpKSxcbiAgICAgICAgICAgIHRva2VuQWRkcmVzczogY29udmVydFRvMzJCeXRlcyhmLnRva2VuQWRkcmVzcyksXG4gICAgICAgICAgICB1bml2ZXJzZTogZi51bml2ZXJzZSxcbiAgICAgICAgfSkpKTtcbiAgICAgICAgc291cmNlU3dhcHMgPSByZXNwb25zZS5xdW90ZXM7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVN3YXBDcmVhdGlvblRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBzd2FwQ29tYmluZWRCYWxhbmNlID0gbmV3IERlY2ltYWwoMCk7XG4gICAgZm9yIChjb25zdCBzd2FwIG9mIHNvdXJjZVN3YXBzKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dFRva2VuQWRkcmVzcyA9IGNvbnZlcnRUb0VWTUFkZHJlc3Moc3dhcC5yZXEub3V0cHV0VG9rZW4pO1xuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcmFtcy5jaGFpbkxpc3QuZ2V0VG9rZW5CeUFkZHJlc3MoTnVtYmVyKHN3YXAucmVxLmNoYWluLmNoYWluSUQpLCBvdXRwdXRUb2tlbkFkZHJlc3MpO1xuICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvclRva2VuTm90Rm91bmQob3V0cHV0VG9rZW5BZGRyZXNzLCBOdW1iZXIoc3dhcC5yZXEuY2hhaW4uY2hhaW5JRCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyaWRnZUFzc2V0ID0gYnJpZGdlQXNzZXRzLmZpbmQoKGIpID0+IGVxdWFsRm9sZChiLmNvbnRyYWN0QWRkcmVzcywgb3V0cHV0VG9rZW5BZGRyZXNzKSk7XG4gICAgICAgIGNvbnN0IG91dHB1dEFtb3VudEluRGVjaW1hbCA9IGRpdkRlY2ltYWxzKHN3YXAucXVvdGUub3V0cHV0QW1vdW50TWluaW11bSwgdG9rZW4uZGVjaW1hbHMpO1xuICAgICAgICBpZiAoYnJpZGdlQXNzZXQpIHtcbiAgICAgICAgICAgIGJyaWRnZUFzc2V0LmVwaGVtZXJhbEJhbGFuY2UgPSBicmlkZ2VBc3NldC5lcGhlbWVyYWxCYWxhbmNlLmFkZChvdXRwdXRBbW91bnRJbkRlY2ltYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJpZGdlQXNzZXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNoYWluSUQ6IE51bWJlcihzd2FwLnJlcS5jaGFpbi5jaGFpbklEKSxcbiAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IG91dHB1dFRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogdG9rZW4uZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgZW9hQmFsYW5jZTogbmV3IERlY2ltYWwoMCksXG4gICAgICAgICAgICAgICAgZXBoZW1lcmFsQmFsYW5jZTogb3V0cHV0QW1vdW50SW5EZWNpbWFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dhcENvbWJpbmVkQmFsYW5jZSA9IHN3YXBDb21iaW5lZEJhbGFuY2UuYWRkKG91dHB1dEFtb3VudEluRGVjaW1hbCk7XG4gICAgfVxuICAgIGxldCBkc3RTd2FwSW5wdXRBbW91bnRJbkRlY2ltYWwgPSBEZWNpbWFsLmFkZChjb3RDb21iaW5lZEJhbGFuY2UsIHN3YXBDb21iaW5lZEJhbGFuY2UpO1xuICAgIGxvZ2dlciRhLmRlYnVnKCdFeGFjdElOOjYnLCB7XG4gICAgICAgIGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbDogZHN0U3dhcElucHV0QW1vdW50SW5EZWNpbWFsLnRvRml4ZWQoKSxcbiAgICAgICAgYnJpZGdlQXNzZXRzLFxuICAgIH0pO1xuICAgIGxldCBicmlkZ2VJbnB1dCA9IG51bGw7XG4gICAgaWYgKGlzQnJpZGdlUmVxdWlyZWQpIHtcbiAgICAgICAgY29uc3QgbWF4RmVlID0gY2FsY3VsYXRlTWF4QnJpZGdlRmVlcyh7XG4gICAgICAgICAgICBhc3NldHM6IGJyaWRnZUFzc2V0cyxcbiAgICAgICAgICAgIGRzdDoge1xuICAgICAgICAgICAgICAgIGNoYWluSWQ6IGlucHV0LnRvQ2hhaW5JZCxcbiAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGRzdENoYWluQ09UQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogZHN0Q2hhaW5DT1QuZGVjaW1hbHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmVlU3RvcmUsXG4gICAgICAgIH0pO1xuICAgICAgICBkc3RTd2FwSW5wdXRBbW91bnRJbkRlY2ltYWwgPSBkc3RTd2FwSW5wdXRBbW91bnRJbkRlY2ltYWwubWludXMobWF4RmVlKS5tdWwoMC45OCk7XG4gICAgICAgIGxvZ2dlciRhLmRlYnVnKCdFeGFjdElOOjcnLCB7XG4gICAgICAgICAgICBkc3RTd2FwSW5wdXRBbW91bnRJbkRlY2ltYWw6IGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbC50b0ZpeGVkKCksXG4gICAgICAgICAgICBtYXhGZWU6IG1heEZlZS50b0ZpeGVkKCksXG4gICAgICAgIH0pO1xuICAgICAgICBicmlkZ2VJbnB1dCA9IHtcbiAgICAgICAgICAgIGFtb3VudDogZHN0U3dhcElucHV0QW1vdW50SW5EZWNpbWFsLFxuICAgICAgICAgICAgYXNzZXRzOiBicmlkZ2VBc3NldHMsXG4gICAgICAgICAgICBjaGFpbklEOiBpbnB1dC50b0NoYWluSWQsXG4gICAgICAgICAgICBkZWNpbWFsczogZHN0Q2hhaW5DT1QuZGVjaW1hbHMsXG4gICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGNvbnZlcnRUb0VWTUFkZHJlc3MoZHN0Q2hhaW5DT1QudG9rZW5BZGRyZXNzKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbG9nZ2VyJGEuZGVidWcoJ2JlZm9yZUREUzogRXhhY3RJTicsIHtcbiAgICAgICAgZHN0U3dhcElucHV0QW1vdW50SW5EZWNpbWFsOiBkc3RTd2FwSW5wdXRBbW91bnRJbkRlY2ltYWwudG9GaXhlZCgpLFxuICAgIH0pO1xuICAgIGNvbnN0IGdldEREUyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGRkcyA9IHtcbiAgICAgICAgICAgIGFnZ3JlZ2F0b3I6IHBhcmFtcy5hZ2dyZWdhdG9yc1swXSxcbiAgICAgICAgICAgIGlucHV0QW1vdW50OiBkc3RTd2FwSW5wdXRBbW91bnRJbkRlY2ltYWwsXG4gICAgICAgICAgICBvdXRwdXRBbW91bnQ6IG11bERlY2ltYWxzKGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbCwgZHN0Q2hhaW5DT1QuZGVjaW1hbHMpLFxuICAgICAgICAgICAgcXVvdGU6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlciRhLmRlYnVnKCdnZXRERFM6IEV4YWN0SU46IEJlZm9yZScsIHtcbiAgICAgICAgICAgIGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbDogZHN0U3dhcElucHV0QW1vdW50SW5EZWNpbWFsLnRvRml4ZWQoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbCA9IGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbC50b0RQKGRzdENoYWluQ09ULmRlY2ltYWxzLCBEZWNpbWFsLlJPVU5EX0ZMT09SKTtcbiAgICAgICAgLy8gSWYgdG9Ub2tlbkFkZHJlc3MgaXMgbm90IHNhbWUgYXMgY290IHRoZW4gY3JlYXRlIGRzdFN3YXBcbiAgICAgICAgaWYgKCFlcXVhbEZvbGQoaW5wdXQudG9Ub2tlbkFkZHJlc3MsIGRzdENoYWluQ09UQWRkcmVzcykpIHtcbiAgICAgICAgICAgIGRkcyA9IGF3YWl0IGRlc3RpbmF0aW9uU3dhcFdpdGhFeGFjdEluKHVzZXJBZGRyZXNzSW5CeXRlcywgZHN0T21uaXZlcnNhbENoYWluSUQsIG11bERlY2ltYWxzKGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbCwgZHN0Q2hhaW5DT1QuZGVjaW1hbHMpLCBjb252ZXJ0VG8zMkJ5dGVzKGlucHV0LnRvVG9rZW5BZGRyZXNzKSwgcGFyYW1zLmFnZ3JlZ2F0b3JzLCBkc3RDaGFpbkNPVC5jdXJyZW5jeUlEKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgZHN0RU9BVG9FcGhUeCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGhhc0RzdENoYWluQ09USW5JbnB1dCA9IGNvdFNvdXJjZXMuZmluZCgoYykgPT4gZXF1YWxGb2xkKGMudG9rZW5BZGRyZXNzLCBkc3RDaGFpbkNPVEFkZHJlc3MpKTtcbiAgICAgICAgaWYgKGhhc0RzdENoYWluQ09USW5JbnB1dCkge1xuICAgICAgICAgICAgZHN0RU9BVG9FcGhUeCA9IHtcbiAgICAgICAgICAgICAgICBhbW91bnQ6IG11bERlY2ltYWxzKGhhc0RzdENoYWluQ09USW5JbnB1dC5hbW91bnQsIGhhc0RzdENoYWluQ09USW5JbnB1dC5kZWNpbWFscyksXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBoYXNEc3RDaGFpbkNPVEluSW5wdXQudG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIkYS5kZWJ1ZygnRXhhY3RJTjogZ2V0RERTOiBTaW5nbGVTcmNTd2FwOiBBZnRlcicsIHtcbiAgICAgICAgICAgIGRkcyxcbiAgICAgICAgICAgIGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbDogZHN0U3dhcElucHV0QW1vdW50SW5EZWNpbWFsLnRvRml4ZWQoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5kZHMsXG4gICAgICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgICAgICBkc3RDaGFpbkNPVDogZHN0Q2hhaW5DT1QsXG4gICAgICAgICAgICBkc3RFT0FUb0VwaFR4LFxuICAgICAgICAgICAgaW5wdXRBbW91bnRXaXRoQnVmZmVyOiBkc3RTd2FwSW5wdXRBbW91bnRJbkRlY2ltYWwsXG4gICAgICAgICAgICByZXE6IHtcbiAgICAgICAgICAgICAgICBjaGFpbjogZHN0T21uaXZlcnNhbENoYWluSUQsXG4gICAgICAgICAgICAgICAgaW5wdXRUb2tlbjogZHN0Q2hhaW5DT1QudG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgIG91dHB1dFRva2VuOiB0b0J5dGVzKGlucHV0LnRvVG9rZW5BZGRyZXNzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBkZXN0aW5hdGlvblN3YXAgPSBhd2FpdCBnZXRERFMoKTtcbiAgICBsb2dnZXIkYS5kZWJ1ZygnZ2V0U3dhcFJvdXRlOiBFeGFjdElOOiBBZnRlcicsIHtcbiAgICAgICAgZGVzdGluYXRpb25Td2FwLFxuICAgICAgICBkc3RTd2FwSW5wdXRBbW91bnRJbkRlY2ltYWw6IGRzdFN3YXBJbnB1dEFtb3VudEluRGVjaW1hbC50b0ZpeGVkKCksXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWdncmVnYXRvcnM6IHBhcmFtcy5hZ2dyZWdhdG9ycyxcbiAgICAgICAgYXNzZXRzVXNlZCxcbiAgICAgICAgYmFsYW5jZXMsXG4gICAgICAgIGJyaWRnZUlucHV0LFxuICAgICAgICBjb3RTeW1ib2wsXG4gICAgICAgIGRlc3RpbmF0aW9uU3dhcCxcbiAgICAgICAgZ2V0RERTLFxuICAgICAgICBvcmFjbGVQcmljZXMsXG4gICAgICAgIHNvdXJjZVN3YXBDcmVhdGlvblRpbWUsXG4gICAgICAgIHNvdXJjZVN3YXBzLFxuICAgIH07XG59O1xuXG5jb25zdCBsb2dnZXIkOSA9IGdldExvZ2dlcigpO1xuY2xhc3MgQmFzZVJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5zdGVwcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1aWxkSW50ZW50ID0gYXN5bmMgKHNvdXJjZUNoYWlucyA9IFtdKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLnRpbWUoJ3Byb2Nlc3M6cHJlSW50ZW50U3RlcHMnKTtcbiAgICAgICAgICAgIGNvbnNvbGUudGltZSgncHJlSW50ZW50U3RlcHM6QVBJJyk7XG4gICAgICAgICAgICBjb25zdCBbc2ltdWxhdGlvbiwgW2JhbGFuY2VzLCBvcmFjbGVQcmljZXMsIGZlZVN0b3JlXV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5zaW11bGF0ZVR4KCksXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICBnZXRCYWxhbmNlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrSGludDogdGhpcy5pbnB1dC5vcHRpb25zLm5ldHdvcmtDb25maWcuTkVUV09SS19ISU5ULFxuICAgICAgICAgICAgICAgICAgICAgICAgdnNjRG9tYWluOiB0aGlzLmlucHV0Lm9wdGlvbnMubmV0d29ya0NvbmZpZy5WU0NfRE9NQUlOLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZtQWRkcmVzczogdGhpcy5pbnB1dC5ldm0uYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluTGlzdDogdGhpcy5jaGFpbkxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWVsQWRkcmVzczogdGhpcy5pbnB1dC5mdWVsPy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hQcmljZU9yYWNsZSh0aGlzLmlucHV0Lm9wdGlvbnMubmV0d29ya0NvbmZpZy5HUlBDX1VSTCksXG4gICAgICAgICAgICAgICAgICAgIGdldEZlZVN0b3JlKHRoaXMuaW5wdXQub3B0aW9ucy5uZXR3b3JrQ29uZmlnLkdSUENfVVJMKSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gaWYgc2ltdWxhdGlvbiBpcyBudWxsLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBub3QgYSBzdXBwb3J0ZWQgdG9rZW4gdHJhbnNmZXIsIHNvIHNraXBcbiAgICAgICAgICAgIGlmICghc2ltdWxhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUudGltZUVuZCgncHJlSW50ZW50U3RlcHM6QVBJJyk7XG4gICAgICAgICAgICBsb2dnZXIkOS5kZWJ1ZygnU3RlcCAxOicsIHtcbiAgICAgICAgICAgICAgICBiYWxhbmNlcyxcbiAgICAgICAgICAgICAgICBmZWVTdG9yZSxcbiAgICAgICAgICAgICAgICBvcmFjbGVQcmljZXMsXG4gICAgICAgICAgICAgICAgc2ltdWxhdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS50aW1lKCdwcmVJbnRlbnRTdGVwczogUGFyc2UnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYXNzZXRzIH0gPSBiYWxhbmNlcztcbiAgICAgICAgICAgIC8vIFN0ZXAgMjogcGFyc2Ugc2ltdWxhdGlvbiByZXN1bHRzXG4gICAgICAgICAgICBjb25zdCB1c2VyQXNzZXRzID0gbmV3IFVzZXJBc3NldHMoYXNzZXRzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYW1vdW50LCBnYXMsIGlzSW50ZW50UmVxdWlyZWQgfSA9IHRoaXMucGFyc2VTaW11bGF0aW9uKHtcbiAgICAgICAgICAgICAgICBhc3NldHM6IHVzZXJBc3NldHMsXG4gICAgICAgICAgICAgICAgc2ltdWxhdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS50aW1lRW5kKCdwcmVJbnRlbnRTdGVwczogUGFyc2UnKTtcbiAgICAgICAgICAgIGlmICghaXNJbnRlbnRSZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUudGltZSgncHJlSW50ZW50U3RlcHM6IENhbGN1bGF0ZUdhcycpO1xuICAgICAgICAgICAgY29uc3QgZ2FzSW5Ub2tlbiA9IGNvbnZlcnRHYXNUb1Rva2VuKHNpbXVsYXRpb24udG9rZW4sIG9yYWNsZVByaWNlcywgdGhpcy5pbnB1dC5jaGFpbi5pZCwgdGhpcy5pbnB1dC5jaGFpbi51bml2ZXJzZSwgZ2FzKTtcbiAgICAgICAgICAgIGNvbnNvbGUudGltZUVuZCgncHJlSW50ZW50U3RlcHM6IENhbGN1bGF0ZUdhcycpO1xuICAgICAgICAgICAgbG9nZ2VyJDkuZGVidWcoJ3ByZUludGVudDoxJywge1xuICAgICAgICAgICAgICAgIGdhc0luTmF0aXZlOiBnYXMudG9GaXhlZCgpLFxuICAgICAgICAgICAgICAgIGdhc0luVG9rZW46IGdhc0luVG9rZW4udG9GaXhlZCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTdGVwIDQ6IGNyZWF0ZSBpbnRlbnRcbiAgICAgICAgICAgIGNvbnNvbGUudGltZSgncHJlSW50ZW50U3RlcHM6IENyZWF0ZUludGVudCcpO1xuICAgICAgICAgICAgY29uc3QgaW50ZW50ID0gdGhpcy5jcmVhdGVJbnRlbnQoe1xuICAgICAgICAgICAgICAgIGFtb3VudCxcbiAgICAgICAgICAgICAgICBhc3NldHM6IHVzZXJBc3NldHMsXG4gICAgICAgICAgICAgICAgZmVlU3RvcmUsXG4gICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgIGdhc0luVG9rZW4sXG4gICAgICAgICAgICAgICAgc291cmNlQ2hhaW5zLFxuICAgICAgICAgICAgICAgIHRva2VuOiBzaW11bGF0aW9uLnRva2VuLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ3ByZUludGVudFN0ZXBzOiBDcmVhdGVJbnRlbnQnKTtcbiAgICAgICAgICAgIGNvbnNvbGUudGltZUVuZCgncHJvY2VzczpwcmVJbnRlbnRTdGVwcycpO1xuICAgICAgICAgICAgcmV0dXJuIHsgaW50ZW50LCB0b2tlbjogc2ltdWxhdGlvbi50b2tlbiB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3MgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpID0gYXdhaXQgdGhpcy5idWlsZEludGVudCh0aGlzLmlucHV0Lm9wdGlvbnMuc291cmNlQ2hhaW5zKTtcbiAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbnRlbnQgPSBpLmludGVudDtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gaS50b2tlbjtcbiAgICAgICAgICAgIGlmIChpbnRlbnQuaXNBdmFpbGFibGVCYWxhbmNlSW5zdWZmaWNpZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JJbnN1ZmZpY2llbnRCYWxhbmNlJDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgc3RlcHMgbGlrZSBhIGNyYXp5IHBlcnNvbiB0byBjcmVhdGUgYW5vdGhlciBvbmUgYWdhaW5cbiAgICAgICAgICAgIGNvbnN0IGFsbG93YW5jZXMgPSBhd2FpdCBnZXRBbGxvd2FuY2VzKGludGVudC5hbGxTb3VyY2VzLCB0aGlzLmlucHV0LmV2bS5hZGRyZXNzLCB0aGlzLmlucHV0LmNoYWluTGlzdCk7XG4gICAgICAgICAgICBsZXQgdW5hbGxvd2VkU291cmNlcyA9IHRoaXMuZ2V0VW5hbGxvd2VkU291cmNlcyhpbnRlbnQsIGFsbG93YW5jZXMpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVFeHBlY3RlZFN0ZXBzKGludGVudCwgdW5hbGxvd2VkU291cmNlcyk7XG4gICAgICAgICAgICBsZXQgYWNjZXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHJlZnJlc2ggPSBhc3luYyAoc291cmNlQ2hhaW5zKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFjY2VwdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciQ5Lndhcm4oJ0ludGVudCByZWZyZXNoIGNhbGxlZCBhZnRlciBhY2NlcHRhbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0SW50ZW50KGludGVudCwgdG9rZW4sIHRoaXMuY2hhaW5MaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IGF3YWl0IHRoaXMuYnVpbGRJbnRlbnQoc291cmNlQ2hhaW5zKTtcbiAgICAgICAgICAgICAgICBpbnRlbnQgPSBpLmludGVudDtcbiAgICAgICAgICAgICAgICBsb2dnZXIkOS5kZWJ1ZygnaW4gcmVmcmVzaCcsIHtcbiAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgaW50ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlbnQuaXNBdmFpbGFibGVCYWxhbmNlSW5zdWZmaWNpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9ySW5zdWZmaWNpZW50QmFsYW5jZSQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmFsbG93ZWRTb3VyY2VzID0gdGhpcy5nZXRVbmFsbG93ZWRTb3VyY2VzKGludGVudCwgYWxsb3dhbmNlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVFeHBlY3RlZFN0ZXBzKGludGVudCwgdW5hbGxvd2VkU291cmNlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRJbnRlbnQoaW50ZW50LCB0b2tlbiwgdGhpcy5jaGFpbkxpc3QpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGludGVudCBhY2NlcHRhbmNlIGhvb2tcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvdyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXB0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgnVXNlciBhbGxvd2VkIGludGVudCcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVueSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChFcnJvclVzZXJEZW5pZWRJbnRlbnQkMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Lmhvb2tzLm9uSW50ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3csXG4gICAgICAgICAgICAgICAgICAgIGRlbnksXG4gICAgICAgICAgICAgICAgICAgIGludGVudDogY29udmVydEludGVudChpbnRlbnQsIHRva2VuLCB0aGlzLmNoYWluTGlzdCksXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2gsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWFya1N0ZXBEb25lKElOVEVOVF9BQ0NFUFRFRCk7XG4gICAgICAgICAgICBjb25zb2xlLnRpbWUoJ3Byb2Nlc3M6QWxsb3dhbmNlSG9vaycpO1xuICAgICAgICAgICAgLy8gU3RlcCA1OiBzZXQgYWxsb3dhbmNlIGlmIG5vdCBzZXRcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud2FpdEZvck9uQWxsb3dhbmNlSG9vayh1bmFsbG93ZWRTb3VyY2VzKTtcbiAgICAgICAgICAgIGNvbnNvbGUudGltZUVuZCgncHJvY2VzczpBbGxvd2FuY2VIb29rJyk7XG4gICAgICAgICAgICAvLyBGSVhNRTogQWRkIHNob3dpbmcgaW50ZW50IGFnYWluIGlmIHByaWNlcyBjaGFuZ2U/XG4gICAgICAgICAgICAvLyBTdGVwIDY6IHByb2Nlc3MgaW50ZW50XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm9jZXNzSW50ZW50KGludGVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFya1N0ZXBEb25lID0gKHN0ZXAsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLnN0ZXBzLmZpbmQoKHMpID0+IHMudHlwZUlEID09PSBzdGVwLnR5cGVJRCk7XG4gICAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQub3B0aW9ucy5lbWl0KCdzdGVwX2NvbXBsZXRlJywge1xuICAgICAgICAgICAgICAgICAgICAuLi5zLFxuICAgICAgICAgICAgICAgICAgICAuLi4oZGF0YSA/IHsgZGF0YSB9IDoge30pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYWluTGlzdCA9IHRoaXMuaW5wdXQuY2hhaW5MaXN0O1xuICAgIH1cbiAgICBnZXRVbmFsbG93ZWRTb3VyY2VzKGludGVudCwgYWxsb3dhbmNlcykge1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBpbnRlbnQuc291cmNlcykge1xuICAgICAgICAgICAgaWYgKHMuY2hhaW5JRCA9PT0gaW50ZW50LmRlc3RpbmF0aW9uLmNoYWluSUQgfHxcbiAgICAgICAgICAgICAgICBpc05hdGl2ZUFkZHJlc3MkMShzLnVuaXZlcnNlLCBzLnRva2VuQ29udHJhY3QpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuY2hhaW5MaXN0LmdldENoYWluQnlJRChzLmNoYWluSUQpO1xuICAgICAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hhaW4gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmNoYWluTGlzdC5nZXRUb2tlbkJ5QWRkcmVzcyhzLmNoYWluSUQsIHMudG9rZW5Db250cmFjdCk7XG4gICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b2tlbiBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1aXJlZEFsbG93YW5jZSA9IG11bERlY2ltYWxzKHMuYW1vdW50LCB0b2tlbi5kZWNpbWFscyk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QWxsb3dhbmNlID0gYWxsb3dhbmNlc1tzLmNoYWluSURdID8/IDBuO1xuICAgICAgICAgICAgbG9nZ2VyJDkuZGVidWcoJ2dldFVuYWxsb3dlZFNvdXJjZXM6MScsIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50QWxsb3dhbmNlOiBjdXJyZW50QWxsb3dhbmNlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcmVxdWlyZWRBbGxvd2FuY2U6IHJlcXVpcmVkQWxsb3dhbmNlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlZEFsbG93YW5jZSA+IGN1cnJlbnRBbGxvd2FuY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkID0ge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd2FuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQ6IGN1cnJlbnRBbGxvd2FuY2UudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IHJlcXVpcmVkQWxsb3dhbmNlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNoYWluOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dvOiBjaGFpbi5jdXN0b20uaWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGNoYWluLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHRva2VuLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiB0b2tlbi5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ286IHRva2VuLmxvZ28gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b2tlbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiB0b2tlbi5zeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzb3VyY2VzLnB1c2goZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZXM7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NJbnRlbnQoaW50ZW50KSB7XG4gICAgICAgIGxvZ2dlciQ5LmRlYnVnKCdpbnRlbnQnLCB7IGludGVudCB9KTtcbiAgICAgICAgY29uc3QgeyBleHBsb3JlclVSTCwgaWQsIHJlcXVlc3RIYXNoLCB3YWl0Rm9yRG91YmxlQ2hlY2tUeCB9ID0gYXdhaXQgdGhpcy5wcm9jZXNzUkZGKGludGVudCk7XG4gICAgICAgIHN0b3JlSW50ZW50SGFzaFRvU3RvcmUodGhpcy5pbnB1dC5ldm0uYWRkcmVzcywgaWQudG9OdW1iZXIoKSk7XG4gICAgICAgIGF3YWl0IHRoaXMud2FpdEZvckZpbGwocmVxdWVzdEhhc2gsIGlkLCB3YWl0Rm9yRG91YmxlQ2hlY2tUeCk7XG4gICAgICAgIHJlbW92ZUludGVudEhhc2hGcm9tU3RvcmUodGhpcy5pbnB1dC5ldm0uYWRkcmVzcywgaWQpO1xuICAgICAgICB0aGlzLm1hcmtTdGVwRG9uZShJTlRFTlRfRlVMRklMTEVEKTtcbiAgICAgICAgcmV0dXJuIHsgZXhwbG9yZXJVUkwgfTtcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc1JGRihpbnRlbnQpIHtcbiAgICAgICAgY29uc3QgeyBkZXN0aW5hdGlvbnMsIHNvdXJjZXMsIHVuaXZlcnNlcyB9ID0gZ2V0U291cmNlc0FuZERlc3RpbmF0aW9uc0ZvclJGRihpbnRlbnQsIHRoaXMuaW5wdXQuY2hhaW5MaXN0LCB0aGlzLmRlc3RpbmF0aW9uVW5pdmVyc2UpO1xuICAgICAgICBjb25zdCBwYXJ0aWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdW5pdmVyc2Ugb2YgdW5pdmVyc2VzKSB7XG4gICAgICAgICAgICBpZiAodW5pdmVyc2UgPT09IFVuaXZlcnNlLkVUSEVSRVVNKSB7XG4gICAgICAgICAgICAgICAgcGFydGllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogY29udmVydFRvMzJCeXRlc0hleCh0aGlzLmlucHV0LmV2bS5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgdW5pdmVyc2U6IHVuaXZlcnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuaXZlcnNlID09PSBVbml2ZXJzZS5GVUVMKSB7XG4gICAgICAgICAgICAgICAgcGFydGllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogY29udmVydFRvMzJCeXRlc0hleCh0aGlzLmlucHV0LmZ1ZWwuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgICAgIHVuaXZlcnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvZ2dlciQ5LmRlYnVnKCdwcm9jZXNzUkZGOjEnLCB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbnMsXG4gICAgICAgICAgICBwYXJ0aWVzLFxuICAgICAgICAgICAgc291cmNlcyxcbiAgICAgICAgICAgIHVuaXZlcnNlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9tbml2ZXJzYWxSZmYgPSBuZXcgT21uaXZlcnNhbFJGRih7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbkNoYWluSUQ6IGNvbnZlcnRUbzMyQnl0ZXMkMShpbnRlbnQuZGVzdGluYXRpb24uY2hhaW5JRCksXG4gICAgICAgICAgICBkZXN0aW5hdGlvbnM6IGRlc3RpbmF0aW9ucy5tYXAoKGRlc3QpID0+ICh7XG4gICAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiB0b0J5dGVzKGRlc3QudG9rZW5BZGRyZXNzKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdG9CeXRlcyhkZXN0LnZhbHVlKSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uVW5pdmVyc2U6IGludGVudC5kZXN0aW5hdGlvbi51bml2ZXJzZSxcbiAgICAgICAgICAgIGV4cGlyeTogTG9uZy5mcm9tU3RyaW5nKChCaWdJbnQoRGF0ZS5ub3coKSArIElOVEVOVF9FWFBJUlkpIC8gMTAwMG4pLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgbm9uY2U6IHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSksXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBzaWduYXR1cmVEYXRhOiBwYXJ0aWVzLm1hcCgocCkgPT4gKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0b0J5dGVzKHAuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgdW5pdmVyc2U6IHAudW5pdmVyc2UsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBzb3VyY2VzOiBzb3VyY2VzLm1hcCgoc291cmNlKSA9PiAoe1xuICAgICAgICAgICAgICAgIGNoYWluSUQ6IGNvbnZlcnRUbzMyQnl0ZXMkMShzb3VyY2UuY2hhaW5JRCksXG4gICAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiBjb252ZXJ0VG8zMkJ5dGVzJDEoc291cmNlLnRva2VuQWRkcmVzcyksXG4gICAgICAgICAgICAgICAgdW5pdmVyc2U6IHNvdXJjZS51bml2ZXJzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdG9CeXRlcyhzb3VyY2UudmFsdWUpLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlRGF0YSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHVuaXZlcnNlIG9mIHVuaXZlcnNlcykge1xuICAgICAgICAgICAgaWYgKHVuaXZlcnNlID09PSBVbml2ZXJzZS5FVEhFUkVVTSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVxdWVzdEhhc2gsIHNpZ25hdHVyZSB9ID0gYXdhaXQgY3JlYXRlUmVxdWVzdEVWTVNpZ25hdHVyZShvbW5pdmVyc2FsUmZmLmFzRVZNUkZGKCksIHRoaXMuaW5wdXQuZXZtLmFkZHJlc3MsIHRoaXMuaW5wdXQuZXZtLmNsaWVudCk7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogY29udmVydFRvMzJCeXRlcyQxKHRoaXMuaW5wdXQuZXZtLmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFzaCxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICB1bml2ZXJzZTogVW5pdmVyc2UuRVRIRVJFVU0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5pdmVyc2UgPT09IFVuaXZlcnNlLkZVRUwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5wdXQuZnVlbD8uYWRkcmVzcyB8fFxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pbnB1dC5mdWVsPy5wcm92aWRlciB8fFxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pbnB1dC5mdWVsPy5jb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDkuZXJyb3IoJ3VuaXZlcnNlIGhhcyBmdWVsIGJ1dCBub3QgZXhwZWN0ZWQgaW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdWVsSW5wdXQ6IHRoaXMuaW5wdXQuZnVlbCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5pdmVyc2UgaGFzIGZ1ZWwgYnV0IG5vdCBleHBlY3RlZCBpbnB1dCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlcXVlc3RIYXNoLCBzaWduYXR1cmUgfSA9IGF3YWl0IGNyZWF0ZVJlcXVlc3RGdWVsU2lnbmF0dXJlKHRoaXMuaW5wdXQuY2hhaW5MaXN0LmdldFZhdWx0Q29udHJhY3RBZGRyZXNzKENIQUlOX0lEUy5mdWVsLm1haW5uZXQpLCB0aGlzLmlucHV0LmZ1ZWwucHJvdmlkZXIsIHRoaXMuaW5wdXQuZnVlbC5jb25uZWN0b3IsIG9tbml2ZXJzYWxSZmYuYXNGdWVsUkZGKCkpO1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZURhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRvQnl0ZXModGhpcy5pbnB1dC5mdWVsLmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFzaCxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICB1bml2ZXJzZTogVW5pdmVyc2UuRlVFTCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIkOS5kZWJ1ZygncHJvY2Vzc1JGRjoyJywgeyBvbW5pdmVyc2FsUmZmLCBzaWduYXR1cmVEYXRhIH0pO1xuICAgICAgICB0aGlzLm1hcmtTdGVwRG9uZShJTlRFTlRfSEFTSF9TSUdORUQpO1xuICAgICAgICBjb25zdCBjb3Ntb3NXYWxsZXRBZGRyZXNzID0gKGF3YWl0IHRoaXMuaW5wdXQuY29zbW9zV2FsbGV0LmdldEFjY291bnRzKCkpWzBdLmFkZHJlc3M7XG4gICAgICAgIGNvbnN0IG1zZ0Jhc2ljQ29zbW9zID0gTXNnQ3JlYXRlUmVxdWVzdEZvckZ1bmRzLmNyZWF0ZSh7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbkNoYWluSUQ6IG9tbml2ZXJzYWxSZmYucHJvdG9idWZSRkYuZGVzdGluYXRpb25DaGFpbklELFxuICAgICAgICAgICAgZGVzdGluYXRpb25zOiBvbW5pdmVyc2FsUmZmLnByb3RvYnVmUkZGLmRlc3RpbmF0aW9ucyxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uVW5pdmVyc2U6IG9tbml2ZXJzYWxSZmYucHJvdG9idWZSRkYuZGVzdGluYXRpb25Vbml2ZXJzZSxcbiAgICAgICAgICAgIGV4cGlyeTogb21uaXZlcnNhbFJmZi5wcm90b2J1ZlJGRi5leHBpcnksXG4gICAgICAgICAgICBub25jZTogb21uaXZlcnNhbFJmZi5wcm90b2J1ZlJGRi5ub25jZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZURhdGE6IHNpZ25hdHVyZURhdGEubWFwKChzKSA9PiAoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHMuc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIHVuaXZlcnNlOiBzLnVuaXZlcnNlLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgc291cmNlczogb21uaXZlcnNhbFJmZi5wcm90b2J1ZlJGRi5zb3VyY2VzLFxuICAgICAgICAgICAgdXNlcjogY29zbW9zV2FsbGV0QWRkcmVzcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ2dlciQ5LmRlYnVnKCdwcm9jZXNzUkZGOjMnLCB7IG1zZ0Jhc2ljQ29zbW9zIH0pO1xuICAgICAgICBjb25zdCBpbnRlbnRJRCA9IGF3YWl0IGNvc21vc0NyZWF0ZVJGRiQxKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGNvc21vc1dhbGxldEFkZHJlc3MsXG4gICAgICAgICAgICBjb3Ntb3NVUkw6IHRoaXMuaW5wdXQub3B0aW9ucy5uZXR3b3JrQ29uZmlnLkNPU01PU19VUkwsXG4gICAgICAgICAgICBtc2c6IG1zZ0Jhc2ljQ29zbW9zLFxuICAgICAgICAgICAgd2FsbGV0OiB0aGlzLmlucHV0LmNvc21vc1dhbGxldCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGV4cGxvcmVyVVJMID0gZ2V0RXhwbG9yZXJVUkwodGhpcy5pbnB1dC5vcHRpb25zLm5ldHdvcmtDb25maWcuRVhQTE9SRVJfVVJMLCBpbnRlbnRJRCk7XG4gICAgICAgIHRoaXMubWFya1N0ZXBEb25lKElOVEVOVF9TVUJNSVRURUQsIHtcbiAgICAgICAgICAgIGV4cGxvcmVyVVJMLFxuICAgICAgICAgICAgaW50ZW50SUQ6IGludGVudElELnRvTnVtYmVyKCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b2tlbkNvbGxlY3Rpb25zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2ksIHNdIG9mIHNvdXJjZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoIWlzTmF0aXZlQWRkcmVzcyQxKHMudW5pdmVyc2UsIHMudG9rZW5BZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHRva2VuQ29sbGVjdGlvbnMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldm1EZXBvc2l0cyA9IFtdO1xuICAgICAgICBjb25zdCBmdWVsRGVwb3NpdHMgPSBbXTtcbiAgICAgICAgY29uc3QgZXZtU2lnbmF0dXJlRGF0YSA9IHNpZ25hdHVyZURhdGEuZmluZCgoZCkgPT4gZC51bml2ZXJzZSA9PT0gVW5pdmVyc2UuRVRIRVJFVU0pO1xuICAgICAgICBpZiAoIWV2bVNpZ25hdHVyZURhdGEgJiYgdW5pdmVyc2VzLmhhcyhVbml2ZXJzZS5FVEhFUkVVTSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXRoZXJldW0gaW4gdW5pdmVyc2UgbGlzdCBidXQgbm8gc2lnbmF0dXJlIGRhdGEgcHJlc2VudCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1ZWxTaWduYXR1cmVEYXRhID0gc2lnbmF0dXJlRGF0YS5maW5kKChkKSA9PiBkLnVuaXZlcnNlID09PSBVbml2ZXJzZS5GVUVMKTtcbiAgICAgICAgaWYgKCFmdWVsU2lnbmF0dXJlRGF0YSAmJiB1bml2ZXJzZXMuaGFzKFVuaXZlcnNlLkZVRUwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1ZWwgaW4gdW5pdmVyc2UgbGlzdCBidXQgbm8gc2lnbmF0dXJlIGRhdGEgcHJlc2VudCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvdWJsZUNoZWNrVHhzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2ksIHNdIG9mIHNvdXJjZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuaW5wdXQuY2hhaW5MaXN0LmdldENoYWluQnlJRChOdW1iZXIocy5jaGFpbklEKSk7XG4gICAgICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGFpbiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzLnVuaXZlcnNlID09PSBVbml2ZXJzZS5GVUVMKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlucHV0LmZ1ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdWVsIGlzIGludm9sdmVkIGJ1dCBubyBhc3NvY2lhdGVkIGRhdGEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IG5ldyBBY2NvdW50KHRoaXMuaW5wdXQuZnVlbC5hZGRyZXNzLCB0aGlzLmlucHV0LmZ1ZWwucHJvdmlkZXIsIHRoaXMuaW5wdXQuZnVlbC5jb25uZWN0b3IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhdWx0ID0gbmV3IEFyY2FuYVZhdWx0KHRoaXMuY2hhaW5MaXN0LmdldFZhdWx0Q29udHJhY3RBZGRyZXNzKENIQUlOX0lEUy5mdWVsLm1haW5uZXQpLCBhY2NvdW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHZhdWx0LmZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAuZGVwb3NpdChvbW5pdmVyc2FsUmZmLmFzRnVlbFJGRigpLCBoZXhsaWZ5KGZ1ZWxTaWduYXR1cmVEYXRhLnNpZ25hdHVyZSksIGkpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBuZXcgQk4ocy52YWx1ZS50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0SWQ6IHMudG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrU3RlcERvbmUoSU5URU5UX0RFUE9TSVRfUkVRKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgZnVlbERlcG9zaXRzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHhSZXN1bHQgPSBhd2FpdCB0eC53YWl0Rm9yUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciQ5LmRlYnVnKCdQb3N0SW50ZW50U3VibWlzc2lvbjogRnVlbCBkZXBvc2l0IHJlc3VsdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4UmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4UmVzdWx0LnRyYW5zYWN0aW9uUmVzdWx0LmlzU3RhdHVzRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdWVsIGRlcG9zaXQgZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHMudW5pdmVyc2UgPT09IFVuaXZlcnNlLkVUSEVSRVVNICYmIGlzTmF0aXZlQWRkcmVzcyQxKHMudW5pdmVyc2UsIHMudG9rZW5BZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluID0gdGhpcy5pbnB1dC5jaGFpbkxpc3QuZ2V0Q2hhaW5CeUlEKE51bWJlcihzLmNoYWluSUQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hhaW4gbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHN3aXRjaENoYWluKHRoaXMuaW5wdXQuZXZtLmNsaWVudCwgY2hhaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1YmxpY0NsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudFdpdGhGYWxsYmFjayhjaGFpbik7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXF1ZXN0IH0gPSBhd2FpdCBwdWJsaWNDbGllbnQuc2ltdWxhdGVDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgICAgIGFiaTogRVZNVmF1bHRBQkksXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6IHRoaXMuaW5wdXQuZXZtLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuaW5wdXQuY2hhaW5MaXN0LmdldFZhdWx0Q29udHJhY3RBZGRyZXNzKGNoYWluLmlkKSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW29tbml2ZXJzYWxSZmYuYXNFVk1SRkYoKSwgdG9IZXgoZXZtU2lnbmF0dXJlRGF0YS5zaWduYXR1cmUpLCBCaWdJbnQoaSldLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ2RlcG9zaXQnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcy52YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5pbnB1dC5ldm0uY2xpZW50LndyaXRlQ29udHJhY3QocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrU3RlcERvbmUoSU5URU5UX0RFUE9TSVRfUkVRKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgZXZtRGVwb3NpdHMucHVzaCh3YWl0Rm9yVHhSZWNlaXB0KGhhc2gsIHB1YmxpY0NsaWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG91YmxlQ2hlY2tUeHMucHVzaChjcmVhdGVEZXBvc2l0RG91YmxlQ2hlY2tUeChjb252ZXJ0VG8zMkJ5dGVzJDEoY2hhaW4uaWQpLCB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogY29zbW9zV2FsbGV0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICB3YWxsZXQ6IHRoaXMuaW5wdXQuY29zbW9zV2FsbGV0LFxuICAgICAgICAgICAgfSwgaW50ZW50SUQsIHRoaXMuaW5wdXQub3B0aW9ucy5uZXR3b3JrQ29uZmlnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2bURlcG9zaXRzLmxlbmd0aCB8fCBmdWVsRGVwb3NpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbUHJvbWlzZS5hbGwoZXZtRGVwb3NpdHMpLCBQcm9taXNlLmFsbChmdWVsRGVwb3NpdHMpXSk7XG4gICAgICAgICAgICB0aGlzLm1hcmtTdGVwRG9uZShJTlRFTlRfREVQT1NJVFNfQ09ORklSTUVEKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIkOS5kZWJ1ZygnUG9zdEludGVudFN1Ym1pc3Npb246IEludGVudCBJRCcsIHtcbiAgICAgICAgICAgIGlkOiBpbnRlbnRJRC50b051bWJlcigpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRva2VuQ29sbGVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbG9nZ2VyJDkuZGVidWcoJ3Byb2Nlc3NSRkYnLCB7XG4gICAgICAgICAgICAgICAgaW50ZW50SUQ6IGludGVudElELnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ2dvaW5nIHRvIGNyZWF0ZSBSRkYnLFxuICAgICAgICAgICAgICAgIHRva2VuQ29sbGVjdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHZzY0NyZWF0ZVJGRih0aGlzLmlucHV0Lm9wdGlvbnMubmV0d29ya0NvbmZpZy5WU0NfRE9NQUlOLCBpbnRlbnRJRCwgdGhpcy5tYXJrU3RlcERvbmUsIHRva2VuQ29sbGVjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyJDkuZGVidWcoJ3Byb2Nlc3NSRkYnLCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ2dvaW5nIHRvIHB1Ymxpc2ggUkZGJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgdnNjUHVibGlzaFJGRih0aGlzLmlucHV0Lm9wdGlvbnMubmV0d29ya0NvbmZpZy5WU0NfRE9NQUlOLCBpbnRlbnRJRCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25TaWdEYXRhID0gc2lnbmF0dXJlRGF0YS5maW5kKChzKSA9PiBzLnVuaXZlcnNlID09PSBpbnRlbnQuZGVzdGluYXRpb24udW5pdmVyc2UpO1xuICAgICAgICBpZiAoIWRlc3RpbmF0aW9uU2lnRGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1ZXN0SGFzaCBub3QgZm91bmQgZm9yIGRlc3RpbmF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cGxvcmVyVVJMLFxuICAgICAgICAgICAgaWQ6IGludGVudElELFxuICAgICAgICAgICAgcmVxdWVzdEhhc2g6IGRlc3RpbmF0aW9uU2lnRGF0YS5yZXF1ZXN0SGFzaCxcbiAgICAgICAgICAgIHdhaXRGb3JEb3VibGVDaGVja1R4OiB3YWl0Rm9yRG91YmxlQ2hlY2tUeChkb3VibGVDaGVja1R4cyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHNldEFsbG93YW5jZXMoaW5wdXQpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDaGFpbiA9IHRoaXMuaW5wdXQuY2hhaW4uaWQ7XG4gICAgICAgIGxvZ2dlciQ5LmRlYnVnKCdzZXRBbGxvd2FuY2VzJywgeyBvcmlnaW5hbENoYWluIH0pO1xuICAgICAgICBjb25zdCBzcG9uc29yZWRBcHByb3ZhbFBhcmFtcyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2YgaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuY2hhaW5MaXN0LmdldENoYWluQnlJRChzb3VyY2UuY2hhaW5JRCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYWluIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50V2l0aEZhbGxiYWNrKGNoYWluKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YyA9IHRoaXMuaW5wdXQuY2hhaW5MaXN0LmdldFZhdWx0Q29udHJhY3RBZGRyZXNzKGNoYWluLmlkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gbmV3IE9tbml2ZXJzYWxDaGFpbklEKFVuaXZlcnNlLkVUSEVSRVVNLCBzb3VyY2UuY2hhaW5JRCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhaW5EYXR1bSA9IENoYWluZGF0YU1hcC5nZXQoY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFpbkRhdHVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhaW4gZGF0YSBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVuY3kgPSBjaGFpbkRhdHVtLkN1cnJlbmN5TWFwLmdldChjb252ZXJ0VG8zMkJ5dGVzJDEoc291cmNlLnRva2VuQ29udHJhY3QpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVuY3kgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHN3aXRjaENoYWluKHRoaXMuaW5wdXQuZXZtLmNsaWVudCwgY2hhaW4pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeS5wZXJtaXRWYXJpYW50ID09PSBQZXJtaXRWYXJpYW50LlVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGggPSBhd2FpdCB0aGlzLmlucHV0LmV2bS5jbGllbnQud3JpdGVDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmk6IEVSQzIwQUJJLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogdGhpcy5pbnB1dC5ldm0uYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHNvdXJjZS50b2tlbkNvbnRyYWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3ZjLCBCaWdJbnQoc291cmNlLmFtb3VudCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdhcHByb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFya1N0ZXBEb25lKEFMTE9XQU5DRV9BUFBST1ZBTF9SRVEoc291cmNlLmNoYWluSUQpKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHVibGljQ2xpZW50LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogaCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFya1N0ZXBEb25lKEFMTE9XQU5DRV9BUFBST1ZBTF9NSU5FRChzb3VyY2UuY2hhaW5JRCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuaW5wdXQuZXZtLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnanNvbi1ycGMnLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWQgPSBwYXJzZVNpZ25hdHVyZShhd2FpdCBzaWduUGVybWl0Rm9yQWRkcmVzc0FuZFZhbHVlKGN1cnJlbmN5LCB0aGlzLmlucHV0LmV2bS5jbGllbnQsIHB1YmxpY0NsaWVudCwgYWNjb3VudCwgdmMsIHNvdXJjZS5hbW91bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrU3RlcERvbmUoQUxMT1dBTkNFX0FQUFJPVkFMX1JFUShzb3VyY2UuY2hhaW5JRCkpO1xuICAgICAgICAgICAgICAgICAgICBzcG9uc29yZWRBcHByb3ZhbFBhcmFtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGNvbnZlcnRUbzMyQnl0ZXMkMShhY2NvdW50LmFkZHJlc3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5faWQ6IGNoYWluRGF0dW0uQ2hhaW5JRDMyLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnX3I6IGhleFRvQnl0ZXMoc2lnbmVkLnIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWdfczogaGV4VG9CeXRlcyhzaWduZWQucyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ192OiBzaWduZWQueVBhcml0eSA8IDI3ID8gc2lnbmVkLnlQYXJpdHkgKyAyNyA6IHNpZ25lZC55UGFyaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbl9hZGRyZXNzOiBjdXJyZW5jeS50b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb252ZXJ0VG8zMkJ5dGVzJDEoc291cmNlLmFtb3VudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ6IGN1cnJlbmN5LnBlcm1pdFZhcmlhbnQgPT09IFBlcm1pdFZhcmlhbnQuUG9seWdvbkVNVCA/IDIgOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pdmVyc2U6IGNoYWluRGF0dW0uVW5pdmVyc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcG9uc29yZWRBcHByb3ZhbFBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB2c2NDcmVhdGVTcG9uc29yZWRBcHByb3ZhbHModGhpcy5pbnB1dC5vcHRpb25zLm5ldHdvcmtDb25maWcuVlNDX0RPTUFJTiwgc3BvbnNvcmVkQXBwcm92YWxQYXJhbXMsIHRoaXMubWFya1N0ZXBEb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2V0dGluZyBhbGxvd2FuY2VzJywgZSk7XG4gICAgICAgICAgICB0aHJvdyBFcnJvclVzZXJEZW5pZWRBbGxvd2FuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFpbi51bml2ZXJzZSA9PT0gVW5pdmVyc2UuRVRIRVJFVU0pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzd2l0Y2hDaGFpbih0aGlzLmlucHV0LmV2bS5jbGllbnQsIHRoaXMuaW5wdXQuY2hhaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXJrU3RlcERvbmUoQUxMT1dBTkNFX0NPTVBMRVRFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yT25BbGxvd2FuY2VIb29rKHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWxsb3cgPSAoYWxsb3dhbmNlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VzLmxlbmd0aCAhPT0gYWxsb3dhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgbGVuZ3RoIGZvciBhbGxvdygpLiBleHBlY3RlZDogJHtzb3VyY2VzLmxlbmd0aH0gZ290OiAke2FsbG93YW5jZXMubGVuZ3RofWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93YW5jZSA9IGFsbG93YW5jZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbW91bnQgPSAwbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhbGxvd2FuY2UgPT09ICdzdHJpbmcnICYmIGVxdWFsRm9sZChhbGxvd2FuY2UsICdtYXgnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50ID0gbWF4VWludDI1NjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYWxsb3dhbmNlID09PSAnc3RyaW5nJyAmJiBlcXVhbEZvbGQoYWxsb3dhbmNlLCAnbWluJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudCA9IG11bERlY2ltYWxzKHNvdXJjZS5hbGxvd2FuY2UubWluaW11bSwgc291cmNlLnRva2VuLmRlY2ltYWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYWxsb3dhbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50ID0gbXVsRGVjaW1hbHMoYWxsb3dhbmNlLCBzb3VyY2UudG9rZW4uZGVjaW1hbHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50ID0gYWxsb3dhbmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSUQ6IHNvdXJjZS5jaGFpbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuQ29udHJhY3Q6IHNvdXJjZS50b2tlbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldEFsbG93YW5jZXModmFsKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZGVueSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KEVycm9yVXNlckRlbmllZEFsbG93YW5jZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5ob29rcy5vbkFsbG93YW5jZSh7XG4gICAgICAgICAgICAgICAgYWxsb3csXG4gICAgICAgICAgICAgICAgZGVueSxcbiAgICAgICAgICAgICAgICBzb3VyY2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY3JlYXRlRXhwZWN0ZWRTdGVwcyhpbnRlbnQsIHVuYWxsb3dlZFNvdXJjZXMpIHtcbiAgICAgICAgdGhpcy5zdGVwcyA9IGNyZWF0ZVN0ZXBzKGludGVudCwgdGhpcy5jaGFpbkxpc3QsIHVuYWxsb3dlZFNvdXJjZXMpO1xuICAgICAgICB0aGlzLmlucHV0Lm9wdGlvbnMuZW1pdCgnZXhwZWN0ZWRfc3RlcHMnLCB0aGlzLnN0ZXBzKTtcbiAgICAgICAgbG9nZ2VyJDkuZGVidWcoJ0V4cGVjdGVkU3RlcHMnLCB0aGlzLnN0ZXBzKTtcbiAgICB9XG4gICAgY3JlYXRlSW50ZW50KGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgYW1vdW50LCBhc3NldHMsIGZlZVN0b3JlLCBnYXMsIGdhc0luVG9rZW4sIHRva2VuIH0gPSBpbnB1dDtcbiAgICAgICAgY29uc3QgaW50ZW50ID0ge1xuICAgICAgICAgICAgYWxsU291cmNlczogW10sXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICAgICAgICAgIGFtb3VudDogbmV3IERlY2ltYWwoJzAnKSxcbiAgICAgICAgICAgICAgICBjaGFpbklEOiB0aGlzLmlucHV0LmNoYWluLmlkLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiB0b2tlbi5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICBnYXM6IDBuLFxuICAgICAgICAgICAgICAgIHRva2VuQ29udHJhY3Q6IHRva2VuLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICB1bml2ZXJzZTogdGhpcy5kZXN0aW5hdGlvblVuaXZlcnNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZlZXM6IHtcbiAgICAgICAgICAgICAgICBjYUdhczogJzAnLFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246ICcwJyxcbiAgICAgICAgICAgICAgICBmdWxmaWxtZW50OiAnMCcsXG4gICAgICAgICAgICAgICAgZ2FzU3VwcGxpZWQ6IGlucHV0Lmdhc0luVG9rZW4udG9GaXhlZCgpLFxuICAgICAgICAgICAgICAgIHByb3RvY29sOiAnMCcsXG4gICAgICAgICAgICAgICAgc29sdmVyOiAnMCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNBdmFpbGFibGVCYWxhbmNlSW5zdWZmaWNpZW50OiBmYWxzZSxcbiAgICAgICAgICAgIHNvdXJjZXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhc3NldCA9IGFzc2V0cy5maW5kKHRva2VuLnN5bWJvbCk7XG4gICAgICAgIGlmICghYXNzZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZXQgJHt0b2tlbi5zeW1ib2x9IG5vdCBmb3VuZCBpbiBVc2VyQXNzZXRzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsU291cmNlcyA9IGFzc2V0Lml0ZXJhdGUoZmVlU3RvcmUpLm1hcCgodikgPT4gKHsgLi4udiwgYW1vdW50OiB2LmJhbGFuY2UgfSkpO1xuICAgICAgICBpbnRlbnQuYWxsU291cmNlcyA9IGFsbFNvdXJjZXM7XG4gICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uQmFsYW5jZSA9IGFzc2V0LmdldEJhbGFuY2VPbkNoYWluKHRoaXMuaW5wdXQuY2hhaW4uaWQsIHRva2VuLmNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgIGxldCBib3Jyb3cgPSBuZXcgRGVjaW1hbCgwKTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQub3B0aW9ucy5icmlkZ2UpIHtcbiAgICAgICAgICAgIGJvcnJvdyA9IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbW91bnQuZ3JlYXRlclRoYW4oZGVzdGluYXRpb25CYWxhbmNlKSkge1xuICAgICAgICAgICAgICAgIGJvcnJvdyA9IGFtb3VudC5taW51cyhkZXN0aW5hdGlvbkJhbGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uQmFsYW5jZSAhPT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgaW50ZW50LnNvdXJjZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogYW1vdW50LmdyZWF0ZXJUaGFuKGRlc3RpbmF0aW9uQmFsYW5jZSkgPyBuZXcgRGVjaW1hbChkZXN0aW5hdGlvbkJhbGFuY2UpIDogYW1vdW50LFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklEOiB0aGlzLmlucHV0LmNoYWluLmlkLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbkNvbnRyYWN0OiB0b2tlbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHVuaXZlcnNlOiB0aGlzLmRlc3RpbmF0aW9uVW5pdmVyc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdG9jb2xGZWUgPSBmZWVTdG9yZS5jYWxjdWxhdGVQcm90b2NvbEZlZShib3Jyb3cpO1xuICAgICAgICBpbnRlbnQuZmVlcy5wcm90b2NvbCA9IHByb3RvY29sRmVlLnRvRml4ZWQoKTtcbiAgICAgICAgbGV0IGJvcnJvd1dpdGhGZWUgPSBib3Jyb3cuYWRkKGdhc0luVG9rZW4pLmFkZChwcm90b2NvbEZlZSk7XG4gICAgICAgIGxvZ2dlciQ5LmRlYnVnKCdjcmVhdGVJbnRlbnQ6MCcsIHtcbiAgICAgICAgICAgIGJvcnJvdzogYm9ycm93LnRvRml4ZWQoKSxcbiAgICAgICAgICAgIGJvcnJvd1dpdGhGZWU6IGJvcnJvd1dpdGhGZWUudG9GaXhlZCgpLFxuICAgICAgICAgICAgZGVzdGluYXRpb25CYWxhbmNlLFxuICAgICAgICAgICAgZ2FzSW5Ub2tlbjogZ2FzSW5Ub2tlbi50b0ZpeGVkKCksXG4gICAgICAgICAgICBwcm90b2NvbEZlZTogcHJvdG9jb2xGZWUudG9GaXhlZCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZnVsZmlsbWVudEZlZSA9IGZlZVN0b3JlLmNhbGN1bGF0ZUZ1bGZpbG1lbnRGZWUoe1xuICAgICAgICAgICAgZGVjaW1hbHM6IHRva2VuLmRlY2ltYWxzLFxuICAgICAgICAgICAgZGVzdGluYXRpb25DaGFpbklEOiB0aGlzLmlucHV0LmNoYWluLmlkLFxuICAgICAgICAgICAgZGVzdGluYXRpb25Ub2tlbkFkZHJlc3M6IHRva2VuLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ2dlciQ5LmRlYnVnKCdjcmVhdGVJbnRlbnQ6MScsIHsgZnVsZmlsbWVudEZlZSB9KTtcbiAgICAgICAgaW50ZW50LmZlZXMuZnVsZmlsbWVudCA9IGZ1bGZpbG1lbnRGZWUudG9GaXhlZCgpO1xuICAgICAgICBib3Jyb3dXaXRoRmVlID0gYm9ycm93V2l0aEZlZS5hZGQoZnVsZmlsbWVudEZlZSk7XG4gICAgICAgIGxldCBhY2NvdW50ZWRBbW91bnQgPSBuZXcgRGVjaW1hbCgwKTtcbiAgICAgICAgY29uc3QgYWxsb3dlZFNvdXJjZXMgPSBhbGxTb3VyY2VzLmZpbHRlcigoYikgPT4ge1xuICAgICAgICAgICAgaWYgKGlucHV0LnNvdXJjZUNoYWlucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zb3VyY2VDaGFpbnMuaW5jbHVkZXMoYi5jaGFpbklEKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ2dlciQ5LmRlYnVnKCdjcmVhdGVJbnRlbnQ6MS4xJywgeyBhbGxvd2VkU291cmNlcyB9KTtcbiAgICAgICAgZm9yIChjb25zdCBhc3NldEMgb2YgYWxsb3dlZFNvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NvdW50ZWRBbW91bnQuZ3JlYXRlclRoYW5PckVxdWFsVG8oYm9ycm93V2l0aEZlZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3NldEMuY2hhaW5JRCA9PT0gdGhpcy5pbnB1dC5jaGFpbi5pZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzc2V0Qy5jaGFpbklEID09PSBDSEFJTl9JRFMuZnVlbC5tYWlubmV0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVlbENoYWluID0gdGhpcy5jaGFpbkxpc3QuZ2V0Q2hhaW5CeUlEKENIQUlOX0lEUy5mdWVsLm1haW5uZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VBc3NldEJhbGFuY2VPbkZ1ZWwgPSBhc3NldHMuZ2V0TmF0aXZlQmFsYW5jZShmdWVsQ2hhaW4pO1xuICAgICAgICAgICAgICAgIGlmIChuZXcgRGVjaW1hbChiYXNlQXNzZXRCYWxhbmNlT25GdWVsKS5sZXNzVGhhbignMC4wMDBfMDAzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDkuZGVidWcoJ2Z1ZWwgYmFzZSBhc3NldCBiYWxhbmNlIGlzIGxlc3NlciB0aGFuIG1pbiBleHBlY3RlZCBkZXBvc2l0IGZlZSwgc28gc2tpcCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQ6IGJhc2VBc3NldEJhbGFuY2VPbkZ1ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiAnMC4wMDBfMDAzJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOYXRpdmVBZGRyZXNzJDEoYXNzZXRDLnVuaXZlcnNlLCBhc3NldEMudG9rZW5Db250cmFjdCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uRmVlID0gZmVlU3RvcmUuY2FsY3VsYXRlQ29sbGVjdGlvbkZlZSh7XG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBhc3NldEMuZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUNoYWluSUQ6IGFzc2V0Qy5jaGFpbklELFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VUb2tlbkFkZHJlc3M6IGFzc2V0Qy50b2tlbkNvbnRyYWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGludGVudC5mZWVzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uRmVlLmFkZChpbnRlbnQuZmVlcy5jb2xsZWN0aW9uKS50b0ZpeGVkKCk7XG4gICAgICAgICAgICAgICAgYm9ycm93V2l0aEZlZSA9IGJvcnJvd1dpdGhGZWUuYWRkKGNvbGxlY3Rpb25GZWUpO1xuICAgICAgICAgICAgICAgIGxvZ2dlciQ5LmRlYnVnKCdjcmVhdGVJbnRlbnQ6MicsIHsgY29sbGVjdGlvbkZlZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVuYWNjb3VudGVkQW1vdW50ID0gYm9ycm93V2l0aEZlZS5taW51cyhhY2NvdW50ZWRBbW91bnQpO1xuICAgICAgICAgICAgbGV0IGJvcnJvd0Zyb21UaGlzQ2hhaW4gPSBuZXcgRGVjaW1hbChhc3NldEMuYmFsYW5jZSkubGVzc1RoYW5PckVxdWFsVG8odW5hY2NvdW50ZWRBbW91bnQpXG4gICAgICAgICAgICAgICAgPyBuZXcgRGVjaW1hbChhc3NldEMuYmFsYW5jZSlcbiAgICAgICAgICAgICAgICA6IHVuYWNjb3VudGVkQW1vdW50O1xuICAgICAgICAgICAgbG9nZ2VyJDkuZGVidWcoJ2NyZWF0ZUludGVudDoyLjEnLCB7XG4gICAgICAgICAgICAgICAgYWNjb3VudGVkQW1vdW50OiBhY2NvdW50ZWRBbW91bnQudG9GaXhlZCgpLFxuICAgICAgICAgICAgICAgIGFzc2V0OiBhc3NldEMsXG4gICAgICAgICAgICAgICAgYmFsYW5jZTogYXNzZXRDLmJhbGFuY2UudG9GaXhlZCgpLFxuICAgICAgICAgICAgICAgIGJvcnJvd0Zyb21UaGlzQ2hhaW46IGJvcnJvd0Zyb21UaGlzQ2hhaW4udG9GaXhlZCgpLFxuICAgICAgICAgICAgICAgIHVuYWNjb3VudGVkQW1vdW50OiB1bmFjY291bnRlZEFtb3VudC50b0ZpeGVkKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNvbHZlckZlZSA9IGZlZVN0b3JlLmNhbGN1bGF0ZVNvbHZlckZlZSh7XG4gICAgICAgICAgICAgICAgYm9ycm93QW1vdW50OiBib3Jyb3dGcm9tVGhpc0NoYWluLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBhc3NldEMuZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25DaGFpbklEOiB0aGlzLmlucHV0LmNoYWluLmlkLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uVG9rZW5BZGRyZXNzOiB0b2tlbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc291cmNlQ2hhaW5JRDogYXNzZXRDLmNoYWluSUQsXG4gICAgICAgICAgICAgICAgc291cmNlVG9rZW5BZGRyZXNzOiBhc3NldEMudG9rZW5Db250cmFjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW50ZW50LmZlZXMuc29sdmVyID0gc29sdmVyRmVlLmFkZChpbnRlbnQuZmVlcy5zb2x2ZXIpLnRvRml4ZWQoKTtcbiAgICAgICAgICAgIGxvZ2dlciQ5LmRlYnVnKCdjcmVhdGVJbnRlbnQ6MycsIHsgc29sdmVyRmVlIH0pO1xuICAgICAgICAgICAgYm9ycm93V2l0aEZlZSA9IGJvcnJvd1dpdGhGZWUuYWRkKHNvbHZlckZlZSk7XG4gICAgICAgICAgICBjb25zdCB1bmFjY291bnRlZEJhbGFuY2UgPSBib3Jyb3dXaXRoRmVlLm1pbnVzKGFjY291bnRlZEFtb3VudCk7XG4gICAgICAgICAgICBib3Jyb3dGcm9tVGhpc0NoYWluID0gbmV3IERlY2ltYWwoYXNzZXRDLmJhbGFuY2UpLmxlc3NUaGFuT3JFcXVhbFRvKHVuYWNjb3VudGVkQmFsYW5jZSlcbiAgICAgICAgICAgICAgICA/IG5ldyBEZWNpbWFsKGFzc2V0Qy5iYWxhbmNlKVxuICAgICAgICAgICAgICAgIDogdW5hY2NvdW50ZWRCYWxhbmNlO1xuICAgICAgICAgICAgaW50ZW50LnNvdXJjZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgYW1vdW50OiBib3Jyb3dGcm9tVGhpc0NoYWluLFxuICAgICAgICAgICAgICAgIGNoYWluSUQ6IGFzc2V0Qy5jaGFpbklELFxuICAgICAgICAgICAgICAgIHRva2VuQ29udHJhY3Q6IGFzc2V0Qy50b2tlbkNvbnRyYWN0LFxuICAgICAgICAgICAgICAgIHVuaXZlcnNlOiBhc3NldEMudW5pdmVyc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFjY291bnRlZEFtb3VudCA9IGFjY291bnRlZEFtb3VudC5hZGQoYm9ycm93RnJvbVRoaXNDaGFpbik7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZW50LmRlc3RpbmF0aW9uLmFtb3VudCA9IGJvcnJvdztcbiAgICAgICAgaWYgKGFjY291bnRlZEFtb3VudCA8IGJvcnJvd1dpdGhGZWUpIHtcbiAgICAgICAgICAgIGludGVudC5pc0F2YWlsYWJsZUJhbGFuY2VJbnN1ZmZpY2llbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ2FzLmVxdWFscygwKSkge1xuICAgICAgICAgICAgaW50ZW50LmRlc3RpbmF0aW9uLmdhcyA9IG11bERlY2ltYWxzKGdhcywgdGhpcy5pbnB1dC5jaGFpbi5uYXRpdmVDdXJyZW5jeS5kZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyJDkuZGVidWcoJ2NyZWF0ZUludGVudDo0JywgeyBpbnRlbnQgfSk7XG4gICAgICAgIHJldHVybiBpbnRlbnQ7XG4gICAgfVxufVxuY29uc3Qgd2FpdEZvckRvdWJsZUNoZWNrVHggPSAoaW5wdXQpID0+IHtcbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoaW5wdXQubWFwKChpKSA9PiBpKCkpKTtcbiAgICB9O1xufTtcblxuY29uc3QgbG9nZ2VyJDggPSBnZXRMb2dnZXIoKTtcbmNvbnN0IHRva2VuUmVxdWVzdFBhcnNlU2ltdWxhdGlvbiA9ICh7IGFzc2V0cywgYnJpZGdlLCBjaGFpbiwgaUdhcywgc2ltdWxhdGlvbiwgfSkgPT4ge1xuICAgIGNvbnN0IHRva2VuQ29udHJhY3QgPSBzaW11bGF0aW9uLnRva2VuLmNvbnRyYWN0QWRkcmVzcztcbiAgICBjb25zdCBhbW91bnQgPSBzaW11bGF0aW9uLmFtb3VudCA/PyBuZXcgRGVjaW1hbCgwKTtcbiAgICBjb25zdCBuYXRpdmVUb2tlbiA9IGNoYWluLm5hdGl2ZUN1cnJlbmN5O1xuICAgIGxvZ2dlciQ4LmRlYnVnKCdFUkMyMFJlcXVlc3RCYXNlOlBhcnNlU2ltdWxhdGlvbjoxJywge1xuICAgICAgICBhc3NldHMsXG4gICAgICAgIHRva2VuQ29udHJhY3QsXG4gICAgfSk7XG4gICAgY29uc3QgeyBjaGFpbnNXaXRoQmFsYW5jZSwgZGVzdGluYXRpb25Bc3NldEJhbGFuY2UsIGRlc3RpbmF0aW9uR2FzQmFsYW5jZSB9ID0gYXNzZXRzLmdldEFzc2V0RGV0YWlscyhjaGFpbiwgdG9rZW5Db250cmFjdCk7XG4gICAgY29uc3QgZ2FzTXVsdGlwbGUgPSBzaW11bGF0aW9uLmdhc0ZlZVxuICAgICAgICAubXVsKGNoYWluLmlkID09PSBTT1BIT05fQ0hBSU5fSUQgPyAzIDogMilcbiAgICAgICAgLmFkZChkaXZEZWNpbWFscyhpR2FzLCBuYXRpdmVUb2tlbi5kZWNpbWFscykpO1xuICAgIGxvZ2dlciQ4LmRlYnVnKCdFUkMyMFJlcXVlc3RCYXNlOlBhcnNlU2ltdWxhdGlvbjowJywge1xuICAgICAgICBkZXN0aW5hdGlvbkdhc0JhbGFuY2UsXG4gICAgICAgIGV4cGVjdGVkR2FzOiBnYXNNdWx0aXBsZS50b0ZpeGVkKCksXG4gICAgICAgIHNpbUdhczogc2ltdWxhdGlvbi5nYXNGZWUudG9GaXhlZCgpLFxuICAgIH0pO1xuICAgIGNvbnN0IGlzR2FzUmVxdWlyZWRUb0JlQm9ycm93ZWQgPSBicmlkZ2VcbiAgICAgICAgPyBnYXNNdWx0aXBsZS5ncmVhdGVyVGhhbigwKVxuICAgICAgICA6IGdhc011bHRpcGxlLmdyZWF0ZXJUaGFuKGRlc3RpbmF0aW9uR2FzQmFsYW5jZSk7XG4gICAgbGV0IGlzSW50ZW50UmVxdWlyZWQgPSBmYWxzZTtcbiAgICBpZiAoYnJpZGdlKSB7XG4gICAgICAgIGlzSW50ZW50UmVxdWlyZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgZ2FzID0gbmV3IERlY2ltYWwoMCk7XG4gICAgbG9nZ2VyJDguZGVidWcoJ0VSQzIwUmVxdWVzdEJhc2U6cGFyc2VTaW11bGF0aW9uOjEnLCB7XG4gICAgICAgIGNoYWluc1dpdGhCYWxhbmNlLFxuICAgICAgICBkZXN0aW5hdGlvbkFzc2V0QmFsYW5jZSxcbiAgICAgICAgaXNHYXNSZXF1aXJlZFRvQmVCb3Jyb3dlZCxcbiAgICB9KTtcbiAgICBpZiAoY2hhaW5zV2l0aEJhbGFuY2UpIHtcbiAgICAgICAgaWYgKGFtb3VudC5ncmVhdGVyVGhhbihkZXN0aW5hdGlvbkFzc2V0QmFsYW5jZSkpIHtcbiAgICAgICAgICAgIGlzSW50ZW50UmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0dhc1JlcXVpcmVkVG9CZUJvcnJvd2VkKSB7XG4gICAgICAgICAgICBpc0ludGVudFJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGdhcyA9IGJyaWRnZSA/IGdhc011bHRpcGxlIDogZ2FzTXVsdGlwbGUubWludXMoZGVzdGluYXRpb25HYXNCYWxhbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbW91bnQsXG4gICAgICAgIGdhcyxcbiAgICAgICAgaXNJbnRlbnRSZXF1aXJlZCxcbiAgICB9O1xufTtcbmNvbnN0IG5hdGl2ZVJlcXVlc3RQYXJzZVNpbXVsYXRpb24gPSAoeyBhc3NldHMsIGJyaWRnZSwgY2hhaW4sIHNpbXVsYXRpb24sIH0pID0+IHtcbiAgICBjb25zdCB7IGNoYWluc1dpdGhCYWxhbmNlLCBkZXN0aW5hdGlvbkdhc0JhbGFuY2UgfSA9IGFzc2V0cy5nZXRBc3NldERldGFpbHMoY2hhaW4sIHNpbXVsYXRpb24udG9rZW4uY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBnYXNNdWx0aXBsZSA9IHNpbXVsYXRpb24uZ2FzRmVlLm11bCgyKTtcbiAgICBsZXQgaXNJbnRlbnRSZXF1aXJlZCA9IGZhbHNlO1xuICAgIGlmIChicmlkZ2UpIHtcbiAgICAgICAgaXNJbnRlbnRSZXF1aXJlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjaGFpbnNXaXRoQmFsYW5jZSkge1xuICAgICAgICBpZiAoc2ltdWxhdGlvbi5hbW91bnQuYWRkKGdhc011bHRpcGxlKS5ncmVhdGVyVGhhbihkZXN0aW5hdGlvbkdhc0JhbGFuY2UpKSB7XG4gICAgICAgICAgICBpc0ludGVudFJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2dnZXIkOC5kZWJ1ZygncGFyc2VTaW11bGF0aW9uJywge1xuICAgICAgICBhbW91bnQ6IHNpbXVsYXRpb24uYW1vdW50LnRvRml4ZWQoKSxcbiAgICAgICAgZGVzdGluYXRpb25HYXNCYWxhbmNlOiBkZXN0aW5hdGlvbkdhc0JhbGFuY2UsXG4gICAgICAgIGdhczogZ2FzTXVsdGlwbGUudG9GaXhlZCgpLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFtb3VudDogc2ltdWxhdGlvbi5hbW91bnQsXG4gICAgICAgIGdhczogZ2FzTXVsdGlwbGUsXG4gICAgICAgIGlzSW50ZW50UmVxdWlyZWQsXG4gICAgfTtcbn07XG5cbmNvbnN0IGxvZ2dlciQ3ID0gZ2V0TG9nZ2VyKCk7XG5jbGFzcyBFUkMyMFRyYW5zZmVyIGV4dGVuZHMgQmFzZVJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHN1cGVyKGlucHV0KTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uVW5pdmVyc2UgPSBVbml2ZXJzZS5FVEhFUkVVTTtcbiAgICAgICAgdGhpcy5wdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICAgICAgdHJhbnNwb3J0OiB3ZWJTb2NrZXQodGhpcy5pbnB1dC5jaGFpbi5ycGNVcmxzLmRlZmF1bHQud2ViU29ja2V0WzBdKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhcnNlU2ltdWxhdGlvbih7IGFzc2V0cywgc2ltdWxhdGlvbiB9KSB7XG4gICAgICAgIHJldHVybiB0b2tlblJlcXVlc3RQYXJzZVNpbXVsYXRpb24oe1xuICAgICAgICAgICAgYXNzZXRzLFxuICAgICAgICAgICAgYnJpZGdlOiB0aGlzLmlucHV0Lm9wdGlvbnMuYnJpZGdlLFxuICAgICAgICAgICAgY2hhaW46IHRoaXMuaW5wdXQuY2hhaW4sXG4gICAgICAgICAgICBpR2FzOiB0aGlzLmlucHV0Lm9wdGlvbnMuZ2FzLFxuICAgICAgICAgICAgc2ltdWxhdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNpbXVsYXRlVHgoKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgdG8gfSA9IHRoaXMuaW5wdXQuZXZtLnR4O1xuICAgICAgICBjb25zdCBmcm9tID0gdGhpcy5pbnB1dC5ldm0uYWRkcmVzcztcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmNoYWluTGlzdC5nZXRUb2tlbkJ5QWRkcmVzcyh0aGlzLmlucHV0LmNoYWluLmlkLCB0byk7XG4gICAgICAgIGNvbnN0IG5hdGl2ZVRva2VuID0gdGhpcy5jaGFpbkxpc3QuZ2V0TmF0aXZlVG9rZW4odGhpcy5pbnB1dC5jaGFpbi5pZCk7XG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFyZ3MgfSA9IGRlY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICBhYmk6IFtFUkMyMFRyYW5zZmVyQUJJXSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEgPz8gJzB4MDAnLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKFtIWVBFUkVWTV9DSEFJTl9JRCwgS0FJQV9DSEFJTl9JRCwgTU9OQURfVEVTVE5FVF9DSEFJTl9JRF0uaW5jbHVkZXModGhpcy5pbnB1dC5jaGFpbi5pZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2ltdWxhdGVUeFJlcyA9IHtcbiAgICAgICAgICAgICAgICBhbW91bnQ6IGRpdkRlY2ltYWxzKGFyZ3NbMV0sIHRva2VuLmRlY2ltYWxzKSxcbiAgICAgICAgICAgICAgICBnYXM6IDEwMDAwMG4sXG4gICAgICAgICAgICAgICAgZ2FzRmVlOiBuZXcgRGVjaW1hbCgwKSxcbiAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2ltdWxhdGVUeFJlcykge1xuICAgICAgICAgICAgbGV0IGdhc0ZlZSA9IDBuO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlucHV0Lm9wdGlvbnMuYnJpZGdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3sgZ2FzUHJpY2UsIG1heEZlZVBlckdhcyB9LCBsMUZlZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljQ2xpZW50LmVzdGltYXRlRmVlc1BlckdhcygpLFxuICAgICAgICAgICAgICAgICAgICBnZXRMMUZlZSh0aGlzLmlucHV0LmNoYWluLCBzZXJpYWxpemVUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiB0aGlzLmlucHV0LmNoYWluLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSA/PyAnMHgwMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZWlwMTU1OScsXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXNVbml0UHJpY2UgPSBtYXhGZWVQZXJHYXMgPz8gZ2FzUHJpY2UgPz8gMG47XG4gICAgICAgICAgICAgICAgaWYgKGdhc1VuaXRQcmljZSA9PT0gMG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZ2V0IG1heEZlZVBlckdhcyBvciBnYXNQcmljZSBmcm9tIFJQQycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnYXNGZWUgPSB0aGlzLnNpbXVsYXRlVHhSZXMuZ2FzICogZ2FzVW5pdFByaWNlICsgbDFGZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuc2ltdWxhdGVUeFJlcyxcbiAgICAgICAgICAgICAgICBnYXNGZWU6IGRpdkRlY2ltYWxzKGdhc0ZlZSwgbmF0aXZlVG9rZW4uZGVjaW1hbHMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbW91bnRUb0FkZCA9IG5ldyBEZWNpbWFsKGFyZ3NbMV0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIC50b0hleGFkZWNpbWFsKClcbiAgICAgICAgICAgIC5zcGxpdCgnMHgnKVsxXVxuICAgICAgICAgICAgLnBhZFN0YXJ0KDQwLCAnMCcpO1xuICAgICAgICBsZXQgdHhzVG9TaW11bGF0ZSA9IFtdO1xuICAgICAgICBpZiAoQWF2ZVRva2VuQ29udHJhY3RzW3RoaXMuaW5wdXQuY2hhaW4uaWRdPy5bdG9rZW4uc3ltYm9sXSkge1xuICAgICAgICAgICAgdHhzVG9TaW11bGF0ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBmcm9tOiBBYXZlVG9rZW5Db250cmFjdHNbdGhpcy5pbnB1dC5jaGFpbi5pZF1bdG9rZW4uc3ltYm9sXSxcbiAgICAgICAgICAgICAgICBpbnB1dDogYDB4YTkwNTljYmIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAke2Zyb21cbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJzB4JywgJycpXG4gICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpfTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCR7YW1vdW50VG9BZGR9YCxcbiAgICAgICAgICAgICAgICB0bzogdG9rZW4uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVE9LRU5fTUlOVEVSX0NPTlRSQUNUU1t0aGlzLmlucHV0LmNoYWluLmlkXT8uW3Rva2VuLnN5bWJvbF0pIHtcbiAgICAgICAgICAgIHR4c1RvU2ltdWxhdGUucHVzaCh7XG4gICAgICAgICAgICAgICAgZnJvbTogVE9LRU5fTUlOVEVSX0NPTlRSQUNUU1t0aGlzLmlucHV0LmNoYWluLmlkXT8uW3Rva2VuLnN5bWJvbF0sXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGAweDQwYzEwZjE5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJHtmcm9tXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCcweCcsICcnKVxuICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKX0wMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDNiOWFjYTAwYCxcbiAgICAgICAgICAgICAgICB0bzogdG9rZW4uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHhzVG9TaW11bGF0ZS5wdXNoKHtcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICBpbnB1dDogZGF0YSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKFRPUF9PV05FUlt0aGlzLmlucHV0LmNoYWluLmlkXT8uW3Rva2VuLnN5bWJvbF0pIHtcbiAgICAgICAgICAgIGNvbnN0IG93bmVyQWRkcmVzcyA9IFRPUF9PV05FUlt0aGlzLmlucHV0LmNoYWluLmlkXVt0b2tlbi5zeW1ib2xdO1xuICAgICAgICAgICAgdHhzVG9TaW11bGF0ZSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IG93bmVyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtzaW11bGF0aW9uLCBmZWVEYXRhLCBsMUZlZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBzaW11bGF0ZVRyYW5zYWN0aW9uKHRoaXMuaW5wdXQuY2hhaW4uaWQsIHR4c1RvU2ltdWxhdGUsIHRoaXMuaW5wdXQub3B0aW9ucy5uZXR3b3JrQ29uZmlnLlNJTVVMQVRJT05fVVJMKSxcbiAgICAgICAgICAgIHRoaXMucHVibGljQ2xpZW50LmVzdGltYXRlRmVlc1BlckdhcygpLFxuICAgICAgICAgICAgZ2V0TDFGZWUodGhpcy5pbnB1dC5jaGFpbiwgc2VyaWFsaXplVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuaW5wdXQuY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSA/PyAnMHgwMCcsXG4gICAgICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdlaXAxNTU5JyxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGxvZ2dlciQ3LmRlYnVnKCdzaW11bGF0ZVR4JywgeyBmZWVEYXRhIH0pO1xuICAgICAgICBjb25zdCBnYXNVbml0UHJpY2UgPSBmZWVEYXRhLm1heEZlZVBlckdhcyA/PyBmZWVEYXRhLmdhc1ByaWNlID8/IDBuO1xuICAgICAgICBpZiAoZ2FzVW5pdFByaWNlID09PSAwbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZ2V0IG1heEZlZVBlckdhcyBvciBnYXNQcmljZSBmcm9tIFJQQycpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnYXNGZWUgPSAodGhpcy5pbnB1dC5jaGFpbi5pZCA9PT0gU09QSE9OX0NIQUlOX0lEXG4gICAgICAgICAgICA/IEJpZ0ludChzaW11bGF0aW9uLmRhdGEuZ2FzKVxuICAgICAgICAgICAgOiBCaWdJbnQoc2ltdWxhdGlvbi5kYXRhLmdhc191c2VkKSkgKlxuICAgICAgICAgICAgZ2FzVW5pdFByaWNlICtcbiAgICAgICAgICAgIGwxRmVlO1xuICAgICAgICBsb2dnZXIkNy5kZWJ1ZygnZXJjMjA6c2ltdWxhdGVUeCcsIHtcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICBmZWVEYXRhLFxuICAgICAgICAgICAgbDFGZWUsXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IGdhc1VuaXRQcmljZSxcbiAgICAgICAgICAgIHNpbXVsYXRpb24sXG4gICAgICAgICAgICB0b3RhbEdhczogZ2FzRmVlLFxuICAgICAgICAgICAgdG90YWxHYXNJbkRlY2ltYWw6IGRpdkRlY2ltYWxzKGdhc0ZlZSwgbmF0aXZlVG9rZW4uZGVjaW1hbHMpLnRvRml4ZWQoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmlucHV0Lm9wdGlvbnMuYnJpZGdlKSB7XG4gICAgICAgICAgICBnYXNGZWUgPSAwbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbW91bnQgPSBzaW11bGF0aW9uLmRhdGEuYW1vdW50ID09PSAnJyA/IGFyZ3NbMV0udG9TdHJpbmcoKSA6IHNpbXVsYXRpb24uZGF0YS5hbW91bnQ7XG4gICAgICAgIHRoaXMuc2ltdWxhdGVUeFJlcyA9IHtcbiAgICAgICAgICAgIGFtb3VudDogZGl2RGVjaW1hbHMoYW1vdW50LCB0b2tlbi5kZWNpbWFscyksXG4gICAgICAgICAgICBnYXM6IHRoaXMuaW5wdXQuY2hhaW4uaWQgPT09IFNPUEhPTl9DSEFJTl9JRFxuICAgICAgICAgICAgICAgID8gQmlnSW50KHNpbXVsYXRpb24uZGF0YS5nYXMpXG4gICAgICAgICAgICAgICAgOiBCaWdJbnQoc2ltdWxhdGlvbi5kYXRhLmdhc191c2VkKSxcbiAgICAgICAgICAgIGdhc0ZlZTogZGl2RGVjaW1hbHMoZ2FzRmVlLCBuYXRpdmVUb2tlbi5kZWNpbWFscyksXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2ltdWxhdGVUeFJlcztcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvckZpbGwocmVxdWVzdEhhc2gsIGludGVudElELCB3YWl0Rm9yRG91YmxlQ2hlY2tUeCkge1xuICAgICAgICBsb2dnZXIkNy5kZWJ1Zygnd2FpdEZvckZpbGwnLCB7XG4gICAgICAgICAgICBpbnRlbnRJRCxcbiAgICAgICAgICAgIHJlcXVlc3RIYXNoLFxuICAgICAgICAgICAgd2FpdEZvckRvdWJsZUNoZWNrVHgsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHdhaXRGb3JEb3VibGVDaGVja1R4KCksXG4gICAgICAgICAgICAgICAgZXZtV2FpdEZvckZpbGwodGhpcy5pbnB1dC5jaGFpbkxpc3QuZ2V0VmF1bHRDb250cmFjdEFkZHJlc3ModGhpcy5pbnB1dC5jaGFpbi5pZCksIHRoaXMucHVibGljQ2xpZW50LCByZXF1ZXN0SGFzaCwgaW50ZW50SUQsIHRoaXMuaW5wdXQub3B0aW9ucy5uZXR3b3JrQ29uZmlnLkdSUENfVVJMLCB0aGlzLmlucHV0Lm9wdGlvbnMubmV0d29ya0NvbmZpZy5DT1NNT1NfVVJMKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgKGF3YWl0IHRoaXMucHVibGljQ2xpZW50LnRyYW5zcG9ydC5nZXRScGNDbGllbnQoKSkuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgbG9nZ2VyJDYgPSBnZXRMb2dnZXIoKTtcbmNsYXNzIE5hdGl2ZVRyYW5zZmVyIGV4dGVuZHMgQmFzZVJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHN1cGVyKGlucHV0KTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uVW5pdmVyc2UgPSBVbml2ZXJzZS5FVEhFUkVVTTtcbiAgICAgICAgY29uc3Qgd3NVcmxzID0gdGhpcy5pbnB1dC5jaGFpbi5ycGNVcmxzPy5kZWZhdWx0Py53ZWJTb2NrZXQ7XG4gICAgICAgIGlmICghd3NVcmxzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2ViLVNvY2tldCBSUEMgVVJMIG1pc3NpbmcgZm9yIGNoYWluICR7dGhpcy5pbnB1dC5jaGFpbi5pZH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1YmxpY0NsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgICAgICB0cmFuc3BvcnQ6IHdlYlNvY2tldCh3c1VybHNbMF0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2VTaW11bGF0aW9uKHsgYXNzZXRzLCBzaW11bGF0aW9uIH0pIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVJlcXVlc3RQYXJzZVNpbXVsYXRpb24oe1xuICAgICAgICAgICAgYXNzZXRzLFxuICAgICAgICAgICAgYnJpZGdlOiB0aGlzLmlucHV0Lm9wdGlvbnMuYnJpZGdlLFxuICAgICAgICAgICAgY2hhaW46IHRoaXMuaW5wdXQuY2hhaW4sXG4gICAgICAgICAgICBzaW11bGF0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2ltdWxhdGVUeCgpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCB0bywgdmFsdWUgfSA9IHRoaXMuaW5wdXQuZXZtLnR4O1xuICAgICAgICBjb25zdCBuYXRpdmVUb2tlbiA9IHRoaXMuaW5wdXQuY2hhaW5MaXN0LmdldE5hdGl2ZVRva2VuKHRoaXMuaW5wdXQuY2hhaW4uaWQpO1xuICAgICAgICBpZiAodGhpcy5zaW11bGF0ZVR4UmVzKSB7XG4gICAgICAgICAgICBsZXQgZ2FzRmVlID0gMG47XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5wdXQub3B0aW9ucy5icmlkZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbeyBnYXNQcmljZSwgbWF4RmVlUGVyR2FzIH0sIGwxRmVlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNDbGllbnQuZXN0aW1hdGVGZWVzUGVyR2FzKCksXG4gICAgICAgICAgICAgICAgICAgIGdldEwxRmVlKHRoaXMuaW5wdXQuY2hhaW4sIHNlcmlhbGl6ZVRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuaW5wdXQuY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhID8/ICcweDAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlaXAxNTU5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBoZXhUb0JpZ0ludCh2YWx1ZSA/PyBgMHgwMGApLFxuICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FzVW5pdFByaWNlID0gbWF4RmVlUGVyR2FzID8/IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgIGdhc0ZlZSA9IHRoaXMuc2ltdWxhdGVUeFJlcy5nYXMgKiBnYXNVbml0UHJpY2UgKyBsMUZlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5zaW11bGF0ZVR4UmVzLFxuICAgICAgICAgICAgICAgIGdhc0ZlZTogZGl2RGVjaW1hbHMoZ2FzRmVlLCBuYXRpdmVUb2tlbi5kZWNpbWFscyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4c1RvU2ltdWxhdGUgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogWkVST19BRERSRVNTLFxuICAgICAgICAgICAgICAgIGlucHV0OiBkYXRhID8/ICcweDAwJyxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPz8gJzB4MDAnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgW3NpbXVsYXRpb24sIGZlZURhdGEsIGwxRmVlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHNpbXVsYXRlVHJhbnNhY3Rpb24odGhpcy5pbnB1dC5jaGFpbi5pZCwgdHhzVG9TaW11bGF0ZSwgdGhpcy5pbnB1dC5vcHRpb25zLm5ldHdvcmtDb25maWcuU0lNVUxBVElPTl9VUkwpLFxuICAgICAgICAgICAgdGhpcy5wdWJsaWNDbGllbnQuZXN0aW1hdGVGZWVzUGVyR2FzKCksXG4gICAgICAgICAgICBnZXRMMUZlZSh0aGlzLmlucHV0LmNoYWluLCBzZXJpYWxpemVUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5pbnB1dC5jaGFpbi5pZCxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhID8/ICcweDAwJyxcbiAgICAgICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICAgICAgdHlwZTogJ2VpcDE1NTknLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBoZXhUb0JpZ0ludCh2YWx1ZSA/PyAnMHgwMCcpLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZ2FzVW5pdFByaWNlID0gZmVlRGF0YS5tYXhGZWVQZXJHYXMgPz8gZmVlRGF0YS5nYXNQcmljZSA/PyAwbjtcbiAgICAgICAgaWYgKGdhc1VuaXRQcmljZSA9PT0gMG4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IGdldCBtYXhGZWVQZXJHYXMgb3IgZ2FzUHJpY2UgZnJvbSBSUEMnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ2FzRmVlID0gQmlnSW50KHNpbXVsYXRpb24uZGF0YS5nYXNfdXNlZCkgKiBnYXNVbml0UHJpY2UgKyBsMUZlZTtcbiAgICAgICAgbG9nZ2VyJDYuZGVidWcoJ25hdGl2ZTpzaW11bGF0ZVR4Jywge1xuICAgICAgICAgICAgZmVlRGF0YSxcbiAgICAgICAgICAgIGwxRmVlLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBnYXNVbml0UHJpY2UsXG4gICAgICAgICAgICBzaW11bGF0aW9uLFxuICAgICAgICAgICAgdG90YWxHYXM6IGdhc0ZlZSxcbiAgICAgICAgICAgIHRvdGFsR2FzSW5EZWNpbWFsOiBkaXZEZWNpbWFscyhnYXNGZWUsIG5hdGl2ZVRva2VuLmRlY2ltYWxzKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmlucHV0Lm9wdGlvbnMuYnJpZGdlKSB7XG4gICAgICAgICAgICBnYXNGZWUgPSAwbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpbXVsYXRlVHhSZXMgPSB7XG4gICAgICAgICAgICBhbW91bnQ6IGRpdkRlY2ltYWxzKHZhbHVlID8/ICcwJywgbmF0aXZlVG9rZW4uZGVjaW1hbHMpLFxuICAgICAgICAgICAgZ2FzOiBCaWdJbnQoc2ltdWxhdGlvbi5kYXRhLmdhc191c2VkKSxcbiAgICAgICAgICAgIGdhc0ZlZTogZGl2RGVjaW1hbHMoZ2FzRmVlLCBuYXRpdmVUb2tlbi5kZWNpbWFscyksXG4gICAgICAgICAgICB0b2tlbjoge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogWkVST19BRERSRVNTLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBuYXRpdmVUb2tlbi5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYXRpdmVUb2tlbi5uYW1lLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogbmF0aXZlVG9rZW4uc3ltYm9sLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2ltdWxhdGVUeFJlcztcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvckZpbGwocmVxdWVzdEhhc2gsIGludGVudElELCB3YWl0Rm9yRG91YmxlQ2hlY2tUeCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHdhaXRGb3JEb3VibGVDaGVja1R4KCksXG4gICAgICAgICAgICAgICAgZXZtV2FpdEZvckZpbGwodGhpcy5pbnB1dC5jaGFpbkxpc3QuZ2V0VmF1bHRDb250cmFjdEFkZHJlc3ModGhpcy5pbnB1dC5jaGFpbi5pZCksIHRoaXMucHVibGljQ2xpZW50LCByZXF1ZXN0SGFzaCwgaW50ZW50SUQsIHRoaXMuaW5wdXQub3B0aW9ucy5uZXR3b3JrQ29uZmlnLkdSUENfVVJMLCB0aGlzLmlucHV0Lm9wdGlvbnMubmV0d29ya0NvbmZpZy5DT1NNT1NfVVJMKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgKGF3YWl0IHRoaXMucHVibGljQ2xpZW50LnRyYW5zcG9ydC5nZXRScGNDbGllbnQoKSkuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgbG9nZ2VyJDUgPSBnZXRMb2dnZXIoKTtcbmNsYXNzIEZ1ZWxOYXRpdmVUcmFuc2ZlciBleHRlbmRzIEJhc2VSZXF1ZXN0IHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBzdXBlcihpbnB1dCk7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5hbGxvd2FuY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvblVuaXZlcnNlID0gVW5pdmVyc2UuRlVFTDtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0LmZ1ZWw/LnR4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVxdWVzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pbnB1dC5mdWVsLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnVlbCBhZGRyZXNzIG1pc3NpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR4ID0gdGhpcy5pbnB1dC5mdWVsLnR4O1xuICAgICAgICB0aGlzLmZ1ZWxBZGRyZXNzID0gdGhpcy5pbnB1dC5mdWVsLmFkZHJlc3M7XG4gICAgfVxuICAgIHBhcnNlU2ltdWxhdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlUmVxdWVzdFBhcnNlU2ltdWxhdGlvbih7XG4gICAgICAgICAgICAuLi5pbnB1dCxcbiAgICAgICAgICAgIGJyaWRnZTogdGhpcy5pbnB1dC5vcHRpb25zLmJyaWRnZSxcbiAgICAgICAgICAgIGNoYWluOiB0aGlzLmlucHV0LmNoYWluLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2ltdWxhdGVUeCgpIHtcbiAgICAgICAgbG9nZ2VyJDUuZGVidWcoJ2Z1ZWw6IHJlYWNoZWQgc2ltdWxhdGUgdHgnKTtcbiAgICAgICAgY29uc3QgbmF0aXZlQ3VycmVuY3kgPSB0aGlzLmlucHV0LmNoYWluLm5hdGl2ZUN1cnJlbmN5O1xuICAgICAgICBpZiAodGhpcy5zaW11bGF0ZVR4UmVzKSB7XG4gICAgICAgICAgICBsZXQgZ2FzRmVlID0gbmV3IERlY2ltYWwoMCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5wdXQub3B0aW9ucy5icmlkZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFzc2VtYmxlZFJlcXVlc3QgfSA9IGF3YWl0IHRoaXMuaW5wdXQuZnVlbC5wcm92aWRlci5hc3NlbWJsZVR4KHtcbiAgICAgICAgICAgICAgICAgICAgZmVlUGF5ZXJBY2NvdW50OiBuZXcgQWNjb3VudCh0aGlzLmlucHV0LmZ1ZWwuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMuaW5wdXQuZnVlbC50eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBnYXNGZWUgPSBkaXZEZWNpbWFscyhCaWdJbnQoYXNzZW1ibGVkUmVxdWVzdC5tYXhGZWUudG9TdHJpbmcoKSkgKiAybiwgbmF0aXZlQ3VycmVuY3kuZGVjaW1hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnNpbXVsYXRlVHhSZXMsXG4gICAgICAgICAgICAgICAgZ2FzRmVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpbXVsYXRlVHhSZXMgPSBhd2FpdCBzaW11bGF0ZSh0aGlzLnR4LCB0aGlzLmZ1ZWxBZGRyZXNzLCB0aGlzLmlucHV0LmZ1ZWwucHJvdmlkZXIsIHRoaXMuaW5wdXQuY2hhaW5MaXN0KTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQub3B0aW9ucy5icmlkZ2UgJiYgdGhpcy5zaW11bGF0ZVR4UmVzKSB7XG4gICAgICAgICAgICB0aGlzLnNpbXVsYXRlVHhSZXMuZ2FzRmVlID0gbmV3IERlY2ltYWwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2ltdWxhdGVUeFJlcztcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvckZpbGwoXywgaW50ZW50SUQpIHtcbiAgICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICByZXF1ZXN0VGltZW91dCgzLCBhYyksXG4gICAgICAgICAgICBjb3Ntb3NGaWxsQ2hlY2soaW50ZW50SUQsIHRoaXMuaW5wdXQub3B0aW9ucy5uZXR3b3JrQ29uZmlnLkdSUENfVVJMLCB0aGlzLmlucHV0Lm9wdGlvbnMubmV0d29ya0NvbmZpZy5DT1NNT1NfVVJMLCBhYyksXG4gICAgICAgIF0pO1xuICAgIH1cbn1cblxuY29uc3QgbG9nZ2VyJDQgPSBnZXRMb2dnZXIoKTtcbmNsYXNzIEZ1ZWxUb2tlblRyYW5zZmVyIGV4dGVuZHMgQmFzZVJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHN1cGVyKGlucHV0KTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmFsbG93YW5jZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uVW5pdmVyc2UgPSBVbml2ZXJzZS5GVUVMO1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQuZnVlbD8udHgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXF1ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlucHV0LmZ1ZWwuYWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdWVsIGFkZHJlc3MgbWlzc2luZycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHggPSB0aGlzLmlucHV0LmZ1ZWwudHg7XG4gICAgICAgIHRoaXMuZnVlbEFkZHJlc3MgPSB0aGlzLmlucHV0LmZ1ZWwuYWRkcmVzcztcbiAgICB9XG4gICAgcGFyc2VTaW11bGF0aW9uKHsgYXNzZXRzLCBzaW11bGF0aW9uIH0pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuUmVxdWVzdFBhcnNlU2ltdWxhdGlvbih7XG4gICAgICAgICAgICBhc3NldHMsXG4gICAgICAgICAgICBicmlkZ2U6IHRoaXMuaW5wdXQub3B0aW9ucy5icmlkZ2UsXG4gICAgICAgICAgICBjaGFpbjogdGhpcy5pbnB1dC5jaGFpbixcbiAgICAgICAgICAgIGlHYXM6IHRoaXMuaW5wdXQub3B0aW9ucy5nYXMsXG4gICAgICAgICAgICBzaW11bGF0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2ltdWxhdGVUeCgpIHtcbiAgICAgICAgbG9nZ2VyJDQuZGVidWcoJ2Z1ZWw6IHJlYWNoZWQgc2ltdWxhdGUgdHgnKTtcbiAgICAgICAgY29uc3QgbmF0aXZlQ3VycmVuY3kgPSB0aGlzLmlucHV0LmNoYWluLm5hdGl2ZUN1cnJlbmN5O1xuICAgICAgICBpZiAodGhpcy5zaW11bGF0ZVR4UmVzKSB7XG4gICAgICAgICAgICBsZXQgZ2FzRmVlID0gbmV3IERlY2ltYWwoMCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5wdXQub3B0aW9ucy5icmlkZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFzc2VtYmxlZFJlcXVlc3QgfSA9IGF3YWl0IHRoaXMuaW5wdXQuZnVlbC5wcm92aWRlci5hc3NlbWJsZVR4KHtcbiAgICAgICAgICAgICAgICAgICAgZmVlUGF5ZXJBY2NvdW50OiBuZXcgQWNjb3VudCh0aGlzLmlucHV0LmZ1ZWwuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMuaW5wdXQuZnVlbC50eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBnYXNGZWUgPSBkaXZEZWNpbWFscyhCaWdJbnQoYXNzZW1ibGVkUmVxdWVzdC5tYXhGZWUudG9TdHJpbmcoKSkgKiAybiwgbmF0aXZlQ3VycmVuY3kuZGVjaW1hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnNpbXVsYXRlVHhSZXMsXG4gICAgICAgICAgICAgICAgZ2FzRmVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpbXVsYXRlVHhSZXMgPSBhd2FpdCBzaW11bGF0ZSh0aGlzLnR4LCB0aGlzLmZ1ZWxBZGRyZXNzLCB0aGlzLmlucHV0LmZ1ZWwucHJvdmlkZXIsIHRoaXMuaW5wdXQuY2hhaW5MaXN0KTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQub3B0aW9ucy5icmlkZ2UgJiYgdGhpcy5zaW11bGF0ZVR4UmVzKSB7XG4gICAgICAgICAgICB0aGlzLnNpbXVsYXRlVHhSZXMuZ2FzRmVlID0gbmV3IERlY2ltYWwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2ltdWxhdGVUeFJlcztcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvckZpbGwoXywgaW50ZW50SUQpIHtcbiAgICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICByZXF1ZXN0VGltZW91dCgzLCBhYyksXG4gICAgICAgICAgICBjb3Ntb3NGaWxsQ2hlY2soaW50ZW50SUQsIHRoaXMuaW5wdXQub3B0aW9ucy5uZXR3b3JrQ29uZmlnLkdSUENfVVJMLCB0aGlzLmlucHV0Lm9wdGlvbnMubmV0d29ya0NvbmZpZy5DT1NNT1NfVVJMLCBhYyksXG4gICAgICAgIF0pO1xuICAgIH1cbn1cblxuY29uc3QgbG9nZ2VyJDMgPSBnZXRMb2dnZXIoKTtcbnZhciBUeFR5cGU7XG4oZnVuY3Rpb24gKFR4VHlwZSkge1xuICAgIFR4VHlwZVtUeFR5cGVbXCJFVk1FUkMyMFRyYW5zZmVyXCJdID0gMF0gPSBcIkVWTUVSQzIwVHJhbnNmZXJcIjtcbiAgICBUeFR5cGVbVHhUeXBlW1wiRVZNTmF0aXZlVHJhbnNmZXJcIl0gPSAxXSA9IFwiRVZNTmF0aXZlVHJhbnNmZXJcIjtcbiAgICBUeFR5cGVbVHhUeXBlW1wiRnVlbFRva2VuVHJhbnNmZXJcIl0gPSAyXSA9IFwiRnVlbFRva2VuVHJhbnNmZXJcIjtcbiAgICBUeFR5cGVbVHhUeXBlW1wiRnVlbE5hdGl2ZVRyYW5zZmVyXCJdID0gM10gPSBcIkZ1ZWxOYXRpdmVUcmFuc2ZlclwiO1xufSkoVHhUeXBlIHx8IChUeFR5cGUgPSB7fSkpO1xuY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgW1R4VHlwZS5FVk1FUkMyMFRyYW5zZmVyXTogRVJDMjBUcmFuc2ZlcixcbiAgICBbVHhUeXBlLkVWTU5hdGl2ZVRyYW5zZmVyXTogTmF0aXZlVHJhbnNmZXIsXG4gICAgW1R4VHlwZS5GdWVsTmF0aXZlVHJhbnNmZXJdOiBGdWVsTmF0aXZlVHJhbnNmZXIsXG4gICAgW1R4VHlwZS5GdWVsVG9rZW5UcmFuc2Zlcl06IEZ1ZWxUb2tlblRyYW5zZmVyLFxufTtcbmNvbnN0IGNyZWF0ZUhhbmRsZXIgPSAoaW5wdXQpID0+IHtcbiAgICBsb2dnZXIkMy5kZWJ1Zygncm91dGVyJywgeyBpbnB1dCB9KTtcbiAgICBsZXQgaGFuZGxlciA9IG51bGw7XG4gICAgbGV0IHByb2Nlc3NUeCA9IGFzeW5jICgpID0+IHsgfTtcbiAgICBpZiAoaW5wdXQuZXZtLnR4KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gaW5wdXQuZXZtLnR4O1xuICAgICAgICBpZiAoaXNFUkMyMFRva2VuVHJhbnNmZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gaGFuZGxlcnNbVHhUeXBlLkVWTUVSQzIwVHJhbnNmZXJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTmF0aXZlVG9rZW5UcmFuc2ZlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyc1tUeFR5cGUuRVZNTmF0aXZlVHJhbnNmZXJdO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NUeCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaW5wdXQub3B0aW9ucy5icmlkZ2UgJiYgIWlucHV0Lm9wdGlvbnMuc2tpcFR4KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMuZGVidWcoJ2luIHByb2Nlc3NUeCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdHg6IGlucHV0LmV2bS50eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzd2l0Y2hDaGFpbihpbnB1dC5ldm0uY2xpZW50LCBpbnB1dC5jaGFpbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0LmV2bS5jbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt0eF0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0LmZ1ZWw/LnR4KSB7XG4gICAgICAgIGlmIChpc0Z1ZWxOYXRpdmVUcmFuc2ZlcihpbnB1dC5mdWVsLnR4KSkge1xuICAgICAgICAgICAgaGFuZGxlciA9IGhhbmRsZXJzW1R4VHlwZS5GdWVsTmF0aXZlVHJhbnNmZXJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlciA9IGhhbmRsZXJzW1R4VHlwZS5GdWVsVG9rZW5UcmFuc2Zlcl07XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc1R4ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnB1dC5vcHRpb25zLmJyaWRnZSAmJiAhaW5wdXQub3B0aW9ucy5za2lwVHgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMy5kZWJ1ZygnaW4gcHJvY2Vzc1R4Jywge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBpbnB1dC5mdWVsLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBpbnB1dC5mdWVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICB0eDogaW5wdXQuZnVlbD8udHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCBmaXhUeChpbnB1dC5mdWVsLmFkZHJlc3MsIGlucHV0LmZ1ZWwudHgsIGlucHV0LmZ1ZWwucHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dC5mdWVsLmNvbm5lY3Rvci5zZW5kVHJhbnNhY3Rpb24oaW5wdXQuZnVlbC5hZGRyZXNzLCB0eCwge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBGVUVMX05FVFdPUktfVVJMLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gaGFuZGxlcicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyID8gbmV3IGhhbmRsZXIoaW5wdXQpIDogbnVsbCxcbiAgICAgICAgcHJvY2Vzc1R4LFxuICAgIH07XG59O1xuXG5jb25zdCBsb2dnZXIkMiA9IGdldExvZ2dlcigpO1xuY2xhc3MgQnJpZGdlSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmRlcG9zaXRDYWxscyA9IHt9O1xuICAgICAgICB0aGlzLmVvYVRvRXBoQ2FsbHMgPSB7fTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB7XG4gICAgICAgICAgICBmaWxsZWQ6IHRydWUsXG4gICAgICAgICAgICBpbnRlbnRJRDogTG9uZy5mcm9tSW50KDApLFxuICAgICAgICAgICAgcHJvbWlzZTogUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2FpdEZvckZpbGwgPSAoKSA9PiAoe1xuICAgICAgICAgICAgZmlsbGVkOiB0cnVlLFxuICAgICAgICAgICAgaW50ZW50SUQ6IExvbmcuZnJvbU51bWJlcigwKSxcbiAgICAgICAgICAgIHByb21pc2U6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jcmVhdGVEb3VibGVDaGVja1R4ID0gYXN5bmMgKCkgPT4geyB9O1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXNzZXQgb2YgaW5wdXQuYXNzZXRzKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jYWNoZS5hZGRBbGxvd2FuY2VRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSUQ6IGFzc2V0LmNoYWluSUQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogYXNzZXQuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBvd25lcjogb3B0aW9ucy5hZGRyZXNzLmVwaGVtZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgc3BlbmRlcjogb3B0aW9ucy5jaGFpbkxpc3QuZ2V0VmF1bHRDb250cmFjdEFkZHJlc3MoYXNzZXQuY2hhaW5JRCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUkZGRGVwb3NpdHMoKSB7XG4gICAgICAgIGNvbnN0IHdhaXRpbmdQcm9taXNlcyA9IFtdO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5kZXBvc2l0Q2FsbHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNiY1R4ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGMgaW4gdGhpcy5kZXBvc2l0Q2FsbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMub3B0aW9ucy5jaGFpbkxpc3QuZ2V0Q2hhaW5CeUlEKE51bWJlcihjKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYWluIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNDbGllbnQgPSB0aGlzLm9wdGlvbnMucHVibGljQ2xpZW50TGlzdC5nZXQoYyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbHMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBlMmUgPSB0aGlzLmVvYVRvRXBoQ2FsbHNbTnVtYmVyKGMpXTtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMi5kZWJ1ZygnRW9hLT5FcGggYW5kIGRlcG9zaXQgY2FsbHMnLCB7XG4gICAgICAgICAgICAgICAgICAgIGFsbEVvQVRvRXBoZW1lcmFsQ2FsbHM6IHRoaXMuZW9hVG9FcGhDYWxscyxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW46IGMsXG4gICAgICAgICAgICAgICAgICAgIGVvQVRvRXBoZW1lcmFsQ2FsbHM6IGUyZSxcbiAgICAgICAgICAgICAgICAgICAgcmZmRGVwb3NpdENhbGxzOiB7IC4uLnRoaXMuZGVwb3NpdENhbGxzIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLndhbGxldC5lb2Euc3dpdGNoQ2hhaW4oe1xuICAgICAgICAgICAgICAgICAgICBpZDogTnVtYmVyKGMpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChlMmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLndhbGxldC5lb2Euc3dpdGNoQ2hhaW4oeyBpZDogY2hhaW4uaWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4cyA9IGF3YWl0IGNyZWF0ZVBlcm1pdEFuZFRyYW5zZmVyRnJvbVR4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogZTJlLmFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiB0aGlzLm9wdGlvbnMuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogZTJlLnRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzLm9wdGlvbnMuYWRkcmVzcy5lb2EsXG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lcldhbGxldDogdGhpcy5vcHRpb25zLndhbGxldC5lb2EsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNDbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVuZGVyOiB0aGlzLm9wdGlvbnMuYWRkcmVzcy5lcGhlbWVyYWwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYWxscy5wdXNoKC4uLnR4cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNiY1R4LnB1c2goYXdhaXQgY3JlYXRlU0JDVHhGcm9tQ2FsbHMoe1xuICAgICAgICAgICAgICAgICAgICBjYWNoZTogdGhpcy5vcHRpb25zLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsczogY2FsbHMuY29uY2F0KHRoaXMuZGVwb3NpdENhbGxzW2NdLnR4KS5jb25jYXQoY3JlYXRlU3dlZXBlclR4cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogdGhpcy5vcHRpb25zLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JRDogY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBDT1RDdXJyZW5jeUlEOiB0aGlzLm9wdGlvbnMuY290LmN1cnJlbmN5SUQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlcjogdGhpcy5vcHRpb25zLmFkZHJlc3MuZW9hLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiB0aGlzLm9wdGlvbnMuYWRkcmVzcy5lcGhlbWVyYWwsXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JRDogY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbEFkZHJlc3M6IHRoaXMub3B0aW9ucy5hZGRyZXNzLmVwaGVtZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsV2FsbGV0OiB0aGlzLm9wdGlvbnMud2FsbGV0LmVwaGVtZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgcHVibGljQ2xpZW50LFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzYmNUeC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHMgPSBhd2FpdCB2c2NTQkNUeChzYmNUeCwgdGhpcy5vcHRpb25zLm5ldHdvcmtDb25maWcuVlNDX0RPTUFJTik7XG4gICAgICAgICAgICAgICAgb3BzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbWl0dGVyLmVtaXQoU09VUkNFX1NXQVBfSEFTSChvcCwgdGhpcy5vcHRpb25zLmNoYWluTGlzdCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdhaXRpbmdQcm9taXNlcy5wdXNoKC4uLm9wcy5tYXAoKFtjaGFpbklELCBoYXNoXSkgPT4gd3JhcChOdW1iZXIoY2hhaW5JRCksIHdhaXRGb3JUeFJlY2VpcHQoaGFzaCwgdGhpcy5vcHRpb25zLnB1YmxpY0NsaWVudExpc3QuZ2V0KGNoYWluSUQpLCAyKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh3YWl0aW5nUHJvbWlzZXMpO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzKG1ldGFkYXRhLCBpbnB1dEFzc2V0cykge1xuICAgICAgICBpZiAodGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhc3NldCBvZiB0aGlzLmlucHV0LmFzc2V0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRBc3NldCA9IGlucHV0QXNzZXRzLmZpbmQoKGkpID0+IGkuY2hhaW5JRCA9PT0gYXNzZXQuY2hhaW5JRCAmJiBlcXVhbEZvbGQoaS50b2tlbkFkZHJlc3MsIGFzc2V0LmNvbnRyYWN0QWRkcmVzcykpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkQXNzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXQuZXBoZW1lcmFsQmFsYW5jZSA9IHVwZGF0ZWRBc3NldC5hbW91bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVCcmlkZ2VSRkYoe1xuICAgICAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbkxpc3Q6IHRoaXMub3B0aW9ucy5jaGFpbkxpc3QsXG4gICAgICAgICAgICAgICAgICAgIGNvc21vczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5vcHRpb25zLmFkZHJlc3MuY29zbW9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0OiB0aGlzLm9wdGlvbnMud2FsbGV0LmNvc21vcyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXZtOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLm9wdGlvbnMuYWRkcmVzcy5lcGhlbWVyYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMub3B0aW9ucy53YWxsZXQuZXBoZW1lcmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW9hQWRkcmVzczogdGhpcy5vcHRpb25zLmFkZHJlc3MuZW9hLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDT1NNT1NfVVJMOiB0aGlzLm9wdGlvbnMubmV0d29ya0NvbmZpZy5DT1NNT1NfVVJMLFxuICAgICAgICAgICAgICAgICAgICAgICAgR1JQQ19VUkw6IHRoaXMub3B0aW9ucy5uZXR3b3JrQ29uZmlnLkdSUENfVVJMLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHsgYXNzZXRzOiB0aGlzLmlucHV0LmFzc2V0cyB9LFxuICAgICAgICAgICAgICAgIG91dHB1dDogdGhpcy5pbnB1dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kZXBvc2l0Q2FsbHMgPSByZXNwb25zZS5kZXBvc2l0Q2FsbHM7XG4gICAgICAgICAgICB0aGlzLmVvYVRvRXBoQ2FsbHMgPSByZXNwb25zZS5lb2FUb0VwaGVtZXJhbENhbGxzO1xuICAgICAgICAgICAgY29uc3QgWywgeyBjcmVhdGVEb3VibGVDaGVja1R4IH1dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlUkZGRGVwb3NpdHMoKSxcbiAgICAgICAgICAgICAgICByZXNwb25zZS5jcmVhdGVSRkYoKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdGhpcy53YWl0Rm9yRmlsbCA9IHJlc3BvbnNlLndhaXRGb3JGaWxsO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVEb3VibGVDaGVja1R4ID0gY3JlYXRlRG91YmxlQ2hlY2tUeDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXR1cyA9IHRoaXMud2FpdEZvckZpbGwoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzLmludGVudElELnRvTnVtYmVyKCkgIT0gMCkge1xuICAgICAgICAgICAgYXdhaXQgcmV0cnkoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlRG91YmxlQ2hlY2tUeCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMi5pbmZvKCdkb3VibGUtY2hlY2stcmV0dXJuZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB7IGRlbGF5OiAzMDAwLCByZXRyaWVzOiAzIH0pO1xuICAgICAgICAgICAgbWV0YWRhdGEucmZmX2lkID0gQmlnSW50KHRoaXMuc3RhdHVzLmludGVudElELnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVtaXR0ZXIuZW1pdChSRkZfSUQodGhpcy5zdGF0dXMuaW50ZW50SUQudG9OdW1iZXIoKSkpO1xuICAgICAgICAgICAgLy8gd2lsbCBqdXN0IHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgbm8gQ0Egd2FzIHJlcXVpcmVkXG4gICAgICAgICAgICBsb2dnZXIkMi5kZWJ1ZygnRmlsbCB3YWl0IHN0YXJ0Jyk7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKCdmaWxsLXdhaXQtc3RhcnQnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0dXMuZmlsbGVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGF0dXMucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ2ZpbGwtd2FpdC1lbmQnKTtcbiAgICAgICAgICAgIGxvZ2dlciQyLmRlYnVnKCdGaWxsIHdhaXQgY29tcGxldGUnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIERlc3RpbmF0aW9uU3dhcEhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKGRzdFN3YXAsIGRzdFRva2VuSW5mbywgZHN0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZHN0U3dhcCA9IGRzdFN3YXA7XG4gICAgICAgIHRoaXMuZHN0VG9rZW5JbmZvID0gZHN0VG9rZW5JbmZvO1xuICAgICAgICB0aGlzLmRzdCA9IGRzdDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkNhbGxzID0gW107XG4gICAgICAgIGlmIChkc3RTd2FwLmRzdEVPQVRvRXBoVHgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FjaGUuYWRkQWxsb3dhbmNlUXVlcnkoe1xuICAgICAgICAgICAgICAgIGNoYWluSUQ6IGRzdC5jaGFpbklELFxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogZHN0U3dhcC5kc3RFT0FUb0VwaFR4LmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBvd25lcjogb3B0aW9ucy5hZGRyZXNzLmVvYSxcbiAgICAgICAgICAgICAgICBzcGVuZGVyOiBvcHRpb25zLmFkZHJlc3MuZXBoZW1lcmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5jYWNoZS5hZGRTZXRDb2RlUXVlcnkoe1xuICAgICAgICAgICAgYWRkcmVzczogb3B0aW9ucy5hZGRyZXNzLmVwaGVtZXJhbCxcbiAgICAgICAgICAgIGNoYWluSUQ6IGRzdC5jaGFpbklELFxuICAgICAgICB9KTtcbiAgICAgICAgbG9nZ2VyJDIuZGVidWcoJ2RzdFN3YXBIYW5kbGVyOmNvbnN0cnVjdG9yJywge1xuICAgICAgICAgICAgaXNOYXRpdmVBZGRyZXNzOiBpc05hdGl2ZUFkZHJlc3MoZHN0LnRva2VuKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc05hdGl2ZUFkZHJlc3MoZHN0LnRva2VuKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWNoZS5hZGROYXRpdmVBbGxvd2FuY2VRdWVyeSh7XG4gICAgICAgICAgICAgICAgY2hhaW5JRDogZHN0LmNoYWluSUQsXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBvcHRpb25zLmFkZHJlc3MuZXBoZW1lcmFsLFxuICAgICAgICAgICAgICAgIG93bmVyOiBTV0VFUEVSX0FERFJFU1MsXG4gICAgICAgICAgICAgICAgc3BlbmRlcjogU1dFRVBFUl9BRERSRVNTLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5jYWNoZS5hZGRBbGxvd2FuY2VRdWVyeSh7XG4gICAgICAgICAgICBjaGFpbklEOiBkc3QuY2hhaW5JRCxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udmVydFRvRVZNQWRkcmVzcyhkc3RTd2FwLnJlcS5pbnB1dFRva2VuKSxcbiAgICAgICAgICAgIG93bmVyOiBvcHRpb25zLmFkZHJlc3MuZXBoZW1lcmFsLFxuICAgICAgICAgICAgc3BlbmRlcjogU1dFRVBFUl9BRERSRVNTLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUGVybWl0KCkge1xuICAgICAgICBpZiAodGhpcy5kc3RTd2FwLmRzdEVPQVRvRXBoVHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4cyA9IGF3YWl0IGNyZWF0ZVBlcm1pdEFuZFRyYW5zZmVyRnJvbVR4KHtcbiAgICAgICAgICAgICAgICBhbW91bnQ6IHRoaXMuZHN0U3dhcC5kc3RFT0FUb0VwaFR4LmFtb3VudCxcbiAgICAgICAgICAgICAgICBjYWNoZTogdGhpcy5vcHRpb25zLmNhY2hlLFxuICAgICAgICAgICAgICAgIGNoYWluOiB0aGlzLm9wdGlvbnMuY2hhaW5MaXN0LmdldENoYWluQnlJRCh0aGlzLmRzdC5jaGFpbklEKSxcbiAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuZHN0U3dhcC5kc3RFT0FUb0VwaFR4LmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBvd25lcjogdGhpcy5vcHRpb25zLmFkZHJlc3MuZW9hLFxuICAgICAgICAgICAgICAgIG93bmVyV2FsbGV0OiB0aGlzLm9wdGlvbnMud2FsbGV0LmVvYSxcbiAgICAgICAgICAgICAgICBwdWJsaWNDbGllbnQ6IHRoaXMub3B0aW9ucy5wdWJsaWNDbGllbnRMaXN0LmdldCh0aGlzLmRzdC5jaGFpbklEKSxcbiAgICAgICAgICAgICAgICBzcGVuZGVyOiB0aGlzLm9wdGlvbnMuYWRkcmVzcy5lcGhlbWVyYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb25DYWxscyA9IHRoaXMuZGVzdGluYXRpb25DYWxscy5jb25jYXQodHhzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGSVhNRTogTmVlZCB0byBhZGQgcmV0cnkgYW5kIHJlcW91dGVcbiAgICBhc3luYyBwcm9jZXNzKG1ldGFkYXRhKSB7XG4gICAgICAgIGF3YWl0IHRoaXMub3B0aW9ucy53YWxsZXQuZW9hLnN3aXRjaENoYWluKHtcbiAgICAgICAgICAgIGlkOiBOdW1iZXIodGhpcy5vcHRpb25zLmRlc3RpbmF0aW9uQ2hhaW5JRCksXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaGFzRGVzdGluYXRpb25Td2FwID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmRzdFN3YXAucXVvdGUpIHtcbiAgICAgICAgICAgIGhhc0Rlc3RpbmF0aW9uU3dhcCA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlcXVvdGVJZlJlcXVpcmVkKCAvKmlucHV0QW1vdW50Ki8pO1xuICAgICAgICAgICAgY29uc3QgdHhzID0gZ2V0VHhzRnJvbVF1b3RlKHRoaXMuZHN0U3dhcC5hZ2dyZWdhdG9yLCB0aGlzLmRzdFN3YXAucXVvdGUsIHRoaXMuZHN0U3dhcC5yZXEuaW5wdXRUb2tlbiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAodHhzLmFwcHJvdmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkNhbGxzLnB1c2godHhzLmFwcHJvdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb25DYWxscy5wdXNoKHR4cy5zd2FwKTtcbiAgICAgICAgICAgIGxvZ2dlciQyLmRlYnVnKCdzd2FwOmRlc3RpbmF0aW9uQ2FsbHMnLCB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25DYWxsczogdGhpcy5kZXN0aW5hdGlvbkNhbGxzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZXRhZGF0YS5kc3Quc3dhcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgYWdnOiAwLFxuICAgICAgICAgICAgICAgIGlucHV0X2FtdDogdG9CeXRlcyh0eHMuYW1vdW50KSxcbiAgICAgICAgICAgICAgICBpbnB1dF9jb250cmFjdDogdGhpcy5kc3RTd2FwLnJlcS5pbnB1dFRva2VuLFxuICAgICAgICAgICAgICAgIGlucHV0X2RlY2ltYWxzOiB0aGlzLmRzdFN3YXAuZHN0Q2hhaW5DT1QuZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0X2FtdDogY29udmVydFRvMzJCeXRlcyh0aGlzLmRzdC5hbW91bnQgPz8gMCksXG4gICAgICAgICAgICAgICAgb3V0cHV0X2NvbnRyYWN0OiBjb252ZXJ0VG8zMkJ5dGVzKHRoaXMuZHN0LnRva2VuKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRfZGVjaW1hbHM6IHRoaXMuZHN0VG9rZW5JbmZvLmRlY2ltYWxzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Rlc3RpbmF0aW9uU3dhcCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVtaXR0ZXIuZW1pdChERVNUSU5BVElPTl9TV0FQX0JBVENIX1RYKGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU28gd2hhdGV2ZXIgYW1vdW50IGlzIHN3YXBwZWQgZ2V0cyB0cmFuc2ZlcnJlZCBlcGhlbWVyYWwgLT4gZW9hXG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25DYWxscyA9IHRoaXMuZGVzdGluYXRpb25DYWxscy5jb25jYXQoY3JlYXRlU3dlZXBlclR4cyh7XG4gICAgICAgICAgICBjYWNoZTogdGhpcy5vcHRpb25zLmNhY2hlLFxuICAgICAgICAgICAgY2hhaW5JRDogdGhpcy5kc3QuY2hhaW5JRCxcbiAgICAgICAgICAgIENPVEN1cnJlbmN5SUQ6IHRoaXMub3B0aW9ucy5jb3QuY3VycmVuY3lJRCxcbiAgICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLm9wdGlvbnMuYWRkcmVzcy5lb2EsXG4gICAgICAgICAgICBzZW5kZXI6IHRoaXMub3B0aW9ucy5hZGRyZXNzLmVwaGVtZXJhbCxcbiAgICAgICAgICAgIHRva2VuQWRkcmVzczogdGhpcy5kc3QudG9rZW4sXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gRGVzdGluYXRpb24gc3dhcCBiYXRjaGVkIHR4IHRvIFZTQyBhbmQgd2FpdGluZyBmb3IgcmVjZWlwdCAoc3dlZXAgYWZ0ZXIpXG4gICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBwZXJmb3JtRGVzdGluYXRpb25Td2FwKHtcbiAgICAgICAgICAgIGFjdHVhbEFkZHJlc3M6IHRoaXMub3B0aW9ucy5hZGRyZXNzLmVvYSxcbiAgICAgICAgICAgIGNhY2hlOiB0aGlzLm9wdGlvbnMuY2FjaGUsXG4gICAgICAgICAgICBjYWxsczogdGhpcy5kZXN0aW5hdGlvbkNhbGxzLFxuICAgICAgICAgICAgY2hhaW46IHRoaXMub3B0aW9ucy5jaGFpbkxpc3QuZ2V0Q2hhaW5CeUlEKHRoaXMuZHN0LmNoYWluSUQpLFxuICAgICAgICAgICAgY2hhaW5MaXN0OiB0aGlzLm9wdGlvbnMuY2hhaW5MaXN0LFxuICAgICAgICAgICAgQ09UOiB0aGlzLm9wdGlvbnMuY290LmN1cnJlbmN5SUQsXG4gICAgICAgICAgICBlbWl0dGVyOiB0aGlzLm9wdGlvbnMuZW1pdHRlcixcbiAgICAgICAgICAgIGVwaGVtZXJhbEFkZHJlc3M6IHRoaXMub3B0aW9ucy5hZGRyZXNzLmVwaGVtZXJhbCxcbiAgICAgICAgICAgIGVwaGVtZXJhbFdhbGxldDogdGhpcy5vcHRpb25zLndhbGxldC5lcGhlbWVyYWwsXG4gICAgICAgICAgICBoYXNEZXN0aW5hdGlvblN3YXAsXG4gICAgICAgICAgICBwdWJsaWNDbGllbnRMaXN0OiB0aGlzLm9wdGlvbnMucHVibGljQ2xpZW50TGlzdCxcbiAgICAgICAgICAgIHZzY0RvbWFpbjogdGhpcy5vcHRpb25zLm5ldHdvcmtDb25maWcuVlNDX0RPTUFJTixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNEZXN0aW5hdGlvblN3YXApIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbWl0dGVyLmVtaXQoREVTVElOQVRJT05fU1dBUF9CQVRDSF9UWCh0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLmVtaXR0ZXIuZW1pdChTV0FQX0NPTVBMRVRFKTtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyaygneGNzLW9wcy1lbmQnKTtcbiAgICAgICAgbG9nZ2VyJDIuZGVidWcoJ2JlZm9yZSBkc3QgbWV0YWRhdGEnLCB7XG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGFkYXRhLmRzdC50eF9oYXNoID0gY29udmVydFRvMzJCeXRlcyhoYXNoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVxdW90ZUlmUmVxdWlyZWQoKSB7XG4gICAgICAgIGxldCByZXF1b3RlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmRzdFN3YXAuYWdncmVnYXRvciBpbnN0YW5jZW9mIEJlYm9wQWdncmVnYXRvcikge1xuICAgICAgICAgICAgY29uc3QgcXVvdGUgPSB0aGlzLmRzdFN3YXAucXVvdGU7XG4gICAgICAgICAgICBpZiAocXVvdGUub3JpZ2luYWxSZXNwb25zZS5xdW90ZS5leHBpcnkgKiAxMDAwIDwgRGF0ZS5ub3coKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQyLmRlYnVnKCdERFM6IEJFQk9QJywge1xuICAgICAgICAgICAgICAgICAgICBleHBpcnk6IHF1b3RlLm9yaWdpbmFsUmVzcG9uc2UucXVvdGUuZXhwaXJ5ICogMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgbm93OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlcXVvdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKERhdGUubm93KCkgLSB0aGlzLmRzdFN3YXAuY3JlYXRlZEF0ID4gbWludXRlc1RvTXMoMC40KSkge1xuICAgICAgICAgICAgcmVxdW90ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSBpZiAodGhpcy5kc3RTd2FwLnF1b3RlPy5pbnB1dEFtb3VudCAhPT0gaW5wdXRBbW91bnQpIHtcbiAgICAgICAgLy8gICByZXF1b3RlID0gdHJ1ZTtcbiAgICAgICAgLy8gfVxuICAgICAgICBpZiAocmVxdW90ZSkge1xuICAgICAgICAgICAgY29uc3QgZGRzUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmRzdFN3YXAuZ2V0RERTKCk7XG4gICAgICAgICAgICBpZiAoIWRkc1Jlc3BvbnNlLnF1b3RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVxdW90ZSBEUycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyJDIuZGVidWcoJ3JlcW91dGVkRHN0U3dhcCcsIHtcbiAgICAgICAgICAgICAgICBpbnB1dEFtb3VudFdpdGhCdWZmZXI6IHRoaXMuZHN0U3dhcC5pbnB1dEFtb3VudFdpdGhCdWZmZXIudG9GaXhlZCgpLFxuICAgICAgICAgICAgICAgIG5ld0lucHV0QW1vdW50OiBkZHNSZXNwb25zZS5pbnB1dEFtb3VudC50b0ZpeGVkKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGlzRXhhY3RJbiA9IHRoaXMuZHN0LmFtb3VudCA9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIWlzRXhhY3RJbiAmJiBkZHNSZXNwb25zZS5pbnB1dEFtb3VudC5ndCh0aGlzLmRzdFN3YXAuaW5wdXRBbW91bnRXaXRoQnVmZmVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmF0ZXMgY2hhbmdlZCBmb3IgZGVzdGluYXRpb24gc3dhcCBhbmQgY291bGQgbm90IGJlIGZpbGxlZCBldmVuIHdpdGggYnVmZmVyLiBCZWZvcmU6ICR7dGhpcy5kc3RTd2FwLmlucHV0QW1vdW50V2l0aEJ1ZmZlci50b0ZpeGVkKCl9ICxBZnRlcjogJHtkZHNSZXNwb25zZS5pbnB1dEFtb3VudC50b0ZpeGVkKCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRzdFN3YXAgPSB7IC4uLmRkc1Jlc3BvbnNlLCBnZXRERFM6IHRoaXMuZHN0U3dhcC5nZXRERFMgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNvdXJjZVN3YXBzSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IocXVvdGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZUNhY2hlID0ge307XG4gICAgICAgIHRoaXMuc3dhcHMgPSB0aGlzLmdyb3VwQW5kT3JkZXIocXVvdGVzKTtcbiAgICAgICAgZm9yIChjb25zdCBbY2hhaW5JRCwgc3dhcFF1b3Rlc10gb2YgdGhpcy5pdGVyYXRlKHRoaXMuc3dhcHMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY2FjaGUuYWRkU2V0Q29kZVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLm9wdGlvbnMuYWRkcmVzcy5lcGhlbWVyYWwsXG4gICAgICAgICAgICAgICAgY2hhaW5JRDogTnVtYmVyKGNoYWluSUQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNRdW90ZSBvZiBzd2FwUXVvdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNhY2hlLmFkZEFsbG93YW5jZVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JRDogTnVtYmVyKGNoYWluSUQpLFxuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnZlcnRUb0VWTUFkZHJlc3Moc1F1b3RlLmlucHV0LnJlcS5pbnB1dFRva2VuKSxcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXMub3B0aW9ucy5hZGRyZXNzLmVvYSxcbiAgICAgICAgICAgICAgICAgICAgc3BlbmRlcjogdGhpcy5vcHRpb25zLmFkZHJlc3MuZXBoZW1lcmFsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jYWNoZS5hZGRBbGxvd2FuY2VRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSUQ6IE51bWJlcihjaGFpbklEKSxcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBjb252ZXJ0VG9FVk1BZGRyZXNzKHNRdW90ZS5pbnB1dC5yZXEuaW5wdXRUb2tlbiksXG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzLm9wdGlvbnMuYWRkcmVzcy5lcGhlbWVyYWwsXG4gICAgICAgICAgICAgICAgICAgIHNwZW5kZXI6IFNXRUVQRVJfQUREUkVTUyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTd2Fwc0FuZE1ldGFkYXRhKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHN3YXBzID0gW107XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3dhcCBvZiBpbnB1dCkge1xuICAgICAgICAgICAgY29uc3QgdGQgPSBzd2FwLmdldFR4c0RhdGEoKTtcbiAgICAgICAgICAgIGNvbnN0IG1kID0gc3dhcC5nZXRNZXRhZGF0YSgpO1xuICAgICAgICAgICAgbWV0YWRhdGEucHVzaChtZCk7XG4gICAgICAgICAgICBzd2Fwcy5wdXNoKHRkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtZXRhZGF0YSwgc3dhcHMgfTtcbiAgICB9XG4gICAgKml0ZXJhdGUoaW5wdXQpIHtcbiAgICAgICAgZm9yIChjb25zdCBbY2hhaW5JRCwgc3dhcHNdIG9mIGlucHV0KSB7XG4gICAgICAgICAgICBjb25zdCBkID0gc3dhcHMubWFwKChzd2FwKSA9PiBuZXcgU3dhcChzd2FwKSk7XG4gICAgICAgICAgICB5aWVsZCBbY2hhaW5JRCwgZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcHJvY2VzcyhtZXRhZGF0YSwgaW5wdXQgPSB0aGlzLnN3YXBzLCByZXRyeSA9IHRydWUpIHtcbiAgICAgICAgbG9nZ2VyJDIuZGVidWcoJ3NvdXJjZVN3YXBzSGFuZGxlcicsIHtcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICByZXRyeSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHdhaXRpbmdQcm9taXNlcyA9IFtdO1xuICAgICAgICBjb25zdCBjaGFpbnMgPSBbXTtcbiAgICAgICAgY29uc3QgYXNzZXRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2NoYWluSUQsIHN3YXBRdW90ZXNdIG9mIHRoaXMuaXRlcmF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNoYWlucy5wdXNoKGNoYWluSUQpO1xuICAgICAgICAgICAgY29uc3Qgc2JjQ2FsbHMgPSB7XG4gICAgICAgICAgICAgICAgY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YVR4ID0ge1xuICAgICAgICAgICAgICAgIGNoaWQ6IGNvbnZlcnRUbzMyQnl0ZXMoY2hhaW5JRCksXG4gICAgICAgICAgICAgICAgc3dhcHM6IFtdLFxuICAgICAgICAgICAgICAgIHR4X2hhc2g6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICAgICAgdW5pdjogVW5pdmVyc2UuRVRIRVJFVU0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgeyBtZXRhZGF0YTogbXRkLCBzd2FwcyB9ID0gdGhpcy5nZXRTd2Fwc0FuZE1ldGFkYXRhKHN3YXBRdW90ZXMpO1xuICAgICAgICAgICAgY29uc3QgcHVibGljQ2xpZW50ID0gdGhpcy5vcHRpb25zLnB1YmxpY0NsaWVudExpc3QuZ2V0KGNoYWluSUQpO1xuICAgICAgICAgICAgY29uc3QgY2hhaW4gPSB0aGlzLm9wdGlvbnMuY2hhaW5MaXN0LmdldENoYWluQnlJRChOdW1iZXIoY2hhaW5JRCkpO1xuICAgICAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2hhaW4gbm90IGZvdW5kOiAke2NoYWluSUR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIkMi5kZWJ1Zygnc3JjU3dhcEhhbmRsZXI6cHJvY2VzcycsIHtcbiAgICAgICAgICAgICAgICBzd2FwcyxcbiAgICAgICAgICAgICAgICBtdGQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1ldGFkYXRhVHguc3dhcHMgPSBtZXRhZGF0YVR4LnN3YXBzLmNvbmNhdChtdGQpO1xuICAgICAgICAgICAgLy8gMS4gU291cmNlIHN3YXAgY2FsbHNcbiAgICAgICAgICAgIGxldCBhbW91bnQgPSAwbjtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN3YXAgb2Ygc3dhcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50ICs9IHN3YXAub3V0cHV0QW1vdW50O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHN5bWJvbCB9ID0gZ2V0VG9rZW5EZWNpbWFscyhOdW1iZXIoY2hhaW5JRCksIHN3YXAuaW5wdXRUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hdGl2ZUFkZHJlc3MoY29udmVydFRvRVZNQWRkcmVzcyhzd2FwLmlucHV0VG9rZW4pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2JjQ2FsbHMudmFsdWUgKz0gc3dhcC5hbW91bnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZW1pdHRlci5lbWl0KENSRUFURV9QRVJNSVRfRk9SX1NPVVJDRV9TV0FQKGZhbHNlLCBzeW1ib2wsIGNoYWluKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxvd2FuY2VDYWNoZUtleSA9IGdldEFsbG93YW5jZUNhY2hlS2V5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklEOiBjaGFpbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnZlcnRUb0VWTUFkZHJlc3Moc3dhcC5pbnB1dFRva2VuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogdGhpcy5vcHRpb25zLmFkZHJlc3MuZW9hLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZW5kZXI6IHRoaXMub3B0aW9ucy5hZGRyZXNzLmVwaGVtZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHhzID0gYXdhaXQgY3JlYXRlUGVybWl0QW5kVHJhbnNmZXJGcm9tVHgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogc3dhcC5hbW91bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwcm92YWw6IHRoaXMuZGlzcG9zYWJsZUNhY2hlW2FsbG93YW5jZUNhY2hlS2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogdGhpcy5vcHRpb25zLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udmVydFRvRVZNQWRkcmVzcyhzd2FwLmlucHV0VG9rZW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzLm9wdGlvbnMuYWRkcmVzcy5lb2EsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJXYWxsZXQ6IHRoaXMub3B0aW9ucy53YWxsZXQuZW9hLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpY0NsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVuZGVyOiB0aGlzLm9wdGlvbnMuYWRkcmVzcy5lcGhlbWVyYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcHJvdmFsICYgdHJhbnNmZXJGcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHhzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwcHJvdmFsVHggPSB0eHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlQ2FjaGVbYWxsb3dhbmNlQ2FjaGVLZXldID0gYXBwcm92YWxUeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbWl0dGVyLmVtaXQoQ1JFQVRFX1BFUk1JVF9GT1JfU09VUkNFX1NXQVAodHJ1ZSwgc3ltYm9sLCBjaGFpbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDIuZGVidWcoJ3NvdXJjZVN3YXAnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJtaXRDYWxsczogdHhzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3YXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNiY0NhbGxzLmNhbGxzLnB1c2goLi4udHhzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3dhcC5hcHByb3ZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2JjQ2FsbHMuY2FsbHMucHVzaChzd2FwLmFwcHJvdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzYmNDYWxscy5jYWxscy5wdXNoKHN3YXAuc3dhcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMi4gQ3JlYXRlIGJhdGNoZWQgY2FsbHNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoc2JjQ2FsbHMudmFsdWUgPiAwbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShhd2FpdCBjaGVja0F1dGhDb2RlU2V0KE51bWJlcihjaGFpbklEKSwgdGhpcy5vcHRpb25zLmFkZHJlc3MuZXBoZW1lcmFsLCB0aGlzLm9wdGlvbnMuY2FjaGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BzID0gYXdhaXQgdnNjU0JDVHgoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNyZWF0ZVNCQ1R4RnJvbUNhbGxzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHRoaXMub3B0aW9ucy5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklEOiBjaGFpbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsQWRkcmVzczogdGhpcy5vcHRpb25zLmFkZHJlc3MuZXBoZW1lcmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcGhlbWVyYWxXYWxsZXQ6IHRoaXMub3B0aW9ucy53YWxsZXQuZXBoZW1lcmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNDbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCB0aGlzLm9wdGlvbnMubmV0d29ya0NvbmZpZy5WU0NfRE9NQUlOKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciQyLmRlYnVnKCdTZXRBdXRoQ29kZVdpdGhvdXRDYWxscycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JTQkNUeFJlY2VpcHQob3BzLCB0aGlzLm9wdGlvbnMuY2hhaW5MaXN0LCB0aGlzLm9wdGlvbnMucHVibGljQ2xpZW50TGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBrbm93IGl0cyBzZXQgc2luY2Ugd2UgZ290IHJlY2VpcHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgc28gaWYgd2UgY29tZSBiYWNrIG9uIHJldHJ5IGl0IGlzIGFscmVhZHkgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuY2FjaGUuYWRkU2V0Q29kZVZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLm9wdGlvbnMuYWRkcmVzcy5lcGhlbWVyYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JRDogTnVtYmVyKGNoYWluSUQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgRVhQRUNURURfQ0FMSUJVUl9DT0RFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm9wdGlvbnMud2FsbGV0LmVvYS5zd2l0Y2hDaGFpbih7IGlkOiBOdW1iZXIoY2hhaW5JRCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIEVPQSBjcmVhdGVzICYgc2VuZHMgdHgge1xuICAgICAgICAgICAgICAgICAgICAgICB0bzogZXBoZW1lcmFsQWRkcmVzcyAod2UgY2hlY2sgYWJvdmUgaXQgaXRzIGRlbGVnYXRlZCB0byBjYWxpYnVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNiY0NhbGxzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBTaWduVXNpbmdFcGhlbWVyYWwoQWdncmVnYXRvclR4KGFwcHJvdmFsKGlmZiBub24gbmF0aXZlIGlzIGludm9sdmVkKSBhbmQgc3dhcCkpXG4gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgY2FsaWJ1ckV4ZWN1dGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsQWRkcmVzczogdGhpcy5vcHRpb25zLmFkZHJlc3MuZW9hLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsV2FsbGV0OiB0aGlzLm9wdGlvbnMud2FsbGV0LmVvYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxzOiBzYmNDYWxscy5jYWxscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsQWRkcmVzczogdGhpcy5vcHRpb25zLmFkZHJlc3MuZXBoZW1lcmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsV2FsbGV0OiB0aGlzLm9wdGlvbnMud2FsbGV0LmVwaGVtZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzYmNDYWxscy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVHgudHhfaGFzaCA9IGNvbnZlcnRUbzMyQnl0ZXMoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbWl0dGVyLmVtaXQoU09VUkNFX1NXQVBfSEFTSChbQmlnSW50KGNoYWluLmlkKSwgaGFzaF0sIHRoaXMub3B0aW9ucy5jaGFpbkxpc3QpKTtcbiAgICAgICAgICAgICAgICAgICAgd2FpdGluZ1Byb21pc2VzLnB1c2god3JhcChOdW1iZXIoY2hhaW5JRCksIHdhaXRGb3JUeFJlY2VpcHQoaGFzaCwgcHVibGljQ2xpZW50LCAyKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDIuZGVidWcoJ3NvdXJjZVN3YXBzSGFuZGxlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxzOiBzYmNDYWxscy5jYWxscyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRpbmdQcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMi5kZWJ1Zygnd2FpdGluZ1Byb21pc2VzOjEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wcyA9IGF3YWl0IHZzY1NCQ1R4KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjcmVhdGVTQkNUeEZyb21DYWxscyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiB0aGlzLm9wdGlvbnMuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxzOiBzYmNDYWxscy5jYWxscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JRDogY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbEFkZHJlc3M6IHRoaXMub3B0aW9ucy5hZGRyZXNzLmVwaGVtZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsV2FsbGV0OiB0aGlzLm9wdGlvbnMud2FsbGV0LmVwaGVtZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljQ2xpZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgdGhpcy5vcHRpb25zLm5ldHdvcmtDb25maWcuVlNDX0RPTUFJTik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbY2hhaW5JRCwgaGFzaF0gPSBvcHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVR4LnR4X2hhc2ggPSBjb252ZXJ0VG8zMkJ5dGVzKGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVtaXR0ZXIuZW1pdChTT1VSQ0VfU1dBUF9IQVNIKFtjaGFpbklELCBoYXNoXSwgdGhpcy5vcHRpb25zLmNoYWluTGlzdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXAoTnVtYmVyKGNoYWluSUQpLCB3YWl0Rm9yVHhSZWNlaXB0KGhhc2gsIHRoaXMub3B0aW9ucy5wdWJsaWNDbGllbnRMaXN0LmdldChjaGFpbklEKSwgMikpO1xuICAgICAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NldHMucHVzaCh7XG4gICAgICAgICAgICAgICAgYW1vdW50OiBkaXZEZWNpbWFscyhhbW91bnQsIGdldFRva2VuRGVjaW1hbHMoTnVtYmVyKGNoYWluSUQpLCBzd2Fwc1swXS5vdXRwdXRUb2tlbikuZGVjaW1hbHMpLFxuICAgICAgICAgICAgICAgIGNoYWluSUQ6IE51bWJlcihjaGFpbklEKSxcbiAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGNvbnZlcnRUb0VWTUFkZHJlc3Moc3dhcHNbMF0ub3V0cHV0VG9rZW4pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZXRhZGF0YS5zcmMucHVzaChtZXRhZGF0YVR4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBDaGVjayBzdGF0dXMgb2YgYWxsIHNvdXJjZSBzd2Fwc1xuICAgICAgICAvLyBSZWZ1bmQgQ09UKEVwaGVtZXJhbCAtPiBFT0EpIG9uIGZhaWx1cmUgb2YgYW55IHNvdXJjZSBzd2FwIHBvc3QgcmV0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHdhaXRpbmdQcm9taXNlcyk7XG4gICAgICAgICAgICBjb25zdCBzb21lU3JjU3dhcEZhaWxlZCA9IHJlc3BvbnNlcy5zb21lKChyKSA9PiByLnN0YXR1cyA9PT0gJ3JlamVjdGVkJyk7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZnVsU3dhcHMgPSByZXNwb25zZXMuZmlsdGVyKChyKSA9PiByLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpLm1hcCgocikgPT4gci52YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBmYWlsZWRDaGFpbnMgPSBjaGFpbnMuZmlsdGVyKChjKSA9PiAhc3VjY2Vzc2Z1bFN3YXBzLmluY2x1ZGVzKE51bWJlcihjKSkpO1xuICAgICAgICAgICAgbG9nZ2VyJDIuZGVidWcoJ3NvdXJjZVN3YXBQcm9jZXNzUmVzdWx0cycsIHtcbiAgICAgICAgICAgICAgICBmYWlsZWRDaGFpbnMsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VzLFxuICAgICAgICAgICAgICAgIHJldHJ5LFxuICAgICAgICAgICAgICAgIHNvbWVTcmNTd2FwRmFpbGVkLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NmdWxTd2FwcyxcbiAgICAgICAgICAgICAgICB3YWl0aW5nUHJvbWlzZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFN3ZWVwIGZyb20gYWxsIG90aGVyIHNyYyBzd2FwIGlmIGFueSBmYWlsZWRcbiAgICAgICAgICAgIGlmIChzb21lU3JjU3dhcEZhaWxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJldHJ5V2l0aFNsaXBwYWdlQ2hlY2sobWV0YWRhdGEsIGZhaWxlZENoYWlucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciQyLmRlYnVnKCdzcmMgc3dwIGZhaWxlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NmdWxTd2FwcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2JjVHhzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoYWluSUQgb2Ygc3VjY2Vzc2Z1bFN3YXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2JjVHhzLnB1c2goYXdhaXQgY3JlYXRlU0JDVHhGcm9tQ2FsbHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogdGhpcy5vcHRpb25zLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsczogY3JlYXRlU3dlZXBlclR4cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogdGhpcy5vcHRpb25zLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPVEN1cnJlbmN5SUQ6IHRoaXMub3B0aW9ucy5jb3QuY3VycmVuY3lJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLm9wdGlvbnMuYWRkcmVzcy5lb2EsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXI6IHRoaXMub3B0aW9ucy5hZGRyZXNzLmVwaGVtZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSUQ6IGNoYWluSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwaGVtZXJhbEFkZHJlc3M6IHRoaXMub3B0aW9ucy5hZGRyZXNzLmVwaGVtZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBoZW1lcmFsV2FsbGV0OiB0aGlzLm9wdGlvbnMud2FsbGV0LmVwaGVtZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljQ2xpZW50OiB0aGlzLm9wdGlvbnMucHVibGljQ2xpZW50TGlzdC5nZXQoY2hhaW5JRCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHMgPSBhd2FpdCB2c2NTQkNUeChzYmNUeHMsIHRoaXMub3B0aW9ucy5uZXR3b3JrQ29uZmlnLlZTQ19ET01BSU4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JTQkNUeFJlY2VpcHQob3BzLCB0aGlzLm9wdGlvbnMuY2hhaW5MaXN0LCB0aGlzLm9wdGlvbnMucHVibGljQ2xpZW50TGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogV2hhdCB0byBkbyBoZXJlPyBTdG9yZSBpdCBvciBzb21ldGhpbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBzd2FwIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvbWUgc291cmNlIHN3YXAgZmFpbGVkIGV2ZW4gYWZ0ZXIgcmV0cnknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXNzZXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJldHJ5V2l0aFNsaXBwYWdlQ2hlY2sobWV0YWRhdGEsIGZhaWxlZENoYWlucykge1xuICAgICAgICBsZXQgb2xkVG90YWxPdXRwdXRBbW91bnQgPSAwbjtcbiAgICAgICAgbG9nZ2VyJDIuZGVidWcoJ3NvdXJjZVN3YXBzSGFuZGxlcjpyZXRyeVdpdGhTbGlwcGFnZUNoZWNrOjAnLCB7XG4gICAgICAgICAgICBmYWlsZWRDaGFpbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBxdW90ZVJlc3BvbnNlcyA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHF1b3RlUmVxdWVzdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIGlmIGl0IGNvbWVzIHRvIHJldHJ5IGl0IHNob3VsZCBiZSBzZXQgdG8gMFxuICAgICAgICAgICAgb2xkVG90YWxPdXRwdXRBbW91bnQgPSAwbjtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZkNoYWluIG9mIGZhaWxlZENoYWlucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFF1b3RlcyA9IHRoaXMuc3dhcHMuZ2V0KGZDaGFpbik7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRRdW90ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDIuZGVidWcoJ2hvdyBjYW4gb2xkIHF1b3RlIG5vdCBiZSB0aGVyZT8/Pz8gd2UgYXJlIGl0ZXJhdGluZyBvbiBpdCcpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvcSBvZiBvbGRRdW90ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkVG90YWxPdXRwdXRBbW91bnQgKz0gb3EucXVvdGUub3V0cHV0QW1vdW50TWluaW11bTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDIuZGVidWcoJ3JldHJ5V2l0aFNsaXBwYWdlOnF1b3RlUmVxdWVzdHM6MScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IG9xLnF1b3RlLmlucHV0QW1vdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuQWRkcmVzczogb3EucmVxLmlucHV0VG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGVSZXF1ZXN0cy5wdXNoKGxpcXVpZGF0ZUlucHV0SG9sZGluZ3Mob3EucmVxLnVzZXJBZGRyZXNzLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3Eub3JpZ2luYWxIb2xkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogb3EucXVvdGUuaW5wdXRBbW91bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiBvcS5yZXEuaW5wdXRUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sIHRoaXMub3B0aW9ucy5hZ2dyZWdhdG9ycywgW10sIG9xLmN1ci5jdXJyZW5jeUlEKS50aGVuKChucSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDIuZGVidWcoJ3JldHJ5V2l0aFNsaXBwYWdlOnF1b3RlUmVxdWVzdHM6MicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5xLnF1b3Rlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChxdW90ZVJlcXVlc3RzKTtcbiAgICAgICAgfSwgMik7XG4gICAgICAgIGxvZ2dlciQyLmRlYnVnKCdzb3VyY2VTd2Fwc0hhbmRsZXI6cmV0cnlXaXRoU2xpcHBhZ2VDaGVjazoxJywge1xuICAgICAgICAgICAgb2xkVG90YWxPdXRwdXRBbW91bnQsXG4gICAgICAgICAgICBxdW90ZVJlc3BvbnNlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBuZXdUb3RhbE91dHB1dEFtb3VudCA9IDBuO1xuICAgICAgICBmb3IgKGNvbnN0IHEgb2YgcXVvdGVSZXNwb25zZXMpIHtcbiAgICAgICAgICAgIG5ld1RvdGFsT3V0cHV0QW1vdW50ICs9IHEucXVvdGUub3V0cHV0QW1vdW50TWluaW11bTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWZmID0gb2xkVG90YWxPdXRwdXRBbW91bnQgLSBuZXdUb3RhbE91dHB1dEFtb3VudDtcbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNTd2FwUXVvdGVWYWxpZCh7XG4gICAgICAgICAgICAgICAgbmV3QW1vdW50OiBuZXdUb3RhbE91dHB1dEFtb3VudCxcbiAgICAgICAgICAgICAgICBvbGRBbW91bnQ6IG9sZFRvdGFsT3V0cHV0QW1vdW50LFxuICAgICAgICAgICAgICAgIHNsaXBwYWdlOiB0aGlzLm9wdGlvbnMuc2xpcHBhZ2UsXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2xpcHBhZ2UgZ3JlYXRlciB0aGFuIG1heCBzbGlwcGFnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvZ2dlciQyLmRlYnVnKCdzb3VyY2VTd2Fwc0hhbmRsZXI6cmV0cnlXaXRoU2xpcHBhZ2VDaGVjazoyJywge1xuICAgICAgICAgICAgZGlmZixcbiAgICAgICAgICAgIG5ld1RvdGFsT3V0cHV0QW1vdW50LFxuICAgICAgICAgICAgb2xkVG90YWxPdXRwdXRBbW91bnQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzKG1ldGFkYXRhLCB0aGlzLmdyb3VwQW5kT3JkZXIocXVvdGVSZXNwb25zZXMpLCBmYWxzZSk7XG4gICAgfVxuICAgIGdyb3VwQW5kT3JkZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE1hcC5ncm91cEJ5KG9yZGVyQnkoaW5wdXQsIFtcbiAgICAgICAgICAgIChzKSA9PiBcbiAgICAgICAgICAgIC8vIGlmIG5hdGl2ZSBjdXJyZW5jeSBpcyBpbnZvbHZlZCBtb3ZlIGl0IHVwXG4gICAgICAgICAgICBlcXVhbEZvbGQoY29udmVydFRvRVZNQWRkcmVzcyhzLnJlcS5pbnB1dFRva2VuKSwgRUFERFJFU1MpID8gLTEgOiAxLFxuICAgICAgICBdLCBbJ2FzYyddKSwgKHMpID0+IHMucmVxLmNoYWluLmNoYWluSUQpO1xuICAgIH1cbiAgICBpc1N3YXBRdW90ZVZhbGlkKHsgbmV3QW1vdW50LCBvbGRBbW91bnQsIHNsaXBwYWdlLCB9KSB7XG4gICAgICAgIGNvbnN0IG1pbkFjY2VwdGFibGUgPSBEZWNpbWFsLm11bChvbGRBbW91bnQsIERlY2ltYWwuc3ViKDEsIHNsaXBwYWdlKSk7XG4gICAgICAgIGxvZ2dlciQyLmRlYnVnKCdpc1N3YXBRdW90ZVZhbGlkJywge1xuICAgICAgICAgICAgbWluQWNjZXB0YWJsZTogbWluQWNjZXB0YWJsZS50b0ZpeGVkKCksXG4gICAgICAgICAgICBuZXdBbW91bnQsXG4gICAgICAgICAgICBvbGRBbW91bnQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwobmV3QW1vdW50KS5ndGUobWluQWNjZXB0YWJsZSk7XG4gICAgfVxufVxuY2xhc3MgU3dhcCB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnR4cyA9IG51bGw7XG4gICAgfVxuICAgIGdldE1ldGFkYXRhKCkge1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLmdldFR4c0RhdGEoKTtcbiAgICAgICAgY29uc3QgeyBkZWNpbWFsczogaW5wdXREZWNpbWFscyB9ID0gZ2V0VG9rZW5EZWNpbWFscyhOdW1iZXIodGhpcy5pbnB1dC5yZXEuY2hhaW4uY2hhaW5JRCksIHRoaXMuaW5wdXQucmVxLmlucHV0VG9rZW4pO1xuICAgICAgICBjb25zdCB7IGRlY2ltYWxzOiBvdXRwdXREZWNpbWFscyB9ID0gZ2V0VG9rZW5EZWNpbWFscyhOdW1iZXIodGhpcy5pbnB1dC5yZXEuY2hhaW4uY2hhaW5JRCksIHRoaXMuaW5wdXQucmVxLm91dHB1dFRva2VuKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFnZzogMSxcbiAgICAgICAgICAgIGlucHV0X2FtdDogY29udmVydFRvMzJCeXRlcyh0aGlzLmlucHV0LnJlcS5pbnB1dEFtb3VudCksXG4gICAgICAgICAgICBpbnB1dF9jb250cmFjdDogdGhpcy5pbnB1dC5yZXEuaW5wdXRUb2tlbixcbiAgICAgICAgICAgIGlucHV0X2RlY2ltYWxzOiBpbnB1dERlY2ltYWxzLFxuICAgICAgICAgICAgb3V0cHV0X2FtdDogY29udmVydFRvMzJCeXRlcyh0eHMuYW1vdW50KSxcbiAgICAgICAgICAgIG91dHB1dF9jb250cmFjdDogdGhpcy5pbnB1dC5yZXEub3V0cHV0VG9rZW4sXG4gICAgICAgICAgICBvdXRwdXRfZGVjaW1hbHM6IG91dHB1dERlY2ltYWxzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRUeHNEYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZ2V0VHhzRnJvbVF1b3RlKHRoaXMuaW5wdXQuYWdnLCB0aGlzLmlucHV0LnF1b3RlLCB0aGlzLmlucHV0LnJlcS5pbnB1dFRva2VuLCAhYnl0ZXNFcXVhbChFQUREUkVTU18zMl9CWVRFUywgdGhpcy5pbnB1dC5yZXEuaW5wdXRUb2tlbikpLFxuICAgICAgICAgICAgb3V0cHV0VG9rZW46IHRoaXMuaW5wdXQucmVxLm91dHB1dFRva2VuLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIGNsYXNzIFN3YXBHcm91cCB7XG4vLyAgIHJlcXVvdGVkID0gdHJ1ZTtcbi8vICAgY29uc3RydWN0b3IoXG4vLyAgICAgcHVibGljIHN3YXBzOiBTd2FwW10sXG4vLyAgICAgcHVibGljIGNoYWluSUQ6IG51bWJlcixcbi8vICAgKSB7fVxuLy8gICBleGVjdXRlKCkge1xuLy8gICAgIC8vIFJlcXVvdGVcbi8vICAgICAvLyBFeGVjdXRlXG4vLyAgIH1cbi8vICAgcmVxdW90ZSgpIHt9XG4vLyB9XG5jb25zdCB3cmFwID0gYXN5bmMgKGNoYWluSUQsIHByb21pc2UpID0+IHtcbiAgICBhd2FpdCBwcm9taXNlO1xuICAgIHJldHVybiBjaGFpbklEO1xufTtcblxuY29uc3QgbG9nZ2VyJDEgPSBnZXRMb2dnZXIoKTtcbmNvbnN0IEVycm9yVXNlckRlbmllZEludGVudCA9IG5ldyBFcnJvcignVXNlciBkZW5pZWQgc3dhcCcpO1xuY29uc3Qgc3dhcCA9IGFzeW5jIChpbnB1dCwgb3B0aW9ucywgQ09UID0gQ3VycmVuY3lJRCQxLlVTREMpID0+IHtcbiAgICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKCk7XG4gICAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcygpO1xuICAgIGNvbnN0IHB1YmxpY0NsaWVudExpc3QgPSBuZXcgUHVibGljQ2xpZW50TGlzdChvcHRpb25zLmNoYWluTGlzdCk7XG4gICAgY29uc3QgY2FjaGUgPSBuZXcgQ2FjaGUocHVibGljQ2xpZW50TGlzdCk7XG4gICAgY29uc3QgZHN0Q2hhaW4gPSBvcHRpb25zLmNoYWluTGlzdC5nZXRDaGFpbkJ5SUQoaW5wdXQuZGF0YS50b0NoYWluSWQpO1xuICAgIGlmICghZHN0Q2hhaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXN0aW5hdGlvbiBjaGFpbiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3N3YXAtc3RhcnQnKTtcbiAgICBjb25zdCBlbWl0dGVyID0ge1xuICAgICAgICBlbWl0OiAoc3RlcCkgPT4ge1xuICAgICAgICAgICAgb3B0aW9ucy5lbWl0KCdzd2FwX3N0ZXAnLCBzdGVwKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGVtaXR0ZXIuZW1pdChTV0FQX1NUQVJUKTtcbiAgICBsb2dnZXIkMS5kZWJ1Zygnc3dhcEJlZ2luJywgeyBvcHRpb25zLCBpbnB1dCB9KTtcbiAgICBwZXJmb3JtYW5jZS5tYXJrKCdkZXRlcm1pbmUtc3dhcHMtc3RhcnQnKTtcbiAgICBlbWl0dGVyLmVtaXQoREVURVJNSU5JTkdfU1dBUCgpKTtcbiAgICBjb25zdCBhZ2dyZWdhdG9ycyA9IFtcbiAgICAgICAgbmV3IExpRmlBZ2dyZWdhdG9yKExJRklfQVBJX0tFWSksXG4gICAgICAgIG5ldyBCZWJvcEFnZ3JlZ2F0b3IoQkVCT1BfQVBJX0tFWSksXG4gICAgICAgIC8vIG5ldyBaZXJvRXhBZ2dyZWdhdG9yKFpFUk9fWF9BUElfS0VZKSxcbiAgICBdO1xuICAgIGNvbnN0IHN3YXBSb3V0ZVBhcmFtcyA9IHsgLi4ub3B0aW9ucywgYWdncmVnYXRvcnMsIGNvdEN1cnJlbmN5SUQ6IENPVCB9O1xuICAgIGNvbnN0IFtzd2FwUm91dGUsIGRzdFRva2VuSW5mb10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGRldGVybWluZVN3YXBSb3V0ZShpbnB1dCwgc3dhcFJvdXRlUGFyYW1zKSxcbiAgICAgICAgZ2V0VG9rZW5JbmZvKGlucHV0LmRhdGEudG9Ub2tlbkFkZHJlc3MsIHB1YmxpY0NsaWVudExpc3QuZ2V0KGlucHV0LmRhdGEudG9DaGFpbklkKSwgZHN0Q2hhaW4pLFxuICAgIF0pO1xuICAgIGxvZ2dlciQxLmRlYnVnKCdpbml0aWFsLXN3YXAtcm91dGUnLCB7XG4gICAgICAgIGRzdFRva2VuSW5mbyxcbiAgICAgICAgc3dhcFJvdXRlLFxuICAgIH0pO1xuICAgIGxldCB7IGFzc2V0c1VzZWQsIGJyaWRnZUlucHV0LCBkZXN0aW5hdGlvblN3YXAsIHNvdXJjZVN3YXBzIH0gPSBzd2FwUm91dGU7XG4gICAgbG9nZ2VyJDEuZGVidWcoJ2luaXRpYWwtc3dhcC1yb3V0ZScsIHtcbiAgICAgICAgYXNzZXRzVXNlZCxcbiAgICAgICAgYnJpZGdlSW5wdXQsXG4gICAgICAgIGRlc3RpbmF0aW9uU3dhcCxcbiAgICAgICAgZHN0VG9rZW5JbmZvLFxuICAgICAgICBzb3VyY2VTd2FwcyxcbiAgICAgICAgc3dhcFJvdXRlLFxuICAgIH0pO1xuICAgIGVtaXR0ZXIuZW1pdChERVRFUk1JTklOR19TV0FQKHRydWUpKTtcbiAgICBwZXJmb3JtYW5jZS5tYXJrKCdkZXRlcm1pbmUtc3dhcHMtZW5kJyk7XG4gICAgcGVyZm9ybWFuY2UubWFyaygneGNzLW9wcy1zdGFydCcpO1xuICAgIC8vIFN3YXAgSW50ZW50IGhvb2sgaGFuZGxpbmdcbiAgICB7XG4gICAgICAgIGlmIChvcHRpb25zPy5zd2FwSW50ZW50SG9vaykge1xuICAgICAgICAgICAgY29uc3QgaG9vayA9IG9wdGlvbnM/LnN3YXBJbnRlbnRIb29rO1xuICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgYW1vdW50OiBkaXZEZWNpbWFscyhpbnB1dC5tb2RlID09PSBTd2FwTW9kZS5FWEFDVF9PVVQgPyBpbnB1dC5kYXRhLnRvQW1vdW50IDogZGVzdGluYXRpb25Td2FwLm91dHB1dEFtb3VudCwgZHN0VG9rZW5JbmZvLmRlY2ltYWxzKS50b0ZpeGVkKCksXG4gICAgICAgICAgICAgICAgY2hhaW5JRDogaW5wdXQuZGF0YS50b0NoYWluSWQsXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBpbnB1dC5kYXRhLnRvVG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBkc3RUb2tlbkluZm8uZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBkc3RUb2tlbkluZm8uc3ltYm9sLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBhY2NlcHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcmVmcmVzaCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWNjZXB0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDEud2FybignU3dhcCBJbnRlbnQgcmVmcmVzaCBjYWxsZWQgYWZ0ZXIgYWNjZXB0YW5jZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlU3dhcEludGVudChhc3NldHNVc2VkLCBkZXN0aW5hdGlvbiwgb3B0aW9ucy5jaGFpbkxpc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzd2FwUm91dGVSZXNwb25zZSA9IGF3YWl0IGRldGVybWluZVN3YXBSb3V0ZShpbnB1dCwgc3dhcFJvdXRlUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBzb3VyY2VTd2FwcyA9IHN3YXBSb3V0ZVJlc3BvbnNlLnNvdXJjZVN3YXBzO1xuICAgICAgICAgICAgICAgIGFzc2V0c1VzZWQgPSBzd2FwUm91dGVSZXNwb25zZS5hc3NldHNVc2VkO1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uU3dhcCA9IHN3YXBSb3V0ZVJlc3BvbnNlLmRlc3RpbmF0aW9uU3dhcDtcbiAgICAgICAgICAgICAgICBicmlkZ2VJbnB1dCA9IHN3YXBSb3V0ZVJlc3BvbnNlLmJyaWRnZUlucHV0O1xuICAgICAgICAgICAgICAgIGxvZ2dlciQxLmRlYnVnKCdyZWZyZXNoLXN3YXAtcm91dGUnLCB7XG4gICAgICAgICAgICAgICAgICAgIGRzdFRva2VuSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgc3dhcFJvdXRlOiBzd2FwUm91dGVSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlU3dhcEludGVudChhc3NldHNVc2VkLCBkZXN0aW5hdGlvbiwgb3B0aW9ucy5jaGFpbkxpc3QpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGludGVudCBhY2NlcHRhbmNlIGhvb2tcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvdyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXB0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgnVXNlciBhbGxvd2VkIGludGVudCcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVueSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChFcnJvclVzZXJEZW5pZWRJbnRlbnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaG9vayh7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93LFxuICAgICAgICAgICAgICAgICAgICBkZW55LFxuICAgICAgICAgICAgICAgICAgICBpbnRlbnQ6IGNyZWF0ZVN3YXBJbnRlbnQoYXNzZXRzVXNlZCwgZGVzdGluYXRpb24sIG9wdGlvbnMuY2hhaW5MaXN0KSxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICBkc3Q6IHtcbiAgICAgICAgICAgIGNoaWQ6IGNvbnZlcnRUbzMyQnl0ZXMoaW5wdXQuZGF0YS50b0NoYWluSWQpLFxuICAgICAgICAgICAgc3dhcHM6IFtdLFxuICAgICAgICAgICAgdHhfaGFzaDogWkVST19CWVRFU18zMixcbiAgICAgICAgICAgIHVuaXY6IFVuaXZlcnNlLkVUSEVSRVVNLFxuICAgICAgICB9LFxuICAgICAgICBoYXNfeGNzOiB0cnVlLFxuICAgICAgICByZmZfaWQ6IDBuLFxuICAgICAgICBzcmM6IFtdLFxuICAgIH07XG4gICAgY29uc3Qgb3B0ID0ge1xuICAgICAgICBhZGRyZXNzOiBvcHRpb25zLmFkZHJlc3MsXG4gICAgICAgIGFnZ3JlZ2F0b3JzLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgY2hhaW5MaXN0OiBvcHRpb25zLmNoYWluTGlzdCxcbiAgICAgICAgY290OiB7XG4gICAgICAgICAgICBjdXJyZW5jeUlEOiBDT1QsXG4gICAgICAgICAgICBzeW1ib2w6IEN1cnJlbmN5SUQkMVtDT1RdLFxuICAgICAgICB9LFxuICAgICAgICBkZXN0aW5hdGlvbkNoYWluSUQ6IGlucHV0LmRhdGEudG9DaGFpbklkLFxuICAgICAgICBlbWl0dGVyLFxuICAgICAgICBuZXR3b3JrQ29uZmlnOiBvcHRpb25zLm5ldHdvcmtDb25maWcsXG4gICAgICAgIHB1YmxpY0NsaWVudExpc3QsXG4gICAgICAgIHNsaXBwYWdlOiAwLjAwNSxcbiAgICAgICAgd2FsbGV0OiBvcHRpb25zLndhbGxldCxcbiAgICB9O1xuICAgIGNvbnN0IHNyY1N3YXBzSGFuZGxlciA9IG5ldyBTb3VyY2VTd2Fwc0hhbmRsZXIoc291cmNlU3dhcHMsIG9wdCk7XG4gICAgY29uc3QgYnJpZGdlSGFuZGxlciA9IG5ldyBCcmlkZ2VIYW5kbGVyKGJyaWRnZUlucHV0LCBvcHQpO1xuICAgIGNvbnN0IGRzdFN3YXBIYW5kbGVyID0gbmV3IERlc3RpbmF0aW9uU3dhcEhhbmRsZXIoeyAuLi5kZXN0aW5hdGlvblN3YXAsIGdldEREUzogc3dhcFJvdXRlLmdldEREUyB9LCBkc3RUb2tlbkluZm8sIHtcbiAgICAgICAgY2hhaW5JRDogaW5wdXQuZGF0YS50b0NoYWluSWQsXG4gICAgICAgIHRva2VuOiBpbnB1dC5kYXRhLnRvVG9rZW5BZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IGlucHV0Lm1vZGUgPT09IFN3YXBNb2RlLkVYQUNUX09VVCA/IGlucHV0LmRhdGEudG9BbW91bnQgOiBkZXN0aW5hdGlvblN3YXAub3V0cHV0QW1vdW50LFxuICAgIH0sIG9wdCk7XG4gICAgcGVyZm9ybWFuY2UubWFyaygnYWxsb3dhbmNlLWNhY2hlLXN0YXJ0Jyk7XG4gICAgYXdhaXQgY2FjaGUucHJvY2VzcygpO1xuICAgIHBlcmZvcm1hbmNlLm1hcmsoJ2FsbG93YW5jZS1jYWNoZS1lbmQnKTtcbiAgICAvLyAwLjU6IERlc3RpbmF0aW9uIHN3YXA6IGNyZWF0ZSBwZXJtaXRcbiAgICBhd2FpdCBkc3RTd2FwSGFuZGxlci5jcmVhdGVQZXJtaXQoKTtcbiAgICAvLyAxOiBTb3VyY2Ugc3dhcFxuICAgIGNvbnN0IGFzc2V0cyA9IGF3YWl0IHNyY1N3YXBzSGFuZGxlci5wcm9jZXNzKG1ldGFkYXRhKTtcbiAgICAvLyAyOiBCcmlkZ2UsIHRha2VzIHNvdXJjZSBzd2FwIG91dHB1dCBhcyBpbnB1dCBzbyBicmlkZ2UgYXNzZXRzIGFyZSBhZGp1c3RlZCBhY2NvcmRpbmdseVxuICAgIC8vIHdhaXQgZm9yIFJGRiBGaWxsIChpZiBSRkYgcmVxdWlyZWQpXG4gICAgYXdhaXQgYnJpZGdlSGFuZGxlci5wcm9jZXNzKG1ldGFkYXRhLCBhc3NldHMpO1xuICAgIC8vIDM6IERlc3RpbmF0aW9uIHN3YXBcbiAgICBhd2FpdCBkc3RTd2FwSGFuZGxlci5wcm9jZXNzKG1ldGFkYXRhKTtcbiAgICBjb25zdCByZXN1bHQgPSBjb252ZXJ0TWV0YWRhdGFUb1N3YXBSZXN1bHQobWV0YWRhdGEsIG9wdGlvbnMubmV0d29ya0NvbmZpZy5FWFBMT1JFUl9VUkwpO1xuICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3N3YXAtZW5kJyk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaWQgPSBhd2FpdCBwb3N0U3dhcCh7XG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIHdhbGxldDogb3B0aW9ucy53YWxsZXQuZXBoZW1lcmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgbG9nZ2VyJDEuZGVidWcoJ1N3YXBJRCcsIHsgaWQgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlciQxLmVycm9yKCdwb3N0U3dhcCcsIGUpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVQZXJmb3JtYW5jZSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgY2FsY3VsYXRlUGVyZm9ybWFuY2UgPSAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWVhc3VyZXMgPSBbXTtcbiAgICAgICAgbWVhc3VyZXMucHVzaChwZXJmb3JtYW5jZS5tZWFzdXJlKCd4Y3MtdG90YWwtZHVyYXRpb24nLCAnc3dhcC1zdGFydCcsICdzd2FwLWVuZCcpLCBwZXJmb3JtYW5jZS5tZWFzdXJlKCd4Y3Mtb3BzLWR1cmF0aW9uJywgJ3hjcy1vcHMtc3RhcnQnLCAneGNzLW9wcy1lbmQnKSwgcGVyZm9ybWFuY2UubWVhc3VyZSgnYWxsb3dhbmNlLWNhbGxzLWR1cmF0aW9uJywgJ2FsbG93YW5jZS1jYWNoZS1zdGFydCcsICdhbGxvd2FuY2UtY2FjaGUtZW5kJyksIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ2RldGVybWluZS1zd2Fwcy1kdXJhdGlvbicsICdkZXRlcm1pbmUtc3dhcHMtc3RhcnQnLCAnZGV0ZXJtaW5lLXN3YXBzLWVuZCcpKTtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXMoKTtcbiAgICAgICAgaWYgKGVudHJpZXMuZmluZCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09ICdzb3VyY2Utc3dhcC10eC1zdGFydCcpKSB7XG4gICAgICAgICAgICBtZWFzdXJlcy5wdXNoKHBlcmZvcm1hbmNlLm1lYXN1cmUoJ3NvdXJjZS1zd2FwLXR4LWR1cmF0aW9uJywgJ3NvdXJjZS1zd2FwLXR4LXN0YXJ0JywgJ3NvdXJjZS1zd2FwLXR4LWVuZCcpLCBwZXJmb3JtYW5jZS5tZWFzdXJlKCdzb3VyY2Utc3dhcC1taW5pbmctZHVyYXRpb24nLCAnc291cmNlLXN3YXAtbWluaW5nLXN0YXJ0JywgJ3NvdXJjZS1zd2FwLW1pbmluZy1lbmQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVhc3VyZXMucHVzaChwZXJmb3JtYW5jZS5tZWFzdXJlKCdmaWxsLXdhaXQtZHVyYXRpb24nLCAnZmlsbC13YWl0LXN0YXJ0JywgJ2ZpbGwtd2FpdC1lbmQnKSwgcGVyZm9ybWFuY2UubWVhc3VyZSgnZGVzdGluYXRpb24tc3dhcC10eC1kdXJhdGlvbicsICdkZXN0aW5hdGlvbi1zd2FwLXN0YXJ0JywgJ2Rlc3RpbmF0aW9uLXN3YXAtZW5kJyksIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ2Rlc3RpbmF0aW9uLXN3YXAtbWluaW5nLWR1cmF0aW9uJywgJ2Rlc3RpbmF0aW9uLXN3YXAtbWluaW5nLXN0YXJ0JywgJ2Rlc3RpbmF0aW9uLXN3YXAtbWluaW5nLWVuZCcpKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1RpbWluZ3MgZm9yIFhDUzonKTtcbiAgICAgICAgbWVhc3VyZXMuZm9yRWFjaCgobWVhc3VyZSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYCR7bWVhc3VyZS5uYW1lfTogJHttZWFzdXJlLmR1cmF0aW9ufWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyJDEuZXJyb3IoJ2NhbGN1bGF0ZVBlcmZvcm1hbmNlJywgZSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKCk7XG4gICAgICAgIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMoKTtcbiAgICB9XG59O1xuXG52YXIgX0NBX2Nvc21vc1dhbGxldCwgX0NBX2VwaGVtZXJhbFdhbGxldDtcbnNldExvZ0xldmVsKExPR19MRVZFTC5OT0xPR1MpO1xuY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKCk7XG52YXIgSU5JVF9TVEFUVVM7XG4oZnVuY3Rpb24gKElOSVRfU1RBVFVTKSB7XG4gICAgSU5JVF9TVEFUVVNbSU5JVF9TVEFUVVNbXCJDUkVBVEVEXCJdID0gMF0gPSBcIkNSRUFURURcIjtcbiAgICBJTklUX1NUQVRVU1tJTklUX1NUQVRVU1tcIlJVTk5JTkdcIl0gPSAxXSA9IFwiUlVOTklOR1wiO1xuICAgIElOSVRfU1RBVFVTW0lOSVRfU1RBVFVTW1wiRE9ORVwiXSA9IDJdID0gXCJET05FXCI7XG59KShJTklUX1NUQVRVUyB8fCAoSU5JVF9TVEFUVVMgPSB7fSkpO1xuY29uc3QgU0lXRV9TVEFURU1FTlQgPSAnU2lnbiBpbiB0byBlbmFibGUgTmV4dXMnO1xuY2xhc3MgQ0Ege1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHsgZGVidWc6IGZhbHNlLCBuZXR3b3JrOiAndGVzdG5ldCcgfSkge1xuICAgICAgICB0aGlzLl9jYUV2ZW50cyA9IG5ldyBTYWZlRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF9DQV9jb3Ntb3NXYWxsZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9DQV9lcGhlbWVyYWxXYWxsZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuX2hvb2tzID0ge1xuICAgICAgICAgICAgb25BbGxvd2FuY2U6IChkYXRhKSA9PiBkYXRhLmFsbG93KGRhdGEuc291cmNlcy5tYXAoKCkgPT4gJ21heCcpKSxcbiAgICAgICAgICAgIG9uSW50ZW50OiAoZGF0YSkgPT4gZGF0YS5hbGxvdygpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbml0UHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5pdFN0YXR1cyA9IElOSVRfU1RBVFVTLkNSRUFURUQ7XG4gICAgICAgIHRoaXMuX2lzQXJjYW5hUHJvdmlkZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVpbml0ID0gKCkgPT4ge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0FfY29zbW9zV2FsbGV0LCB1bmRlZmluZWQsIFwiZlwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldm0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldm0ucHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2FjY291bnRzQ2hhbmdlZCcsIHRoaXMub25BY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlZnVuZEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9yZWZ1bmRJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmdW5kSW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbml0U3RhdHVzID0gSU5JVF9TVEFUVVMuQ1JFQVRFRDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZ2V0RVZNUHJvdmlkZXJXaXRoQ0EgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2V2bSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRVZNIHByb3ZpZGVyIGlzIG5vdCBzZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldm0ubW9kUHJvdmlkZXI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2V2bSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlIHNldEVWTVByb3ZpZGVyIGJlZm9yZSBjYWxsaW5nIGluaXQoKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRTdGF0dXMgPT09IElOSVRfU1RBVFVTLkNSRUFURUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0U3RhdHVzID0gSU5JVF9TVEFUVVMuUlVOTklORztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy5fZ2V0RVZNQWRkcmVzcygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm92aWRlckhvb2tzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNBcmNhbmFQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0FfY29zbW9zV2FsbGV0LCBhd2FpdCB0aGlzLl9jcmVhdGVDb3Ntb3NXYWxsZXQoKSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQZW5kaW5nUmVmdW5kcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRTdGF0dXMgPSBJTklUX1NUQVRVUy5ET05FO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlSW5pdFByb21pc2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhRXZlbnRzLmVtaXQoJ2FjY291bnRzQ2hhbmdlZCcsIFthZGRyZXNzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRTdGF0dXMgPSBJTklUX1NUQVRVUy5DUkVBVEVEO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBDQScsIGUpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBDQScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2luaXRTdGF0dXMgPT09IElOSVRfU1RBVFVTLlJVTk5JTkcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fd2FpdEZvckluaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkFjY291bnRzQ2hhbmdlZCA9IChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGVpbml0KCk7XG4gICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jb25maWcgPSBnZXRTREtDb25maWcoY29uZmlnKTtcbiAgICAgICAgdGhpcy5fbmV0d29ya0NvbmZpZyA9IGdldE5ldHdvcmtDb25maWcodGhpcy5fY29uZmlnLm5ldHdvcmspO1xuICAgICAgICB0aGlzLmNoYWluTGlzdCA9IG5ldyBDaGFpbkxpc3QodGhpcy5fbmV0d29ya0NvbmZpZy5ORVRXT1JLX0hJTlQpO1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmRlYnVnKSB7XG4gICAgICAgICAgICBzZXRMb2dMZXZlbChMT0dfTEVWRUwuREVCVUcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hbGxvd2FuY2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VWTSBwcm92aWRlciBpcyBub3Qgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbGxvd2FuY2VRdWVyeSh0aGlzLl9ldm0uY2xpZW50LCB0aGlzLl9uZXR3b3JrQ29uZmlnLCB0aGlzLmNoYWluTGlzdCk7XG4gICAgfVxuICAgIGFzeW5jIF9icmlkZ2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgYnEgPSBuZXcgQnJpZGdlUXVlcnkoaW5wdXQsIHRoaXMuX2luaXQsIHRoaXMuX2NoYW5nZUNoYWluLmJpbmQodGhpcyksIHRoaXMuX2NyZWF0ZUVWTUhhbmRsZXIuYmluZCh0aGlzKSwgdGhpcy5fY3JlYXRlRnVlbEhhbmRsZXIuYmluZCh0aGlzKSwgYXdhaXQgdGhpcy5fZ2V0RVZNQWRkcmVzcygpLCB0aGlzLmNoYWluTGlzdCwgdGhpcy5fZnVlbD8uYWNjb3VudCk7XG4gICAgICAgIGF3YWl0IGJxLmluaXRIYW5kbGVyKCk7XG4gICAgICAgIHJldHVybiB7IGV4ZWM6IGJxLmV4ZWMsIHNpbXVsYXRlOiBicS5zaW11bGF0ZSB9O1xuICAgIH1cbiAgICBhc3luYyBfZ2V0RnVlbFdpdGhDQSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mdWVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1ZWwgY29ubmVjdG9yIGlzIG5vdCBzZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbm5lY3RvcjogdGhpcy5fZnVlbC5tb2RDb25uZWN0b3IsXG4gICAgICAgICAgICBwcm92aWRlcjogdGhpcy5fZnVlbC5tb2RQcm92aWRlcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgX2dldE15SW50ZW50cyhwYWdlID0gMSkge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBhd2FpdCB0aGlzLl9nZXRDb3Ntb3NXYWxsZXQoKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhd2FpdCB3YWxsZXQuZ2V0QWNjb3VudHMoKSlbMF0uYWRkcmVzcztcbiAgICAgICAgcmV0dXJuIGZldGNoTXlJbnRlbnRzKGFkZHJlc3MsIHRoaXMuX25ldHdvcmtDb25maWcuR1JQQ19VUkwsIHBhZ2UpO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0VW5pZmllZEJhbGFuY2Uoc3ltYm9sKSB7XG4gICAgICAgIGNvbnN0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5fZ2V0VW5pZmllZEJhbGFuY2VzKCk7XG4gICAgICAgIHJldHVybiBiYWxhbmNlcy5maW5kKChzKSA9PiBlcXVhbEZvbGQocy5zeW1ib2wsIHN5bWJvbCkpO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0VW5pZmllZEJhbGFuY2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2bSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDQSBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFzc2V0cyB9ID0gYXdhaXQgZ2V0QmFsYW5jZXMoe1xuICAgICAgICAgICAgbmV0d29ya0hpbnQ6IHRoaXMuX25ldHdvcmtDb25maWcuTkVUV09SS19ISU5ULFxuICAgICAgICAgICAgZXZtQWRkcmVzczogKGF3YWl0IHRoaXMuX2V2bS5jbGllbnQucmVxdWVzdEFkZHJlc3NlcygpKVswXSxcbiAgICAgICAgICAgIGNoYWluTGlzdDogdGhpcy5jaGFpbkxpc3QsXG4gICAgICAgICAgICBmaWx0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgdnNjRG9tYWluOiB0aGlzLl9uZXR3b3JrQ29uZmlnLlZTQ19ET01BSU4sXG4gICAgICAgICAgICBmdWVsQWRkcmVzczogdGhpcy5fZnVlbD8uYWRkcmVzcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhc3NldHM7XG4gICAgfVxuICAgIF9pc0luaXRpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdFN0YXR1cyA9PT0gSU5JVF9TVEFUVVMuRE9ORTtcbiAgICB9XG4gICAgYXN5bmMgX3N3YXBXaXRoRXhhY3RJbihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3dhcCh7XG4gICAgICAgICAgICBtb2RlOiBTd2FwTW9kZS5FWEFDVF9JTixcbiAgICAgICAgICAgIGRhdGE6IGlucHV0LFxuICAgICAgICB9LCBhd2FpdCB0aGlzLmdldENvbW1vblN3YXBQYXJhbXMob3B0aW9ucykpO1xuICAgIH1cbiAgICBhc3luYyBfc3dhcFdpdGhFeGFjdE91dChpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3dhcCh7XG4gICAgICAgICAgICBtb2RlOiBTd2FwTW9kZS5FWEFDVF9PVVQsXG4gICAgICAgICAgICBkYXRhOiBpbnB1dCxcbiAgICAgICAgfSwgYXdhaXQgdGhpcy5nZXRDb21tb25Td2FwUGFyYW1zKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q29tbW9uU3dhcFBhcmFtcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbWl0OiB0aGlzLl9jYUV2ZW50cy5lbWl0LmJpbmQodGhpcy5fY2FFdmVudHMpLFxuICAgICAgICAgICAgY2hhaW5MaXN0OiB0aGlzLmNoYWluTGlzdCxcbiAgICAgICAgICAgIGFkZHJlc3M6IHtcbiAgICAgICAgICAgICAgICBjb3Ntb3M6IChhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQV9jb3Ntb3NXYWxsZXQsIFwiZlwiKS5nZXRBY2NvdW50cygpKVswXS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGVvYTogKGF3YWl0IHRoaXMuX2V2bS5jbGllbnQuZ2V0QWRkcmVzc2VzKCkpWzBdLFxuICAgICAgICAgICAgICAgIGVwaGVtZXJhbDogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0FfZXBoZW1lcmFsV2FsbGV0LCBcImZcIikuYWRkcmVzcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3YWxsZXQ6IHtcbiAgICAgICAgICAgICAgICBjb3Ntb3M6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NBX2Nvc21vc1dhbGxldCwgXCJmXCIpLFxuICAgICAgICAgICAgICAgIGVwaGVtZXJhbDogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0FfZXBoZW1lcmFsV2FsbGV0LCBcImZcIiksXG4gICAgICAgICAgICAgICAgZW9hOiB0aGlzLl9ldm0uY2xpZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5ldHdvcmtDb25maWc6IHRoaXMuX25ldHdvcmtDb25maWcsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlRVZNVHgoYXJncywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY3JlYXRlRVZNSGFuZGxlcihhcmdzLnBhcmFtc1swXSwgZ2V0VHhPcHRpb25zKG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBhd2FpdCByZXNwb25zZS5oYW5kbGVyPy5wcm9jZXNzKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucHJvY2Vzc1R4KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3luYyBfc2V0RVZNUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2V2bT8ucHJvdmlkZXIgPT09IHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXZtID0ge1xuICAgICAgICAgICAgY2xpZW50OiBjcmVhdGVXYWxsZXRDbGllbnQoe1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogY3VzdG9tKHByb3ZpZGVyKSxcbiAgICAgICAgICAgIH0pLmV4dGVuZChwdWJsaWNBY3Rpb25zKSxcbiAgICAgICAgICAgIG1vZFByb3ZpZGVyOiBPYmplY3QuYXNzaWduKHt9LCBwcm92aWRlciwge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGFzeW5jIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLm1ldGhvZCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzQXJjYW5hUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlRVZNVHgoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnJlcXVlc3QoYXJncyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2lzQXJjYW5hUHJvdmlkZXIgPSBpc0FyY2FuYVdhbGxldChwcm92aWRlcik7XG4gICAgfVxuICAgIGFzeW5jIF9zZXRGdWVsQ29ubmVjdG9yKGNvbm5lY3Rvcikge1xuICAgICAgICBpZiAodGhpcy5fZnVlbD8uY29ubmVjdG9yID09PSBjb25uZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldEZ1ZWxDb25uZWN0b3InLCB7XG4gICAgICAgICAgICBjb25uZWN0ZWQ6IGNvbm5lY3Rvci5jb25uZWN0ZWQsXG4gICAgICAgICAgICBjb25uZWN0b3I6IGNvbm5lY3RvcixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghKGF3YWl0IGNvbm5lY3Rvci5pc0Nvbm5lY3RlZCgpKSkge1xuICAgICAgICAgICAgYXdhaXQgY29ubmVjdG9yLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgY29ubmVjdG9yLmN1cnJlbnRBY2NvdW50KCk7XG4gICAgICAgIGlmICghYWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZ2V0IGN1cnJlbnQgYWNjb3VudCBmcm9tIGNvbm5lY3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZFByb3ZpZGVyID0gZ2V0RnVlbFByb3ZpZGVyKHRoaXMuX2dldFVuaWZpZWRCYWxhbmNlcy5iaW5kKHRoaXMpLCBhZGRyZXNzLCB0aGlzLmNoYWluTGlzdC5nZXRDaGFpbkJ5SUQoQ0hBSU5fSURTLmZ1ZWwubWFpbm5ldCkpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBQcm92aWRlcihGVUVMX05FVFdPUktfVVJMLCB7XG4gICAgICAgICAgICByZXNvdXJjZUNhY2hlVFRMOiAtMSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZShjb25uZWN0b3IpO1xuICAgICAgICBjbG9uZS5zZW5kVHJhbnNhY3Rpb24gPSBhc3luYyAoX2FkZHJlc3MsIF90cmFuc2FjdGlvbiwgX3BhcmFtcykgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdmdWVsQ2xvbmU6c2VuZFRyYW5zYWN0aW9uOjEnLCB7XG4gICAgICAgICAgICAgICAgX2FkZHJlc3MsXG4gICAgICAgICAgICAgICAgX3BhcmFtcyxcbiAgICAgICAgICAgICAgICBfdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJSZXNwb25zZSA9IGF3YWl0IHRoaXMuX2NyZWF0ZUZ1ZWxIYW5kbGVyKF90cmFuc2FjdGlvbiwge1xuICAgICAgICAgICAgICAgIGJyaWRnZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2FzOiAwbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXJSZXNwb25zZS5oYW5kbGVyPy5wcm9jZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2Z1ZWxDbG9uZTpzZW5kVHJhbnNhY3Rpb246MicsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgICAgICAgICB9LCBfdHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGZpeFR4KF9hZGRyZXNzLCBfdHJhbnNhY3Rpb24sIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0b3Iuc2VuZFRyYW5zYWN0aW9uKF9hZGRyZXNzLCB0eCwgX3BhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Z1ZWwgPSB7XG4gICAgICAgICAgICBhY2NvdW50OiBuZXcgQWNjb3VudChhZGRyZXNzLCBtb2RQcm92aWRlciwgY29ubmVjdG9yKSxcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBjb25uZWN0b3I6IGNvbm5lY3RvcixcbiAgICAgICAgICAgIG1vZENvbm5lY3RvcjogY2xvbmUsXG4gICAgICAgICAgICBtb2RQcm92aWRlcixcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfc2V0T25BbGxvd2FuY2VIb29rKGhvb2spIHtcbiAgICAgICAgdGhpcy5faG9va3Mub25BbGxvd2FuY2UgPSBob29rO1xuICAgIH1cbiAgICBfc2V0T25JbnRlbnRIb29rKGhvb2spIHtcbiAgICAgICAgdGhpcy5faG9va3Mub25JbnRlbnQgPSBob29rO1xuICAgIH1cbiAgICBhc3luYyBfdHJhbnNmZXIoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgdHEgPSBuZXcgVHJhbnNmZXJRdWVyeShpbnB1dCwgdGhpcy5faW5pdCwgdGhpcy5fY2hhbmdlQ2hhaW4uYmluZCh0aGlzKSwgdGhpcy5fY3JlYXRlRVZNSGFuZGxlci5iaW5kKHRoaXMpLCB0aGlzLl9jcmVhdGVGdWVsSGFuZGxlci5iaW5kKHRoaXMpLCBhd2FpdCB0aGlzLl9nZXRFVk1BZGRyZXNzKCksIHRoaXMuY2hhaW5MaXN0LCB0aGlzLl9mdWVsPy5hY2NvdW50KTtcbiAgICAgICAgYXdhaXQgdHEuaW5pdEhhbmRsZXIoKTtcbiAgICAgICAgcmV0dXJuIHsgZXhlYzogdHEuZXhlYywgc2ltdWxhdGU6IHRxLnNpbXVsYXRlIH07XG4gICAgfVxuICAgIF9jaGFuZ2VDaGFpbihjaGFpbklEKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VWTSBwcm92aWRlciBpcyBub3Qgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhaW4gPSB0aGlzLmNoYWluTGlzdC5nZXRDaGFpbkJ5SUQoY2hhaW5JRCk7XG4gICAgICAgIGlmICghY2hhaW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hhaW4gbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzd2l0Y2hDaGFpbih0aGlzLl9ldm0uY2xpZW50LCBjaGFpbik7XG4gICAgfVxuICAgIGFzeW5jIF9jaGVja1BlbmRpbmdSZWZ1bmRzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9pbml0KCk7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLl9nZXRFVk1BZGRyZXNzKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCByZWZ1bmRFeHBpcmVkSW50ZW50cyhhY2NvdW50LCB0aGlzLl9uZXR3b3JrQ29uZmlnLkNPU01PU19VUkwsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NBX2Nvc21vc1dhbGxldCwgXCJmXCIpKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZnVuZEludGVydmFsID0gd2luZG93LnNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZWZ1bmRFeHBpcmVkSW50ZW50cyhhY2NvdW50LCB0aGlzLl9uZXR3b3JrQ29uZmlnLkNPU01PU19VUkwsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NBX2Nvc21vc1dhbGxldCwgXCJmXCIpKTtcbiAgICAgICAgICAgIH0sIG1pbnV0ZXNUb01zKDEwKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgY2hlY2tpbmcgcGVuZGluZyByZWZ1bmRzJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZUNvc21vc1dhbGxldCgpIHtcbiAgICAgICAgY29uc3Qgc2lnID0gYXdhaXQgdGhpcy5fc2lnbmF0dXJlRm9yTG9naW4oKTtcbiAgICAgICAgY29uc3QgcHZ0S2V5ID0ga2V5RGVyaXZhdGlvbi5nZXRQcml2YXRlS2V5RnJvbUV0aFNpZ25hdHVyZShzaWcpO1xuICAgICAgICBjb25zdCBjb3Ntb3NXYWxsZXQgPSBhd2FpdCBjcmVhdGVDb3Ntb3NXYWxsZXQoYDB4JHtwdnRLZXkucGFkU3RhcnQoNjQsICcwJyl9YCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NBX2VwaGVtZXJhbFdhbGxldCwgcHJpdmF0ZUtleVRvQWNjb3VudChgMHgke3B2dEtleS5wYWRTdGFydCg2NCwgJzAnKX1gKSwgXCJmXCIpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGF3YWl0IGNvc21vc1dhbGxldC5nZXRBY2NvdW50cygpKVswXS5hZGRyZXNzO1xuICAgICAgICBhd2FpdCBjb3Ntb3NGZWVHcmFudCh0aGlzLl9uZXR3b3JrQ29uZmlnLkNPU01PU19VUkwsIHRoaXMuX25ldHdvcmtDb25maWcuVlNDX0RPTUFJTiwgYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiBjb3Ntb3NXYWxsZXQ7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVFVk1IYW5kbGVyKHR4LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldm0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRVZNIHByb3ZpZGVyIGlzIG5vdCBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRVZNVHgodHgpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2ludmFsaWQgZXZtIHR4LCByZXR1cm5pbmcnLCB7IHR4IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0ID0gZ2V0VHhPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5fZ2V0Q2hhaW5JRCgpO1xuICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuY2hhaW5MaXN0LmdldENoYWluQnlJRChjaGFpbklkKTtcbiAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oJ2NoYWluIG5vdCBzdXBwb3J0ZWQsIHJldHVybmluZycsIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlSGFuZGxlcih7XG4gICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgIGNoYWluTGlzdDogdGhpcy5jaGFpbkxpc3QsXG4gICAgICAgICAgICBjb3Ntb3NXYWxsZXQ6IGF3YWl0IHRoaXMuX2dldENvc21vc1dhbGxldCgpLFxuICAgICAgICAgICAgZXZtOiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogYXdhaXQgdGhpcy5fZ2V0RVZNQWRkcmVzcygpLFxuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5fZXZtLmNsaWVudCxcbiAgICAgICAgICAgICAgICB0eCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdWVsOiB0aGlzLl9mdWVsLFxuICAgICAgICAgICAgaG9va3M6IHRoaXMuX2hvb2tzLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGVtaXQ6IHRoaXMuX2NhRXZlbnRzLmVtaXQuYmluZCh0aGlzLl9jYUV2ZW50cyksXG4gICAgICAgICAgICAgICAgbmV0d29ya0NvbmZpZzogdGhpcy5fbmV0d29ya0NvbmZpZyxcbiAgICAgICAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RVZNQ2xpZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2bSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFVk0gcHJvdmlkZXIgaXMgbm90IHNldCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ldm0uY2xpZW50O1xuICAgIH1cbiAgICBhc3luYyBfY3JlYXRlRnVlbEhhbmRsZXIodHgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuY2hhaW5MaXN0LmdldENoYWluQnlJRChDSEFJTl9JRFMuZnVlbC5tYWlubmV0KTtcbiAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjaGFpbiBub3QgZm91bmQ6ICR7Q0hBSU5fSURTLmZ1ZWwubWFpbm5ldH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2Z1ZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVlbCBwcm92aWRlciBpcyBub3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHRoaXMuX2Z1ZWwuY29ubmVjdG9yLmN1cnJlbnRBY2NvdW50KCk7XG4gICAgICAgIGlmICghYWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZ2V0IGN1cnJlbnQgYWNjb3VudCBmcm9tIGNvbm5lY3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdCA9IGdldFR4T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUhhbmRsZXIoe1xuICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICBjaGFpbkxpc3Q6IHRoaXMuY2hhaW5MaXN0LFxuICAgICAgICAgICAgY29zbW9zV2FsbGV0OiBhd2FpdCB0aGlzLl9nZXRDb3Ntb3NXYWxsZXQoKSxcbiAgICAgICAgICAgIGV2bToge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGF3YWl0IHRoaXMuX2dldEVWTUFkZHJlc3MoKSxcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuX2V2bS5jbGllbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVlbDoge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yOiB0aGlzLl9mdWVsLmNvbm5lY3RvcixcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpcy5fZnVlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICB0eCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBob29rczoge1xuICAgICAgICAgICAgICAgIG9uQWxsb3dhbmNlOiB0aGlzLl9ob29rcy5vbkFsbG93YW5jZSxcbiAgICAgICAgICAgICAgICBvbkludGVudDogdGhpcy5faG9va3Mub25JbnRlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGVtaXQ6IHRoaXMuX2NhRXZlbnRzLmVtaXQuYmluZCh0aGlzLl9jYUV2ZW50cyksXG4gICAgICAgICAgICAgICAgbmV0d29ya0NvbmZpZzogdGhpcy5fbmV0d29ya0NvbmZpZyxcbiAgICAgICAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldENoYWluSUQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VWTSBwcm92aWRlciBpcyBub3Qgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2bS5jbGllbnQuZ2V0Q2hhaW5JZCgpO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0Q29zbW9zV2FsbGV0KCkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NBX2Nvc21vc1dhbGxldCwgXCJmXCIpKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DQV9jb3Ntb3NXYWxsZXQsIGF3YWl0IHRoaXMuX2NyZWF0ZUNvc21vc1dhbGxldCgpLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NBX2Nvc21vc1dhbGxldCwgXCJmXCIpO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0RVZNQWRkcmVzcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldm0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRVZNIHByb3ZpZGVyIGlzIG5vdCBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuX2V2bS5jbGllbnQucmVxdWVzdEFkZHJlc3NlcygpKVswXTtcbiAgICB9XG4gICAgX3Jlc29sdmVJbml0UHJvbWlzZXMoKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLl9pbml0UHJvbWlzZXM7XG4gICAgICAgIHRoaXMuX2luaXRQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHIgb2YgbGlzdCkge1xuICAgICAgICAgICAgcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9zZXRQcm92aWRlckhvb2tzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2bSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFVk0gcHJvdmlkZXIgaXMgbm90IHNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9ldm0ucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2bS5wcm92aWRlci5vbignYWNjb3VudHNDaGFuZ2VkJywgdGhpcy5vbkFjY291bnRzQ2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3NpZ25hdHVyZUZvckxvZ2luKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2bSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFVk0gcHJvdmlkZXIgaXMgbm90IHNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjaGVtZSA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuICAgICAgICBjb25zdCBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy5fZ2V0RVZNQWRkcmVzcygpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlU2l3ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IDEsXG4gICAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgICBpc3N1ZWRBdDogbmV3IERhdGUoJzIwMjQtMTItMTZUMTI6MTc6NDMuMTgyWicpLCAvLyB0aGlzIHJlbWFpbnMgc2FtZSB0byBhcnJpdmUgYXQgc2FtZSBwdnQga2V5XG4gICAgICAgICAgICBub25jZTogJ2lMallXQzZzOGZyWXQ0bDh3JywgLy8gbWF5YmUgdGhpcyBjYW4gYmUgc2hvcnRlbmVkIGhhc2ggb2YgYWRkcmVzc1xuICAgICAgICAgICAgc2NoZW1lLFxuICAgICAgICAgICAgc3RhdGVtZW50OiBTSVdFX1NUQVRFTUVOVCxcbiAgICAgICAgICAgIHVyaTogb3JpZ2luLFxuICAgICAgICAgICAgdmVyc2lvbjogJzEnLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY3VycmVudENoYWluID0gYXdhaXQgdGhpcy5fZ2V0Q2hhaW5JRCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZXZtLmNsaWVudC5zd2l0Y2hDaGFpbih7IGlkOiAxIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZXZtLmNsaWVudC5zaWduTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgYWNjb3VudDogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZXZtLmNsaWVudC5zd2l0Y2hDaGFpbih7IGlkOiBjdXJyZW50Q2hhaW4gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3dhaXRGb3JJbml0KCkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRQcm9taXNlcy5wdXNoKHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gICAgfVxuICAgIF9nZXRTd2FwU3VwcG9ydGVkQ2hhaW5zQW5kVG9rZW5zKCkge1xuICAgICAgICByZXR1cm4gZ2V0U3dhcFN1cHBvcnRlZENoYWlucyh0aGlzLmNoYWluTGlzdCk7XG4gICAgfVxufVxuX0NBX2Nvc21vc1dhbGxldCA9IG5ldyBXZWFrTWFwKCksIF9DQV9lcGhlbWVyYWxXYWxsZXQgPSBuZXcgV2Vha01hcCgpO1xuQ0EuZ2V0U3VwcG9ydGVkQ2hhaW5zID0gZ2V0U3VwcG9ydGVkQ2hhaW5zO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgY2hhaW4gaXMgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkQ2hhaW4oY2hhaW5JZCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKFNVUFBPUlRFRF9DSEFJTlMpLmluY2x1ZGVzKGNoYWluSWQpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHRva2VuIGlzIHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBpc1N1cHBvcnRlZFRva2VuKHRva2VuKSB7XG4gICAgY29uc3Qgc3VwcG9ydGVkVG9rZW5zID0gWydFVEgnLCAnVVNEQycsICdVU0RUJ107XG4gICAgcmV0dXJuIHN1cHBvcnRlZFRva2Vucy5pbmNsdWRlcyh0b2tlbi50b1VwcGVyQ2FzZSgpKTtcbn1cblxuLyoqXG4gKiBTZXJ2aWNlIHJlc3BvbnNpYmxlIGZvciB0cmFuc2FjdGlvbiBoYW5kbGluZyBhbmQgcHJlcGFyYXRpb25cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gICAgICAgIC8vIEZsYWcgdG8gZW5hYmxlL2Rpc2FibGUgZ2FzIGVzdGltYXRpb24gKGNhbiBiZSBzZXQgdmlhIGNvbnN0cnVjdG9yIG9yIG1ldGhvZClcbiAgICAgICAgdGhpcy5lbmFibGVHYXNFc3RpbWF0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgZ2FzIGVzdGltYXRpb24gYmVmb3JlIHRyYW5zYWN0aW9uIGV4ZWN1dGlvblxuICAgICAqL1xuICAgIHNldEdhc0VzdGltYXRpb25FbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5lbmFibGVHYXNFc3RpbWF0aW9uID0gZW5hYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0aW1hdGUgZ2FzIGZvciBhIHRyYW5zYWN0aW9uIGJlZm9yZSBleGVjdXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBlc3RpbWF0ZVRyYW5zYWN0aW9uR2FzKHByb3ZpZGVyLCB0cmFuc2FjdGlvblBhcmFtcykge1xuICAgICAgICBsb2dnZXIkbS5pbmZvKCdUcmFuc2FjdGlvblNlcnZpY2UgLSBTdGFydGluZyBnYXMgZXN0aW1hdGlvbi4uLicpO1xuICAgICAgICBsb2dnZXIkbS5pbmZvKCdUcmFuc2FjdGlvblNlcnZpY2UgLSBUcmFuc2FjdGlvbiBwYXJhbXM6Jywge1xuICAgICAgICAgICAgZnJvbTogdHJhbnNhY3Rpb25QYXJhbXMuZnJvbSxcbiAgICAgICAgICAgIHRvOiB0cmFuc2FjdGlvblBhcmFtcy50byxcbiAgICAgICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uUGFyYW1zLmRhdGEuc2xpY2UoMCwgNTApICsgJy4uLicsIC8vIFRydW5jYXRlIGZvciBsb2dnaW5nXG4gICAgICAgICAgICB2YWx1ZTogdHJhbnNhY3Rpb25QYXJhbXMudmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU3RlcCAxOiBFc3RpbWF0ZSBnYXNcbiAgICAgICAgICAgIGNvbnN0IGdhc0VzdGltYXRlID0gKGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9lc3RpbWF0ZUdhcycsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbdHJhbnNhY3Rpb25QYXJhbXNdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3QgZ2FzRXN0aW1hdGVEZWNpbWFsID0gcGFyc2VJbnQoZ2FzRXN0aW1hdGUsIDE2KTtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ1RyYW5zYWN0aW9uU2VydmljZSAtIEdhcyBlc3RpbWF0aW9uIHN1Y2Nlc3NmdWw6Jywge1xuICAgICAgICAgICAgICAgIGdhc0VzdGltYXRlSGV4OiBnYXNFc3RpbWF0ZSxcbiAgICAgICAgICAgICAgICBnYXNFc3RpbWF0ZURlY2ltYWw6IGdhc0VzdGltYXRlRGVjaW1hbCxcbiAgICAgICAgICAgICAgICBnYXNFc3RpbWF0ZUZvcm1hdHRlZDogZ2FzRXN0aW1hdGVEZWNpbWFsLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFN0ZXAgMjogR2V0IGN1cnJlbnQgZ2FzIHByaWNlIGZvciBjb3N0IGNhbGN1bGF0aW9uXG4gICAgICAgICAgICBsZXQgZ2FzUHJpY2VHd2VpO1xuICAgICAgICAgICAgbGV0IGVzdGltYXRlZENvc3RFdGg7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlID0gKGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2FzUHJpY2UnLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZURlY2ltYWwgPSBwYXJzZUludChnYXNQcmljZSwgMTYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlZENvc3RXZWkgPSBnYXNFc3RpbWF0ZURlY2ltYWwgKiBnYXNQcmljZURlY2ltYWw7XG4gICAgICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVkQ29zdEV0aE51bSA9IGVzdGltYXRlZENvc3RXZWkgLyAxZTE4O1xuICAgICAgICAgICAgICAgIGdhc1ByaWNlR3dlaSA9IChnYXNQcmljZURlY2ltYWwgLyAxZTkpLnRvRml4ZWQoNCkgKyAnIGd3ZWknO1xuICAgICAgICAgICAgICAgIGVzdGltYXRlZENvc3RFdGggPSBlc3RpbWF0ZWRDb3N0RXRoTnVtLnRvRml4ZWQoOCkgKyAnIEVUSCc7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnVHJhbnNhY3Rpb25TZXJ2aWNlIC0gR2FzIGNvc3QgZXN0aW1hdGlvbjonLCB7XG4gICAgICAgICAgICAgICAgICAgIGdhc1ByaWNlSGV4OiBnYXNQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgZ2FzUHJpY2VHd2VpOiBnYXNQcmljZUd3ZWksXG4gICAgICAgICAgICAgICAgICAgIGVzdGltYXRlZENvc3RXZWk6IGVzdGltYXRlZENvc3RXZWkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgZXN0aW1hdGVkQ29zdEV0aDogZXN0aW1hdGVkQ29zdEV0aCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChnYXNQcmljZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJG0ud2FybignVHJhbnNhY3Rpb25TZXJ2aWNlIC0gRmFpbGVkIHRvIGdldCBnYXMgcHJpY2U6JywgZ2FzUHJpY2VFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2FzRXN0aW1hdGUsXG4gICAgICAgICAgICAgICAgZ2FzRXN0aW1hdGVEZWNpbWFsLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlR3dlaSxcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZWRDb3N0RXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZ2FzRXN0aW1hdGVFcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyJG0uZXJyb3IoJ1RyYW5zYWN0aW9uU2VydmljZSAtIEdhcyBlc3RpbWF0aW9uIGZhaWxlZDonLCBnYXNFc3RpbWF0ZUVycm9yKTtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgcmV2ZXJ0IHJlYXNvbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGxldCByZXZlcnRSZWFzb247XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ0dhcyBlc3RpbWF0aW9uIGZhaWxlZCc7XG4gICAgICAgICAgICBpZiAoZ2FzRXN0aW1hdGVFcnJvciAmJiB0eXBlb2YgZ2FzRXN0aW1hdGVFcnJvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoJ2RhdGEnIGluIGdhc0VzdGltYXRlRXJyb3IgJiYgZ2FzRXN0aW1hdGVFcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciRtLmVycm9yKCdUcmFuc2FjdGlvblNlcnZpY2UgLSBHYXMgZXN0aW1hdGlvbiByZXZlcnQgZGF0YTonLCBnYXNFc3RpbWF0ZUVycm9yLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXZlcnRSZWFzb24gPSBKU09OLnN0cmluZ2lmeShnYXNFc3RpbWF0ZUVycm9yLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIGdhc0VzdGltYXRlRXJyb3IgJiYgZ2FzRXN0aW1hdGVFcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGdhc0VzdGltYXRlRXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJG0uZXJyb3IoJ1RyYW5zYWN0aW9uU2VydmljZSAtIEdhcyBlc3RpbWF0aW9uIGVycm9yIG1lc3NhZ2U6JywgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBjb21tb24gcmV2ZXJ0IHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2V4ZWN1dGlvbiByZXZlcnRlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZlcnRNYXRjaCA9IGVycm9yTWVzc2FnZS5tYXRjaCgvZXhlY3V0aW9uIHJldmVydGVkOj9cXHMqKC4rKS9pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXZlcnRNYXRjaCAmJiByZXZlcnRNYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydFJlYXNvbiA9IHJldmVydE1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydFJlYXNvbiA9ICdUcmFuc2FjdGlvbiB3b3VsZCByZXZlcnQgKG5vIHJlYXNvbiBwcm92aWRlZCknO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnaW5zdWZmaWNpZW50IGZ1bmRzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydFJlYXNvbiA9ICdJbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGdhcyAqIHByaWNlICsgdmFsdWUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnb3V0IG9mIGdhcycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnRSZWFzb24gPSAnVHJhbnNhY3Rpb24gd291bGQgcnVuIG91dCBvZiBnYXMnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHJldmVydFJlYXNvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHdlJ3JlIG9uIHRoZSBjb3JyZWN0IGNoYWluLCBzd2l0Y2ggaWYgbmVlZGVkXG4gICAgICovXG4gICAgYXN5bmMgZW5zdXJlQ29ycmVjdENoYWluKHRhcmdldENoYWluSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaGFpbklkID0gYXdhaXQgdGhpcy5hZGFwdGVyLm5leHVzU0RLLmdldEVWTUNsaWVudCgpLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhaW5JZCAhPT0gdGFyZ2V0Q2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYWRhcHRlci5uZXh1c1NESy5nZXRFVk1DbGllbnQoKS5zd2l0Y2hDaGFpbih7IGlkOiB0YXJnZXRDaGFpbklkIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzd2l0Y2hFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3dpdGNoRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzd2l0Y2hFcnJvciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb2RlJyBpbiBzd2l0Y2hFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoRXJyb3IuY29kZSA9PT0gNDkwMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGFpbiAke3RhcmdldENoYWluSWR9IGlzIG5vdCBjb25maWd1cmVkIGluIHdhbGxldC4gUGxlYXNlIGFkZCBpdCBtYW51YWxseS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzd2l0Y2hFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBleHRyYWN0RXJyb3JNZXNzYWdlKGVycm9yLCAnY2hhaW4gc3dpdGNoaW5nJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgZXhlY3V0aW9uIGJ5IHZhbGlkYXRpbmcgcGFyYW1ldGVycyBhbmQgZW5jb2RpbmcgZnVuY3Rpb24gY2FsbFxuICAgICAqL1xuICAgIGFzeW5jIHByZXBhcmVFeGVjdXRpb24ocGFyYW1zKSB7XG4gICAgICAgIC8vIEdldCB0aGUgZnJvbSBhZGRyZXNzIGZpcnN0IChuZWVkZWQgZm9yIGNhbGxiYWNrKVxuICAgICAgICBjb25zdCBmcm9tQWRkcmVzcyA9IGF3YWl0IHRoaXMuYWRhcHRlci5uZXh1c1NESy5nZXRFVk1DbGllbnQoKS5nZXRBZGRyZXNzZXMoKTtcbiAgICAgICAgaWYgKCFmcm9tQWRkcmVzcyB8fCBmcm9tQWRkcmVzcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjb3VudHMgYXZhaWxhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHdlJ3JlIG9uIHRoZSBjb3JyZWN0IGNoYWluXG4gICAgICAgIGNvbnN0IGNoYWluUmVzdWx0ID0gYXdhaXQgdGhpcy5lbnN1cmVDb3JyZWN0Q2hhaW4ocGFyYW1zLnRvQ2hhaW5JZCk7XG4gICAgICAgIGlmICghY2hhaW5SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3dpdGNoIHRvIGNoYWluICR7cGFyYW1zLnRvQ2hhaW5JZH06ICR7Y2hhaW5SZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCBidWlsZEZ1bmN0aW9uUGFyYW1zIGNhbGxiYWNrIHRvIGdldCB0aGUgYWN0dWFsIGZ1bmN0aW9uIHBhcmFtZXRlcnNcbiAgICAgICAgLy8gRm9yIEVUSCB0cmFuc2FjdGlvbnMsIHByb3ZpZGUgRVRIIGFzIHRva2VuIGFuZCAwIGFzIGFtb3VudCBpZiB0b2tlbkFwcHJvdmFsIGlzIHVuZGVmaW5lZFxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcmFtcy50b2tlbkFwcHJvdmFsPy50b2tlbiB8fCAnRVRIJztcbiAgICAgICAgY29uc3QgYW1vdW50ID0gcGFyYW1zLnRva2VuQXBwcm92YWw/LmFtb3VudCB8fCAnMCc7XG4gICAgICAgIGNvbnN0IHsgZnVuY3Rpb25QYXJhbXMsIHZhbHVlOiBjYWxsYmFja1ZhbHVlIH0gPSBwYXJhbXMuYnVpbGRGdW5jdGlvblBhcmFtcyh0b2tlbiwgYW1vdW50LCBwYXJhbXMudG9DaGFpbklkLCBmcm9tQWRkcmVzc1swXSk7XG4gICAgICAgIC8vIFZhbGlkYXRlIGNvbnRyYWN0IHBhcmFtZXRlcnMgd2l0aCBidWlsdCBmdW5jdGlvbiBwYXJhbXNcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlQ29udHJhY3RQYXJhbXMoe1xuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBwYXJhbXMuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgY29udHJhY3RBYmk6IHBhcmFtcy5jb250cmFjdEFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uUGFyYW1zLFxuICAgICAgICAgICAgY2hhaW5JZDogcGFyYW1zLnRvQ2hhaW5JZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29udHJhY3QgcGFyYW1ldGVyczogJHt2YWxpZGF0aW9uLmVycm9yfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuY29kZSB0aGUgZnVuY3Rpb24gY2FsbFxuICAgICAgICBjb25zdCBlbmNvZGluZ1Jlc3VsdCA9IGVuY29kZUNvbnRyYWN0Q2FsbCh7XG4gICAgICAgICAgICBjb250cmFjdEFiaTogcGFyYW1zLmNvbnRyYWN0QWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBwYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgZnVuY3Rpb25QYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWVuY29kaW5nUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGVuY29kZSBjb250cmFjdCBjYWxsOiAke2VuY29kaW5nUmVzdWx0LmVycm9yfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm92aWRlcjogdGhpcy5hZGFwdGVyLm5leHVzU0RLLmdldEVWTVByb3ZpZGVyV2l0aENBKCksXG4gICAgICAgICAgICBmcm9tQWRkcmVzczogZnJvbUFkZHJlc3NbMF0sXG4gICAgICAgICAgICBlbmNvZGVkRGF0YTogZW5jb2RpbmdSZXN1bHQuZGF0YSxcbiAgICAgICAgICAgIHZhbHVlOiBjYWxsYmFja1ZhbHVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRyYW5zYWN0aW9uIHdpdGggZW5oYW5jZWQgZXJyb3IgaGFuZGxpbmcgYW5kIHBvbGxpbmcgc3VwcG9ydFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbihwcm92aWRlciwgZnJvbUFkZHJlc3MsIGNvbnRyYWN0QWRkcmVzcywgZW5jb2RlZERhdGEsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uUGFyYW1zID0ge1xuICAgICAgICAgICAgZnJvbTogZnJvbUFkZHJlc3MsXG4gICAgICAgICAgICB0bzogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogZW5jb2RlZERhdGEsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUgfHwgJzB4MCcsXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQZXJmb3JtIGdhcyBlc3RpbWF0aW9uIGlmIGVuYWJsZWRcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUdhc0VzdGltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdUcmFuc2FjdGlvblNlcnZpY2UgLSBQZXJmb3JtaW5nIHByZS1leGVjdXRpb24gZ2FzIGVzdGltYXRpb24uLi4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXNFc3RpbWF0aW9uID0gYXdhaXQgdGhpcy5lc3RpbWF0ZVRyYW5zYWN0aW9uR2FzKHByb3ZpZGVyLCB0cmFuc2FjdGlvblBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFnYXNFc3RpbWF0aW9uLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJG0uZXJyb3IoJ1RyYW5zYWN0aW9uU2VydmljZSAtIFByZS1leGVjdXRpb24gZ2FzIGVzdGltYXRpb24gZmFpbGVkOicsIGdhc0VzdGltYXRpb24uZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2FzRXN0aW1hdGlvbi5yZXZlcnRSZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oYFRyYW5zYWN0aW9uU2VydmljZSAtIFRyYW5zYWN0aW9uIHdpbGwgbGlrZWx5IGZhaWw6ICR7Z2FzRXN0aW1hdGlvbi5yZXZlcnRSZWFzb259YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIHNpbXVsYXRpb24gZmFpbGVkOiAke2dhc0VzdGltYXRpb24ucmV2ZXJ0UmVhc29ufWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdUcmFuc2FjdGlvblNlcnZpY2UgLSBHYXMgZXN0aW1hdGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5OicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhc0VzdGltYXRlOiBnYXNFc3RpbWF0aW9uLmdhc0VzdGltYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXN0aW1hdGVkQ29zdDogZ2FzRXN0aW1hdGlvbi5lc3RpbWF0ZWRDb3N0RXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FzUHJpY2U6IGdhc0VzdGltYXRpb24uZ2FzUHJpY2VHd2VpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdUcmFuc2FjdGlvblNlcnZpY2UgLSBHYXMgZXN0aW1hdGlvbiBkaXNhYmxlZCwgcHJvY2VlZGluZyB3aXRoIHRyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdUcmFuc2FjdGlvblNlcnZpY2UgLSBTZW5kaW5nIHRyYW5zYWN0aW9uLi4uJyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW3RyYW5zYWN0aW9uUGFyYW1zXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gR2V0IHRyYW5zYWN0aW9uIGhhc2ggd2l0aCBmYWxsYmFjayBwb2xsaW5nXG4gICAgICAgICAgICBjb25zdCBoYXNoUmVzdWx0ID0gYXdhaXQgZ2V0VHJhbnNhY3Rpb25IYXNoV2l0aEZhbGxiYWNrKHByb3ZpZGVyLCByZXNwb25zZSwge1xuICAgICAgICAgICAgICAgIGVuYWJsZVBvbGxpbmc6IG9wdGlvbnMuZW5hYmxlVHJhbnNhY3Rpb25Qb2xsaW5nLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudHJhbnNhY3Rpb25UaW1lb3V0LFxuICAgICAgICAgICAgICAgIGZyb21BZGRyZXNzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWhhc2hSZXN1bHQuc3VjY2VzcyB8fCAhaGFzaFJlc3VsdC5oYXNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGhhc2hSZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byByZXRyaWV2ZSB0cmFuc2FjdGlvbiBoYXNoIGZyb20gcHJvdmlkZXIgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ1RyYW5zYWN0aW9uU2VydmljZSAtIFRyYW5zYWN0aW9uIHNlbnQgc3VjY2Vzc2Z1bGx5OicsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2hSZXN1bHQuaGFzaCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2hSZXN1bHQuaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEVuaGFuY2VkIGVycm9yIGhhbmRsaW5nIGZvciBjb21tb24gdHJhbnNhY3Rpb24gZmFpbHVyZXNcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICdjb2RlJyBpbiBlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSA0MDAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gcmVqZWN0ZWQgYnkgdXNlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvci5jb2RlID09PSAtMzJlMykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3VmZmljaWVudCBmdW5kcyBmb3IgdHJhbnNhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IuY29kZSA9PT0gLTMyNjAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgSlNPTi1SUEMgZXJyb3IgZHVyaW5nIHRyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBmYWlsZWQ6ICR7ZXh0cmFjdEVycm9yTWVzc2FnZShlcnJvciwgJ3RyYW5zYWN0aW9uJyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiB3aXRoIHJlY2VpcHQgYW5kIGNvbmZpcm1hdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyBoYW5kbGVUcmFuc2FjdGlvbkNvbmZpcm1hdGlvbihwcm92aWRlciwgdHJhbnNhY3Rpb25IYXNoLCBvcHRpb25zLCBjaGFpbklkKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy53YWl0Rm9yUmVjZWlwdCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0UmVzdWx0ID0gYXdhaXQgd2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdChwcm92aWRlciwgdHJhbnNhY3Rpb25IYXNoLCB7XG4gICAgICAgICAgICAgICAgdGltZW91dDogb3B0aW9ucy5yZWNlaXB0VGltZW91dCxcbiAgICAgICAgICAgICAgICByZXF1aXJlZENvbmZpcm1hdGlvbnM6IG9wdGlvbnMucmVxdWlyZWRDb25maXJtYXRpb25zLFxuICAgICAgICAgICAgfSwgY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoIXJlY2VpcHRSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oYEZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24gcmVjZWlwdDogJHtyZWNlaXB0UmVzdWx0LmVycm9yfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVjZWlwdDogcmVjZWlwdFJlc3VsdC5yZWNlaXB0LFxuICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IHJlY2VpcHRSZXN1bHQuY29uZmlybWF0aW9ucyxcbiAgICAgICAgICAgICAgICBnYXNVc2VkOiByZWNlaXB0UmVzdWx0LnJlY2VpcHQ/Lmdhc1VzZWQ/LnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZWZmZWN0aXZlR2FzUHJpY2U6IHJlY2VpcHRSZXN1bHQucmVjZWlwdD8uZWZmZWN0aXZlR2FzUHJpY2U/LnRvU3RyaW5nKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyJG0ud2FybihgUmVjZWlwdCByZXRyaWV2YWwgZmFpbGVkOiAke2V4dHJhY3RFcnJvck1lc3NhZ2UoZXJyb3IsICdyZWNlaXB0IHJldHJpZXZhbCcpfWApO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkIGV4ZWN1dGUgcmVzdWx0IHdpdGggdHJhbnNhY3Rpb24gaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBidWlsZEV4ZWN1dGVSZXN1bHQodHJhbnNhY3Rpb25IYXNoLCBjaGFpbklkLCByZWNlaXB0SW5mbykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgZXhwbG9yZXJVcmw6IGdldEJsb2NrRXhwbG9yZXJVcmwoY2hhaW5JZCwgdHJhbnNhY3Rpb25IYXNoKSxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAuLi5yZWNlaXB0SW5mbyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlyZWN0IG5hdGl2ZSB0b2tlbiB0cmFuc2ZlciAoRVRILCBNQVRJQywgQVZBWCwgZXRjLilcbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zlck5hdGl2ZVRva2VuKHByb3ZpZGVyLCBmcm9tQWRkcmVzcywgdG9BZGRyZXNzLCBhbW91bnQsIC8vIEFtb3VudCBpbiBodW1hbi1yZWFkYWJsZSBmb3JtYXQgKGUuZy4sIFwiMC4xXCIpXG4gICAgZGVjaW1hbHMgPSAxOCkge1xuICAgICAgICBjb25zdCB7IHBhcnNlVW5pdHMgfSA9IGF3YWl0IGltcG9ydCgndmllbScpO1xuICAgICAgICBjb25zdCB2YWx1ZUluV2VpID0gcGFyc2VVbml0cyhhbW91bnQsIGRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25QYXJhbXMgPSB7XG4gICAgICAgICAgICBmcm9tOiBmcm9tQWRkcmVzcyxcbiAgICAgICAgICAgIHRvOiB0b0FkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiAnMHgnLFxuICAgICAgICAgICAgdmFsdWU6IGAweCR7dmFsdWVJbldlaS50b1N0cmluZygxNil9YCxcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gZ2FzIGVzdGltYXRpb24gaWYgZW5hYmxlZFxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlR2FzRXN0aW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ1RyYW5zYWN0aW9uU2VydmljZSAtIFBlcmZvcm1pbmcgZ2FzIGVzdGltYXRpb24gZm9yIG5hdGl2ZSB0b2tlbiB0cmFuc2Zlci4uLicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhc0VzdGltYXRpb24gPSBhd2FpdCB0aGlzLmVzdGltYXRlVHJhbnNhY3Rpb25HYXMocHJvdmlkZXIsIHRyYW5zYWN0aW9uUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIWdhc0VzdGltYXRpb24uc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkbS5lcnJvcignVHJhbnNhY3Rpb25TZXJ2aWNlIC0gR2FzIGVzdGltYXRpb24gZmFpbGVkIGZvciBuYXRpdmUgdG9rZW4gdHJhbnNmZXI6JywgZ2FzRXN0aW1hdGlvbi5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmF0aXZlIHRva2VuIHRyYW5zZmVyIGdhcyBlc3RpbWF0aW9uIGZhaWxlZDogJHtnYXNFc3RpbWF0aW9uLmVycm9yfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdUcmFuc2FjdGlvblNlcnZpY2UgLSBOYXRpdmUgdG9rZW4gdHJhbnNmZXIgZ2FzIGVzdGltYXRpb24gc3VjY2Vzc2Z1bDonLCB7XG4gICAgICAgICAgICAgICAgICAgIGdhc0VzdGltYXRlOiBnYXNFc3RpbWF0aW9uLmdhc0VzdGltYXRlLFxuICAgICAgICAgICAgICAgICAgICBlc3RpbWF0ZWRDb3N0OiBnYXNFc3RpbWF0aW9uLmVzdGltYXRlZENvc3RFdGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdUcmFuc2FjdGlvblNlcnZpY2UgLSBTZW5kaW5nIG5hdGl2ZSB0b2tlbiB0cmFuc2Zlci4uLicpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFt0cmFuc2FjdGlvblBhcmFtc10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IGdldFRyYW5zYWN0aW9uSGFzaFdpdGhGYWxsYmFjayhwcm92aWRlciwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnVHJhbnNhY3Rpb25TZXJ2aWNlIC0gTmF0aXZlIHRva2VuIHRyYW5zZmVyIHNlbnQgc3VjY2Vzc2Z1bGx5OicsIHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25IYXNoO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyJG0uZXJyb3IoJ1RyYW5zYWN0aW9uU2VydmljZSAtIE5hdGl2ZSB0b2tlbiB0cmFuc2ZlciBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOYXRpdmUgdG9rZW4gdHJhbnNmZXIgZmFpbGVkOiAke2V4dHJhY3RFcnJvck1lc3NhZ2UoZXJyb3IsICduYXRpdmUgdHJhbnNmZXInKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXJlY3QgRVJDMjAgdG9rZW4gdHJhbnNmZXJcbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2ZlckVSQzIwVG9rZW4ocHJvdmlkZXIsIGZyb21BZGRyZXNzLCB0b2tlbkFkZHJlc3MsIHRvQWRkcmVzcywgYW1vdW50LCAvLyBBbW91bnQgaW4gaHVtYW4tcmVhZGFibGUgZm9ybWF0IChlLmcuLCBcIjEwMFwiKVxuICAgIGRlY2ltYWxzID0gMTgpIHtcbiAgICAgICAgY29uc3QgeyBwYXJzZVVuaXRzIH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFtb3VudEluV2VpID0gcGFyc2VVbml0cyhhbW91bnQsIGRlY2ltYWxzKTtcbiAgICAgICAgICAgIC8vIEVSQzIwIHRyYW5zZmVyIGZ1bmN0aW9uIHNlbGVjdG9yOiB0cmFuc2ZlcihhZGRyZXNzLHVpbnQyNTYpXG4gICAgICAgICAgICBjb25zdCB0cmFuc2ZlclNlbGVjdG9yID0gJzB4YTkwNTljYmInO1xuICAgICAgICAgICAgY29uc3QgcGFkZGVkUmVjaXBpZW50ID0gdG9BZGRyZXNzLnNsaWNlKDIpLnBhZFN0YXJ0KDY0LCAnMCcpO1xuICAgICAgICAgICAgY29uc3QgcGFkZGVkQW1vdW50ID0gYW1vdW50SW5XZWkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCAnMCcpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJEYXRhID0gYCR7dHJhbnNmZXJTZWxlY3Rvcn0ke3BhZGRlZFJlY2lwaWVudH0ke3BhZGRlZEFtb3VudH1gO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25QYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdG86IHRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBkYXRhOiB0cmFuc2ZlckRhdGEsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICcweDAnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gZ2FzIGVzdGltYXRpb24gaWYgZW5hYmxlZFxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlR2FzRXN0aW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ1RyYW5zYWN0aW9uU2VydmljZSAtIFBlcmZvcm1pbmcgZ2FzIGVzdGltYXRpb24gZm9yIEVSQzIwIHRyYW5zZmVyLi4uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FzRXN0aW1hdGlvbiA9IGF3YWl0IHRoaXMuZXN0aW1hdGVUcmFuc2FjdGlvbkdhcyhwcm92aWRlciwgdHJhbnNhY3Rpb25QYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghZ2FzRXN0aW1hdGlvbi5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciRtLmVycm9yKCdUcmFuc2FjdGlvblNlcnZpY2UgLSBHYXMgZXN0aW1hdGlvbiBmYWlsZWQgZm9yIEVSQzIwIHRyYW5zZmVyOicsIGdhc0VzdGltYXRpb24uZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2FzRXN0aW1hdGlvbi5yZXZlcnRSZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRVJDMjAgdHJhbnNmZXIgd2lsbCBmYWlsOiAke2dhc0VzdGltYXRpb24ucmV2ZXJ0UmVhc29ufWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRVJDMjAgdHJhbnNmZXIgZ2FzIGVzdGltYXRpb24gZmFpbGVkOiAke2dhc0VzdGltYXRpb24uZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ1RyYW5zYWN0aW9uU2VydmljZSAtIEVSQzIwIHRyYW5zZmVyIGdhcyBlc3RpbWF0aW9uIHN1Y2Nlc3NmdWw6Jywge1xuICAgICAgICAgICAgICAgICAgICBnYXNFc3RpbWF0ZTogZ2FzRXN0aW1hdGlvbi5nYXNFc3RpbWF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZXN0aW1hdGVkQ29zdDogZ2FzRXN0aW1hdGlvbi5lc3RpbWF0ZWRDb3N0RXRoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnVHJhbnNhY3Rpb25TZXJ2aWNlIC0gU2VuZGluZyBFUkMyMCB0cmFuc2Zlci4uLicpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFt0cmFuc2FjdGlvblBhcmFtc10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IGdldFRyYW5zYWN0aW9uSGFzaFdpdGhGYWxsYmFjayhwcm92aWRlciwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnVHJhbnNhY3Rpb25TZXJ2aWNlIC0gRVJDMjAgdHJhbnNmZXIgc2VudCBzdWNjZXNzZnVsbHk6JywgdHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIkbS5lcnJvcignVHJhbnNhY3Rpb25TZXJ2aWNlIC0gRVJDMjAgdHJhbnNmZXIgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRVJDMjAgdHJhbnNmZXIgZmFpbGVkOiAke2V4dHJhY3RFcnJvck1lc3NhZ2UoZXJyb3IsICdFUkMyMCB0cmFuc2ZlcicpfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEludGVybmFsIGNvbnN0YW50cyBmb3IgYWRhcHRlciBiZWhhdmlvclxuICovXG5jb25zdCBBREFQVEVSX0NPTlNUQU5UUyQxID0ge1xuICAgIC8vIERlZmF1bHQgMiUgYnVmZmVyICgyMDAgYnBzKSB0byBoYW5kbGUgcHJlY2lzaW9uIGlzc3Vlcy4gQ2FuIGJlIG92ZXJyaWRkZW4gcGVyLWNhbGwgdmlhIEV4ZWN1dGVQYXJhbXMuYXBwcm92YWxCdWZmZXJCcHNcbiAgICBBUFBST1ZBTF9CVUZGRVJfQlBTX0RFRkFVTFQ6IDIwMG4sXG4gICAgREVGQVVMVF9ERUNJTUFMUzogMTgsXG4gICAgTUFYX0FQUFJPVkFMX0FNT1VOVDogJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsXG59O1xuLyoqXG4gKiBTZXJ2aWNlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyBjb250cmFjdCBhcHByb3ZhbHNcbiAqL1xuY2xhc3MgQXBwcm92YWxTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFwcHJvdmFsIGlzIG5lZWRlZCBmb3IgYSB0b2tlbiBzcGVuZGluZyBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBjaGVja0FwcHJvdmFsTmVlZGVkKHRva2VuQXBwcm92YWwsIHNwZW5kZXJBZGRyZXNzLCBjaGFpbklkLCBhcHByb3ZhbEJ1ZmZlckJwcykge1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuYWRhcHRlci5uZXh1c1NESy5nZXRFVk1DbGllbnQoKS5nZXRBZGRyZXNzZXMoKTtcbiAgICAgICAgaWYgKCFhY2NvdW50cyB8fCBhY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjb3VudHMgYXZhaWxhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3duZXJBZGRyZXNzID0gYWNjb3VudHNbMF07XG4gICAgICAgIGNvbnN0IHRva2VuQ29udHJhY3RBZGRyZXNzID0gZ2V0VG9rZW5Db250cmFjdEFkZHJlc3ModG9rZW5BcHByb3ZhbC50b2tlbiwgY2hhaW5JZCk7XG4gICAgICAgIGlmICghdG9rZW5Db250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9rZW4gY29udHJhY3QgYWRkcmVzcyBub3QgZm91bmQgZm9yICR7dG9rZW5BcHByb3ZhbC50b2tlbn0gb24gY2hhaW4gJHtjaGFpbklkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGFtb3VudCB0byBwcm9wZXIgdG9rZW4gdW5pdHMgLSBoYW5kbGUgYm90aCBkZWNpbWFsIGFuZCBpbnRlZ2VyIGZvcm1hdHNcbiAgICAgICAgICAgIGxldCBhbW91bnRJbldlaTtcbiAgICAgICAgICAgIC8vIEdldCB0b2tlbiBtZXRhZGF0YSBmb3IgZGVjaW1hbCBoYW5kbGluZ1xuICAgICAgICAgICAgY29uc3QgdG9rZW5NZXRhZGF0YSA9IFRPS0VOX01FVEFEQVRBW3Rva2VuQXBwcm92YWwudG9rZW4udG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IHRva2VuTWV0YWRhdGE/LmRlY2ltYWxzIHx8IEFEQVBURVJfQ09OU1RBTlRTJDEuREVGQVVMVF9ERUNJTUFMUztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGJvdGggZGVjaW1hbCBzdHJpbmdzICh1c2VyLWZyaWVuZGx5KSBhbmQgaW50ZWdlciBzdHJpbmdzIChhbHJlYWR5IGNvbnZlcnRlZClcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIGxvZ2ljIGZyb20gdGhlIGxlZ2FjeSBhZGFwdGVyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuQXBwcm92YWwuYW1vdW50LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVjaW1hbCBhbW91bnQgLSB1c2VyLWZyaWVuZGx5IGZvcm1hdCBsaWtlIFwiMC4wMVwiXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudEluV2VpID0gcGFyc2VVbml0cyQxKHRva2VuQXBwcm92YWwuYW1vdW50LCBkZWNpbWFscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnRlZ2VyIGFtb3VudCAtIGxpa2VseSBhbHJlYWR5IGluIHdlaS9taWNybyBmb3JtYXQgbGlrZSBcIjEwMDAwXCJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIFVTREMgYW5kIG90aGVyIDYtZGVjaW1hbCB0b2tlbnMsIGNoZWNrIGlmIHRoaXMgaXMgYWxyZWFkeSBpbiBtaWNyby11bml0c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbW91bnROdW0gPSBCaWdJbnQodG9rZW5BcHByb3ZhbC5hbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBVU0RDX1RIUkVTSE9MRCA9IDEwMDAwMDBuOyAvLyAxIFVTREMgaW4gbWljcm8tdW5pdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2ltYWxzID09PSA2ICYmIGFtb3VudE51bSA+IFVTRENfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgVVNEQywgbGFyZ2UgbnVtYmVycyBhcmUgbGlrZWx5IGFscmVhZHkgaW4gbWljcm8tdW5pdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudEluV2VpID0gYW1vdW50TnVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2ltYWxzID09PSAxOCAmJiBhbW91bnROdW0gPiAxMDAwMDAwMDAwMDAwMDAwMDAwbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIEVUSCwgbGFyZ2UgbnVtYmVycyBhcmUgbGlrZWx5IGFscmVhZHkgaW4gd2VpXG4gICAgICAgICAgICAgICAgICAgICAgICBhbW91bnRJbldlaSA9IGFtb3VudE51bTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNtYWxsIG51bWJlcnMgYXJlIGxpa2VseSB1c2VyIGFtb3VudHMgdGhhdCBuZWVkIGNvbnZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudEluV2VpID0gcGFyc2VVbml0cyQxKHRva2VuQXBwcm92YWwuYW1vdW50LCBkZWNpbWFscyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBhbW91bnQgJHt0b2tlbkFwcHJvdmFsLmFtb3VudH0gZm9yICR7dG9rZW5BcHByb3ZhbC50b2tlbn06ICR7ZXh0cmFjdEVycm9yTWVzc2FnZShlcnJvciwgJ2Ftb3VudCBwYXJzaW5nJyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QWxsb3dhbmNlID0gYXdhaXQgdGhpcy5hZGFwdGVyLm5leHVzU0RLLmdldEVWTUNsaWVudCgpLnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdG9rZW5Db250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYWJpOiBlcmMyMEFiaSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdhbGxvd2FuY2UnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtvd25lckFkZHJlc3MsIHNwZW5kZXJBZGRyZXNzXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQWRkIGEgc21hbGwgYnVmZmVyIHRvIGF2b2lkIHJlcGVhdGVkIGFwcHJvdmFscyBkdWUgdG8gbWlub3IgYW1vdW50IGRpZmZlcmVuY2VzXG4gICAgICAgICAgICBjb25zdCBidWZmZXJCcHMgPSBhcHByb3ZhbEJ1ZmZlckJwcyAhPT0gdW5kZWZpbmVkICYmIGFwcHJvdmFsQnVmZmVyQnBzID49IDBcbiAgICAgICAgICAgICAgICA/IEJpZ0ludChhcHByb3ZhbEJ1ZmZlckJwcylcbiAgICAgICAgICAgICAgICA6IEFEQVBURVJfQ09OU1RBTlRTJDEuQVBQUk9WQUxfQlVGRkVSX0JQU19ERUZBVUxUO1xuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRBbW91bnRXaXRoQnVmZmVyID0gYW1vdW50SW5XZWkgKyAoYW1vdW50SW5XZWkgKiBidWZmZXJCcHMpIC8gMTAwMDBuO1xuICAgICAgICAgICAgY29uc3QgbmVlZHNBcHByb3ZhbCA9IGN1cnJlbnRBbGxvd2FuY2UgPCByZXF1aXJlZEFtb3VudFdpdGhCdWZmZXI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5lZWRzQXBwcm92YWwsXG4gICAgICAgICAgICAgICAgY3VycmVudEFsbG93YW5jZSxcbiAgICAgICAgICAgICAgICByZXF1aXJlZEFtb3VudDogYW1vdW50SW5XZWksXG4gICAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiB0b2tlbkNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzcGVuZGVyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICB0b2tlbjogdG9rZW5BcHByb3ZhbC50b2tlbixcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIGhhc1BlbmRpbmdBcHByb3ZhbDogIW5lZWRzQXBwcm92YWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY2hlY2sgYXBwcm92YWwgZm9yICR7dG9rZW5BcHByb3ZhbC50b2tlbn06ICR7ZXh0cmFjdEVycm9yTWVzc2FnZShlcnJvciwgJ2FwcHJvdmFsIGNoZWNrJyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIGNvbnRyYWN0IGFwcHJvdmFsIGlzIGluIHBsYWNlIGZvciB0b2tlbiBzcGVuZGluZ1xuICAgICAqL1xuICAgIGFzeW5jIGVuc3VyZUNvbnRyYWN0QXBwcm92YWwodG9rZW5BcHByb3ZhbCwgc3BlbmRlckFkZHJlc3MsIGNoYWluSWQsIHdhaXRGb3JDb25maXJtYXRpb24gPSBmYWxzZSwgYXBwcm92YWxCdWZmZXJCcHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFwcHJvdmFsIGlzIG5lZWRlZFxuICAgICAgICAgICAgY29uc3QgYXBwcm92YWxJbmZvID0gYXdhaXQgdGhpcy5jaGVja0FwcHJvdmFsTmVlZGVkKHRva2VuQXBwcm92YWwsIHNwZW5kZXJBZGRyZXNzLCBjaGFpbklkLCBhcHByb3ZhbEJ1ZmZlckJwcyk7XG4gICAgICAgICAgICAvLyBTa2lwIGFwcHJvdmFsIGlmIHN1ZmZpY2llbnQgYWxsb3dhbmNlIGV4aXN0c1xuICAgICAgICAgICAgaWYgKCFhcHByb3ZhbEluZm8ubmVlZHNBcHByb3ZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHdhc05lZWRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1lZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmFkYXB0ZXIubmV4dXNTREsuZ2V0RVZNQ2xpZW50KCkuZ2V0QWRkcmVzc2VzKCk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnRzIHx8IGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHdhc05lZWRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdObyBhY2NvdW50cyBhdmFpbGFibGUnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgYnVmZmVyIGFtb3VudCB3aXRoIHByb3BlciBkZWNpbWFsIGhhbmRsaW5nIGZvciBNZXRhTWFzayBkaXNwbGF5XG4gICAgICAgICAgICBjb25zdCBidWZmZXJCcHMgPSBhcHByb3ZhbEJ1ZmZlckJwcyAhPT0gdW5kZWZpbmVkICYmIGFwcHJvdmFsQnVmZmVyQnBzID49IDBcbiAgICAgICAgICAgICAgICA/IEJpZ0ludChhcHByb3ZhbEJ1ZmZlckJwcylcbiAgICAgICAgICAgICAgICA6IEFEQVBURVJfQ09OU1RBTlRTJDEuQVBQUk9WQUxfQlVGRkVSX0JQU19ERUZBVUxUO1xuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRBbW91bnRXaXRoQnVmZmVyID0gYXBwcm92YWxJbmZvLnJlcXVpcmVkQW1vdW50ICsgKGFwcHJvdmFsSW5mby5yZXF1aXJlZEFtb3VudCAqIGJ1ZmZlckJwcykgLyAxMDAwMG47XG4gICAgICAgICAgICAvLyBHZXQgdG9rZW4gZGVjaW1hbHMgZm9yIHByb3BlciBmb3JtYXR0aW5nXG4gICAgICAgICAgICBjb25zdCB0b2tlbk1ldGFkYXRhID0gVE9LRU5fTUVUQURBVEFbdG9rZW5BcHByb3ZhbC50b2tlbi50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuRGVjaW1hbHMgPSB0b2tlbk1ldGFkYXRhPy5kZWNpbWFscyB8fCBBREFQVEVSX0NPTlNUQU5UUyQxLkRFRkFVTFRfREVDSU1BTFM7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIGh1bWFuLXJlYWRhYmxlIGZvcm1hdCBmaXJzdCwgdGhlbiBiYWNrIHRvIHdlaSBmb3IgYmV0dGVyIE1ldGFNYXNrIGRpc3BsYXlcbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyBNZXRhTWFzayBzaG93cyBcIjAuMDEwMDFcIiBpbnN0ZWFkIG9mIFwiMTAxMDBcIlxuICAgICAgICAgICAgY29uc3QgaHVtYW5SZWFkYWJsZUFtb3VudCA9IGZvcm1hdFVuaXRzJDEocmVxdWlyZWRBbW91bnRXaXRoQnVmZmVyLCB0b2tlbkRlY2ltYWxzKTtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIGFwcHJvdmFsIC0gSHVtYW4gcmVhZGFibGUgYW1vdW50IGZvciBNZXRhTWFzazonLCB7XG4gICAgICAgICAgICAgICAgaHVtYW5SZWFkYWJsZUFtb3VudCxcbiAgICAgICAgICAgICAgICB0b2tlbjogdG9rZW5BcHByb3ZhbC50b2tlbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ29udmVydCBiYWNrIHRvIHdlaSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBjb25zdCBmaW5hbEFwcHJvdmFsQW1vdW50ID0gcGFyc2VVbml0cyQxKGh1bWFuUmVhZGFibGVBbW91bnQsIHRva2VuRGVjaW1hbHMpO1xuICAgICAgICAgICAgY29uc3QgY2hhaW4gPSB0aGlzLmFkYXB0ZXIubmV4dXNTREsuY2hhaW5MaXN0LmdldENoYWluQnlJRChjaGFpbklkKTtcbiAgICAgICAgICAgIGlmICghY2hhaW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYWluIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IGF3YWl0IHRoaXMuYWRhcHRlci5uZXh1c1NESy5nZXRFVk1DbGllbnQoKS53cml0ZUNvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdhcHByb3ZlJyxcbiAgICAgICAgICAgICAgICBhYmk6IGVyYzIwQWJpLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFwcHJvdmFsSW5mby50b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYXJnczogW3NwZW5kZXJBZGRyZXNzLCBmaW5hbEFwcHJvdmFsQW1vdW50XSxcbiAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50c1swXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHdhaXRGb3JDb25maXJtYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIubmV4dXNTREsuZ2V0RVZNQ2xpZW50KCkud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeUNvdW50OiAxMCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChjb25maXJtYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkbS53YXJuKCdERUJVRyBhcHByb3ZhbCAtIENvbmZpcm1hdGlvbiBmYWlsZWQ6JywgY29uZmlybWF0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FzTmVlZGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgQXBwcm92YWwgY29uZmlybWF0aW9uIGZhaWxlZDogJHtleHRyYWN0RXJyb3JNZXNzYWdlKGNvbmZpcm1hdGlvbkVycm9yLCAnYXBwcm92YWwgY29uZmlybWF0aW9uJyl9YCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgICAgICB3YXNOZWVkZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1lZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgd2FzTmVlZGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maXJtZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlciRtLmVycm9yKCdERUJVRyBhcHByb3ZhbCAtIEVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2FzTmVlZGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBleHRyYWN0RXJyb3JNZXNzYWdlKGVycm9yLCAnY29udHJhY3QgYXBwcm92YWwnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogTXVsdGktc3RlcCBzaW11bGF0aW9uIGVuZ2luZSB3aXRoIHN0YXRlIG92ZXJyaWRlIGNhcGFiaWxpdGllc1xuICovXG5jbGFzcyBTaW11bGF0aW9uRW5naW5lIHtcbiAgICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gICAgfVxuICAgIGVuc3VyZUluaXRpYWxpemVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWRhcHRlci5uZXh1c1NESy5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWRhcHRlciBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWluIGVudHJ5IHBvaW50IGZvciBlbmhhbmNlZCBzaW11bGF0aW9uIHdpdGggYXV0b21hdGljIHN0YXRlIHNldHVwXG4gICAgICovXG4gICAgYXN5bmMgc2ltdWxhdGVXaXRoU3RhdGVTZXR1cChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VyLCB0b2tlblJlcXVpcmVkLCBhbW91bnRSZXF1aXJlZCwgY29udHJhY3RDYWxsIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gY29udHJhY3RDYWxsLnRvQ2hhaW5JZDtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIFNpbXVsYXRpb25FbmdpbmUgLSBTdGFydGluZyBlbmhhbmNlZCBzaW11bGF0aW9uIHdpdGggZnVsbCBjb250ZXh0OicsIHtcbiAgICAgICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgICAgIHRva2VuUmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgYW1vdW50UmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBjb250cmFjdDogY29udHJhY3RDYWxsLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogY29udHJhY3RDYWxsLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBjb250cmFjdENhbGxQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5BcHByb3ZhbDogY29udHJhY3RDYWxsLnRva2VuQXBwcm92YWwsXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkRnVuY3Rpb25QYXJhbXM6IHR5cGVvZiBjb250cmFjdENhbGwuYnVpbGRGdW5jdGlvblBhcmFtcyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTdGVwIDE6IENoZWNrIHVzZXIncyBjdXJyZW50IHRva2VuIGJhbGFuY2VcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VDaGVjayA9IGF3YWl0IHRoaXMuY2hlY2tVc2VyQmFsYW5jZSh1c2VyLCB0b2tlblJlcXVpcmVkLCBjaGFpbklkLCBhbW91bnRSZXF1aXJlZCk7XG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdERUJVRyBTaW11bGF0aW9uRW5naW5lIC0gQmFsYW5jZSBjaGVjayByZXN1bHQ6JywgYmFsYW5jZUNoZWNrKTtcbiAgICAgICAgICAgIC8vIFN0ZXAgMjogR2VuZXJhdGUgc2ltdWxhdGlvbiBzdGVwc1xuICAgICAgICAgICAgY29uc3Qgc3RlcHMgPSBhd2FpdCB0aGlzLmdlbmVyYXRlU2ltdWxhdGlvblN0ZXBzKHtcbiAgICAgICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgICAgIHRva2VuUmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgYW1vdW50UmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgY29udHJhY3RDYWxsLFxuICAgICAgICAgICAgICAgIGJhbGFuY2VDaGVjayxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnREVCVUcgU2ltdWxhdGlvbkVuZ2luZSAtIEdlbmVyYXRlZCBzdGVwczonLCBzdGVwcy5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gU3RlcCAzOiBFeGVjdXRlIG11bHRpLXN0ZXAgc2ltdWxhdGlvblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRlQmF0Y2hTaW11bGF0aW9uKHN0ZXBzLCBjaGFpbklkKTtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIFNpbXVsYXRpb25FbmdpbmUgLSBTaW11bGF0aW9uIGNvbXBsZXRlOicsIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiByZXN1bHQuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICB0b3RhbEdhczogcmVzdWx0LnRvdGFsR2FzVXNlZCxcbiAgICAgICAgICAgICAgICBzdGVwc0V4ZWN1dGVkOiByZXN1bHQuc3RlcHMubGVuZ3RoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyJG0uZXJyb3IoJ0RFQlVHIFNpbXVsYXRpb25FbmdpbmUgLSBTaW11bGF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGYWlsZWRSZXN1bHQoYEVuaGFuY2VkIHNpbXVsYXRpb24gZmFpbGVkOiAke2V4dHJhY3RFcnJvck1lc3NhZ2UoZXJyb3IsICdzaW11bGF0aW9uJyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdXNlcidzIHRva2VuIGJhbGFuY2Ugb24gc3BlY2lmaWMgY2hhaW5cbiAgICAgKi9cbiAgICBhc3luYyBjaGVja1VzZXJCYWxhbmNlKHVzZXIsIHRva2VuLCBjaGFpbklkLCByZXF1aXJlZEFtb3VudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5BZGRyZXNzID0gZ2V0VG9rZW5Db250cmFjdEFkZHJlc3ModG9rZW4sIGNoYWluSWQpO1xuICAgICAgICAgICAgaWYgKCF0b2tlbkFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRva2VuICR7dG9rZW59IG5vdCBzdXBwb3J0ZWQgb24gY2hhaW4gJHtjaGFpbklkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yIG5hdGl2ZSBFVEgsIHVzZSBldGhfZ2V0QmFsYW5jZVxuICAgICAgICAgICAgaWYgKHRva2VuID09PSAnRVRIJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCB0aGlzLmFkYXB0ZXIubmV4dXNTREsuZ2V0RVZNQ2xpZW50KCkuZ2V0QmFsYW5jZSh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHVzZXIsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnOiAnbGF0ZXN0JyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlQmlnSW50ID0gQmlnSW50KGJhbGFuY2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkQmlnSW50ID0gcmVxdWlyZWRBbW91bnQgPyBCaWdJbnQocmVxdWlyZWRBbW91bnQpIDogQmlnSW50KDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpY2llbnQgPSBiYWxhbmNlQmlnSW50ID49IHJlcXVpcmVkQmlnSW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3J0ZmFsbCA9IHN1ZmZpY2llbnQgPyAnMCcgOiAocmVxdWlyZWRCaWdJbnQgLSBiYWxhbmNlQmlnSW50KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2U6IGJhbGFuY2UudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgc3VmZmljaWVudCxcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRmYWxsLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCB0aGlzLmFkYXB0ZXIubmV4dXNTREsuZ2V0RVZNQ2xpZW50KCkucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBhYmk6IGVyYzIwQWJpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ2JhbGFuY2VPZicsXG4gICAgICAgICAgICAgICAgYXJnczogW3VzZXJdLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkQW1vdW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRCaWdJbnQgPSBCaWdJbnQocmVxdWlyZWRBbW91bnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpY2llbnQgPSBiYWxhbmNlID49IHJlcXVpcmVkQmlnSW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3J0ZmFsbCA9IHN1ZmZpY2llbnQgPyAnMCcgOiAocmVxdWlyZWRCaWdJbnQgLSBiYWxhbmNlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2U6IGJhbGFuY2UudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgc3VmZmljaWVudCxcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRmYWxsLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmFsYW5jZTogYmFsYW5jZS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHN1ZmZpY2llbnQ6IGZhbHNlLCAvLyBDYW5ub3QgZGV0ZXJtaW5lIHdpdGhvdXQgcmVxdWlyZWQgYW1vdW50XG4gICAgICAgICAgICAgICAgc2hvcnRmYWxsOiAnMCcsXG4gICAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oYEZhaWxlZCB0byBjaGVjayBiYWxhbmNlIGZvciAke3Rva2VufSBvbiBjaGFpbiAke2NoYWluSWR9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmFsYW5jZTogJzAnLFxuICAgICAgICAgICAgICAgIHN1ZmZpY2llbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3J0ZmFsbDogcmVxdWlyZWRBbW91bnQgfHwgJzAnLFxuICAgICAgICAgICAgICAgIHRva2VuQWRkcmVzczogZ2V0VG9rZW5Db250cmFjdEFkZHJlc3ModG9rZW4sIGNoYWluSWQpIHx8ICcnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0b3JhZ2Ugc2xvdCBmb3IgdG9rZW4gYmFsYW5jZXMgbWFwcGluZyAtIFByb2R1Y3Rpb24gUmVhZHkgU3RhdGljIE1hcHBpbmdcbiAgICAgKiBCYXNlZCBvbiBhY3R1YWwgY29udHJhY3QgYW5hbHlzaXMgZm9yIGFsbCBzdXBwb3J0ZWQgdG9rZW5zIGFuZCBjaGFpbnNcbiAgICAgKi9cbiAgICBnZXRCYWxhbmNlU3RvcmFnZVNsb3QodG9rZW4sIGNoYWluSWQpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZVNsb3RNYXBwaW5nID0ge1xuICAgICAgICAgICAgLy8gRXRoZXJldW0gTWFpbm5ldCAoMSlcbiAgICAgICAgICAgIDE6IHtcbiAgICAgICAgICAgICAgICBFVEg6IDAsXG4gICAgICAgICAgICAgICAgVVNEQzogOSxcbiAgICAgICAgICAgICAgICBVU0RUOiAyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEJhc2UgTWFpbm5ldCAoODQ1MylcbiAgICAgICAgICAgIDg0NTM6IHtcbiAgICAgICAgICAgICAgICBFVEg6IDAsXG4gICAgICAgICAgICAgICAgVVNEQzogOSxcbiAgICAgICAgICAgICAgICBVU0RUOiAyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEFyYml0cnVtIE9uZSAoNDIxNjEpXG4gICAgICAgICAgICA0MjE2MToge1xuICAgICAgICAgICAgICAgIEVUSDogMCxcbiAgICAgICAgICAgICAgICBVU0RDOiA5LFxuICAgICAgICAgICAgICAgIFVTRFQ6IDIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gT3B0aW1pc20gKDEwKVxuICAgICAgICAgICAgMTA6IHtcbiAgICAgICAgICAgICAgICBFVEg6IDAsXG4gICAgICAgICAgICAgICAgVVNEQzogOSxcbiAgICAgICAgICAgICAgICBVU0RUOiAyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFBvbHlnb24gKDEzNylcbiAgICAgICAgICAgIDEzNzoge1xuICAgICAgICAgICAgICAgIEVUSDogMCxcbiAgICAgICAgICAgICAgICBVU0RDOiA5LFxuICAgICAgICAgICAgICAgIFVTRFQ6IDIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gQXZhbGFuY2hlIEMtQ2hhaW4gKDQzMTE0KVxuICAgICAgICAgICAgNDMxMTQ6IHtcbiAgICAgICAgICAgICAgICBFVEg6IDAsXG4gICAgICAgICAgICAgICAgVVNEQzogOSxcbiAgICAgICAgICAgICAgICBVU0RUOiAyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFNjcm9sbCAoNTM0MzUyKVxuICAgICAgICAgICAgNTM0MzUyOiB7XG4gICAgICAgICAgICAgICAgRVRIOiAwLFxuICAgICAgICAgICAgICAgIFVTREM6IDksXG4gICAgICAgICAgICAgICAgVVNEVDogMixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBCYXNlIFNlcG9saWEgVGVzdG5ldCAoODQ1MzIpXG4gICAgICAgICAgICA4NDUzMjoge1xuICAgICAgICAgICAgICAgIEVUSDogMCxcbiAgICAgICAgICAgICAgICBVU0RDOiA5LFxuICAgICAgICAgICAgICAgIFVTRFQ6IDIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gQXJiaXRydW0gU2Vwb2xpYSBUZXN0bmV0ICg0MjE2MTQpXG4gICAgICAgICAgICA0MjE2MTQ6IHtcbiAgICAgICAgICAgICAgICBFVEg6IDAsXG4gICAgICAgICAgICAgICAgVVNEQzogOSxcbiAgICAgICAgICAgICAgICBVU0RUOiAyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIE9wdGltaXNtIFNlcG9saWEgVGVzdG5ldCAoMTExNTU0MjApXG4gICAgICAgICAgICAxMTE1NTQyMDoge1xuICAgICAgICAgICAgICAgIEVUSDogMCxcbiAgICAgICAgICAgICAgICBVU0RDOiA5LFxuICAgICAgICAgICAgICAgIFVTRFQ6IDIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gUG9seWdvbiBBbW95IFRlc3RuZXQgKDgwMDAyKVxuICAgICAgICAgICAgODAwMDI6IHtcbiAgICAgICAgICAgICAgICBFVEg6IDAsXG4gICAgICAgICAgICAgICAgVVNEQzogOSxcbiAgICAgICAgICAgICAgICBVU0RUOiAyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2hhaW5NYXBwaW5nID0gc3RvcmFnZVNsb3RNYXBwaW5nW2NoYWluSWRdO1xuICAgICAgICBpZiAoIWNoYWluTWFwcGluZykge1xuICAgICAgICAgICAgbG9nZ2VyJG0ud2FybihgVW5zdXBwb3J0ZWQgY2hhaW4gJHtjaGFpbklkfSwgZmFsbGluZyBiYWNrIHRvIGRlZmF1bHRzYCk7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayBkZWZhdWx0cyBiYXNlZCBvbiBtb3N0IGNvbW1vbiBwYXR0ZXJuc1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuID09PSAnVVNEQycgPyA5IDogdG9rZW4gPT09ICdVU0RUJyA/IDIgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNsb3QgPSBjaGFpbk1hcHBpbmdbdG9rZW5dO1xuICAgICAgICBpZiAoc2xvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsb2dnZXIkbS53YXJuKGBUb2tlbiAke3Rva2VufSBub3Qgc3VwcG9ydGVkIG9uIGNoYWluICR7Y2hhaW5JZH0sIGZhbGxpbmcgYmFjayB0byBkZWZhdWx0c2ApO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuID09PSAnVVNEQycgPyA5IDogdG9rZW4gPT09ICdVU0RUJyA/IDIgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlciRtLmluZm8oYFVzaW5nIHN0b3JhZ2Ugc2xvdCAke3Nsb3R9IGZvciAke3Rva2VufSBvbiBjaGFpbiAke2NoYWluSWR9YCk7XG4gICAgICAgIHJldHVybiBzbG90O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBzdGF0ZSBvdmVycmlkZXMgdG8gZnVuZCB1c2VyIHdpdGggcmVxdWlyZWQgdG9rZW5zXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVTdGF0ZU92ZXJyaWRlcyh1c2VyLCB0b2tlbiwgcmVxdWlyZWRBbW91bnQsIGNoYWluSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuQWRkcmVzcyA9IGdldFRva2VuQ29udHJhY3RBZGRyZXNzKHRva2VuLCBjaGFpbklkKTtcbiAgICAgICAgICAgIGlmICghdG9rZW5BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb2tlbiAke3Rva2VufSBub3Qgc3VwcG9ydGVkIG9uIGNoYWluICR7Y2hhaW5JZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciBuYXRpdmUgRVRIXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09ICdFVEgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgW3VzZXJdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlOiBgMHgke0JpZ0ludChyZXF1aXJlZEFtb3VudCkudG9TdHJpbmcoMTYpfWAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciBFUkMyMCB0b2tlbnMgLSBvdmVycmlkZSB0aGUgYmFsYW5jZSBtYXBwaW5nIHVzaW5nIHZlcmlmaWVkIHN0b3JhZ2Ugc2xvdHNcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VTbG90ID0gdGhpcy5nZXRCYWxhbmNlU3RvcmFnZVNsb3QodG9rZW4sIGNoYWluSWQpO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHN0b3JhZ2Ugc2xvdCBmb3IgdXNlcidzIGJhbGFuY2U6IGtlY2NhazI1Nih1c2VyX2FkZHJlc3MgLiBiYWxhbmNlc19zbG90KVxuICAgICAgICAgICAgY29uc3QgdXNlckJhbGFuY2VTbG90ID0ga2VjY2FrMjU2KGVuY29kZVBhY2tlZChbJ2FkZHJlc3MnLCAndWludDI1NiddLCBbdXNlciwgQmlnSW50KGJhbGFuY2VTbG90KV0pKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgYW1vdW50IHRvIGhleCB3aXRoIHByb3BlciBwYWRkaW5nXG4gICAgICAgICAgICBjb25zdCBhbW91bnRIZXggPSBgMHgke0JpZ0ludChyZXF1aXJlZEFtb3VudCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCAnMCcpfWA7XG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKGBHZW5lcmF0aW5nIHN0YXRlIG92ZXJyaWRlIGZvciAke3Rva2VufSBvbiBjaGFpbiAke2NoYWluSWR9OiBzbG90PSR7YmFsYW5jZVNsb3R9LCBzdG9yYWdlS2V5PSR7dXNlckJhbGFuY2VTbG90fWApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBbdG9rZW5BZGRyZXNzXToge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbdXNlckJhbGFuY2VTbG90XTogYW1vdW50SGV4LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyJG0uZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgc3RhdGUgb3ZlcnJpZGVzOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBzZXF1ZW5jZSBvZiBzaW11bGF0aW9uIHN0ZXBzIG5lZWRlZFxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlU2ltdWxhdGlvblN0ZXBzKHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IHVzZXIsIHRva2VuUmVxdWlyZWQsIGFtb3VudFJlcXVpcmVkLCBjb250cmFjdENhbGwsIGJhbGFuY2VDaGVjayB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBzdGVwcyA9IFtdO1xuICAgICAgICAvLyBDaGVjayBpZiB1c2VyIGhhcyBzdWZmaWNpZW50IGJhbGFuY2VcbiAgICAgICAgY29uc3QgcmVxdWlyZWRBbW91bnRCaWdJbnQgPSBCaWdJbnQoYW1vdW50UmVxdWlyZWQpO1xuICAgICAgICBjb25zdCBjdXJyZW50QmFsYW5jZUJpZ0ludCA9IEJpZ0ludChiYWxhbmNlQ2hlY2suYmFsYW5jZSk7XG4gICAgICAgIGNvbnN0IG5lZWRzRnVuZGluZyA9IGN1cnJlbnRCYWxhbmNlQmlnSW50IDwgcmVxdWlyZWRBbW91bnRCaWdJbnQ7XG4gICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIGdlbmVyYXRlU2ltdWxhdGlvblN0ZXBzIC0gQmFsYW5jZSBhbmFseXNpczonLCB7XG4gICAgICAgICAgICByZXF1aXJlZDogcmVxdWlyZWRBbW91bnRCaWdJbnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGN1cnJlbnQ6IGN1cnJlbnRCYWxhbmNlQmlnSW50LnRvU3RyaW5nKCksXG4gICAgICAgICAgICBuZWVkc0Z1bmRpbmcsXG4gICAgICAgICAgICB0b2tlblJlcXVpcmVkLFxuICAgICAgICAgICAgdXNlcixcbiAgICAgICAgICAgIGNvbnRyYWN0Q2FsbDoge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogY29udHJhY3RDYWxsLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0Q2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdG9rZW5BcHByb3ZhbDogY29udHJhY3RDYWxsLnRva2VuQXBwcm92YWwsXG4gICAgICAgICAgICAgICAgYnVpbGRGdW5jdGlvblBhcmFtc1R5cGU6IHR5cGVvZiBjb250cmFjdENhbGwuYnVpbGRGdW5jdGlvblBhcmFtcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTdGVwIDE6IEZ1bmRpbmcgc3RlcCAoaWYgbmVlZGVkKVxuICAgICAgICBpZiAobmVlZHNGdW5kaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZU92ZXJyaWRlcyA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVTdGF0ZU92ZXJyaWRlcyh1c2VyLCB0b2tlblJlcXVpcmVkLCBhbW91bnRSZXF1aXJlZCwgY29udHJhY3RDYWxsLnRvQ2hhaW5JZCk7XG4gICAgICAgICAgICBzdGVwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZnVuZGluZycsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBGdW5kIHVzZXIgd2l0aCAke2Ftb3VudFJlcXVpcmVkfSAke3Rva2VuUmVxdWlyZWR9YCxcbiAgICAgICAgICAgICAgICBzdGVwSWQ6ICdmdW5kaW5nLXN0ZXAnLFxuICAgICAgICAgICAgICAgIHN0YXRlT3ZlcnJpZGU6IHN0YXRlT3ZlcnJpZGVzLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjb250cmFjdENhbGwudG9DaGFpbklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHVzZXIsXG4gICAgICAgICAgICAgICAgICAgIHRvOiB1c2VyLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJzB4MCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcnN0LCBjb252ZXJ0IGFtb3VudFJlcXVpcmVkIGZyb20gbWljcm8tdW5pdHMgdG8gdXNlci1mcmllbmRseSBmb3JtYXQgZm9yIHRoZSBjYWxsYmFja1xuICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXhwZWN0cyBhbW91bnQgaW4gdXNlci1mcmllbmRseSBmb3JtYXQgKGUuZy4sIFwiMC4wMVwiIGZvciAwLjAxIFVTREMpXG4gICAgICAgIC8vIGJ1dCBhbW91bnRSZXF1aXJlZCBjb21lcyBpbiBtaWNyby11bml0cyAoZS5nLiwgXCIxMDAwMFwiIGZvciAwLjAxIFVTREMpXG4gICAgICAgIGxvZ2dlciRtLmluZm8oJ1Rva2VuIG1ldGFkYXRhOicsIHsgbWV0YTogVE9LRU5fTUVUQURBVEEsIHRva2VuUmVxdWlyZWQgfSk7XG4gICAgICAgIGNvbnN0IGRlY2ltYWxzID0gVE9LRU5fTUVUQURBVEFbdG9rZW5SZXF1aXJlZF0/LmRlY2ltYWxzID8/IDY7XG4gICAgICAgIGNvbnN0IHVzZXJGcmllbmRseUFtb3VudCA9IGZvcm1hdFVuaXRzJDEoQmlnSW50KGFtb3VudFJlcXVpcmVkKSwgZGVjaW1hbHMpO1xuICAgICAgICBsb2dnZXIkbS5pbmZvKCdERUJVRyBTaW11bGF0aW9uRW5naW5lIC0gQW1vdW50IGNvbnZlcnNpb246Jywge1xuICAgICAgICAgICAgbWljcm9Vbml0czogYW1vdW50UmVxdWlyZWQsXG4gICAgICAgICAgICBkZWNpbWFscyxcbiAgICAgICAgICAgIHVzZXJGcmllbmRseTogdXNlckZyaWVuZGx5QW1vdW50LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2FsbCB0aGUgYnVpbGRGdW5jdGlvblBhcmFtcyB3aXRoIHVzZXItZnJpZW5kbHkgYW1vdW50XG4gICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIFNpbXVsYXRpb25FbmdpbmUgLSBDYWxsaW5nIGJ1aWxkRnVuY3Rpb25QYXJhbXMgd2l0aDonLCB7XG4gICAgICAgICAgICB0b2tlblJlcXVpcmVkLFxuICAgICAgICAgICAgdXNlckZyaWVuZGx5QW1vdW50LFxuICAgICAgICAgICAgY2hhaW5JZDogY29udHJhY3RDYWxsLnRvQ2hhaW5JZCxcbiAgICAgICAgICAgIHVzZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGZ1bmN0aW9uUGFyYW1zLCB2YWx1ZSB9ID0gY29udHJhY3RDYWxsLmJ1aWxkRnVuY3Rpb25QYXJhbXModG9rZW5SZXF1aXJlZCwgdXNlckZyaWVuZGx5QW1vdW50LCBjb250cmFjdENhbGwudG9DaGFpbklkLCB1c2VyKTtcbiAgICAgICAgbG9nZ2VyJG0uaW5mbygnREVCVUcgU2ltdWxhdGlvbkVuZ2luZSAtIGJ1aWxkRnVuY3Rpb25QYXJhbXMgcmVzdWx0OicsIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUGFyYW1zLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBmdW5jdGlvblBhcmFtc0xlbmd0aDogZnVuY3Rpb25QYXJhbXM/Lmxlbmd0aCxcbiAgICAgICAgICAgIGZ1bmN0aW9uUGFyYW1zVHlwZXM6IGZ1bmN0aW9uUGFyYW1zPy5tYXAoKHApID0+IHR5cGVvZiBwKSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN0ZXAgMjogQXBwcm92YWwgc3RlcCAoaWYgbmVlZGVkIGZvciBFUkMyMClcbiAgICAgICAgaWYgKHRva2VuUmVxdWlyZWQgIT09ICdFVEgnICYmIGNvbnRyYWN0Q2FsbC50b2tlbkFwcHJvdmFsKSB7XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxBbW91bnRUb0FwcHJvdmUgPSBhbW91bnRSZXF1aXJlZDtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIFNpbXVsYXRpb25FbmdpbmUgLSBBcHByb3ZhbCBzdGVwIHByZXBhcmF0aW9uOicsIHtcbiAgICAgICAgICAgICAgICB0b2tlblJlcXVpcmVkLFxuICAgICAgICAgICAgICAgIGFtb3VudFJlcXVpcmVkLFxuICAgICAgICAgICAgICAgIGFjdHVhbEFtb3VudFRvQXBwcm92ZSxcbiAgICAgICAgICAgICAgICBjb250cmFjdFRvQXBwcm92ZTogY29udHJhY3RDYWxsLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3M6IGJhbGFuY2VDaGVjay50b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFwcHJvdmFsQ2FsbERhdGEgPSBhd2FpdCB0aGlzLmJ1aWxkQXBwcm92YWxDYWxsRGF0YShjb250cmFjdENhbGwuY29udHJhY3RBZGRyZXNzLCBhY3R1YWxBbW91bnRUb0FwcHJvdmUpO1xuICAgICAgICAgICAgc3RlcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2FwcHJvdmFsJyxcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYEFwcHJvdmUgJHtjb250cmFjdENhbGwuY29udHJhY3RBZGRyZXNzfSB0byBzcGVuZCAke3Rva2VuUmVxdWlyZWR9YCxcbiAgICAgICAgICAgICAgICBzdGVwSWQ6ICdhcHByb3ZhbC1zdGVwJyxcbiAgICAgICAgICAgICAgICBkZXBlbmRzT246IG5lZWRzRnVuZGluZyA/IFsnZnVuZGluZy1zdGVwJ10gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGNvbnRyYWN0Q2FsbC50b0NoYWluSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdXNlcixcbiAgICAgICAgICAgICAgICAgICAgdG86IGJhbGFuY2VDaGVjay50b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGFwcHJvdmFsQ2FsbERhdGEsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnMHgwJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RlcCAzOiBFeGVjdXRlIHN0ZXBcbiAgICAgICAgLy8gRW5jb2RlIHRoZSBmdW5jdGlvbiBjYWxsIHdpdGggdGhlIGJ1aWx0IHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3QgZW5jb2RpbmdSZXN1bHQgPSBlbmNvZGVDb250cmFjdENhbGwoe1xuICAgICAgICAgICAgY29udHJhY3RBYmk6IGNvbnRyYWN0Q2FsbC5jb250cmFjdEFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogY29udHJhY3RDYWxsLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uUGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFlbmNvZGluZ1Jlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBlbmNvZGUgY29udHJhY3QgY2FsbDogJHtlbmNvZGluZ1Jlc3VsdC5lcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIkbS5pbmZvKCdERUJVRyBTaW11bGF0aW9uRW5naW5lIC0gRXhlY3V0ZSBzdGVwIHByZXBhcmF0aW9uOicsIHtcbiAgICAgICAgICAgIGVuY29kZWREYXRhOiBlbmNvZGluZ1Jlc3VsdC5kYXRhLFxuICAgICAgICAgICAgY29udHJhY3RDYWxsVmFsdWU6IGNvbnRyYWN0Q2FsbC52YWx1ZSxcbiAgICAgICAgICAgIGNhbGxiYWNrVmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZmluYWxWYWx1ZTogdmFsdWUgfHwgY29udHJhY3RDYWxsLnZhbHVlIHx8ICcweDAnLFxuICAgICAgICAgICAgZGVwZW5kc09uOiB0b2tlblJlcXVpcmVkICE9PSAnRVRIJyA/IFsnYXBwcm92YWwtc3RlcCddIDogbmVlZHNGdW5kaW5nID8gWydmdW5kaW5nLXN0ZXAnXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHN0ZXBzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2V4ZWN1dGUnLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEV4ZWN1dGUgJHtjb250cmFjdENhbGwuZnVuY3Rpb25OYW1lfSBvbiAke2NvbnRyYWN0Q2FsbC5jb250cmFjdEFkZHJlc3N9YCxcbiAgICAgICAgICAgIHN0ZXBJZDogJ2V4ZWN1dGUtc3RlcCcsXG4gICAgICAgICAgICBkZXBlbmRzT246IHRva2VuUmVxdWlyZWQgIT09ICdFVEgnID8gWydhcHByb3ZhbC1zdGVwJ10gOiBuZWVkc0Z1bmRpbmcgPyBbJ2Z1bmRpbmctc3RlcCddIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZDogY29udHJhY3RDYWxsLnRvQ2hhaW5JZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGZyb206IHVzZXIsXG4gICAgICAgICAgICAgICAgdG86IGNvbnRyYWN0Q2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YTogZW5jb2RpbmdSZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgfHwgY29udHJhY3RDYWxsLnZhbHVlIHx8ICcweDAnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIFNpbXVsYXRpb25FbmdpbmUgLSBGaW5hbCBzdGVwcyBnZW5lcmF0ZWQ6Jywge1xuICAgICAgICAgICAgdG90YWxTdGVwczogc3RlcHMubGVuZ3RoLFxuICAgICAgICAgICAgc3RlcFR5cGVzOiBzdGVwcy5tYXAoKHMpID0+IHMudHlwZSksXG4gICAgICAgICAgICBzdGVwSWRzOiBzdGVwcy5tYXAoKHMpID0+IHMuc3RlcElkKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdGVwcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGQgYXBwcm92YWwgY2FsbCBkYXRhIGZvciBFUkMyMCB0b2tlblxuICAgICAqL1xuICAgIGFzeW5jIGJ1aWxkQXBwcm92YWxDYWxsRGF0YShzcGVuZGVyLCBhbW91bnQpIHtcbiAgICAgICAgLy8gRVJDMjAgYXBwcm92ZSBmdW5jdGlvbiBzZWxlY3RvcjogYXBwcm92ZShhZGRyZXNzLHVpbnQyNTYpXG4gICAgICAgIGNvbnN0IGFwcHJvdmVTZWxlY3RvciA9ICcweDA5NWVhN2IzJztcbiAgICAgICAgY29uc3QgcGFkZGVkU3BlbmRlciA9IHNwZW5kZXIuc2xpY2UoMikucGFkU3RhcnQoNjQsICcwJyk7XG4gICAgICAgIGNvbnN0IHBhZGRlZEFtb3VudCA9IEJpZ0ludChhbW91bnQpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKTtcbiAgICAgICAgcmV0dXJuIGAke2FwcHJvdmVTZWxlY3Rvcn0ke3BhZGRlZFNwZW5kZXJ9JHtwYWRkZWRBbW91bnR9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBiYXRjaCBzaW11bGF0aW9uIHVzaW5nIGJ1bmRsZSBlbmRwb2ludFxuICAgICAqL1xuICAgIGFzeW5jIGV4ZWN1dGVCYXRjaFNpbXVsYXRpb24oc3RlcHMsIGNoYWluSWQpIHtcbiAgICAgICAgY29uc3Qgc2ltdWxhdGlvbkNsaWVudCA9IGdldFNpbXVsYXRpb25DbGllbnQoKTtcbiAgICAgICAgaWYgKCFzaW11bGF0aW9uQ2xpZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGYWlsZWRSZXN1bHQoJ1NpbXVsYXRpb24gY2xpZW50IG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyJG0uaW5mbyhgREVCVUcgZXhlY3V0ZUJhdGNoU2ltdWxhdGlvbiAtIFN0YXJ0aW5nIGJ1bmRsZSBzaW11bGF0aW9uIHdpdGggJHtzdGVwcy5sZW5ndGh9IHN0ZXBzYCk7XG4gICAgICAgIC8vIEJ1aWxkIGN1bXVsYXRpdmUgc3RhdGUgb3ZlcnJpZGVzXG4gICAgICAgIGxldCBjdW11bGF0aXZlU3RhdGVPdmVycmlkZXMgPSB7fTtcbiAgICAgICAgY29uc3QgYnVuZGxlU2ltdWxhdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzdGVwIG9mIHN0ZXBzKSB7XG4gICAgICAgICAgICAvLyBNZXJnZSBjdW11bGF0aXZlIHN0YXRlIG92ZXJyaWRlcyB3aXRoIHN0ZXAtc3BlY2lmaWMgb3ZlcnJpZGVzXG4gICAgICAgICAgICBjdW11bGF0aXZlU3RhdGVPdmVycmlkZXMgPSB0aGlzLm1lcmdlU3RhdGVPdmVycmlkZXMoY3VtdWxhdGl2ZVN0YXRlT3ZlcnJpZGVzLCBzdGVwLnN0YXRlT3ZlcnJpZGUgfHwge30pO1xuICAgICAgICAgICAgLy8gQWRkIHRvIGJ1bmRsZVxuICAgICAgICAgICAgYnVuZGxlU2ltdWxhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RlcElkOiBzdGVwLnN0ZXBJZCB8fCAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiBzdGVwLnR5cGUsXG4gICAgICAgICAgICAgICAgZnJvbTogc3RlcC5wYXJhbXMuZnJvbSB8fCAnJyxcbiAgICAgICAgICAgICAgICB0bzogc3RlcC5wYXJhbXMudG8gfHwgJycsXG4gICAgICAgICAgICAgICAgZGF0YTogc3RlcC5wYXJhbXMuZGF0YSB8fCAnMHgnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzdGVwLnBhcmFtcy52YWx1ZSB8fCAnMHgwJyxcbiAgICAgICAgICAgICAgICBzdGF0ZU92ZXJyaWRlOiB7IC4uLmN1bXVsYXRpdmVTdGF0ZU92ZXJyaWRlcyB9LCAvLyBFYWNoIHN0ZXAgZ2V0cyBjdW11bGF0aXZlIHN0YXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYERFQlVHIGV4ZWN1dGVCYXRjaFNpbXVsYXRpb24gLSBQcmVwYXJlZCBzdGVwOiAke3N0ZXAuc3RlcElkfSAoJHtzdGVwLnR5cGV9KWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBFeGVjdXRlIGJ1bmRsZSBzaW11bGF0aW9uXG4gICAgICAgICAgICBjb25zdCBidW5kbGVSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBzaW11bGF0aW9uczogYnVuZGxlU2ltdWxhdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnREVCVUcgZXhlY3V0ZUJhdGNoU2ltdWxhdGlvbiAtIFNlbmRpbmcgYnVuZGxlIHJlcXVlc3QnKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1bmRsZVJlc3VsdCA9IGF3YWl0IHNpbXVsYXRpb25DbGllbnQuc2ltdWxhdGVCdW5kbGUoYnVuZGxlUmVxdWVzdCk7XG4gICAgICAgICAgICBpZiAoIWJ1bmRsZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxHYXNVc2VkOiAnMCcsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0J1bmRsZSBzaW11bGF0aW9uIGZhaWxlZCcsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBidW5kbGVSZXN1bHQucmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBJZDogcmVzdWx0LnN0ZXBJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGJ1bmRsZVNpbXVsYXRpb25zLmZpbmQoKHNpbSkgPT4gc2ltLnN0ZXBJZCA9PT0gcmVzdWx0LnN0ZXBJZCk/LnR5cGUgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXNVc2VkOiByZXN1bHQuZ2FzVXNlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlc3VsdC5zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZU92ZXJyaWRlczogY3VtdWxhdGl2ZVN0YXRlT3ZlcnJpZGVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHN1Y2Nlc3NmdWwgYnVuZGxlIHJlc3VsdFxuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZWRTdGVwcyA9IGJ1bmRsZVJlc3VsdC5yZXN1bHRzLm1hcCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcFR5cGUgPSBidW5kbGVTaW11bGF0aW9ucy5maW5kKChzaW0pID0+IHNpbS5zdGVwSWQgPT09IHJlc3VsdC5zdGVwSWQpPy50eXBlIHx8ICcnO1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYERFQlVHIGV4ZWN1dGVCYXRjaFNpbXVsYXRpb24gLSBTdGVwICR7cmVzdWx0LnN0ZXBJZH0gY29tcGxldGVkOmAsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FzVXNlZDogcmVzdWx0Lmdhc1VzZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcElkOiByZXN1bHQuc3RlcElkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBzdGVwVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZ2FzVXNlZDogcmVzdWx0Lmdhc1VzZWQsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlc3VsdC5zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZUNoYW5nZXM6IGJ1bmRsZVNpbXVsYXRpb25zLmZpbmQoKHNpbSkgPT4gc2ltLnN0ZXBJZCA9PT0gcmVzdWx0LnN0ZXBJZClcbiAgICAgICAgICAgICAgICAgICAgICAgID8uc3RhdGVPdmVycmlkZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvdGFsR2FzVXNlZDogYnVuZGxlUmVzdWx0LnRvdGFsR2FzVXNlZCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0ZXBzOiBleGVjdXRlZFN0ZXBzLFxuICAgICAgICAgICAgICAgIHN0YXRlT3ZlcnJpZGVzOiBjdW11bGF0aXZlU3RhdGVPdmVycmlkZXMsXG4gICAgICAgICAgICAgICAgc2ltdWxhdGlvbk1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiAnbGF0ZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlciRtLmVycm9yKCdCdW5kbGUgc2ltdWxhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGYWlsZWRSZXN1bHQoYEJ1bmRsZSBzaW11bGF0aW9uIGZhaWxlZDogJHtleHRyYWN0RXJyb3JNZXNzYWdlKGVycm9yLCAnYnVuZGxlIHNpbXVsYXRpb24nKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZSB0d28gc3RhdGUgb3ZlcnJpZGUgb2JqZWN0c1xuICAgICAqL1xuICAgIG1lcmdlU3RhdGVPdmVycmlkZXMoYmFzZSwgYWRkaXRpb25hbCkge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSB7IC4uLmJhc2UgfTtcbiAgICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgb3ZlcnJpZGVzXSBvZiBPYmplY3QuZW50cmllcyhhZGRpdGlvbmFsKSkge1xuICAgICAgICAgICAgaWYgKG1lcmdlZFthZGRyZXNzXSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFthZGRyZXNzXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubWVyZ2VkW2FkZHJlc3NdLFxuICAgICAgICAgICAgICAgICAgICAuLi5vdmVycmlkZXMsXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1lcmdlZFthZGRyZXNzXS5zdG9yYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3ZlcnJpZGVzLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZFthZGRyZXNzXSA9IG92ZXJyaWRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBmYWlsZWQgc2ltdWxhdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBjcmVhdGVGYWlsZWRSZXN1bHQoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdGFsR2FzVXNlZDogJzAnLFxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHN0ZXBzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogU2VydmljZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgZXhlY3V0aW9uIG9wZXJhdGlvbnNcbiAqL1xuY2xhc3MgRXhlY3V0ZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gYWRhcHRlcjtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvblNlcnZpY2UgPSBuZXcgVHJhbnNhY3Rpb25TZXJ2aWNlKGFkYXB0ZXIpO1xuICAgICAgICB0aGlzLmFwcHJvdmFsU2VydmljZSA9IG5ldyBBcHByb3ZhbFNlcnZpY2UoYWRhcHRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGdhcyBlc3RpbWF0aW9uIGZvciB0cmFuc2FjdGlvbnNcbiAgICAgKi9cbiAgICBzZXRHYXNFc3RpbWF0aW9uRW5hYmxlZChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25TZXJ2aWNlLnNldEdhc0VzdGltYXRpb25FbmFibGVkKGVuYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGEgY29udHJhY3QgY2FsbCB3aXRoIGFwcHJvdmFsIGhhbmRsaW5nXG4gICAgICovXG4gICAgYXN5bmMgZXhlY3V0ZShwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgZXhlY3V0aW9uIChpbmNsdWRlcyBjaGFpbiBzd2l0Y2hpbmcpXG4gICAgICAgICAgICBjb25zdCBwcmVwYXJhdGlvbiA9IGF3YWl0IHRoaXMudHJhbnNhY3Rpb25TZXJ2aWNlLnByZXBhcmVFeGVjdXRpb24ocGFyYW1zKTtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhcHByb3ZhbCBpZiBuZWVkZWQgKGFmdGVyIGNoYWluIHN3aXRjaGluZylcbiAgICAgICAgICAgIGxldCBhcHByb3ZhbFR4SGFzaDtcbiAgICAgICAgICAgIGlmIChwYXJhbXMudG9rZW5BcHByb3ZhbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcHJvdmFsUmVzdWx0ID0gYXdhaXQgdGhpcy5hcHByb3ZhbFNlcnZpY2UuZW5zdXJlQ29udHJhY3RBcHByb3ZhbChwYXJhbXMudG9rZW5BcHByb3ZhbCwgcGFyYW1zLmNvbnRyYWN0QWRkcmVzcywgcGFyYW1zLnRvQ2hhaW5JZCwgZmFsc2UsIHBhcmFtcy5hcHByb3ZhbEJ1ZmZlckJwcyk7XG4gICAgICAgICAgICAgICAgaWYgKGFwcHJvdmFsUmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXBwcm92YWwgZmFpbGVkOiAke2FwcHJvdmFsUmVzdWx0LmVycm9yfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHByb3ZhbFR4SGFzaCA9IGFwcHJvdmFsUmVzdWx0LnRyYW5zYWN0aW9uSGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlbmQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IGF3YWl0IHRoaXMudHJhbnNhY3Rpb25TZXJ2aWNlLnNlbmRUcmFuc2FjdGlvbihwcmVwYXJhdGlvbi5wcm92aWRlciwgcHJlcGFyYXRpb24uZnJvbUFkZHJlc3MsIHBhcmFtcy5jb250cmFjdEFkZHJlc3MsIHByZXBhcmF0aW9uLmVuY29kZWREYXRhLCBwcmVwYXJhdGlvbi52YWx1ZSB8fCBwYXJhbXMudmFsdWUgfHwgJzB4MCcsIHtcbiAgICAgICAgICAgICAgICBlbmFibGVUcmFuc2FjdGlvblBvbGxpbmc6IHBhcmFtcy5lbmFibGVUcmFuc2FjdGlvblBvbGxpbmcsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25UaW1lb3V0OiBwYXJhbXMudHJhbnNhY3Rpb25UaW1lb3V0LFxuICAgICAgICAgICAgICAgIHdhaXRGb3JSZWNlaXB0OiBwYXJhbXMud2FpdEZvclJlY2VpcHQsXG4gICAgICAgICAgICAgICAgcmVjZWlwdFRpbWVvdXQ6IHBhcmFtcy5yZWNlaXB0VGltZW91dCxcbiAgICAgICAgICAgICAgICByZXF1aXJlZENvbmZpcm1hdGlvbnM6IHBhcmFtcy5yZXF1aXJlZENvbmZpcm1hdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0cmFuc2FjdGlvbiBjb25maXJtYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHJlY2VpcHRJbmZvID0gYXdhaXQgdGhpcy50cmFuc2FjdGlvblNlcnZpY2UuaGFuZGxlVHJhbnNhY3Rpb25Db25maXJtYXRpb24ocHJlcGFyYXRpb24ucHJvdmlkZXIsIHRyYW5zYWN0aW9uSGFzaCwge1xuICAgICAgICAgICAgICAgIHdhaXRGb3JSZWNlaXB0OiBwYXJhbXMud2FpdEZvclJlY2VpcHQsXG4gICAgICAgICAgICAgICAgcmVjZWlwdFRpbWVvdXQ6IHBhcmFtcy5yZWNlaXB0VGltZW91dCxcbiAgICAgICAgICAgICAgICByZXF1aXJlZENvbmZpcm1hdGlvbnM6IHBhcmFtcy5yZXF1aXJlZENvbmZpcm1hdGlvbnMsXG4gICAgICAgICAgICB9LCBwYXJhbXMudG9DaGFpbklkKTtcbiAgICAgICAgICAgIC8vIEJ1aWxkIHJlc3VsdFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cmFuc2FjdGlvblNlcnZpY2UuYnVpbGRFeGVjdXRlUmVzdWx0KHRyYW5zYWN0aW9uSGFzaCwgcGFyYW1zLnRvQ2hhaW5JZCwgcmVjZWlwdEluZm8pO1xuICAgICAgICAgICAgLy8gSWYgYXBwcm92YWwgaGFwcGVuZWQsIGF0dGFjaCBhcHByb3ZhbCB0eCBoYXNoIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgaWYgKHBhcmFtcy50b2tlbkFwcHJvdmFsICYmIGFwcHJvdmFsVHhIYXNoKSB7XG4gICAgICAgICAgICAgICAgLy8gQXVnbWVudCB0aGUgdHlwZWQgcmVzdWx0IGJ5IGNhc3RpbmcgdG8gdGhlIGV4dGVuZGVkIHR5cGUgbG9jYWxseSBiZWZvcmUgcmV0dXJuaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5kZWRSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwcm92YWxUcmFuc2FjdGlvbkhhc2g6IGFwcHJvdmFsVHhIYXNoLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuZGVkUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXVsYXRlIGNvbnRyYWN0IGV4ZWN1dGlvblxuICAgICAqL1xuICAgIGFzeW5jIHNpbXVsYXRlRXhlY3V0ZShwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBzaW11bGF0aW9uIGNsaWVudFxuICAgICAgICAgICAgY29uc3Qgc2ltdWxhdGlvbkNsaWVudCA9IGdldFNpbXVsYXRpb25DbGllbnQoKTtcbiAgICAgICAgICAgIGlmICghc2ltdWxhdGlvbkNsaWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogcGFyYW1zLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBwYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBnYXNVc2VkOiAnMCcsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ1NpbXVsYXRpb24gY2xpZW50IG5vdCBjb25maWd1cmVkJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHVzZXIgYWRkcmVzcyBmb3IgY2FsbGJhY2tcbiAgICAgICAgICAgIGNvbnN0IGZyb21BZGRyZXNzID0gYXdhaXQgdGhpcy5hZGFwdGVyLm5leHVzU0RLLmdldEVWTUNsaWVudCgpLmdldEFkZHJlc3NlcygpO1xuICAgICAgICAgICAgaWYgKCFmcm9tQWRkcmVzcyB8fCBmcm9tQWRkcmVzcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY291bnRzIGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJlcGFyZSBleGVjdXRpb24gdG8gZ2V0IGVuY29kZWQgZGF0YSBhbmQgdmFsdWUgKGNhbGxzIGJ1aWxkRnVuY3Rpb25QYXJhbXMgaW50ZXJuYWxseSlcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmF0aW9uID0gYXdhaXQgdGhpcy50cmFuc2FjdGlvblNlcnZpY2UucHJlcGFyZUV4ZWN1dGlvbihwYXJhbXMpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHNpbXVsYXRpb24gcGFyYW1ldGVyc1xuICAgICAgICAgICAgY29uc3Qgc2ltdWxhdGlvblBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBmcm9tOiBwcmVwYXJhdGlvbi5mcm9tQWRkcmVzcyxcbiAgICAgICAgICAgICAgICB0bzogcGFyYW1zLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBkYXRhOiBwcmVwYXJhdGlvbi5lbmNvZGVkRGF0YSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJlcGFyYXRpb24udmFsdWUgfHwgcGFyYW1zLnZhbHVlIHx8ICcweDAnLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IHBhcmFtcy50b0NoYWluSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBSdW4gc2ltdWxhdGlvblxuICAgICAgICAgICAgY29uc3Qgc2ltdWxhdGlvblJlc3VsdCA9IGF3YWl0IHNpbXVsYXRpb25DbGllbnQuc2ltdWxhdGUoc2ltdWxhdGlvblBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoIXNpbXVsYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogcGFyYW1zLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBwYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBnYXNVc2VkOiAnMCcsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogc2ltdWxhdGlvblJlc3VsdC5lcnJvck1lc3NhZ2UgfHwgJ1NpbXVsYXRpb24gZmFpbGVkJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2FzVXNlZERlY2ltYWwgPSBoZXhUb051bWJlcihzaW11bGF0aW9uUmVzdWx0Lmdhc1VzZWQpO1xuICAgICAgICAgICAgbGV0IGdhc0Nvc3RFdGg7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlSGV4ID0gKGF3YWl0IHRoaXMuYWRhcHRlci5uZXh1c1NESy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2dhc1ByaWNlJyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2VXZWkgPSBwYXJzZUludChnYXNQcmljZUhleCwgMTYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvc3RFdGhOdW0gPSAoZ2FzVXNlZERlY2ltYWwgKiBnYXNQcmljZVdlaSkgLyAxZTE4O1xuICAgICAgICAgICAgICAgIGdhc0Nvc3RFdGggPSBjb3N0RXRoTnVtLnRvRml4ZWQoOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZ3BFcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkbS53YXJuKCdGYWlsZWQgdG8gZmV0Y2ggZ2FzIHByaWNlIGR1cmluZyBzaW11bGF0aW9uIGNvc3QgY2FsYzonLCBncEVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdhc1VzZWQ6IGdhc1VzZWREZWNpbWFsLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAuLi4oZ2FzQ29zdEV0aCA/IHsgZ2FzQ29zdEV0aCB9IDoge30pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBwYXJhbXMuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBnYXNVc2VkOiAnMCcsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGV4dHJhY3RFcnJvck1lc3NhZ2UoZXJyb3IsICdleGVjdXRpb24gc2ltdWxhdGlvbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmhhbmNlZCBzaW11bGF0aW9uIHdpdGggYXV0b21hdGljIHN0YXRlIHNldHVwXG4gICAgICovXG4gICAgYXN5bmMgc2ltdWxhdGVFeGVjdXRlRW5oYW5jZWQocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgdXNlIGVuaGFuY2VkIHNpbXVsYXRpb25cbiAgICAgICAgICAgIGxvZ2dlciRtLmRlYnVnKCdERUJVRyBFeGVjdXRlU2VydmljZSAtIEZ1bGwgcGFyYW1zIHJlY2VpdmVkOicsIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IHBhcmFtcy5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBwYXJhbXMuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIHRva2VuQXBwcm92YWw6IHBhcmFtcy50b2tlbkFwcHJvdmFsLFxuICAgICAgICAgICAgICAgIGJ1aWxkRnVuY3Rpb25QYXJhbXM6IHR5cGVvZiBwYXJhbXMuYnVpbGRGdW5jdGlvblBhcmFtcyxcbiAgICAgICAgICAgICAgICB0b0NoYWluSWQ6IHBhcmFtcy50b0NoYWluSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFVzZUVuaGFuY2VkU2ltdWxhdGlvbiA9IHRoaXMuc2hvdWxkVXNlRW5oYW5jZWRTaW11bGF0aW9uKHBhcmFtcyk7XG4gICAgICAgICAgICBsb2dnZXIkbS5kZWJ1ZygnREVCVUcgRXhlY3V0ZVNlcnZpY2UgLSBGaW5hbCBlbmhhbmNlZCBzaW11bGF0aW9uIGRlY2lzaW9uOicsIHNob3VsZFVzZUVuaGFuY2VkU2ltdWxhdGlvbik7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXNlRW5oYW5jZWRTaW11bGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucnVuRW5oYW5jZWRTaW11bGF0aW9uKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zaW11bGF0ZUV4ZWN1dGUocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBwYXJhbXMuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBnYXNVc2VkOiAnMCcsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGV4dHJhY3RFcnJvck1lc3NhZ2UoZXJyb3IsICdlbmhhbmNlZCBzaW11bGF0aW9uJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBlbmhhbmNlZCBzaW11bGF0aW9uIHNob3VsZCBiZSB1c2VkXG4gICAgICovXG4gICAgc2hvdWxkVXNlRW5oYW5jZWRTaW11bGF0aW9uKHBhcmFtcykge1xuICAgICAgICAvLyBVc2UgZW5oYW5jZWQgc2ltdWxhdGlvbiBpZjpcbiAgICAgICAgLy8gMS4gVG9rZW4gYXBwcm92YWwgaXMgcmVxdWlyZWQgKGluZGljYXRlcyBFUkMyMCBpbnRlcmFjdGlvbilcbiAgICAgICAgLy8gMi4gRnVuY3Rpb24gaXMgbGlrZWx5IHRvIGZhaWwgd2l0aG91dCBwcm9wZXIgYmFsYW5jZSBzZXR1cFxuICAgICAgICBjb25zdCBzaG91bGRVc2UgPSBwYXJhbXMudG9rZW5BcHByb3ZhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBwYXJhbXMudG9rZW5BcHByb3ZhbC50b2tlbiAhPT0gJ0VUSCcgJiZcbiAgICAgICAgICAgIHRoaXMuaXNDb21wbGV4Q29udHJhY3RDYWxsKHBhcmFtcyk7XG4gICAgICAgIGxvZ2dlciRtLmRlYnVnKCdERUJVRyBzaG91bGRVc2VFbmhhbmNlZFNpbXVsYXRpb24gLSBEZWNpc2lvbjonLCB7XG4gICAgICAgICAgICBoYXNUb2tlbkFwcHJvdmFsOiAhIXBhcmFtcy50b2tlbkFwcHJvdmFsLFxuICAgICAgICAgICAgaXNDb21wbGV4OiB0aGlzLmlzQ29tcGxleENvbnRyYWN0Q2FsbChwYXJhbXMpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBwYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgZmluYWxEZWNpc2lvbjogc2hvdWxkVXNlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChwYXJhbXMudG9rZW5BcHByb3ZhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBwYXJhbXMudG9rZW5BcHByb3ZhbC50b2tlbiAhPT0gJ0VUSCcgJiZcbiAgICAgICAgICAgIHRoaXMuaXNDb21wbGV4Q29udHJhY3RDYWxsKHBhcmFtcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGlzIGEgY29tcGxleCBjb250cmFjdCBjYWxsIHRoYXQgYmVuZWZpdHMgZnJvbSBlbmhhbmNlZCBzaW11bGF0aW9uXG4gICAgICovXG4gICAgaXNDb21wbGV4Q29udHJhY3RDYWxsKHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb21wbGV4RnVuY3Rpb25zID0gW1xuICAgICAgICAgICAgJ2RlcG9zaXQnLFxuICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgICdzd2FwJyxcbiAgICAgICAgICAgICd0cmFkZScsXG4gICAgICAgICAgICAnc3Rha2UnLFxuICAgICAgICAgICAgJ3Vuc3Rha2UnLFxuICAgICAgICAgICAgJ21pbnQnLFxuICAgICAgICAgICAgJ2J1cm4nLFxuICAgICAgICAgICAgJ3RyYW5zZmVyJyxcbiAgICAgICAgICAgICd0cmFuc2ZlckZyb20nLFxuICAgICAgICAgICAgJ2FwcHJvdmUnLFxuICAgICAgICAgICAgJ3N1cHBseScsXG4gICAgICAgICAgICAnYm9ycm93JyxcbiAgICAgICAgICAgICdyZXBheScsXG4gICAgICAgICAgICAncmVkZWVtJyxcbiAgICAgICAgICAgICdsZW5kJyxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXhGdW5jdGlvbnMuc29tZSgoZnVuYykgPT4gcGFyYW1zLmZ1bmN0aW9uTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZ1bmMudG9Mb3dlckNhc2UoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gZW5oYW5jZWQgc2ltdWxhdGlvbiB3aXRoIGF1dG9tYXRpYyBzdGF0ZSBzZXR1cFxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkVuaGFuY2VkU2ltdWxhdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGV2bVByb3ZpZGVyIGlzIGF2YWlsYWJsZVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFkYXB0ZXIubmV4dXNTREsuZ2V0RVZNUHJvdmlkZXJXaXRoQ0EoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRVZNIHByb3ZpZGVyIG5vdCBhdmFpbGFibGUgZm9yIGVuaGFuY2VkIHNpbXVsYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpbXVsYXRpb25FbmdpbmUgPSBuZXcgU2ltdWxhdGlvbkVuZ2luZSh0aGlzLmFkYXB0ZXIpO1xuICAgICAgICAgICAgLy8gR2V0IHVzZXIgYWRkcmVzc1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyYXRpb24gPSBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uU2VydmljZS5wcmVwYXJlRXhlY3V0aW9uKHBhcmFtcyk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRva2VuQXBwcm92YWwgYW1vdW50IHRvIHByb3BlciBmb3JtYXQgaWYgbmVlZGVkXG4gICAgICAgICAgICBjb25zdCB0b2tlbkFtb3VudCA9IHBhcmFtcy50b2tlbkFwcHJvdmFsPy5hbW91bnQgfHwgJzAnO1xuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnREVCVUcgRXhlY3V0ZVNlcnZpY2UgLSBSdW5uaW5nIGVuaGFuY2VkIHNpbXVsYXRpb246Jywge1xuICAgICAgICAgICAgICAgIHVzZXI6IHByZXBhcmF0aW9uLmZyb21BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHRva2VuOiBwYXJhbXMudG9rZW5BcHByb3ZhbD8udG9rZW4sXG4gICAgICAgICAgICAgICAgYW1vdW50OiB0b2tlbkFtb3VudCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUnVuIGVuaGFuY2VkIHNpbXVsYXRpb24gKHRva2VuQXBwcm92YWwgaXMgZ3VhcmFudGVlZCB0byBleGlzdCBoZXJlIGR1ZSB0byBzaG91bGRVc2VFbmhhbmNlZFNpbXVsYXRpb24gY2hlY2spXG4gICAgICAgICAgICBpZiAoIXBhcmFtcy50b2tlbkFwcHJvdmFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmhhbmNlZCBzaW11bGF0aW9uIHJlcXVpcmVzIHRva2VuIGFwcHJvdmFsIGluZm9ybWF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmhhbmNlZFJlc3VsdCA9IGF3YWl0IHNpbXVsYXRpb25FbmdpbmUuc2ltdWxhdGVXaXRoU3RhdGVTZXR1cCh7XG4gICAgICAgICAgICAgICAgdXNlcjogcHJlcGFyYXRpb24uZnJvbUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdG9rZW5SZXF1aXJlZDogcGFyYW1zLnRva2VuQXBwcm92YWwudG9rZW4sXG4gICAgICAgICAgICAgICAgYW1vdW50UmVxdWlyZWQ6IHRva2VuQW1vdW50LFxuICAgICAgICAgICAgICAgIGNvbnRyYWN0Q2FsbDogcGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGVuaGFuY2VkIHJlc3VsdCB0byBFeGVjdXRlU2ltdWxhdGlvbiBmb3JtYXRcbiAgICAgICAgICAgIGlmICghZW5oYW5jZWRSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogcGFyYW1zLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBwYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBnYXNVc2VkOiAnMCcsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZW5oYW5jZWRSZXN1bHQuZXJyb3IgfHwgJ0VuaGFuY2VkIHNpbXVsYXRpb24gZmFpbGVkJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW5oYW5jZWRSZXN1bHQudG90YWxHYXNVc2VkIGlzIGFscmVhZHkgYW4gRVRILWRlbm9taW5hdGVkIHN0cmluZyAoU2ltdWxhdGlvbkVuZ2luZSBjb252ZXJ0cylcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBwYXJhbXMuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogcGFyYW1zLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBnYXNVc2VkOiBlbmhhbmNlZFJlc3VsdC50b3RhbEdhc1VzZWQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnYXNDb3N0RXRoOiBlbmhhbmNlZFJlc3VsdC50b3RhbEdhc1VzZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyJG0uZXJyb3IoJ0VuaGFuY2VkIHNpbXVsYXRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gc3RhbmRhcmQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gc3RhbmRhcmQgc2ltdWxhdGlvblxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2ltdWxhdGVFeGVjdXRlKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIExvY2FsIGNvbnN0YW50cyBmb3IgdGhlIHNlcnZpY2VcbmNvbnN0IEFEQVBURVJfQ09OU1RBTlRTID0ge1xuICAgIERFRkFVTFRfREVDSU1BTFM6IDE4LFxufTtcbmNsYXNzIEJyaWRnZUV4ZWN1dGVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gICAgICAgIHRoaXMuc2tpcEJyaWRnZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdGltYWxCcmlkZ2VBbW91bnQgPSAnMCc7XG4gICAgICAgIHRoaXMuZXhlY3V0ZVNlcnZpY2UgPSBuZXcgRXhlY3V0ZVNlcnZpY2UoYWRhcHRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGdhcyBlc3RpbWF0aW9uIGZvciBleGVjdXRlIHRyYW5zYWN0aW9uc1xuICAgICAqIFRoaXMgcHJvdmlkZXMgZWFzeSBjb250cm9sIG92ZXIgd2hldGhlciBnYXMgZXN0aW1hdGlvbiBydW5zIGJlZm9yZSBleGVjdXRpb25cbiAgICAgKi9cbiAgICBzZXRHYXNFc3RpbWF0aW9uRW5hYmxlZChlbmFibGVkKSB7XG4gICAgICAgIC8vIEFjY2VzcyB0aGUgdHJhbnNhY3Rpb24gc2VydmljZSB0aHJvdWdoIHRoZSBleGVjdXRlIHNlcnZpY2UncyBwdWJsaWMgbWV0aG9kXG4gICAgICAgIHRoaXMuZXhlY3V0ZVNlcnZpY2Uuc2V0R2FzRXN0aW1hdGlvbkVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyaWRnZSBhbmQgZXhlY3V0ZSBvcGVyYXRpb24gLSBjb21iaW5lcyBicmlkZ2UgYW5kIGV4ZWN1dGUgd2l0aCBwcm9wZXIgc2VxdWVuY2luZ1xuICAgICAqIE5vdyBpbmNsdWRlcyBzbWFydCBiYWxhbmNlIGNoZWNraW5nIHRvIHNraXAgYnJpZGdpbmcgd2hlbiBzdWZmaWNpZW50IGZ1bmRzIGV4aXN0XG4gICAgICovXG4gICAgYXN5bmMgYnJpZGdlQW5kRXhlY3V0ZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyB0b0NoYWluSWQsIHRva2VuLCBhbW91bnQsIGV4ZWN1dGUsIGVuYWJsZVRyYW5zYWN0aW9uUG9sbGluZyA9IGZhbHNlLCB0cmFuc2FjdGlvblRpbWVvdXQgPSAzMDAwMCwgd2FpdEZvclJlY2VpcHQgPSB0cnVlLCByZWNlaXB0VGltZW91dCA9IDMwMDAwMCwgcmVxdWlyZWRDb25maXJtYXRpb25zID0gMSwgfSA9IHBhcmFtcztcbiAgICAgICAgLy8gRGVjbGFyZSBoZXJlIHNvIGFjY2Vzc2libGUgaW4gY2F0Y2gvZmluYWxseVxuICAgICAgICBsZXQgc3RlcEZvcndhcmRlciA9ICgpID0+IHsgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaW5wdXQgYW1vdW50IHRvIGVuc3VyZSBjb25zaXN0ZW50IHByb2Nlc3NpbmdcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBbW91bnQgPSB0aGlzLm5vcm1hbGl6ZUFtb3VudFRvV2VpKGFtb3VudCwgdG9rZW4pO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgc2ltdWxhdGlvbiB3YXMgcnVuIC0gaWYgbm90LCBjYWxjdWxhdGUgb3B0aW1hbCBicmlkZ2UgYW1vdW50XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpbWFsQnJpZGdlQW1vdW50ID09PSAnMCcgJiYgIXRoaXMuc2tpcEJyaWRnZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ1NpbXVsYXRpb24gd2FzIG5vdCBydW4sIGNhbGN1bGF0aW5nIG9wdGltYWwgYnJpZGdlIGFtb3VudC4uLicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyaWRnZU9wdGltaXphdGlvbiA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlT3B0aW1hbEJyaWRnZUFtb3VudCh0b0NoYWluSWQsIHRva2VuLCBub3JtYWxpemVkQW1vdW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBCcmlkZ2UgPSBicmlkZ2VPcHRpbWl6YXRpb24uc2tpcEJyaWRnZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGltYWxCcmlkZ2VBbW91bnQgPSBicmlkZ2VPcHRpbWl6YXRpb24ub3B0aW1hbEFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzZSB0aGUgc2tpcEJyaWRnZSBmbGFnIHNldCBkdXJpbmcgc2ltdWxhdGlvbiB0byBkZXRlcm1pbmUgZXhlY3V0aW9uIHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXBCcmlkZ2UgJiYgZXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYEVuaGFuY2VkIHNtYXJ0IHJvdXRpbmc6IFN1ZmZpY2llbnQgJHt0b2tlbn0gKyBnYXMgYmFsYW5jZSBvbiBjaGFpbiAke3RvQ2hhaW5JZH0sIHNraXBwaW5nIGJyaWRnZSBhbmQgZXhlY3V0aW5nIGRpcmVjdGx5YCk7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBicmlkZ2luZyAtIGV4ZWN1dGUgZGlyZWN0bHkgd2l0aCBleGlzdGluZyBmdW5kc1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVEaXJlY3RseShleGVjdXRlLCB0b0NoYWluSWQsIHRva2VuLCBub3JtYWxpemVkQW1vdW50LCBlbmFibGVUcmFuc2FjdGlvblBvbGxpbmcsIHRyYW5zYWN0aW9uVGltZW91dCwgd2FpdEZvclJlY2VpcHQsIHJlY2VpcHRUaW1lb3V0LCByZXF1aXJlZENvbmZpcm1hdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgYnJpZGdlLWFuZC1leGVjdXRlIGZsb3cgd2hlbiBlbmhhbmNlZCBiYWxhbmNlIGNoZWNrIGZhaWxzXG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKGBFbmhhbmNlZCBzbWFydCByb3V0aW5nOiBJbnN1ZmZpY2llbnQgJHt0b2tlbn0gb3IgZ2FzIGJhbGFuY2Ugb24gY2hhaW4gJHt0b0NoYWluSWR9LCBwcm9jZWVkaW5nIHdpdGggYnJpZGdlICsgZXhlY3V0ZWApO1xuICAgICAgICAgICAgLy8gU2V0IHVwIGxpc3RlbmVycyB0byBjYXB0dXJlIEFyY2FuYSBicmlkZ2Ugc3RlcHMgYW5kIGZvcndhcmQgc3RlcCBjb21wbGV0aW9uc1xuICAgICAgICAgICAgY29uc3QgYnJpZGdlU3RlcHNQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZEhhbmRsZXIgPSAoc3RlcHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLm5leHVzU0RLLm5leHVzRXZlbnRzLm9mZihORVhVU19FVkVOVFMuRVhQRUNURURfU1RFUFMsIGV4cGVjdGVkSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3RlcHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLm5leHVzU0RLLm5leHVzRXZlbnRzLm9uKE5FWFVTX0VWRU5UUy5FWFBFQ1RFRF9TVEVQUywgZXhwZWN0ZWRIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RlcEZvcndhcmRlciA9IChzdGVwKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdGVyLm5leHVzU0RLLm5leHVzRXZlbnRzLmVtaXQoTkVYVVNfRVZFTlRTLkJSSURHRV9FWEVDVVRFX0NPTVBMRVRFRF9TVEVQUywgc3RlcCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLm5leHVzU0RLLm5leHVzRXZlbnRzLm9uKE5FWFVTX0VWRU5UUy5TVEVQX0NPTVBMRVRFLCBzdGVwRm9yd2FyZGVyKTtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIGFjdHVhbCBicmlkZ2UgdHJhbnNhY3Rpb24gdXNpbmcgb3B0aW1hbCBhbW91bnRcbiAgICAgICAgICAgIC8vIENvbnZlcnQgb3B0aW1hbCBicmlkZ2UgYW1vdW50IGZyb20gd2VpIHRvIHVzZXItZnJpZW5kbHkgZm9ybWF0IGZvciBicmlkZ2Ugc2VydmljZVxuICAgICAgICAgICAgY29uc3QgdG9rZW5NZXRhZGF0YSA9IFRPS0VOX01FVEFEQVRBW3Rva2VuLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgICAgY29uc3QgZGVjaW1hbHMgPSB0b2tlbk1ldGFkYXRhPy5kZWNpbWFscyB8fCAxODtcbiAgICAgICAgICAgIGNvbnN0IHsgZm9ybWF0VW5pdHMgfSA9IGF3YWl0IGltcG9ydCgndmllbScpO1xuICAgICAgICAgICAgY29uc3QgdXNlckZyaWVuZGx5QnJpZGdlQW1vdW50ID0gZm9ybWF0VW5pdHMoQmlnSW50KHRoaXMub3B0aW1hbEJyaWRnZUFtb3VudCksIGRlY2ltYWxzKTtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0JyaWRnZSBhbW91bnQgY29udmVyc2lvbiBmb3IgZXhlY3V0aW9uOicsIHtcbiAgICAgICAgICAgICAgICBvcHRpbWFsQnJpZGdlQW1vdW50V2VpOiB0aGlzLm9wdGltYWxCcmlkZ2VBbW91bnQsXG4gICAgICAgICAgICAgICAgdXNlckZyaWVuZGx5QnJpZGdlQW1vdW50LFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzLFxuICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBicmlkZ2VSZXN1bHQgPSBhd2FpdCB0aGlzLmFkYXB0ZXIubmV4dXNTREsuYnJpZGdlKHtcbiAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICBhbW91bnQ6IHVzZXJGcmllbmRseUJyaWRnZUFtb3VudCxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiB0b0NoYWluSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghYnJpZGdlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJyaWRnZSBmYWlsZWQ6ICR7YnJpZGdlUmVzdWx0LmVycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2FpdCBmb3IgY2FwdHVyZWQgYnJpZGdlIHN0ZXBzXG4gICAgICAgICAgICBjb25zdCBicmlkZ2VTdGVwcyA9IGF3YWl0IGJyaWRnZVN0ZXBzUHJvbWlzZTtcbiAgICAgICAgICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IHRvIGVuc3VyZSBicmlkZ2Ugc2V0dGxlbWVudCBpcyBjb21wbGV0ZVxuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnREVCVUcgYnJpZGdlQW5kRXhlY3V0ZSAtIFdhaXRpbmcgZm9yIGJyaWRnZSBzZXR0bGVtZW50Li4uJyk7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSk7IC8vIDIgc2Vjb25kIGRlbGF5XG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdERUJVRyBicmlkZ2VBbmRFeGVjdXRlIC0gQnJpZGdlIHNldHRsZW1lbnQgZGVsYXkgY29tcGxldGUnKTtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgZXh0cmEgc3RlcHMgZm9yIGFwcHJvdmFsL2V4ZWN1dGUvcmVjZWlwdC9jb25maXJtYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGV4dHJhU3RlcHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG1ha2VTdGVwID0gKHR5cGVJRCwgdHlwZSwgZGF0YSA9IHt9KSA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGVJRCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JRDogdG9DaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbk5hbWU6IENIQUlOX01FVEFEQVRBW3RvQ2hhaW5JZF0/Lm5hbWUgfHwgdG9DaGFpbklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGV4ZWN1dGU/LnRva2VuQXBwcm92YWwpIHtcbiAgICAgICAgICAgICAgICBleHRyYVN0ZXBzLnB1c2gobWFrZVN0ZXAoJ0FQJywgJ0FQUFJPVkFMJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICBleHRyYVN0ZXBzLnB1c2gobWFrZVN0ZXAoJ1RTJywgJ1RSQU5TQUNUSU9OX1NFTlQnKSk7XG4gICAgICAgICAgICAgICAgaWYgKHdhaXRGb3JSZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhU3RlcHMucHVzaChtYWtlU3RlcCgnUlInLCAnUkVDRUlQVF9SRUNFSVZFRCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChyZXF1aXJlZENvbmZpcm1hdGlvbnMgPz8gMCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhU3RlcHMucHVzaChtYWtlU3RlcCgnQ04nLCAnVFJBTlNBQ1RJT05fQ09ORklSTUVEJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVtaXQgY29uc29saWRhdGVkIGV4cGVjdGVkIHN0ZXBzIGZvciB0aGUgd2hvbGUgb3BlcmF0aW9uXG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIubmV4dXNTREsubmV4dXNFdmVudHMuZW1pdChORVhVU19FVkVOVFMuQlJJREdFX0VYRUNVVEVfRVhQRUNURURfU1RFUFMsIFtcbiAgICAgICAgICAgICAgICAuLi5icmlkZ2VTdGVwcyxcbiAgICAgICAgICAgICAgICAuLi5leHRyYVN0ZXBzLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb25zdCB7IGV4ZWN1dGVUcmFuc2FjdGlvbkhhc2gsIGV4ZWN1dGVFeHBsb3JlclVybCwgYXBwcm92YWxUcmFuc2FjdGlvbkhhc2ggfSA9IGF3YWl0IHRoaXMuaGFuZGxlRXhlY3V0ZVBoYXNlKGV4ZWN1dGUsIHRvQ2hhaW5JZCwgdG9rZW4sIG5vcm1hbGl6ZWRBbW91bnQsIGVuYWJsZVRyYW5zYWN0aW9uUG9sbGluZywgdHJhbnNhY3Rpb25UaW1lb3V0LCB3YWl0Rm9yUmVjZWlwdCwgcmVjZWlwdFRpbWVvdXQsIHJlcXVpcmVkQ29uZmlybWF0aW9ucywgXG4gICAgICAgICAgICAvLyBwYXNzIGhlbHBlciB0byBlbWl0IHN0ZXBzXG4gICAgICAgICAgICAoc3RlcCkgPT4gdGhpcy5hZGFwdGVyLm5leHVzU0RLLm5leHVzRXZlbnRzLmVtaXQoTkVYVVNfRVZFTlRTLkJSSURHRV9FWEVDVVRFX0NPTVBMRVRFRF9TVEVQUywgc3RlcCksIG1ha2VTdGVwKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBleGVjdXRlVHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVFeHBsb3JlclVybCxcbiAgICAgICAgICAgICAgICBhcHByb3ZhbFRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICBicmlkZ2VUcmFuc2FjdGlvbkhhc2g6IGJyaWRnZVJlc3VsdC50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgYnJpZGdlRXhwbG9yZXJVcmw6IGJyaWRnZVJlc3VsdC5leHBsb3JlclVybCxcbiAgICAgICAgICAgICAgICB0b0NoYWluSWQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBicmlkZ2VTa2lwcGVkOiBmYWxzZSwgLy8gYnJpZGdlIHdhcyBwZXJmb3JtZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBsaXN0ZW5lclxuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLm5leHVzU0RLLm5leHVzRXZlbnRzLm9mZihORVhVU19FVkVOVFMuU1RFUF9DT01QTEVURSwgc3RlcEZvcndhcmRlcik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXh0cmFjdEVycm9yTWVzc2FnZShlcnJvciwgJ2JyaWRnZSBhbmQgZXhlY3V0ZScpO1xuICAgICAgICAgICAgLy8gRm9yd2FyZCBlcnJvciBzdGVwIChnZW5lcmljKSBmb3IgVUkgY29uc3VtZXJzXG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIubmV4dXNTREsubmV4dXNFdmVudHMuZW1pdChORVhVU19FVkVOVFMuQlJJREdFX0VYRUNVVEVfQ09NUExFVEVEX1NURVBTLCB7XG4gICAgICAgICAgICAgICAgdHlwZUlEOiAnRVInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVyYXRpb24uZmFpbGVkJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN0YWdlOiBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0V4ZWN1dGUgcGhhc2UgZmFpbGVkJykgPyAnZXhlY3V0ZScgOiAnYnJpZGdlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDbGVhbiBsaXN0ZW5lclxuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLm5leHVzU0RLLm5leHVzRXZlbnRzLm9mZihORVhVU19FVkVOVFMuU1RFUF9DT01QTEVURSwgc3RlcEZvcndhcmRlcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvQ2hhaW5JZCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogYEJyaWRnZSBhbmQgZXhlY3V0ZSBvcGVyYXRpb24gZmFpbGVkOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgIGJyaWRnZVNraXBwZWQ6IGZhbHNlLCAvLyBlcnJvciBvY2N1cnJlZCBkdXJpbmcgbm9ybWFsIGJyaWRnZSBmbG93XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXVsYXRlIGJyaWRnZSBhbmQgZXhlY3V0ZSBvcGVyYXRpb25cbiAgICAgKiBOb3cgaW5jbHVkZXMgc21hcnQgcm91dGluZyBzaW11bGF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgc2ltdWxhdGVCcmlkZ2VBbmRFeGVjdXRlKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBleGVjdXRlIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBzdGVwcyA9IFtdO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpbnB1dCBhbW91bnQgdG8gZW5zdXJlIGNvbnNpc3RlbnQgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEFtb3VudCA9IHRoaXMubm9ybWFsaXplQW1vdW50VG9XZWkocGFyYW1zLmFtb3VudCwgcGFyYW1zLnRva2VuKTtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBjYWxjdWxhdGUgb3B0aW1hbCBicmlkZ2UgYW1vdW50IGJhc2VkIG9uIGRlc3RpbmF0aW9uIGJhbGFuY2VcbiAgICAgICAgICAgIGNvbnN0IGJyaWRnZU9wdGltaXphdGlvbiA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlT3B0aW1hbEJyaWRnZUFtb3VudChwYXJhbXMudG9DaGFpbklkLCBwYXJhbXMudG9rZW4sIG5vcm1hbGl6ZWRBbW91bnQpO1xuICAgICAgICAgICAgdGhpcy5za2lwQnJpZGdlID0gYnJpZGdlT3B0aW1pemF0aW9uLnNraXBCcmlkZ2U7XG4gICAgICAgICAgICB0aGlzLm9wdGltYWxCcmlkZ2VBbW91bnQgPSBicmlkZ2VPcHRpbWl6YXRpb24ub3B0aW1hbEFtb3VudDtcbiAgICAgICAgICAgIC8vIFJ1biBzaW11bGF0aW9ucyB3aXRoIG9wdGltYWwgYW1vdW50c1xuICAgICAgICAgICAgbGV0IGJyaWRnZVNpbXVsYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGJyaWRnZVJlY2VpdmVBbW91bnQgPSAnMCc7XG4gICAgICAgICAgICBsZXQgdG90YWxCcmlkZ2VGZWUgPSAnMCc7XG4gICAgICAgICAgICAvLyBPbmx5IGFkZCBicmlkZ2Ugc3RlcCBpZiB3ZSdyZSBub3Qgc2tpcHBpbmcgaXRcbiAgICAgICAgICAgIGlmICghdGhpcy5za2lwQnJpZGdlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBvcHRpbWFsIGJyaWRnZSBhbW91bnQgZnJvbSB3ZWkgdG8gdXNlci1mcmllbmRseSBmb3JtYXQgZm9yIGJyaWRnZSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5NZXRhZGF0YSA9IFRPS0VOX01FVEFEQVRBW3BhcmFtcy50b2tlbi50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IHRva2VuTWV0YWRhdGE/LmRlY2ltYWxzIHx8IDE4O1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZm9ybWF0VW5pdHMgfSA9IGF3YWl0IGltcG9ydCgndmllbScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJGcmllbmRseUJyaWRnZUFtb3VudCA9IGZvcm1hdFVuaXRzKEJpZ0ludCh0aGlzLm9wdGltYWxCcmlkZ2VBbW91bnQpLCBkZWNpbWFscyk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnQnJpZGdlIGFtb3VudCBjb252ZXJzaW9uIGZvciBzaW11bGF0aW9uOicsIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1hbEJyaWRnZUFtb3VudFdlaTogdGhpcy5vcHRpbWFsQnJpZGdlQW1vdW50LFxuICAgICAgICAgICAgICAgICAgICB1c2VyRnJpZW5kbHlCcmlkZ2VBbW91bnQsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogcGFyYW1zLnRva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyaWRnZVNpbXVsYXRpb24gPSBhd2FpdCB0aGlzLmFkYXB0ZXIubmV4dXNTREsuc2ltdWxhdGVCcmlkZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbjogcGFyYW1zLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IHVzZXJGcmllbmRseUJyaWRnZUFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogcGFyYW1zLnRvQ2hhaW5JZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGVwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2JyaWRnZScsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzaW11bGF0aW9uOiBicmlkZ2VTaW11bGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYEJyaWRnZSAke3VzZXJGcmllbmRseUJyaWRnZUFtb3VudH0gJHtwYXJhbXMudG9rZW59IHRvIGNoYWluICR7cGFyYW1zLnRvQ2hhaW5JZH1gLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIEVuaGFuY2VkIGJyaWRnZSBhbmFseXNpc1xuICAgICAgICAgICAgICAgIGlmIChicmlkZ2VTaW11bGF0aW9uPy5pbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZW50ID0gYnJpZGdlU2ltdWxhdGlvbi5pbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZGVzdGluYXRpb24gYW1vdW50IChyZWNlaXZlZCBhbW91bnQgYWZ0ZXIgYnJpZGdpbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlbnQuZGVzdGluYXRpb24/LmFtb3VudCAmJiBpbnRlbnQuZGVzdGluYXRpb24uYW1vdW50ICE9PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyaWRnZVJlY2VpdmVBbW91bnQgPSBpbnRlbnQuZGVzdGluYXRpb24uYW1vdW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBicmlkZ2UgZmVlcyBwcm9wZXJseVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZW50LmZlZXM/LnRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEJyaWRnZUZlZSA9IGAke2ludGVudC5mZWVzLnRvdGFsfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXhlY3V0ZVNpbXVsYXRpb247XG4gICAgICAgICAgICBjb25zdCBhcHByb3ZhbFJlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgcmVjZWl2ZWQgYW1vdW50IGZyb20gYnJpZGdlIHNpbXVsYXRpb24gZm9yIGV4ZWN1dGUgc2ltdWxhdGlvblxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjZWl2ZWRBbW91bnRGb3JDb250cmFjdCA9IG5vcm1hbGl6ZWRBbW91bnQ7IC8vIGZhbGxiYWNrIHRvIG5vcm1hbGl6ZWQgb3JpZ2luYWwgYW1vdW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChicmlkZ2VSZWNlaXZlQW1vdW50ICE9PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0b2tlbiBkZWNpbWFscyBmcm9tIGJyaWRnZSBzaW11bGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkRlY2ltYWxzID0gYnJpZGdlU2ltdWxhdGlvbj8uaW50ZW50Py50b2tlbj8uZGVjaW1hbHMgfHwgYnJpZGdlU2ltdWxhdGlvbj8udG9rZW4/LmRlY2ltYWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuRGVjaW1hbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXZlZEFtb3VudEJpZ0ludCA9IHBhcnNlVW5pdHMkMShicmlkZ2VSZWNlaXZlQW1vdW50LCB0b2tlbkRlY2ltYWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZEFtb3VudEZvckNvbnRyYWN0ID0gcmVjZWl2ZWRBbW91bnRCaWdJbnQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZXhlY3V0ZSBwYXJhbWV0ZXJzIGZvciBzaW11bGF0aW9uIC0gdXNlIHdlaSBmb3JtYXQgZm9yIFNpbXVsYXRpb25FbmdpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gU2ltdWxhdGlvbkVuZ2luZSBleHBlY3RzIGFtb3VudHMgaW4gd2VpIGZvcm1hdCwgbm90IHVzZXItZnJpZW5kbHkgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkRXhlY3V0ZVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmV4ZWN1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b0NoYWluSWQ6IHBhcmFtcy50b0NoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkFwcHJvdmFsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHBhcmFtcy50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IHJlY2VpdmVkQW1vdW50Rm9yQ29udHJhY3QsIC8vIEtlZXAgaW4gd2VpIGZvcm1hdCBmb3IgU2ltdWxhdGlvbkVuZ2luZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZVNpbXVsYXRpb24gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5leGVjdXRlU2VydmljZS5zaW11bGF0ZUV4ZWN1dGVFbmhhbmNlZChtb2RpZmllZEV4ZWN1dGVQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhlY3V0ZVNpbXVsYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdleGVjdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW11bGF0aW9uOiBleGVjdXRlU2ltdWxhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYEV4ZWN1dGUgJHtleGVjdXRlLmZ1bmN0aW9uTmFtZX0gb24gY29udHJhY3QgJHtleGVjdXRlLmNvbnRyYWN0QWRkcmVzc31gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSBhbmFseXNpcyBkZXRhaWxzIGFyZSBhdmFpbGFibGUgaW4gdGhlIHNpbXVsYXRpb24gcmVzdWx0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzaW11bGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJG0ud2FybihgRXhlY3V0ZSBzaW11bGF0aW9uIGVycm9yOiAke3NpbXVsYXRpb25FcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZVNpbXVsYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IGV4ZWN1dGUuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBleGVjdXRlLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhc1VzZWQ6ICcwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBTaW11bGF0aW9uIGZhaWxlZDogJHtzaW11bGF0aW9uRXJyb3J9YCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3RlcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXhlY3V0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXVsYXRpb246IGV4ZWN1dGVTaW11bGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBFeGVjdXRlICR7ZXhlY3V0ZS5mdW5jdGlvbk5hbWV9IG9uIGNvbnRyYWN0ICR7ZXhlY3V0ZS5jb250cmFjdEFkZHJlc3N9IChmYWlsZWQpYCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGVuaGFuY2VkIHRvdGFsIGNvc3Qgd2l0aCBhcHByb3ZhbCBzdGVwXG4gICAgICAgICAgICBsZXQgdG90YWxFc3RpbWF0ZWRDb3N0O1xuICAgICAgICAgICAgaWYgKHRvdGFsQnJpZGdlRmVlICE9PSAnMCcgfHwgZXhlY3V0ZVNpbXVsYXRpb24/Lmdhc1VzZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkbS5kZWJ1ZygnREVCVUcgYnJpZGdlLWV4ZWN1dGUtc2VydmljZSAtIHRvdGFsQnJpZGdlRmVlIChFVEgpOicsIHRvdGFsQnJpZGdlRmVlKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIkbS5kZWJ1ZygnREVCVUcgYnJpZGdlLWV4ZWN1dGUtc2VydmljZSAtIGV4ZWN1dGVTaW11bGF0aW9uPy5nYXNVc2VkOicsIGV4ZWN1dGVTaW11bGF0aW9uPy5nYXNVc2VkKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGVjdXRlRmVlID0gZXhlY3V0ZVNpbXVsYXRpb24/Lmdhc0Nvc3RFdGggfHwgZXhlY3V0ZVNpbXVsYXRpb24/Lmdhc1VzZWQgfHwgJzAnO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkbS5kZWJ1ZygnREVCVUcgYnJpZGdlLWV4ZWN1dGUtc2VydmljZSAtIGV4ZWN1dGVGZWUgc291cmNlIHZhbHVlOicsIGV4ZWN1dGVGZWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhlY3V0ZUZlZUV0aCA9IGV4ZWN1dGVGZWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGdhc0Nvc3RFdGggd2Fzbid0IGF2YWlsYWJsZSwgZXhlY3V0ZUZlZSB3aWxsIGJlIGdhcyB1bml0cyDigJMgY29udmVydC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4ZWN1dGVTaW11bGF0aW9uPy5nYXNDb3N0RXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciRtLmRlYnVnKCdERUJVRyBicmlkZ2UtZXhlY3V0ZS1zZXJ2aWNlIC0gZXhlY3V0ZUZlZSAoZ2FzIHVuaXRzKTonLCBleGVjdXRlRmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGdhcyBwcmljZSBmcm9tIHRoZSBjb25uZWN0ZWQgcHJvdmlkZXIgKHdlaSwgaGV4IHN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZUhleCA9IChhd2FpdCB0aGlzLmFkYXB0ZXIubmV4dXNTREsucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9nYXNQcmljZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlV2VpID0gcGFyc2VJbnQoZ2FzUHJpY2VIZXgsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnYXNVc2VkIChzdHJpbmcpICogZ2FzUHJpY2VXZWkgKG51bWJlcikgPT4gd2VpLCB0aGVuIGNvbnZlcnQgdG8gRVRIXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2FzVXNlZE51bSA9IHBhcnNlRmxvYXQoZXhlY3V0ZUZlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29zdEV0aE51bSA9IChnYXNVc2VkTnVtICogZ2FzUHJpY2VXZWkpIC8gMWUxODsgLy8gMWUxOCB3ZWkgcGVyIEVUSFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVGZWVFdGggPSBjb3N0RXRoTnVtLnRvRml4ZWQoOCk7IC8vIGtlZXAgcmVhc29uYWJsZSBwcmVjaXNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChncEVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oJ0ZhaWxlZCB0byBmZXRjaCBnYXMgcHJpY2UgZm9yIGV4ZWN1dGUgZmVlIGNvbnZlcnNpb246JywgZ3BFcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciRtLmRlYnVnKCdERUJVRyBicmlkZ2UtZXhlY3V0ZS1zZXJ2aWNlIC0gZXhlY3V0ZUZlZSAoRVRIKTonLCBleGVjdXRlRmVlRXRoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGJyaWRnZSBmZWUgKGFscmVhZHkgYW4gRVRIIGZpZ3VyZSkgd2l0aCBjb252ZXJ0ZWQgZXhlY3V0ZSBmZWVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxGZWVFdGggPSAocGFyc2VGbG9hdCh0b3RhbEJyaWRnZUZlZSkgKyBwYXJzZUZsb2F0KGV4ZWN1dGVGZWVFdGgpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkbS5kZWJ1ZygnREVCVUcgYnJpZGdlLWV4ZWN1dGUtc2VydmljZSAtIHRvdGFsRmVlRXRoOicsIHRvdGFsRmVlRXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxFc3RpbWF0ZWRDb3N0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWw6IHRvdGFsRmVlRXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtkb3duOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJpZGdlOiB0b3RhbEJyaWRnZUZlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlOiBleGVjdXRlRmVlRXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oJ0NvdWxkIG5vdCBjYWxjdWxhdGUgdG90YWwgY29zdCAtIGNvc3QgYnJlYWtkb3duIG1heSBiZSBpbmNvbXBsZXRlOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbmhhbmNlZCBiYWxhbmNlIGNoZWNrIGFmdGVyIHNpbXVsYXRpb25zIGFyZSBjb21wbGV0ZVxuICAgICAgICAgICAgLy8gUmUtdmFsaWRhdGUgdGhlIHNraXAgYnJpZGdlIGRlY2lzaW9uIHdpdGggYWN0dWFsIGdhcyBlc3RpbWF0ZXNcbiAgICAgICAgICAgIGlmICghdGhpcy5za2lwQnJpZGdlICYmIGV4ZWN1dGVTaW11bGF0aW9uPy5nYXNVc2VkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxPcHRpbWl6YXRpb24gPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZU9wdGltYWxCcmlkZ2VBbW91bnQocGFyYW1zLnRvQ2hhaW5JZCwgcGFyYW1zLnRva2VuLCBub3JtYWxpemVkQW1vdW50LCBleGVjdXRlU2ltdWxhdGlvbj8uZ2FzVXNlZCwgZXhlY3V0ZVNpbXVsYXRpb24/Lmdhc0Nvc3RFdGgpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBza2lwIGJyaWRnZSBkZWNpc2lvbiBpZiBnYXMgY2hlY2sgcmV2ZWFscyB3ZSBjYW4gc2tpcFxuICAgICAgICAgICAgICAgIGlmIChmaW5hbE9wdGltaXphdGlvbi5za2lwQnJpZGdlICYmICF0aGlzLnNraXBCcmlkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwQnJpZGdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpbWFsQnJpZGdlQW1vdW50ID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdVcGRhdGVkIGJyaWRnZSBkZWNpc2lvbiBhZnRlciBnYXMgdmFsaWRhdGlvbjogYnJpZGdlIGNhbiBiZSBza2lwcGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbyhgRW5oYW5jZWQgYmFsYW5jZSBjaGVjayByZXN1bHQ6IHNraXBCcmlkZ2UgPSAke3RoaXMuc2tpcEJyaWRnZX0gZm9yIGNoYWluICR7cGFyYW1zLnRvQ2hhaW5JZH1gKTtcbiAgICAgICAgICAgIC8vIEFkanVzdCBzaW11bGF0aW9uIHJlc3VsdCBiYXNlZCBvbiBza2lwIGRlY2lzaW9uXG4gICAgICAgICAgICBsZXQgZmluYWxCcmlkZ2VTaW11bGF0aW9uID0gYnJpZGdlU2ltdWxhdGlvbjtcbiAgICAgICAgICAgIGxldCBmaW5hbFN0ZXBzID0gc3RlcHM7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwQnJpZGdlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBicmlkZ2UgaXMgc2tpcHBlZCwgc2V0IGJyaWRnZVNpbXVsYXRpb24gdG8gbnVsbCBhbmQgZmlsdGVyIG91dCBicmlkZ2Ugc3RlcHNcbiAgICAgICAgICAgICAgICBmaW5hbEJyaWRnZVNpbXVsYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGZpbmFsU3RlcHMgPSBzdGVwcy5maWx0ZXIoKHN0ZXApID0+IHN0ZXAudHlwZSAhPT0gJ2JyaWRnZScpO1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0JyaWRnZSB3aWxsIGJlIHNraXBwZWQgLSB1c2luZyBleGVjdXRlLW9ubHkgc2ltdWxhdGlvbiByZXN1bHQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGVwczogZmluYWxTdGVwcyxcbiAgICAgICAgICAgICAgICAgICAgYnJpZGdlU2ltdWxhdGlvbjogZmluYWxCcmlkZ2VTaW11bGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlU2ltdWxhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdG90YWxFc3RpbWF0ZWRDb3N0LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBleGVjdXRlU2ltdWxhdGlvbj8uY29udHJhY3RBZGRyZXNzID8/ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBleGVjdXRlU2ltdWxhdGlvbj8uZnVuY3Rpb25OYW1lID8/ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJpZGdlUmVjZWl2ZUFtb3VudDogdGhpcy5za2lwQnJpZGdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJhbXMuYW1vdW50LnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGJyaWRnZVJlY2VpdmVBbW91bnQgIT09ICcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGJyaWRnZVJlY2VpdmVBbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLm9wdGltYWxCcmlkZ2VBbW91bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBicmlkZ2VGZWU6IHRoaXMuc2tpcEJyaWRnZSA/ICcwJyA6IHRvdGFsQnJpZGdlRmVlLnJlcGxhY2UoJyBFVEgnLCAnJykgfHwgJzAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRBbW91bnQ6IHBhcmFtcy5hbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltYWxCcmlkZ2VBbW91bnQ6IHRoaXMub3B0aW1hbEJyaWRnZUFtb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENoYWluOiBwYXJhbXMudG9DaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwcm92YWxSZXF1aXJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyaWRnZVNraXBwZWQ6IHRoaXMuc2tpcEJyaWRnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBwYXJhbXM/LnRva2VuLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0ZXBzOiBmaW5hbFN0ZXBzLFxuICAgICAgICAgICAgICAgIGJyaWRnZVNpbXVsYXRpb246IGZpbmFsQnJpZGdlU2ltdWxhdGlvbixcbiAgICAgICAgICAgICAgICBleGVjdXRlU2ltdWxhdGlvbixcbiAgICAgICAgICAgICAgICB0b3RhbEVzdGltYXRlZENvc3QsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0ZXBzOiBbXSxcbiAgICAgICAgICAgICAgICBicmlkZ2VTaW11bGF0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVTaW11bGF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBTaW11bGF0aW9uIGZhaWxlZDogJHtleHRyYWN0RXJyb3JNZXNzYWdlKGVycm9yLCAnc2ltdWxhdGlvbicpfWAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgZXhlY3V0ZSBwaGFzZSBvZiBicmlkZ2UgYW5kIGV4ZWN1dGVcbiAgICAgKiBVc2VzIGNhbGxiYWNrLWJhc2VkIHBhcmFtZXRlciBwYXR0ZXJuIGZvciBkeW5hbWljIHBhcmFtZXRlciBidWlsZGluZ1xuICAgICAqL1xuICAgIGFzeW5jIGhhbmRsZUV4ZWN1dGVQaGFzZShleGVjdXRlLCB0b0NoYWluSWQsIGJyaWRnZVRva2VuLCBicmlkZ2VBbW91bnQsIGVuYWJsZVRyYW5zYWN0aW9uUG9sbGluZywgdHJhbnNhY3Rpb25UaW1lb3V0LCB3YWl0Rm9yUmVjZWlwdCwgcmVjZWlwdFRpbWVvdXQsIHJlcXVpcmVkQ29uZmlybWF0aW9ucywgZW1pdFN0ZXAsIG1ha2VTdGVwLCBhcHByb3ZhbEJ1ZmZlckJwc092ZXJyaWRlKSB7XG4gICAgICAgIGlmICghZXhlY3V0ZSB8fCAhZW1pdFN0ZXAgfHwgIW1ha2VTdGVwKVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRGVidWcgbG9nZ2luZyB0byB1bmRlcnN0YW5kIGFtb3VudCBoYW5kbGluZ1xuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnREVCVUcgaGFuZGxlRXhlY3V0ZVBoYXNlIC0gQnJpZGdlIGFtb3VudCAobWljcm8tdW5pdHMpOicsIGJyaWRnZUFtb3VudCk7XG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdERUJVRyBoYW5kbGVFeGVjdXRlUGhhc2UgLSBCcmlkZ2UgdG9rZW46JywgYnJpZGdlVG9rZW4pO1xuICAgICAgICAgICAgY29uc3QgeyBmb3JtYXRVbml0cyB9ID0gYXdhaXQgaW1wb3J0KCd2aWVtJyk7XG4gICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IFRPS0VOX01FVEFEQVRBW2JyaWRnZVRva2VuXT8uZGVjaW1hbHMgfHwgMTg7XG4gICAgICAgICAgICBjb25zdCB1c2VyRnJpZW5kbHlBbW91bnQgPSBmb3JtYXRVbml0cyhCaWdJbnQoYnJpZGdlQW1vdW50KSwgZGVjaW1hbHMpO1xuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnREVCVUcgaGFuZGxlRXhlY3V0ZVBoYXNlIC0gQW1vdW50IGNvbnZlcnNpb246Jywge1xuICAgICAgICAgICAgICAgIG1pY3JvVW5pdHM6IGJyaWRnZUFtb3VudCxcbiAgICAgICAgICAgICAgICBkZWNpbWFscyxcbiAgICAgICAgICAgICAgICB1c2VyRnJpZW5kbHk6IHVzZXJGcmllbmRseUFtb3VudCxcbiAgICAgICAgICAgICAgICBicmlkZ2VUb2tlbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGV4ZWN1dGUgcGFyYW1ldGVycyB3aXRoIHVzZXItZnJpZW5kbHkgYW1vdW50IGZvciB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsRXhlY3V0ZVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5leGVjdXRlLFxuICAgICAgICAgICAgICAgIHRvQ2hhaW5JZCxcbiAgICAgICAgICAgICAgICB0b2tlbkFwcHJvdmFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBicmlkZ2VUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiB1c2VyRnJpZW5kbHlBbW91bnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi4oYXBwcm92YWxCdWZmZXJCcHNPdmVycmlkZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8geyBhcHByb3ZhbEJ1ZmZlckJwczogYXBwcm92YWxCdWZmZXJCcHNPdmVycmlkZSB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdERUJVRyBoYW5kbGVFeGVjdXRlUGhhc2UgLSBFeGVjdXRlIHBhcmFtcyBjcmVhdGVkIHdpdGggdXNlci1mcmllbmRseSBhbW91bnQ6Jywge1xuICAgICAgICAgICAgICAgIHVzZXJGcmllbmRseUFtb3VudCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEJyaWRnZUFtb3VudDogYnJpZGdlQW1vdW50LFxuICAgICAgICAgICAgICAgIHRva2VuOiBicmlkZ2VUb2tlbixcbiAgICAgICAgICAgICAgICBkZWNpbWFscyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdXNlciBiYWxhbmNlIG9uIGRlc3RpbmF0aW9uIGNoYWluIGJlZm9yZSBleGVjdXRpbmdcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25CYWxhbmNlID0gYXdhaXQgdGhpcy5nZXREZXN0aW5hdGlvbkNoYWluQmFsYW5jZSh0b0NoYWluSWQsIGJyaWRnZVRva2VuKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdERUJVRyBoYW5kbGVFeGVjdXRlUGhhc2UgLSBVc2VyIGJhbGFuY2Ugb24gZGVzdGluYXRpb24gY2hhaW46Jywge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiB0b0NoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBicmlkZ2VUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZTogZGVzdGluYXRpb25CYWxhbmNlLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZEFtb3VudDogYnJpZGdlQW1vdW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGJhbGFuY2VFcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oJ0RFQlVHIGhhbmRsZUV4ZWN1dGVQaGFzZSAtIENvdWxkIG5vdCBjaGVjayBkZXN0aW5hdGlvbiBiYWxhbmNlOicsIGJhbGFuY2VFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSB0YXJnZXQgY29udHJhY3QgY2FsbCAtIGxldCBleGVjdXRlIHNlcnZpY2UgaGFuZGxlIGFwcHJvdmFsXG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdERUJVRyBoYW5kbGVFeGVjdXRlUGhhc2UgLSBFeGVjdXRpbmcgY29udHJhY3QgY2FsbCB3aXRoIHBhcmFtczonLCB7XG4gICAgICAgICAgICAgICAgLi4uZmluYWxFeGVjdXRlUGFyYW1zLFxuICAgICAgICAgICAgICAgIHRvQ2hhaW5JZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY3V0ZVNlcnZpY2UuZXhlY3V0ZSh7XG4gICAgICAgICAgICAgICAgLi4uZmluYWxFeGVjdXRlUGFyYW1zLFxuICAgICAgICAgICAgICAgIGVuYWJsZVRyYW5zYWN0aW9uUG9sbGluZyxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblRpbWVvdXQsXG4gICAgICAgICAgICAgICAgd2FpdEZvclJlY2VpcHQsXG4gICAgICAgICAgICAgICAgcmVjZWlwdFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWRDb25maXJtYXRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgdmVyaWZ5IHRyYW5zYWN0aW9uIHN1Y2Nlc3NcbiAgICAgICAgICAgIGlmIChleGVjdXRlUmVzdWx0LnRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zYWN0aW9uIHNlbnQgc3RlcFxuICAgICAgICAgICAgICAgIGVtaXRTdGVwKG1ha2VTdGVwKCdUUycsICd0cmFuc2FjdGlvbi5zZW50Jywge1xuICAgICAgICAgICAgICAgICAgICB0eEhhc2g6IGV4ZWN1dGVSZXN1bHQudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3YWl0Rm9yUmVjZWlwdCAmJiBleGVjdXRlUmVzdWx0LnRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIGhhbmRsZUV4ZWN1dGVQaGFzZSAtIENoZWNraW5nIHRyYW5zYWN0aW9uIHN1Y2Nlc3MgZm9yOicsIGV4ZWN1dGVSZXN1bHQudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkNoZWNrID0gYXdhaXQgdGhpcy5jaGVja1RyYW5zYWN0aW9uU3VjY2VzcyhleGVjdXRlUmVzdWx0LnRyYW5zYWN0aW9uSGFzaCwgdG9DaGFpbklkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uQ2hlY2suc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkbS5lcnJvcignREVCVUcgaGFuZGxlRXhlY3V0ZVBoYXNlIC0gVHJhbnNhY3Rpb24gZmFpbGVkOicsIHRyYW5zYWN0aW9uQ2hlY2suZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBlbWl0U3RlcChtYWtlU3RlcCgnRVgnLCAnZXhlY3V0ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiB0cmFuc2FjdGlvbkNoZWNrLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhlY3V0ZSB0cmFuc2FjdGlvbiBmYWlsZWQ6ICR7dHJhbnNhY3Rpb25DaGVjay5lcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnREVCVUcgaGFuZGxlRXhlY3V0ZVBoYXNlIC0gVHJhbnNhY3Rpb24gc3VjY2VlZGVkIHdpdGggZ2FzIHVzZWQ6JywgdHJhbnNhY3Rpb25DaGVjay5nYXNVc2VkKTtcbiAgICAgICAgICAgICAgICAvLyBFbWl0IHJlY2VpcHQgcmVjZWl2ZWQgc3RlcFxuICAgICAgICAgICAgICAgIGVtaXRTdGVwKG1ha2VTdGVwKCdSUicsICdyZWNlaXB0LnJlY2VpdmVkJywge1xuICAgICAgICAgICAgICAgICAgICB0eEhhc2g6IGV4ZWN1dGVSZXN1bHQudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBFbWl0IGNvbmZpcm1hdGlvbiBzdGVwIGlmIHJlcXVpcmVkQ29uZmlybWF0aW9ucyBtZXRcbiAgICAgICAgICAgICAgICBpZiAoKHJlcXVpcmVkQ29uZmlybWF0aW9ucyA/PyAwKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdFN0ZXAobWFrZVN0ZXAoJ0NOJywgJ3RyYW5zYWN0aW9uLmNvbmZpcm1lZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IHJlcXVpcmVkQ29uZmlybWF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZVRyYW5zYWN0aW9uSGFzaDogZXhlY3V0ZVJlc3VsdC50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUV4cGxvcmVyVXJsOiBleGVjdXRlUmVzdWx0LmV4cGxvcmVyVXJsLFxuICAgICAgICAgICAgICAgIGFwcHJvdmFsVHJhbnNhY3Rpb25IYXNoOiBleGVjdXRlUmVzdWx0LmFwcHJvdmFsVHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXhlY3V0ZUVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIkbS5lcnJvcignREVCVUcgaGFuZGxlRXhlY3V0ZVBoYXNlIC0gRXhlY3V0ZSBlcnJvcjonLCBleGVjdXRlRXJyb3IpO1xuICAgICAgICAgICAgZW1pdFN0ZXAobWFrZVN0ZXAoJ0VYJywgJ2V4ZWN1dGUnLCB7IGVycm9yOiBleGVjdXRlRXJyb3IubWVzc2FnZSB9KSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4ZWN1dGUgcGhhc2UgZmFpbGVkOiAke2V4dHJhY3RFcnJvck1lc3NhZ2UoZXhlY3V0ZUVycm9yLCAnZXhlY3V0ZSBwaGFzZScpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBhbW91bnQgaW5wdXQgdG8gd2VpIGZvcm1hdCBmb3IgY29uc2lzdGVudCBwcm9jZXNzaW5nXG4gICAgICogU3VwcG9ydHMgdmFyaW91cyBpbnB1dCBmb3JtYXRzIGFuZCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgdG9rZW4gZGVjaW1hbHNcbiAgICAgKi9cbiAgICBub3JtYWxpemVBbW91bnRUb1dlaShhbW91bnQsIHRva2VuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZyBpZiBpdCdzIGEgbnVtYmVyXG4gICAgICAgICAgICBjb25zdCBhbW91bnRTdHIgPSBhbW91bnQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIG5vcm1hbGl6ZUFtb3VudFRvV2VpIC0gSW5wdXQ6JywgeyBhbW91bnQ6IGFtb3VudFN0ciwgdG9rZW4gfSk7XG4gICAgICAgICAgICAvLyBIYW5kbGUgZWRnZSBjYXNlc1xuICAgICAgICAgICAgaWYgKCFhbW91bnRTdHIgfHwgYW1vdW50U3RyID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRva2VuIG1ldGFkYXRhIGZvciBhY2N1cmF0ZSBkZWNpbWFsIGhhbmRsaW5nXG4gICAgICAgICAgICBjb25zdCB0b2tlblVwcGVyID0gdG9rZW4udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuTWV0YWRhdGEgPSBUT0tFTl9NRVRBREFUQVt0b2tlblVwcGVyXTtcbiAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gdG9rZW5NZXRhZGF0YT8uZGVjaW1hbHMgfHwgQURBUFRFUl9DT05TVEFOVFM/LkRFRkFVTFRfREVDSU1BTFMgfHwgMTg7XG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdERUJVRyBub3JtYWxpemVBbW91bnRUb1dlaSAtIFRva2VuIGluZm86Jywge1xuICAgICAgICAgICAgICAgIHRva2VuVXBwZXIsXG4gICAgICAgICAgICAgICAgZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgdG9rZW5NZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSWYgaXQncyBhbHJlYWR5IGluIHdlaSBmb3JtYXQgKG5vIGRlY2ltYWxzLCBsYXJnZSBudW1iZXIpLCByZXR1cm4gYXMtaXNcbiAgICAgICAgICAgIC8vIENoZWNrIGxlbmd0aCB0byBhdm9pZCBjb252ZXJ0aW5nIHNtYWxsIGludGVnZXJzIHRvIHdlaSBpbmNvcnJlY3RseVxuICAgICAgICAgICAgaWYgKCFhbW91bnRTdHIuaW5jbHVkZXMoJy4nKSAmJiBhbW91bnRTdHIubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkbS5pbmZvKCdERUJVRyBub3JtYWxpemVBbW91bnRUb1dlaSAtIEFscmVhZHkgaW4gd2VpIGZvcm1hdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbW91bnRTdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgaGV4IHZhbHVlc1xuICAgICAgICAgICAgaWYgKGFtb3VudFN0ci5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gQmlnSW50KGFtb3VudFN0cikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIkbS5pbmZvKGBERUJVRyBub3JtYWxpemVBbW91bnRUb1dlaSAtIEhleCBjb252ZXJzaW9uOiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIGRlY2ltYWwgYW1vdW50cyAobmVlZCBjb252ZXJzaW9uIHRvIHdlaSlcbiAgICAgICAgICAgIGlmIChhbW91bnRTdHIuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlVW5pdHMkMShhbW91bnRTdHIsIGRlY2ltYWxzKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYERFQlVHIG5vcm1hbGl6ZUFtb3VudFRvV2VpIC0gRGVjaW1hbCBjb252ZXJzaW9uOiAke2Ftb3VudFN0cn0gLT4gJHtyZXN1bHR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSB3aG9sZSBudW1iZXIgaW5wdXRzXG4gICAgICAgICAgICBjb25zdCBudW1WYWx1ZSA9IHBhcnNlRmxvYXQoYW1vdW50U3RyKTtcbiAgICAgICAgICAgIC8vIEZvciBVU0RDIHNwZWNpZmljYWxseSwgYmUgbW9yZSBjYXJlZnVsIHdpdGggdGhlIGNvbnZlcnNpb25cbiAgICAgICAgICAgIC8vIFVTREMgdHlwaWNhbGx5IGhhcyA2IGRlY2ltYWxzLCBzbyAxIFVTREMgPSAxLDAwMCwwMDAgbWljcm8tVVNEQ1xuICAgICAgICAgICAgY29uc3QgVVNEQ19NSUNST19VTklUU19USFJFU0hPTEQgPSAxMDAwMDAwOyAvLyAxIFVTRENcbiAgICAgICAgICAgIGlmICh0b2tlblVwcGVyID09PSAnVVNEQycpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgVVNEQywgc21hbGwgbnVtYmVycyAoPCAxLDAwMCwwMDApIGFyZSBsaWtlbHkgdXNlciBhbW91bnRzIHRoYXQgbmVlZCBjb252ZXJzaW9uXG4gICAgICAgICAgICAgICAgaWYgKG51bVZhbHVlIDwgVVNEQ19NSUNST19VTklUU19USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VVbml0cyQxKGFtb3VudFN0ciwgNikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbyhgREVCVUcgbm9ybWFsaXplQW1vdW50VG9XZWkgLSBVU0RDIHVzZXIgYW1vdW50IGNvbnZlcnNpb246ICR7YW1vdW50U3RyfSAtPiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExhcmdlciBudW1iZXJzIGFyZSBsaWtlbHkgYWxyZWFkeSBpbiBtaWNyby1VU0RDXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oJ0RFQlVHIG5vcm1hbGl6ZUFtb3VudFRvV2VpIC0gVVNEQyBhbHJlYWR5IGluIG1pY3JvIGZvcm1hdCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW1vdW50U3RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciBzbWFsbCB3aG9sZSBudW1iZXJzLCBsaWtlbHkgcmVwcmVzZW50IHVzZXItZnJpZW5kbHkgYW1vdW50cyAoZS5nLiwgXCIxXCIgRVRIKVxuICAgICAgICAgICAgLy8gRm9yIGxhcmdlciBudW1iZXJzLCBsaWtlbHkgYWxyZWFkeSBpbiB3ZWkgZm9ybWF0XG4gICAgICAgICAgICBpZiAobnVtVmFsdWUgPCAxMDAwIHx8ICh0b2tlbk1ldGFkYXRhPy5kZWNpbWFscyA9PT0gNiAmJiBudW1WYWx1ZSA8IDEwMDAwMDApKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBzbWFsbCBudW1iZXJzIGFzIHVzZXItZnJpZW5kbHkgYW1vdW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlVW5pdHMkMShhbW91bnRTdHIsIGRlY2ltYWxzKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYERFQlVHIG5vcm1hbGl6ZUFtb3VudFRvV2VpIC0gVXNlciBhbW91bnQgY29udmVyc2lvbjogJHthbW91bnRTdHJ9IC0+ICR7cmVzdWx0fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBc3N1bWUgbGFyZ2VyIG51bWJlcnMgYXJlIGFscmVhZHkgaW4gdGhlIGNvcnJlY3QgZm9ybWF0XG4gICAgICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnREVCVUcgbm9ybWFsaXplQW1vdW50VG9XZWkgLSBBbHJlYWR5IGluIGNvcnJlY3QgZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFtb3VudFN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElmIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbFxuICAgICAgICAgICAgbG9nZ2VyJG0ud2FybihgRmFpbGVkIHRvIG5vcm1hbGl6ZSBhbW91bnQgJHthbW91bnR9IGZvciB0b2tlbiAke3Rva2VufTpgLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRyYW5zYWN0aW9uIHJlY2VpcHQgd2l0aCByZXRyeSBsb2dpY1xuICAgICAqIE5vdGU6IEFzc3VtZXMgd2UncmUgYWxyZWFkeSBvbiB0aGUgY29ycmVjdCBjaGFpbiAoaGFuZGxlZCBieSBjaGVja1RyYW5zYWN0aW9uU3VjY2VzcylcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoLCBtYXhSZXRyaWVzID0gMykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLm5leHVzU0RLLmdldEVWTUNsaWVudCgpLndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoe1xuICAgICAgICAgICAgaGFzaDogdHhIYXNoLFxuICAgICAgICAgICAgcmV0cnlDb3VudDogbWF4UmV0cmllcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXVsYXRlIGEgZmFpbGVkIHRyYW5zYWN0aW9uIHRvIGdldCB0aGUgcmV2ZXJ0IHJlYXNvblxuICAgICAqIE5vdGU6IEFzc3VtZXMgd2UncmUgYWxyZWFkeSBvbiB0aGUgY29ycmVjdCBjaGFpbiAoaGFuZGxlZCBieSBjaGVja1RyYW5zYWN0aW9uU3VjY2VzcylcbiAgICAgKi9cbiAgICBhc3luYyBzaW11bGF0ZUZhaWxlZFRyYW5zYWN0aW9uKHR4SGFzaCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCB0cmFuc2FjdGlvbiBkZXRhaWxzXG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuYWRhcHRlci5uZXh1c1NESy5nZXRFVk1DbGllbnQoKS5nZXRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgaGFzaDogdHhIYXNoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXR4IHx8IHR4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUeXBlIGd1YXJkIHRvIGVuc3VyZSB0cmFuc2FjdGlvbiBoYXMgcmVxdWlyZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eCAhPT0gJ29iamVjdCcgfHwgdHggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0ludmFsaWQgdHJhbnNhY3Rpb24gZGF0YSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXR4LnRvIHx8ICF0eC5pbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnSW52YWxpZCB0cmFuc2FjdGlvbiBkYXRhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCB0byBmaW5kIHRoZSBibG9jayBudW1iZXIgd2hlcmUgaXQgZmFpbGVkXG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5hZGFwdGVyLm5leHVzU0RLLmdldEVWTUNsaWVudCgpLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh7XG4gICAgICAgICAgICAgICAgaGFzaDogdHhIYXNoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGJsb2NrIG51bWJlciB3aGVyZSB0aGUgdHJhbnNhY3Rpb24gd2FzIG1pbmVkLCBvciB0aGUgcHJldmlvdXMgYmxvY2tcbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBzaW11bGF0ZSB0aGUgZXhhY3Qgc3RhdGUgd2hlbiB0aGUgdHJhbnNhY3Rpb24gZmFpbGVkXG4gICAgICAgICAgICBsZXQgc2ltdWxhdGlvbkJsb2NrID0gMG47XG4gICAgICAgICAgICBpZiAocmVjZWlwdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0LmJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbXVsYXRpb25CbG9jayA9IHJlY2VpcHQuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHguYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBzaW11bGF0aW9uQmxvY2sgPSB0eC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYERFQlVHIHNpbXVsYXRlRmFpbGVkVHJhbnNhY3Rpb24gLSBTaW11bGF0aW5nIGF0IGJsb2NrOiAke3NpbXVsYXRpb25CbG9ja31gKTtcbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIHRoZSB0cmFuc2FjdGlvbiBjYWxsIHRvIGdldCByZXZlcnQgcmVhc29uXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIubmV4dXNTREsuZ2V0RVZNQ2xpZW50KCkuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgICAgIGRhdGE6IHR4LmlucHV0LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0eC52YWx1ZSxcbiAgICAgICAgICAgICAgICBnYXM6IHR4LmdhcyxcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogc2ltdWxhdGlvbkJsb2NrLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiBldGhfY2FsbCBzdWNjZWVkcyB3aGVuIHdlIGV4cGVjdGVkIGl0IHRvIGZhaWwsIHRoaXMgaXMgc3VzcGljaW91c1xuICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIHRyYW5zYWN0aW9uIGZhaWxlZCBidXQgdGhlIHNpbXVsYXRpb24gcGFzc2VzXG4gICAgICAgICAgICBsb2dnZXIkbS53YXJuKCdERUJVRyBzaW11bGF0ZUZhaWxlZFRyYW5zYWN0aW9uIC0gZXRoX2NhbGwgc3VjY2VlZGVkIGJ1dCBvcmlnaW5hbCB0cmFuc2FjdGlvbiBmYWlsZWQuIFRoaXMgbWlnaHQgaW5kaWNhdGUgYSBzdGF0ZS1kZXBlbmRlbnQgZmFpbHVyZS4nKTtcbiAgICAgICAgICAgIHJldHVybiAnVHJhbnNhY3Rpb24gZmFpbGVkIGR1ZSB0byBzdGF0ZSBjaGFuZ2VzIG9yIGdhcyBpc3N1ZXMnO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbygnREVCVUcgc2ltdWxhdGVGYWlsZWRUcmFuc2FjdGlvbiAtIGV0aF9jYWxsIGZhaWxlZCBhcyBleHBlY3RlZCwgZXh0cmFjdGluZyByZXZlcnQgcmVhc29uJyk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBleHBlY3RlZCBwYXRoIC0gZXRoX2NhbGwgc2hvdWxkIGZhaWwgYW5kIGdpdmUgdXMgdGhlIHJldmVydCByZWFzb25cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgcmV2ZXJ0IHJlYXNvbiBmcm9tIGVycm9yXG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm92aWRlckVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyRXJyb3IuZGF0YT8ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJFcnJvci5kYXRhLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgJ21lc3NhZ2UnIGluIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JXaXRoTWVzc2FnZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGNvbW1vbiByZXZlcnQgcmVhc29uIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgY29uc3QgcmV2ZXJ0TWF0Y2ggPSBlcnJvcldpdGhNZXNzYWdlLm1lc3NhZ2UubWF0Y2goL3JldmVydCAoLis/KSg/Olxcc3wkKS9pKTtcbiAgICAgICAgICAgICAgICBpZiAocmV2ZXJ0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldmVydE1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgZXhlY3V0aW9uIHJldmVydGVkIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yV2l0aE1lc3NhZ2UubWVzc2FnZS5pbmNsdWRlcygnZXhlY3V0aW9uIHJldmVydGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xlYW5NZXNzYWdlID0gZXJyb3JXaXRoTWVzc2FnZS5tZXNzYWdlLnJlcGxhY2UoJ2V4ZWN1dGlvbiByZXZlcnRlZDogJywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFuTWVzc2FnZSB8fCAnVHJhbnNhY3Rpb24gcmV2ZXJ0ZWQgd2l0aG91dCByZWFzb24nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgb3RoZXIgY29tbW9uIGVycm9yIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yV2l0aE1lc3NhZ2UubWVzc2FnZS5pbmNsdWRlcygnaW5zdWZmaWNpZW50IGZ1bmRzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdJbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGdhcyAqIHByaWNlICsgdmFsdWUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JXaXRoTWVzc2FnZS5tZXNzYWdlLmluY2x1ZGVzKCdnYXMgcmVxdWlyZWQgZXhjZWVkcyBhbGxvd2FuY2UnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ091dCBvZiBnYXMnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JXaXRoTWVzc2FnZS5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdUcmFuc2FjdGlvbiBzaW11bGF0aW9uIGZhaWxlZCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdHJhbnNhY3Rpb24gc3VjY2VzcyBhbmQgZ2V0IGRldGFpbGVkIGVycm9yIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgY2hlY2tUcmFuc2FjdGlvblN1Y2Nlc3ModHhIYXNoLCBjaGFpbklkLCBtYXhSZXRyaWVzID0gNSwgcmV0cnlEZWxheSA9IDMwMDApIHtcbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gbWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYERFQlVHIGNoZWNrVHJhbnNhY3Rpb25TdWNjZXNzIC0gQXR0ZW1wdCAke2F0dGVtcHR9LyR7bWF4UmV0cmllc306IENoZWNraW5nIHRyYW5zYWN0aW9uOiAke3R4SGFzaH0gb24gY2hhaW46ICR7Y2hhaW5JZH1gKTtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgd2UncmUgb24gdGhlIGNvcnJlY3QgY2hhaW4gYmVmb3JlIGNoZWNraW5nIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENoYWluSWQgPSBhd2FpdCB0aGlzLmFkYXB0ZXIubmV4dXNTREsuZ2V0RVZNQ2xpZW50KCkuZ2V0Q2hhaW5JZCgpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhaW5JZCAhPT0gY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkbS5pbmZvKGBERUJVRyBjaGVja1RyYW5zYWN0aW9uU3VjY2VzcyAtIFN3aXRjaGluZyBmcm9tIGNoYWluICR7Y3VycmVudENoYWluSWR9IHRvICR7Y2hhaW5JZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYWRhcHRlci5uZXh1c1NESy5nZXRFVk1DbGllbnQoKS5zd2l0Y2hDaGFpbih7IGlkOiBjaGFpbklkIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCBhIGJpdCBhZnRlciBjaGFpbiBzd2l0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoc3dpdGNoRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciRtLmVycm9yKGBERUJVRyBjaGVja1RyYW5zYWN0aW9uU3VjY2VzcyAtIEZhaWxlZCB0byBzd2l0Y2ggdG8gY2hhaW4gJHtjaGFpbklkfTpgLCBzd2l0Y2hFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIHN3aXRjaCB0byBjaGFpbiAke2NoYWluSWR9IGZvciB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb25gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAxLiBHZXQgdHJhbnNhY3Rpb24gcmVjZWlwdCAtIGJhc2ljIHN1Y2Nlc3MvZmFpbHVyZVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYERFQlVHIGNoZWNrVHJhbnNhY3Rpb25TdWNjZXNzIC0gUmVjZWlwdCBub3QgZm91bmQsIHJldHJ5aW5nIGluICR7cmV0cnlEZWxheX1tcy4uLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIFJldHJ5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdUcmFuc2FjdGlvbiByZWNlaXB0IG5vdCBmb3VuZCBhZnRlciBtdWx0aXBsZSBhdHRlbXB0cycsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYERFQlVHIGNoZWNrVHJhbnNhY3Rpb25TdWNjZXNzIC0gUmVjZWlwdCBzdGF0dXM6ICR7cmVjZWlwdC5zdGF0dXN9YCk7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdHJhbnNhY3Rpb24gc3VjY2VlZGVkXG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzID09PSAnc3VjY2VzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXNVc2VkOiB0b0hleChyZWNlaXB0Lmdhc1VzZWQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdUcmFuc2FjdGlvbiBmYWlsZWQnO1xuICAgICAgICAgICAgICAgICAgICAvLyAzLiBTaW11bGF0ZSB0aGUgdHJhbnNhY3Rpb24gdG8gZ2V0IGRldGFpbGVkIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaW11bGF0aW9uRXJyb3IgPSBhd2FpdCB0aGlzLnNpbXVsYXRlRmFpbGVkVHJhbnNhY3Rpb24odHhIYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW11bGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBzaW11bGF0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKHNpbUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIkbS53YXJuKCdERUJVRyBjaGVja1RyYW5zYWN0aW9uU3VjY2VzcyAtIFNpbXVsYXRpb24gZmFpbGVkOicsIHNpbUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgZ2VuZXJpYyBlcnJvciBtZXNzYWdlIGlmIHNpbXVsYXRpb24gZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkbS5pbmZvKGBERUJVRyBjaGVja1RyYW5zYWN0aW9uU3VjY2VzcyAtIEZpbmFsIGVycm9yOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhc1VzZWQ6IHRvSGV4KHJlY2VpcHQuZ2FzVXNlZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyYW5zYWN0aW9uIGZhaWxlZCAtIG5vdyBnZXQgdGhlIGVycm9yIHJlYXNvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJG0uZXJyb3IoYERFQlVHIGNoZWNrVHJhbnNhY3Rpb25TdWNjZXNzIC0gQXR0ZW1wdCAke2F0dGVtcHR9IGZhaWxlZDpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYERFQlVHIGNoZWNrVHJhbnNhY3Rpb25TdWNjZXNzIC0gUmV0cnlpbmcgaW4gJHtyZXRyeURlbGF5fW1zLi4uYCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5RGVsYXkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIFJldHJ5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbmFsIGF0dGVtcHQgZmFpbGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIGNoZWNrIHRyYW5zYWN0aW9uIHN0YXR1cyBhZnRlciAke21heFJldHJpZXN9IGF0dGVtcHRzOiAke2V4dHJhY3RFcnJvck1lc3NhZ2UoZXJyb3IsICd0cmFuc2FjdGlvbiBjaGVjaycpfWAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBiZSByZWFjaGVkLCBidXQganVzdCBpbiBjYXNlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBgVHJhbnNhY3Rpb24gY2hlY2sgZmFpbGVkIGFmdGVyICR7bWF4UmV0cmllc30gYXR0ZW1wdHNgLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgb3B0aW1hbCBicmlkZ2UgYW1vdW50IGJhc2VkIG9uIGRlc3RpbmF0aW9uIGNoYWluIGJhbGFuY2VcbiAgICAgKiBSZXR1cm5zIHRoZSBleGFjdCBhbW91bnQgbmVlZGVkIHRvIGJyaWRnZSwgb3IgaW5kaWNhdGVzIGlmIGJyaWRnZSBjYW4gYmUgc2tpcHBlZCBlbnRpcmVseVxuICAgICAqL1xuICAgIGFzeW5jIGNhbGN1bGF0ZU9wdGltYWxCcmlkZ2VBbW91bnQoY2hhaW5JZCwgdG9rZW4sIHJlcXVpcmVkQW1vdW50LCBnYXNFc3RpbWF0ZSwgZ2FzQ29zdEV0aCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2V0IGRlc3RpbmF0aW9uIGNoYWluIGJhbGFuY2VcbiAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uQmFsYW5jZSA9IGF3YWl0IHRoaXMuZ2V0RGVzdGluYXRpb25DaGFpbkJhbGFuY2UoY2hhaW5JZCwgdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uQmFsYW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGdldCBiYWxhbmNlIGluZm8sIGJyaWRnZSB0aGUgZnVsbCBhbW91bnRcbiAgICAgICAgICAgICAgICByZXR1cm4geyBza2lwQnJpZGdlOiBmYWxzZSwgb3B0aW1hbEFtb3VudDogcmVxdWlyZWRBbW91bnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkQW1vdW50QmlnSW50ID0gQmlnSW50KHJlcXVpcmVkQW1vdW50KTtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uQmFsYW5jZUJpZ0ludCA9IEJpZ0ludChkZXN0aW5hdGlvbkJhbGFuY2UpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBzdWZmaWNpZW50IGJhbGFuY2Ugb24gZGVzdGluYXRpb24gdG8gc2tpcCBicmlkZ2UgZW50aXJlbHlcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbkJhbGFuY2VCaWdJbnQgPj0gcmVxdWlyZWRBbW91bnRCaWdJbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBnYXMgYmFsYW5jZSBpZiB3ZSBoYXZlIGdhcyBlc3RpbWF0ZVxuICAgICAgICAgICAgICAgIGlmIChnYXNFc3RpbWF0ZSB8fCBnYXNDb3N0RXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0dhc0JhbGFuY2UgPSBhd2FpdCB0aGlzLmNoZWNrR2FzQmFsYW5jZShjaGFpbklkLCBnYXNFc3RpbWF0ZSwgZ2FzQ29zdEV0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzR2FzQmFsYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbyhgSW5zdWZmaWNpZW50IGdhcyBiYWxhbmNlIG9uIGNoYWluICR7Y2hhaW5JZH0sIGNhbm5vdCBza2lwIGJyaWRnZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2tpcEJyaWRnZTogZmFsc2UsIG9wdGltYWxBbW91bnQ6IHJlcXVpcmVkQW1vdW50IH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbyhgU3VmZmljaWVudCAke3Rva2VufSBhbmQgZ2FzIGJhbGFuY2Ugb24gY2hhaW4gJHtjaGFpbklkfSwgYnJpZGdlIGNhbiBiZSBza2lwcGVkYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc2tpcEJyaWRnZTogdHJ1ZSwgb3B0aW1hbEFtb3VudDogJzAnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byBicmlkZ2UgKHJlcXVpcmVkIC0gd2hhdCdzIGFscmVhZHkgb24gZGVzdGluYXRpb24pXG4gICAgICAgICAgICBjb25zdCBvcHRpbWFsQnJpZGdlQW1vdW50QmlnSW50ID0gcmVxdWlyZWRBbW91bnRCaWdJbnQgLSBkZXN0aW5hdGlvbkJhbGFuY2VCaWdJbnQ7XG4gICAgICAgICAgICBjb25zdCBvcHRpbWFsQW1vdW50ID0gKG9wdGltYWxCcmlkZ2VBbW91bnRCaWdJbnQgPiAwbiA/IG9wdGltYWxCcmlkZ2VBbW91bnRCaWdJbnQgOiAwbikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYE9wdGltYWwgYnJpZGdlIGNhbGN1bGF0aW9uOmAsIHtcbiAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkQW1vdW50LFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uQmFsYW5jZSxcbiAgICAgICAgICAgICAgICBvcHRpbWFsQnJpZGdlQW1vdW50OiBvcHRpbWFsQW1vdW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBza2lwQnJpZGdlOiBmYWxzZSwgb3B0aW1hbEFtb3VudCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyJG0ud2FybihgRmFpbGVkIHRvIGNhbGN1bGF0ZSBvcHRpbWFsIGJyaWRnZSBhbW91bnQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGJyaWRnaW5nIGZ1bGwgYW1vdW50IG9uIGVycm9yXG4gICAgICAgICAgICByZXR1cm4geyBza2lwQnJpZGdlOiBmYWxzZSwgb3B0aW1hbEFtb3VudDogcmVxdWlyZWRBbW91bnQgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZGVzdGluYXRpb24gY2hhaW4gYmFsYW5jZSBmb3IgYSBzcGVjaWZpYyB0b2tlblxuICAgICAqIFJldHVybnMgYmFsYW5jZSBpbiB3ZWkgYXMgc3RyaW5nLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGFzeW5jIGdldERlc3RpbmF0aW9uQ2hhaW5CYWxhbmNlKGNoYWluSWQsIHRva2VuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2dnZXIkbS5pbmZvKGBHZXR0aW5nICR7dG9rZW59IGJhbGFuY2Ugb24gY2hhaW4gJHtjaGFpbklkfWApO1xuICAgICAgICAgICAgLy8gR2V0IHVzZXIncyB1bmlmaWVkIGJhbGFuY2VzXG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlcyA9IChhd2FpdCB0aGlzLmFkYXB0ZXIubmV4dXNTREsuZ2V0VW5pZmllZEJhbGFuY2VzKCkpO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgYmFsYW5jZSBmb3IgdGhlIHNwZWNpZmljIHRva2VuXG4gICAgICAgICAgICBjb25zdCB0b2tlbkJhbGFuY2UgPSBiYWxhbmNlcy5maW5kKChhc3NldCkgPT4gYXNzZXQuc3ltYm9sID09PSB0b2tlbik7XG4gICAgICAgICAgICBpZiAoIXRva2VuQmFsYW5jZSB8fCAhdG9rZW5CYWxhbmNlLmJyZWFrZG93bikge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYE5vICR7dG9rZW59IGJhbGFuY2UgZm91bmRgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmQgYmFsYW5jZSBvbiB0aGUgc3BlY2lmaWMgY2hhaW5cbiAgICAgICAgICAgIGNvbnN0IGNoYWluQmFsYW5jZSA9IHRva2VuQmFsYW5jZS5icmVha2Rvd24uZmluZCgoYmFsYW5jZSkgPT4gYmFsYW5jZS5jaGFpbi5pZCA9PT0gY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoIWNoYWluQmFsYW5jZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYE5vICR7dG9rZW59IGJhbGFuY2UgZm91bmQgb24gY2hhaW4gJHtjaGFpbklkfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiAnMCc7IC8vIFJldHVybiAwIGlmIG5vIGJhbGFuY2Ugb24gdGhpcyBjaGFpblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRva2VuIG1ldGFkYXRhIGZvciBkZWNpbWFsIGNvbnZlcnNpb25cbiAgICAgICAgICAgIGNvbnN0IHRva2VuTWV0YWRhdGEgPSBUT0tFTl9NRVRBREFUQVt0b2tlbi50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gdG9rZW5NZXRhZGF0YT8uZGVjaW1hbHMgfHwgMTg7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBiYWxhbmNlIHRvIHdlaSBmb3IgY2FsY3VsYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VJbldlaSA9IHBhcnNlVW5pdHMkMShjaGFpbkJhbGFuY2UuYmFsYW5jZSwgZGVjaW1hbHMpO1xuICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbyhgQmFsYW5jZSBmb3VuZDpgLCB7XG4gICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBiYWxhbmNlOiBjaGFpbkJhbGFuY2UuYmFsYW5jZSxcbiAgICAgICAgICAgICAgICBiYWxhbmNlSW5XZWk6IGJhbGFuY2VJbldlaS50b1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYmFsYW5jZUluV2VpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIkbS53YXJuKGBGYWlsZWQgdG8gZ2V0IGRlc3RpbmF0aW9uIGNoYWluIGJhbGFuY2U6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBuYXRpdmUgdG9rZW4gYmFsYW5jZSBmb3IgZ2FzIHJlcXVpcmVtZW50c1xuICAgICAqL1xuICAgIGFzeW5jIGNoZWNrR2FzQmFsYW5jZShjaGFpbklkLCBnYXNFc3RpbWF0ZSwgZ2FzQ29zdEV0aCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2V0IG5hdGl2ZSB0b2tlbiBzeW1ib2wgZm9yIHRoaXMgY2hhaW5cbiAgICAgICAgICAgIGNvbnN0IGNoYWluTWV0YWRhdGEgPSBDSEFJTl9NRVRBREFUQVtjaGFpbklkXTtcbiAgICAgICAgICAgIGlmICghY2hhaW5NZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oYE5vIGNoYWluIG1ldGFkYXRhIGZvdW5kIGZvciBjaGFpbiAke2NoYWluSWR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmF0aXZlVG9rZW5TeW1ib2wgPSBjaGFpbk1ldGFkYXRhLm5hdGl2ZUN1cnJlbmN5LnN5bWJvbDtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYENoZWNraW5nICR7bmF0aXZlVG9rZW5TeW1ib2x9IGJhbGFuY2Ugb24gY2hhaW4gJHtjaGFpbklkfSBmb3IgZ2FzYCk7XG4gICAgICAgICAgICAvLyBHZXQgdXNlcidzIHVuaWZpZWQgYmFsYW5jZXNcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VzID0gKGF3YWl0IHRoaXMuYWRhcHRlci5uZXh1c1NESy5nZXRVbmlmaWVkQmFsYW5jZXMoKSk7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBuYXRpdmUgdG9rZW4gYmFsYW5jZVxuICAgICAgICAgICAgY29uc3QgbmF0aXZlVG9rZW5CYWxhbmNlID0gYmFsYW5jZXMuZmluZCgoYXNzZXQpID0+IGFzc2V0LnN5bWJvbCA9PT0gbmF0aXZlVG9rZW5TeW1ib2wpO1xuICAgICAgICAgICAgaWYgKCFuYXRpdmVUb2tlbkJhbGFuY2UgfHwgIW5hdGl2ZVRva2VuQmFsYW5jZS5icmVha2Rvd24pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkbS5pbmZvKGBObyAke25hdGl2ZVRva2VuU3ltYm9sfSBiYWxhbmNlIGZvdW5kYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluZCBiYWxhbmNlIG9uIHRoZSBzcGVjaWZpYyBjaGFpblxuICAgICAgICAgICAgY29uc3QgY2hhaW5CYWxhbmNlID0gbmF0aXZlVG9rZW5CYWxhbmNlLmJyZWFrZG93bi5maW5kKChiYWxhbmNlKSA9PiBiYWxhbmNlLmNoYWluLmlkID09PSBjaGFpbklkKTtcbiAgICAgICAgICAgIGlmICghY2hhaW5CYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJG0uaW5mbyhgTm8gJHtuYXRpdmVUb2tlblN5bWJvbH0gYmFsYW5jZSBmb3VuZCBvbiBjaGFpbiAke2NoYWluSWR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHJlcXVpcmVkIGdhcyBjb3N0XG4gICAgICAgICAgICBsZXQgcmVxdWlyZWRHYXNDb3N0ID0gJzAnO1xuICAgICAgICAgICAgaWYgKGdhc0Nvc3RFdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGdhcyBjb3N0IGluIEVUSCwgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgcmVxdWlyZWRHYXNDb3N0ID0gZ2FzQ29zdEV0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGdhc0VzdGltYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBnYXMgZXN0aW1hdGUgdG8gRVRIIHVzaW5nIGN1cnJlbnQgZ2FzIHByaWNlXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2VIZXggPSAoYXdhaXQgdGhpcy5hZGFwdGVyLm5leHVzU0RLLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2dhc1ByaWNlJyxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZVdlaSA9IHBhcnNlSW50KGdhc1ByaWNlSGV4LCAxNik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhc1VzZWROdW0gPSBwYXJzZUZsb2F0KGdhc0VzdGltYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29zdEV0aE51bSA9IChnYXNVc2VkTnVtICogZ2FzUHJpY2VXZWkpIC8gMWUxODsgLy8gQ29udmVydCB3ZWkgdG8gRVRIXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkR2FzQ29zdCA9IGNvc3RFdGhOdW0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oYEZhaWxlZCB0byBmZXRjaCBnYXMgcHJpY2UgZm9yIGdhcyBiYWxhbmNlIGNoZWNrOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIDEwJSBidWZmZXIgdG8gcmVxdWlyZWQgZ2FzIGNvc3RcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkR2FzQ29zdFdpdGhCdWZmZXIgPSAocGFyc2VGbG9hdChyZXF1aXJlZEdhc0Nvc3QpICogMS4xKS50b1N0cmluZygpO1xuICAgICAgICAgICAgLy8gQ29tcGFyZSBiYWxhbmNlcyAoYm90aCBpbiB1c2VyLWZyaWVuZGx5IGZvcm1hdCBsaWtlIEVUSClcbiAgICAgICAgICAgIGNvbnN0IHVzZXJCYWxhbmNlID0gcGFyc2VGbG9hdChjaGFpbkJhbGFuY2UuYmFsYW5jZSk7XG4gICAgICAgICAgICBjb25zdCByZXF1aXJlZEdhc0Zsb2F0ID0gcGFyc2VGbG9hdChyZXF1aXJlZEdhc0Nvc3RXaXRoQnVmZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1N1ZmZpY2llbnRHYXNCYWxhbmNlID0gdXNlckJhbGFuY2UgPj0gcmVxdWlyZWRHYXNGbG9hdDtcbiAgICAgICAgICAgIGxvZ2dlciRtLmluZm8oYEdhcyBiYWxhbmNlIGNoZWNrIHJlc3VsdDpgLCB7XG4gICAgICAgICAgICAgICAgbmF0aXZlVG9rZW5TeW1ib2wsXG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICB1c2VyQmFsYW5jZTogY2hhaW5CYWxhbmNlLmJhbGFuY2UsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWRHYXNDb3N0LFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkR2FzQ29zdFdpdGhCdWZmZXIsXG4gICAgICAgICAgICAgICAgaGFzU3VmZmljaWVudEdhc0JhbGFuY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBoYXNTdWZmaWNpZW50R2FzQmFsYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlciRtLndhcm4oYEZhaWxlZCB0byBjaGVjayBnYXMgYmFsYW5jZTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGRpcmVjdGx5IHdpdGhvdXQgYnJpZGdpbmcgd2hlbiB1c2VyIGhhcyBzdWZmaWNpZW50IGZ1bmRzXG4gICAgICogVXNlcyBjYWxsYmFjay1iYXNlZCBwYXJhbWV0ZXJzIGZvciBkeW5hbWljIGV4ZWN1dGlvblxuICAgICAqL1xuICAgIGFzeW5jIGV4ZWN1dGVEaXJlY3RseShleGVjdXRlLCB0b0NoYWluSWQsIHRva2VuLCBhbW91bnQsIGVuYWJsZVRyYW5zYWN0aW9uUG9sbGluZywgdHJhbnNhY3Rpb25UaW1lb3V0LCB3YWl0Rm9yUmVjZWlwdCwgcmVjZWlwdFRpbWVvdXQsIHJlcXVpcmVkQ29uZmlybWF0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRW1pdCBleHBlY3RlZCBzdGVwcyBmb3IgZXhlY3V0ZS1vbmx5IGZsb3dcbiAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVTdGVwcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbWFrZVN0ZXAgPSAodHlwZUlELCB0eXBlLCBkYXRhID0ge30pID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZUlELFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklEOiB0b0NoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluTmFtZTogQ0hBSU5fTUVUQURBVEFbdG9DaGFpbklkXT8ubmFtZSB8fCB0b0NoYWluSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBZGQgc3RlcHMgZm9yIGV4ZWN1dGUtb25seSBmbG93XG4gICAgICAgICAgICBpZiAoZXhlY3V0ZS50b2tlbkFwcHJvdmFsKSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZVN0ZXBzLnB1c2gobWFrZVN0ZXAoJ0FQJywgJ0FQUFJPVkFMJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhlY3V0ZVN0ZXBzLnB1c2gobWFrZVN0ZXAoJ1RTJywgJ1RSQU5TQUNUSU9OX1NFTlQnKSk7XG4gICAgICAgICAgICBpZiAod2FpdEZvclJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRlU3RlcHMucHVzaChtYWtlU3RlcCgnUlInLCAnUkVDRUlQVF9SRUNFSVZFRCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgocmVxdWlyZWRDb25maXJtYXRpb25zID8/IDApID4gMCkge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGVTdGVwcy5wdXNoKG1ha2VTdGVwKCdDTicsICdUUkFOU0FDVElPTl9DT05GSVJNRUQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbWl0IGV4cGVjdGVkIHN0ZXBzIGZvciBleGVjdXRlLW9ubHkgZmxvd1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLm5leHVzU0RLLm5leHVzRXZlbnRzLmVtaXQoTkVYVVNfRVZFTlRTLkJSSURHRV9FWEVDVVRFX0VYUEVDVEVEX1NURVBTLCBleGVjdXRlU3RlcHMpO1xuICAgICAgICAgICAgLy8gRXhlY3V0ZSBkaXJlY3RseSB1c2luZyBleGlzdGluZyBmdW5kc1xuICAgICAgICAgICAgY29uc3QgeyBleGVjdXRlVHJhbnNhY3Rpb25IYXNoLCBleGVjdXRlRXhwbG9yZXJVcmwsIGFwcHJvdmFsVHJhbnNhY3Rpb25IYXNoIH0gPSBhd2FpdCB0aGlzLmhhbmRsZUV4ZWN1dGVQaGFzZShleGVjdXRlLCB0b0NoYWluSWQsIHRva2VuLCBhbW91bnQsIGVuYWJsZVRyYW5zYWN0aW9uUG9sbGluZywgdHJhbnNhY3Rpb25UaW1lb3V0LCB3YWl0Rm9yUmVjZWlwdCwgcmVjZWlwdFRpbWVvdXQsIHJlcXVpcmVkQ29uZmlybWF0aW9ucywgKHN0ZXApID0+IHRoaXMuYWRhcHRlci5uZXh1c1NESy5uZXh1c0V2ZW50cy5lbWl0KE5FWFVTX0VWRU5UUy5CUklER0VfRVhFQ1VURV9DT01QTEVURURfU1RFUFMsIHN0ZXApLCBtYWtlU3RlcCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGVUcmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUV4cGxvcmVyVXJsLFxuICAgICAgICAgICAgICAgIGFwcHJvdmFsVHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgIGJyaWRnZVRyYW5zYWN0aW9uSGFzaDogdW5kZWZpbmVkLCAvLyBicmlkZ2Ugd2FzIHNraXBwZWRcbiAgICAgICAgICAgICAgICBicmlkZ2VFeHBsb3JlclVybDogdW5kZWZpbmVkLCAvLyBicmlkZ2Ugd2FzIHNraXBwZWRcbiAgICAgICAgICAgICAgICB0b0NoYWluSWQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBicmlkZ2VTa2lwcGVkOiB0cnVlLCAvLyBicmlkZ2Ugd2FzIHNraXBwZWQgZHVlIHRvIHN1ZmZpY2llbnQgZnVuZHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBleHRyYWN0RXJyb3JNZXNzYWdlKGVycm9yLCAnZXhlY3V0ZSBkaXJlY3RseScpO1xuICAgICAgICAgICAgLy8gRW1pdCBlcnJvciBzdGVwXG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIubmV4dXNTREsubmV4dXNFdmVudHMuZW1pdChORVhVU19FVkVOVFMuQlJJREdFX0VYRUNVVEVfQ09NUExFVEVEX1NURVBTLCB7XG4gICAgICAgICAgICAgICAgdHlwZUlEOiAnRVInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVyYXRpb24uZmFpbGVkJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN0YWdlOiAnZXhlY3V0ZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0NoYWluSWQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBFeGVjdXRlLW9ubHkgb3BlcmF0aW9uIGZhaWxlZDogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICBicmlkZ2VTa2lwcGVkOiB0cnVlLCAvLyBlcnJvciBvY2N1cnJlZCBkdXJpbmcgZXhlY3V0ZS1vbmx5IGZsb3dcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgY2hhaW4gYWJzdHJhY3Rpb24gb3BlcmF0aW9ucy5cbiAqL1xuY2xhc3MgQ2hhaW5BYnN0cmFjdGlvbkFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG5leHVzU0RLKSB7XG4gICAgICAgIHRoaXMubmV4dXNTREsgPSBuZXh1c1NESztcbiAgICAgICAgbG9nZ2VyJG0uZGVidWcoJ0NoYWluQWJzdHJhY3Rpb25BZGFwdGVyJywgeyBuZXh1c1NESyB9KTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBzZXJ2aWNlc1xuICAgICAgICB0aGlzLmV4ZWN1dGVTZXJ2aWNlID0gbmV3IEV4ZWN1dGVTZXJ2aWNlKHRoaXMpO1xuICAgICAgICB0aGlzLmJyaWRnZUV4ZWN1dGVTZXJ2aWNlID0gbmV3IEJyaWRnZUV4ZWN1dGVTZXJ2aWNlKHRoaXMpO1xuICAgICAgICB0aGlzLnNldEdhc0VzdGltYXRpb25FbmFibGVkKHRydWUpO1xuICAgIH1cbiAgICBhc3luYyBnZXRFVk1DbGllbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHVzU0RLLmdldEVWTUNsaWVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGEgY29udHJhY3QgY2FsbCB1c2luZyB0aGUgZXhlY3V0ZSBzZXJ2aWNlLlxuICAgICAqL1xuICAgIGFzeW5jIGV4ZWN1dGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVTZXJ2aWNlLmV4ZWN1dGUocGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltdWxhdGUgY29udHJhY3QgZXhlY3V0aW9uIHVzaW5nIHRoZSBleGVjdXRlIHNlcnZpY2UuXG4gICAgICovXG4gICAgYXN5bmMgc2ltdWxhdGVFeGVjdXRlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlU2VydmljZS5zaW11bGF0ZUV4ZWN1dGUocGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIHN1cHBvcnRlZCBjaGFpbnMgZnJvbSB0aGUgQ0EgU0RLLlxuICAgICAqL1xuICAgIGdldFN1cHBvcnRlZENoYWlucyhlbnYpIHtcbiAgICAgICAgcmV0dXJuIGdldFN1cHBvcnRlZENoYWlucyhlbnYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGNoYWluIGlzIHN1cHBvcnRlZCBieSB0aGUgYWRhcHRlci5cbiAgICAgKi9cbiAgICBpc1N1cHBvcnRlZENoYWluKGNoYWluSWQpIHtcbiAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkQ2hhaW4oY2hhaW5JZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdG9rZW4gaXMgc3VwcG9ydGVkIGJ5IHRoZSBhZGFwdGVyLlxuICAgICAqL1xuICAgIGlzU3VwcG9ydGVkVG9rZW4odG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkVG9rZW4odG9rZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcmlkZ2UgYW5kIGV4ZWN1dGUgb3BlcmF0aW9uIC0gdXNlcyB0aGUgQnJpZGdlRXhlY3V0ZVNlcnZpY2VcbiAgICAgKi9cbiAgICBhc3luYyBicmlkZ2VBbmRFeGVjdXRlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5icmlkZ2VFeGVjdXRlU2VydmljZS5icmlkZ2VBbmRFeGVjdXRlKHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbXVsYXRlIGJyaWRnZSBhbmQgZXhlY3V0ZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBzaW11bGF0ZUJyaWRnZUFuZEV4ZWN1dGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyaWRnZUV4ZWN1dGVTZXJ2aWNlLnNpbXVsYXRlQnJpZGdlQW5kRXhlY3V0ZShwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBnYXMgZXN0aW1hdGlvbiBmb3IgdHJhbnNhY3Rpb25zXG4gICAgICogV2hlbiBlbmFibGVkLCBnYXMgZXN0aW1hdGlvbiB3aWxsIHJ1biBiZWZvcmUgZWFjaCB0cmFuc2FjdGlvbiBleGVjdXRpb25cbiAgICAgKiBUaGlzIGhlbHBzIGlkZW50aWZ5IHBvdGVudGlhbCBmYWlsdXJlcyBlYXJseSBhbmQgcHJvdmlkZXMgY29zdCBlc3RpbWF0ZXNcbiAgICAgKi9cbiAgICBzZXRHYXNFc3RpbWF0aW9uRW5hYmxlZChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuYnJpZGdlRXhlY3V0ZVNlcnZpY2Uuc2V0R2FzRXN0aW1hdGlvbkVuYWJsZWQoZW5hYmxlZCk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZVNlcnZpY2Uuc2V0R2FzRXN0aW1hdGlvbkVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxufVxuXG4vLyBzcmMvY29yZS9zZGsvaW5kZXgudHNcbmNsYXNzIE5leHVzU0RLIGV4dGVuZHMgQ0Ege1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICBsb2dnZXIkbS5kZWJ1ZygnTmV4dXMgU0RLIGluaXRpYWxpemVkIHdpdGggY29uZmlnOicsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMubmV4dXNBZGFwdGVyID0gbmV3IENoYWluQWJzdHJhY3Rpb25BZGFwdGVyKHRoaXMpO1xuICAgICAgICB0aGlzLm5leHVzRXZlbnRzID0gdGhpcy5fY2FFdmVudHM7XG4gICAgICAgIHRoaXMudXRpbHMgPSBuZXcgTmV4dXNVdGlscyh0aGlzLm5leHVzQWRhcHRlciwgKCkgPT4gdGhpcy5pc0luaXRpYWxpemVkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBTREsgd2l0aCBhIHByb3ZpZGVyXG4gICAgICovXG4gICAgYXN5bmMgaW5pdGlhbGl6ZShwcm92aWRlcikge1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBjb3JlIGFkYXB0ZXIgZmlyc3RcbiAgICAgICAgdGhpcy5fc2V0RVZNUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9pbml0KCk7XG4gICAgICAgIGNvbnN0IEJBQ0tFTkRfVVJMID0gJ2h0dHBzOi8vbmV4dXMtYmFja2VuZC5hdmFpbC5zbyc7XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdFJlc3VsdCA9IGF3YWl0IGluaXRpYWxpemVTaW11bGF0aW9uQ2xpZW50KEJBQ0tFTkRfVVJMKTtcbiAgICAgICAgICAgICAgICBpZiAoIWluaXRSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhY2tlbmQgaW5pdGlhbGl6YXRpb24gZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWNrZW5kIGluaXRpYWxpemF0aW9uIGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB1bmlmaWVkIGJhbGFuY2VzIGFjcm9zcyBhbGwgY2hhaW5zXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VW5pZmllZEJhbGFuY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VW5pZmllZEJhbGFuY2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB1bmlmaWVkIGJhbGFuY2UgZm9yIGEgc3BlY2lmaWMgdG9rZW5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRVbmlmaWVkQmFsYW5jZShzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFVuaWZpZWRCYWxhbmNlKHN5bWJvbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyb3NzIGNoYWluIHRva2VuIHRyYW5zZmVyXG4gICAgICovXG4gICAgYXN5bmMgYnJpZGdlKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGF3YWl0IHRoaXMuX2JyaWRnZShwYXJhbXMpKS5leGVjKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhwbG9yZXJVcmw6IHJlc3VsdD8uZXhwbG9yZXJVUkwgPz8gJycsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyb3NzIGNoYWluIHRva2VuIHRyYW5zZmVyIHRvIEVPQVxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZmVyKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGF3YWl0IHRoaXMuX3RyYW5zZmVyKHsgLi4ucGFyYW1zLCB0bzogcGFyYW1zLnJlY2lwaWVudCB9KSkuZXhlYygpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogcmVzdWx0Lmhhc2gsXG4gICAgICAgICAgICAgICAgZXhwbG9yZXJVcmw6IHJlc3VsdC5leHBsb3JlclVSTCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc3dhcFdpdGhFeGFjdEluKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9zd2FwV2l0aEV4YWN0SW4oaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzd2FwIHdpdGggZXhhY3Qgb3V0JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzd2FwV2l0aEV4YWN0T3V0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9zd2FwV2l0aEV4YWN0T3V0KGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gc3dhcCB3aXRoIGV4YWN0IG91dCcsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGNoYWluIGFic3RyYWN0ZWQgcHJvdmlkZXIgYWxsb3dpbmcgdXNlIG9mIGNoYWluIGFzYnRyYWN0aW9uXG4gICAgICogQHJldHVybnMgRXRoZXJldW1Qcm92aWRlclxuICAgICAqL1xuICAgIGdldEVWTVByb3ZpZGVyV2l0aENBKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RVZNUHJvdmlkZXJXaXRoQ0EoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltdWxhdGUgYnJpZGdlIHRyYW5zYWN0aW9uIHRvIGdldCBjb3N0cyBhbmQgZmVlc1xuICAgICAqL1xuICAgIGFzeW5jIHNpbXVsYXRlQnJpZGdlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuX2JyaWRnZShwYXJhbXMpKS5zaW11bGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW11bGF0ZSB0cmFuc2ZlciB0cmFuc2FjdGlvbiB0byBnZXQgY29zdHMgYW5kIGZlZXNcbiAgICAgKi9cbiAgICBhc3luYyBzaW11bGF0ZVRyYW5zZmVyKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuX3RyYW5zZmVyKHsgLi4ucGFyYW1zLCB0bzogcGFyYW1zLnJlY2lwaWVudCB9KSkuc2ltdWxhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIncyBpbnRlbnRzIHdpdGggcGFnaW5hdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGdldE15SW50ZW50cyhwYWdlID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TXlJbnRlbnRzKHBhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBhbGxvd2FuY2UgZm9yIHRva2VucyBvbiBhIHNwZWNpZmljIGNoYWluXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsb3dhbmNlKGNoYWluSWQsIHRva2Vucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsb3dhbmNlKCkuZ2V0KHsgY2hhaW5JRDogY2hhaW5JZCwgdG9rZW5zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYWxsb3dhbmNlIGZvciBhIHRva2VuIG9uIGEgc3BlY2lmaWMgY2hhaW5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRBbGxvd2FuY2UoY2hhaW5JZCwgdG9rZW5zLCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbG93YW5jZSgpLnNldCh7IGNoYWluSUQ6IGNoYWluSWQsIHRva2VucywgYW1vdW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZva2UgYWxsb3dhbmNlIGZvciBhIHRva2VuIG9uIGEgc3BlY2lmaWMgY2hhaW5cbiAgICAgKi9cbiAgICBhc3luYyByZXZva2VBbGxvd2FuY2UoY2hhaW5JZCwgdG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxvd2FuY2UoKS5yZXZva2UoeyBjaGFpbklEOiBjaGFpbklkLCB0b2tlbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBjYWxsYmFjayBmb3IgaW50ZW50IHN0YXR1cyB1cGRhdGVzXG4gICAgICovXG4gICAgc2V0T25JbnRlbnRIb29rKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3NldE9uSW50ZW50SG9vayhjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBjYWxsYmFjayBmb3IgYWxsb3dhbmNlIGFwcHJvdmFsIGV2ZW50c1xuICAgICAqL1xuICAgIHNldE9uQWxsb3dhbmNlSG9vayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9zZXRPbkFsbG93YW5jZUhvb2soY2FsbGJhY2spO1xuICAgIH1cbiAgICBhc3luYyBkZWluaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWluaXQoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdChhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVFVk1UeChhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhbmRhbG9uZSBmdW5jdGlvbiB0byBleGVjdXRlIGZ1bmRzIGludG8gYSBzbWFydCBjb250cmFjdFxuICAgICAqIEBwYXJhbSBwYXJhbXMgZXhlY3V0ZSBwYXJhbWV0ZXJzIGluY2x1ZGluZyBjb250cmFjdCBkZXRhaWxzIGFuZCB0cmFuc2FjdGlvbiBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGV4ZWN1dGUgcmVzdWx0IHdpdGggdHJhbnNhY3Rpb24gaGFzaCBhbmQgZXhwbG9yZXIgVVJMXG4gICAgICovXG4gICAgYXN5bmMgZXhlY3V0ZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dXNBZGFwdGVyLmV4ZWN1dGUocGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltdWxhdGUgYSBzdGFuZGFsb25lIGV4ZWN1dGUgdG8gZXN0aW1hdGUgZ2FzIGNvc3RzIGFuZCB2YWxpZGF0ZSBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHBhcmFtcyBleGVjdXRlIHBhcmFtZXRlcnMgZm9yIHNpbXVsYXRpb25cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBzaW11bGF0aW9uIHJlc3VsdCB3aXRoIGdhcyBlc3RpbWF0ZXNcbiAgICAgKi9cbiAgICBhc3luYyBzaW11bGF0ZUV4ZWN1dGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHVzQWRhcHRlci5zaW11bGF0ZUV4ZWN1dGUocGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5oYW5jZWQgYnJpZGdlIGFuZCBleGVjdXRlIGZ1bmN0aW9uIHdpdGggb3B0aW9uYWwgZXhlY3V0ZSBzdGVwIGFuZCBpbXByb3ZlZCBlcnJvciBoYW5kbGluZ1xuICAgICAqIEBwYXJhbSBwYXJhbXMgRW5oYW5jZWQgYnJpZGdlIGFuZCBleGVjdXRlIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBjb21wcmVoZW5zaXZlIG9wZXJhdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBicmlkZ2VBbmRFeGVjdXRlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh1c0FkYXB0ZXIuYnJpZGdlQW5kRXhlY3V0ZShwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW11bGF0ZSBicmlkZ2UgYW5kIGV4ZWN1dGUgb3BlcmF0aW9uIHVzaW5nIGJyaWRnZSBvdXRwdXQgYW1vdW50cyBmb3IgcmVhbGlzdGljIGV4ZWN1dGUgY29zdCBlc3RpbWF0aW9uXG4gICAgICogVGhpcyBtZXRob2QgcHJvdmlkZXMgbW9yZSBhY2N1cmF0ZSBnYXMgZXN0aW1hdGVzIGJ5IHVzaW5nIHRoZSBhY3R1YWwgYW1vdW50IHRoYXQgd2lsbCBiZVxuICAgICAqIHJlY2VpdmVkIG9uIHRoZSBkZXN0aW5hdGlvbiBjaGFpbiBhZnRlciBicmlkZ2luZyAoYWNjb3VudGluZyBmb3IgZmVlcywgc2xpcHBhZ2UsIGV0Yy4pXG4gICAgICogSW5jbHVkZXMgZGV0YWlsZWQgc3RlcC1ieS1zdGVwIGJyZWFrZG93biB3aXRoIGFwcHJvdmFsIGhhbmRsaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHNpbXVsYXRlQnJpZGdlQW5kRXhlY3V0ZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dXNBZGFwdGVyLnNpbXVsYXRlQnJpZGdlQW5kRXhlY3V0ZShwYXJhbXMpO1xuICAgIH1cbiAgICBnZXRTd2FwU3VwcG9ydGVkQ2hhaW5zQW5kVG9rZW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3dhcFN1cHBvcnRlZENoYWluc0FuZFRva2VucygpO1xuICAgIH1cbiAgICBpc0luaXRpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZCgpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgTmV4dXNTREsgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@avail-project+nexus-core@0.0.1-beta.0_bufferutil@4.0.9_google-protobuf@3.21.4_utf-8-va_56dd550c8b9e0639694cd9176377fa72/node_modules/@avail-project/nexus-core/dist/index.esm.js\n");

/***/ })

};
;