"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@fuel-ts+abi-coder@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6_6403986254e63357a3dfff475209c93d";
exports.ids = ["vendor-chunks/@fuel-ts+abi-coder@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6_6403986254e63357a3dfff475209c93d"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@fuel-ts+abi-coder@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6_6403986254e63357a3dfff475209c93d/node_modules/@fuel-ts/abi-coder/dist/index.mjs":
/*!****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@fuel-ts+abi-coder@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6_6403986254e63357a3dfff475209c93d/node_modules/@fuel-ts/abi-coder/dist/index.mjs ***!
  \****************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASSET_ID_LEN: () => (/* binding */ ASSET_ID_LEN),\n/* harmony export */   ArrayCoder: () => (/* binding */ ArrayCoder),\n/* harmony export */   B256Coder: () => (/* binding */ B256Coder),\n/* harmony export */   B512Coder: () => (/* binding */ B512Coder),\n/* harmony export */   BYTES_32: () => (/* binding */ BYTES_32),\n/* harmony export */   BigNumberCoder: () => (/* binding */ BigNumberCoder),\n/* harmony export */   BooleanCoder: () => (/* binding */ BooleanCoder),\n/* harmony export */   ByteCoder: () => (/* binding */ ByteCoder),\n/* harmony export */   CONTRACT_ID_LEN: () => (/* binding */ CONTRACT_ID_LEN),\n/* harmony export */   Coder: () => (/* binding */ Coder),\n/* harmony export */   ENCODING_V1: () => (/* binding */ ENCODING_V1),\n/* harmony export */   EnumCoder: () => (/* binding */ EnumCoder),\n/* harmony export */   INPUT_COIN_FIXED_SIZE: () => (/* binding */ INPUT_COIN_FIXED_SIZE),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   NumberCoder: () => (/* binding */ NumberCoder),\n/* harmony export */   OptionCoder: () => (/* binding */ OptionCoder),\n/* harmony export */   RawSliceCoder: () => (/* binding */ RawSliceCoder),\n/* harmony export */   SCRIPT_FIXED_SIZE: () => (/* binding */ SCRIPT_FIXED_SIZE),\n/* harmony export */   StdStringCoder: () => (/* binding */ StdStringCoder),\n/* harmony export */   StrSliceCoder: () => (/* binding */ StrSliceCoder),\n/* harmony export */   StringCoder: () => (/* binding */ StringCoder),\n/* harmony export */   StructCoder: () => (/* binding */ StructCoder),\n/* harmony export */   TupleCoder: () => (/* binding */ TupleCoder),\n/* harmony export */   UTXO_ID_LEN: () => (/* binding */ UTXO_ID_LEN),\n/* harmony export */   VecCoder: () => (/* binding */ VecCoder),\n/* harmony export */   WORD_SIZE: () => (/* binding */ WORD_SIZE),\n/* harmony export */   calculateVmTxMemory: () => (/* binding */ calculateVmTxMemory),\n/* harmony export */   decodeScriptData: () => (/* binding */ decodeScriptData)\n/* harmony export */ });\n/* harmony import */ var _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fuel-ts/errors */ \"(ssr)/./node_modules/.pnpm/@fuel-ts+errors@0.101.1/node_modules/@fuel-ts/errors/dist/index.mjs\");\n/* harmony import */ var _fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fuel-ts/utils */ \"(ssr)/./node_modules/.pnpm/@fuel-ts+utils@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6.1_j_f5ff000e110be614030afd6e0fd99f41/node_modules/@fuel-ts/utils/dist/index.mjs\");\n/* harmony import */ var _fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fuel-ts/math */ \"(ssr)/./node_modules/.pnpm/@fuel-ts+math@0.101.1/node_modules/@fuel-ts/math/dist/index.mjs\");\n/* harmony import */ var _fuel_ts_crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fuel-ts/crypto */ \"(ssr)/./node_modules/.pnpm/@fuel-ts+crypto@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6.1__2af6281b4693138068177942c72da7d9/node_modules/@fuel-ts/crypto/dist/index.mjs\");\n/* harmony import */ var _fuel_ts_hasher__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fuel-ts/hasher */ \"(ssr)/./node_modules/.pnpm/@fuel-ts+hasher@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6.1__3de5373ec566d2f8672f34c376d1b1fa/node_modules/@fuel-ts/hasher/dist/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\n// src/encoding/coders/AbstractCoder.ts\nvar Coder = class {\n  static {\n    __name(this, \"Coder\");\n  }\n  name;\n  type;\n  encodedLength;\n  constructor(name, type, encodedLength) {\n    this.name = name;\n    this.type = type;\n    this.encodedLength = encodedLength;\n  }\n};\n\n// src/encoding/coders/ArrayCoder.ts\n\n\n\n// src/utils/constants.ts\nvar U8_CODER_TYPE = \"u8\";\nvar U16_CODER_TYPE = \"u16\";\nvar U32_CODER_TYPE = \"u32\";\nvar U64_CODER_TYPE = \"u64\";\nvar U256_CODER_TYPE = \"u256\";\nvar RAW_PTR_CODER_TYPE = \"raw untyped ptr\";\nvar RAW_SLICE_CODER_TYPE = \"raw untyped slice\";\nvar BOOL_CODER_TYPE = \"bool\";\nvar B256_CODER_TYPE = \"b256\";\nvar B512_CODER_TYPE = \"struct std::b512::B512\";\nvar OPTION_CODER_TYPE = \"enum std::option::Option\";\nvar VEC_CODER_TYPE = \"struct std::vec::Vec\";\nvar BYTES_CODER_TYPE = \"struct std::bytes::Bytes\";\nvar STD_STRING_CODER_TYPE = \"struct std::string::String\";\nvar STR_SLICE_CODER_TYPE = \"str\";\nvar VOID_TYPE = \"()\";\nvar optionRegEx = /^enum (std::option::)?Option$/m;\nvar stringRegEx = /^str\\[(?<length>[0-9]+)\\]/;\nvar arrayRegEx = /^\\[(?<item>[\\w\\s\\\\[\\]]+);\\s*(?<length>[0-9]+)\\]/;\nvar structRegEx = /^struct.+/;\nvar enumRegEx = /^enum.+$/;\nvar tupleRegEx = /^\\((?<items>.*)\\)$/;\nvar genericRegEx = /^generic.+$/;\nvar fullNameRegExMatch = /([^\\s]+)$/m;\nvar ENCODING_V1 = \"1\";\nvar WORD_SIZE = 8;\nvar BYTES_32 = 32;\nvar UTXO_ID_LEN = BYTES_32 + 2;\nvar ASSET_ID_LEN = BYTES_32;\nvar CONTRACT_ID_LEN = BYTES_32;\nvar ADDRESS_LEN = BYTES_32;\nvar NONCE_LEN = BYTES_32;\nvar TX_LEN = WORD_SIZE * 4;\nvar TX_POINTER_LEN = WORD_SIZE * 2;\nvar MAX_BYTES = 2 ** 32 - 1;\nvar calculateVmTxMemory = /* @__PURE__ */ __name(({ maxInputs }) => BYTES_32 + // Tx ID\nASSET_ID_LEN + // Base asset ID\n// Asset ID/Balance coin input pairs\nmaxInputs * (ASSET_ID_LEN + WORD_SIZE) + WORD_SIZE, \"calculateVmTxMemory\");\nvar SCRIPT_FIXED_SIZE = WORD_SIZE + // Identifier\nWORD_SIZE + // Gas limit\nWORD_SIZE + // Script size\nWORD_SIZE + // Script data size\nWORD_SIZE + // Policies\nWORD_SIZE + // Inputs size\nWORD_SIZE + // Outputs size\nWORD_SIZE + // Witnesses size\nBYTES_32;\nvar INPUT_COIN_FIXED_SIZE = WORD_SIZE + // Identifier\nTX_LEN + // Utxo Length\nWORD_SIZE + // Output Index\nADDRESS_LEN + // Owner\nWORD_SIZE + // Amount\nASSET_ID_LEN + // Asset id\nTX_POINTER_LEN + // TxPointer\nWORD_SIZE + // Witnesses index\nWORD_SIZE + // Predicate size\nWORD_SIZE + // Predicate data size\nWORD_SIZE;\nvar INPUT_MESSAGE_FIXED_SIZE = WORD_SIZE + // Identifier\nADDRESS_LEN + // Sender\nADDRESS_LEN + // Recipient\nWORD_SIZE + // Amount\nNONCE_LEN + // Nonce\nWORD_SIZE + // witness_index\nWORD_SIZE + // Data size\nWORD_SIZE + // Predicate size\nWORD_SIZE + // Predicate data size\nWORD_SIZE;\n\n// src/utils/utilities.ts\nvar isUint8Array = /* @__PURE__ */ __name((value) => value instanceof Uint8Array, \"isUint8Array\");\nvar hasNestedOption = /* @__PURE__ */ __name((coders) => {\n  const array = Array.isArray(coders) ? coders : Object.values(coders);\n  for (const node of array) {\n    if (node.type === OPTION_CODER_TYPE) {\n      return true;\n    }\n    if (\"coder\" in node && node.coder.type === OPTION_CODER_TYPE) {\n      return true;\n    }\n    if (\"coders\" in node) {\n      const child = hasNestedOption(node.coders);\n      if (child) {\n        return true;\n      }\n    }\n  }\n  return false;\n}, \"hasNestedOption\");\n\n// src/encoding/coders/ArrayCoder.ts\nvar ArrayCoder = class extends Coder {\n  static {\n    __name(this, \"ArrayCoder\");\n  }\n  coder;\n  length;\n  #hasNestedOption;\n  constructor(coder, length) {\n    super(\"array\", `[${coder.type}; ${length}]`, length * coder.encodedLength);\n    this.coder = coder;\n    this.length = length;\n    this.#hasNestedOption = hasNestedOption([coder]);\n  }\n  encode(value) {\n    if (!Array.isArray(value)) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n    if (this.length !== value.length) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n    return (0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.concat)(Array.from(value).map((v) => this.coder.encode(v)));\n  }\n  decode(data, offset) {\n    if (!this.#hasNestedOption && data.length < this.encodedLength || data.length > MAX_BYTES) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid array data size.`);\n    }\n    let newOffset = offset;\n    const decodedValue = Array(this.length).fill(0).map(() => {\n      let decoded;\n      [decoded, newOffset] = this.coder.decode(data, newOffset);\n      return decoded;\n    });\n    return [decodedValue, newOffset];\n  }\n};\n\n// src/encoding/coders/B256Coder.ts\n\n\n\nvar B256Coder = class extends Coder {\n  static {\n    __name(this, \"B256Coder\");\n  }\n  constructor() {\n    super(\"b256\", \"b256\", WORD_SIZE * 4);\n  }\n  encode(value) {\n    let encodedValue;\n    try {\n      encodedValue = (0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);\n    } catch (error) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    if (encodedValue.length !== this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return encodedValue;\n  }\n  decode(data, offset) {\n    if (data.length < this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid b256 data size.`);\n    }\n    let bytes = data.slice(offset, offset + this.encodedLength);\n    const decoded = (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.bn)(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(32);\n    }\n    if (bytes.length !== this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid b256 byte data size.`);\n    }\n    return [(0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.toHex)(bytes, 32), offset + 32];\n  }\n};\n\n// src/encoding/coders/B512Coder.ts\n\n\n\nvar B512Coder = class extends Coder {\n  static {\n    __name(this, \"B512Coder\");\n  }\n  constructor() {\n    super(\"b512\", \"struct B512\", WORD_SIZE * 8);\n  }\n  encode(value) {\n    let encodedValue;\n    try {\n      encodedValue = (0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);\n    } catch (error) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    if (encodedValue.length !== this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return encodedValue;\n  }\n  decode(data, offset) {\n    if (data.length < this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid b512 data size.`);\n    }\n    let bytes = data.slice(offset, offset + this.encodedLength);\n    const decoded = (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.bn)(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(64);\n    }\n    if (bytes.length !== this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid b512 byte data size.`);\n    }\n    return [(0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.toHex)(bytes, this.encodedLength), offset + this.encodedLength];\n  }\n};\n\n// src/encoding/coders/BigNumberCoder.ts\n\n\nvar encodedLengths = {\n  u64: WORD_SIZE,\n  u256: WORD_SIZE * 4\n};\nvar BigNumberCoder = class extends Coder {\n  static {\n    __name(this, \"BigNumberCoder\");\n  }\n  constructor(baseType) {\n    super(\"bigNumber\", baseType, encodedLengths[baseType]);\n  }\n  encode(value) {\n    let bytes;\n    if (typeof value === \"number\" && value > Number.MAX_SAFE_INTEGER) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n        _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR,\n        `Invalid ${this.type} type - number value is too large. Number can only safely handle up to 53 bits.`\n      );\n    }\n    try {\n      bytes = (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.toBytes)(value, this.encodedLength);\n    } catch (error) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return bytes;\n  }\n  decode(data, offset) {\n    if (data.length < this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid ${this.type} data size.`);\n    }\n    let bytes = data.slice(offset, offset + this.encodedLength);\n    bytes = bytes.slice(0, this.encodedLength);\n    if (bytes.length !== this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid ${this.type} byte data size.`);\n    }\n    return [(0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.bn)(bytes), offset + this.encodedLength];\n  }\n};\n\n// src/encoding/coders/BooleanCoder.ts\n\n\nvar BooleanCoder = class extends Coder {\n  static {\n    __name(this, \"BooleanCoder\");\n  }\n  options;\n  constructor(options = {\n    padToWordSize: false\n  }) {\n    const encodedLength = options.padToWordSize ? WORD_SIZE : 1;\n    super(\"boolean\", \"boolean\", encodedLength);\n    this.options = options;\n  }\n  encode(value) {\n    const isTrueBool = value === true || value === false;\n    if (!isTrueBool) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);\n    }\n    return (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.toBytes)(value ? 1 : 0, this.encodedLength);\n  }\n  decode(data, offset) {\n    if (data.length < this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid boolean data size.`);\n    }\n    const bytes = (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.bn)(data.slice(offset, offset + this.encodedLength));\n    if (bytes.isZero()) {\n      return [false, offset + this.encodedLength];\n    }\n    if (!bytes.eq((0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.bn)(1))) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid boolean value.`);\n    }\n    return [true, offset + this.encodedLength];\n  }\n};\n\n// src/encoding/coders/ByteCoder.ts\n\n\nvar ByteCoder = class extends Coder {\n  static {\n    __name(this, \"ByteCoder\");\n  }\n  static memorySize = 1;\n  constructor() {\n    super(\"struct\", \"struct Bytes\", WORD_SIZE);\n  }\n  encode(value) {\n    const bytes = value instanceof Uint8Array ? value : new Uint8Array(value);\n    const lengthBytes = new BigNumberCoder(\"u64\").encode(bytes.length);\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n  decode(data, offset) {\n    if (data.length < WORD_SIZE) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid byte data size.`);\n    }\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.bn)(new BigNumberCoder(\"u64\").decode(lengthBytes, 0)[0]).toNumber();\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n    if (dataBytes.length !== length) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid bytes byte data size.`);\n    }\n    return [dataBytes, offsetAndLength + length];\n  }\n};\n\n// src/encoding/coders/EnumCoder.ts\n\n\n\nvar EnumCoder = class extends Coder {\n  static {\n    __name(this, \"EnumCoder\");\n  }\n  name;\n  coders;\n  #caseIndexCoder;\n  #encodedValueSize;\n  #shouldValidateLength;\n  constructor(name, coders) {\n    const caseIndexCoder = new BigNumberCoder(\"u64\");\n    const encodedValueSize = Object.values(coders).reduce(\n      (min, coder) => Math.min(min, coder.encodedLength),\n      0\n    );\n    super(`enum ${name}`, `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);\n    this.name = name;\n    this.coders = coders;\n    this.#caseIndexCoder = caseIndexCoder;\n    this.#encodedValueSize = encodedValueSize;\n    this.#shouldValidateLength = !(optionRegEx.test(this.type) || hasNestedOption(coders));\n  }\n  // Checks that we're handling a native enum that is of type void.\n  #isNativeEnum(coder) {\n    return this.type !== OPTION_CODER_TYPE && coder.type === VOID_TYPE;\n  }\n  #encodeNativeEnum(value) {\n    const valueCoder = this.coders[value];\n    const encodedValue = valueCoder.encode([]);\n    const caseIndex = Object.keys(this.coders).indexOf(value);\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return (0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.concat)([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n  encode(value) {\n    if (typeof value === \"string\" && this.coders[value]) {\n      return this.#encodeNativeEnum(value);\n    }\n    const [caseKey, ...empty] = Object.keys(value);\n    if (!caseKey) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.INVALID_DECODE_VALUE, \"A field for the case must be provided.\");\n    }\n    if (empty.length !== 0) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.INVALID_DECODE_VALUE, \"Only one field must be provided.\");\n    }\n    const valueCoder = this.coders[caseKey];\n    const caseIndex = Object.keys(this.coders).indexOf(caseKey);\n    if (caseIndex === -1) {\n      const validCases = Object.keys(this.coders).map((v) => `'${v}'`).join(\", \");\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n        _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.INVALID_DECODE_VALUE,\n        `Invalid case '${caseKey}'. Valid cases: ${validCases}.`\n      );\n    }\n    const encodedValue = valueCoder.encode(value[caseKey]);\n    return new Uint8Array([...this.#caseIndexCoder.encode(caseIndex), ...encodedValue]);\n  }\n  #decodeNativeEnum(caseKey, newOffset) {\n    return [caseKey, newOffset];\n  }\n  decode(data, offset) {\n    if (this.#shouldValidateLength && data.length < this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid enum data size.`);\n    }\n    const caseBytes = new BigNumberCoder(\"u64\").decode(data, offset)[0];\n    const caseIndex = (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.toNumber)(caseBytes);\n    const caseKey = Object.keys(this.coders)[caseIndex];\n    if (!caseKey) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n        _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.INVALID_DECODE_VALUE,\n        `Invalid caseIndex \"${caseIndex}\". Valid cases: ${Object.keys(this.coders)}.`\n      );\n    }\n    const valueCoder = this.coders[caseKey];\n    const offsetAndCase = offset + this.#caseIndexCoder.encodedLength;\n    if (this.#shouldValidateLength && data.length < offsetAndCase + valueCoder.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid enum data size.`);\n    }\n    const [decoded, newOffset] = valueCoder.decode(data, offsetAndCase);\n    if (this.#isNativeEnum(this.coders[caseKey])) {\n      return this.#decodeNativeEnum(caseKey, newOffset);\n    }\n    return [{ [caseKey]: decoded }, newOffset];\n  }\n};\n\n// src/encoding/coders/NumberCoder.ts\n\n\nvar getLength = /* @__PURE__ */ __name((baseType) => {\n  switch (baseType) {\n    case \"u8\":\n      return 1;\n    case \"u16\":\n      return 2;\n    case \"u32\":\n      return 4;\n    default:\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.TYPE_NOT_SUPPORTED, `Invalid number type: ${baseType}`);\n  }\n}, \"getLength\");\nvar NumberCoder = class extends Coder {\n  static {\n    __name(this, \"NumberCoder\");\n  }\n  baseType;\n  options;\n  constructor(baseType, options = {\n    padToWordSize: false\n  }) {\n    const length = options.padToWordSize ? WORD_SIZE : getLength(baseType);\n    super(\"number\", baseType, length);\n    this.baseType = baseType;\n    this.options = options;\n  }\n  encode(value) {\n    let bytes;\n    try {\n      bytes = (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.toBytes)(value);\n    } catch (error) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);\n    }\n    if (bytes.length > this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);\n    }\n    return (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.toBytes)(bytes, this.encodedLength);\n  }\n  decode(data, offset) {\n    if (data.length < this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid number data size.`);\n    }\n    const bytes = data.slice(offset, offset + this.encodedLength);\n    if (bytes.length !== this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid number byte data size.`);\n    }\n    return [(0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.toNumber)(bytes), offset + this.encodedLength];\n  }\n};\n\n// src/encoding/coders/OptionCoder.ts\nvar OptionCoder = class extends EnumCoder {\n  static {\n    __name(this, \"OptionCoder\");\n  }\n  encode(value) {\n    const result = super.encode(this.toSwayOption(value));\n    return result;\n  }\n  toSwayOption(input) {\n    if (input !== void 0) {\n      return { Some: input };\n    }\n    return { None: [] };\n  }\n  decode(data, offset) {\n    const [decoded, newOffset] = super.decode(data, offset);\n    return [this.toOption(decoded), newOffset];\n  }\n  toOption(output) {\n    if (output && \"Some\" in output) {\n      return output.Some;\n    }\n    return void 0;\n  }\n};\n\n// src/encoding/coders/RawSliceCoder.ts\n\n\nvar RawSliceCoder = class extends Coder {\n  static {\n    __name(this, \"RawSliceCoder\");\n  }\n  constructor() {\n    super(\"raw untyped slice\", \"raw untyped slice\", WORD_SIZE);\n  }\n  encode(value) {\n    if (!Array.isArray(value)) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n    const internalCoder = new ArrayCoder(new NumberCoder(\"u8\"), value.length);\n    const bytes = internalCoder.encode(value);\n    const lengthBytes = new BigNumberCoder(\"u64\").encode(bytes.length);\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n  decode(data, offset) {\n    if (data.length < this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid raw slice data size.`);\n    }\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.bn)(new BigNumberCoder(\"u64\").decode(lengthBytes, 0)[0]).toNumber();\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n    if (dataBytes.length !== length) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid raw slice byte data size.`);\n    }\n    const internalCoder = new ArrayCoder(new NumberCoder(\"u8\"), length);\n    const [decodedValue] = internalCoder.decode(dataBytes, 0);\n    return [decodedValue, offsetAndLength + length];\n  }\n};\n\n// src/encoding/coders/StdStringCoder.ts\n\n\n\nvar StdStringCoder = class extends Coder {\n  static {\n    __name(this, \"StdStringCoder\");\n  }\n  static memorySize = 1;\n  constructor() {\n    super(\"struct\", \"struct String\", WORD_SIZE);\n  }\n  encode(value) {\n    const bytes = (0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value);\n    const lengthBytes = new BigNumberCoder(\"u64\").encode(value.length);\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n  decode(data, offset) {\n    if (data.length < this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid std string data size.`);\n    }\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.bn)(new BigNumberCoder(\"u64\").decode(lengthBytes, 0)[0]).toNumber();\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n    if (dataBytes.length !== length) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid std string byte data size.`);\n    }\n    return [(0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(dataBytes), offsetAndLength + length];\n  }\n};\n\n// src/encoding/coders/StrSliceCoder.ts\n\n\n\nvar StrSliceCoder = class extends Coder {\n  static {\n    __name(this, \"StrSliceCoder\");\n  }\n  static memorySize = 1;\n  constructor() {\n    super(\"strSlice\", \"str\", WORD_SIZE);\n  }\n  encode(value) {\n    const bytes = (0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value);\n    const lengthBytes = new BigNumberCoder(\"u64\").encode(value.length);\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n  decode(data, offset) {\n    if (data.length < this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid string slice data size.`);\n    }\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.bn)(new BigNumberCoder(\"u64\").decode(lengthBytes, 0)[0]).toNumber();\n    const bytes = data.slice(offsetAndLength, offsetAndLength + length);\n    if (bytes.length !== length) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid string slice byte data size.`);\n    }\n    return [(0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(bytes), offsetAndLength + length];\n  }\n};\n\n// src/encoding/coders/StringCoder.ts\n\n\nvar StringCoder = class extends Coder {\n  static {\n    __name(this, \"StringCoder\");\n  }\n  constructor(length) {\n    super(\"string\", `str[${length}]`, length);\n  }\n  encode(value) {\n    if (value.length !== this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);\n    }\n    return (0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value);\n  }\n  decode(data, offset) {\n    if (data.length < this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid string data size.`);\n    }\n    const bytes = data.slice(offset, offset + this.encodedLength);\n    if (bytes.length !== this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid string byte data size.`);\n    }\n    return [(0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(bytes), offset + this.encodedLength];\n  }\n};\n\n// src/encoding/coders/StructCoder.ts\n\n\nvar StructCoder = class extends Coder {\n  static {\n    __name(this, \"StructCoder\");\n  }\n  name;\n  coders;\n  #hasNestedOption;\n  constructor(name, coders) {\n    const encodedLength = Object.values(coders).reduce(\n      (acc, coder) => acc + coder.encodedLength,\n      0\n    );\n    super(\"struct\", `struct ${name}`, encodedLength);\n    this.name = name;\n    this.coders = coders;\n    this.#hasNestedOption = hasNestedOption(coders);\n  }\n  encode(value) {\n    return (0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(\n      Object.keys(this.coders).map((fieldName) => {\n        const fieldCoder = this.coders[fieldName];\n        const fieldValue = value[fieldName];\n        if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {\n          throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n            _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR,\n            `Invalid ${this.type}. Field \"${fieldName}\" not present.`\n          );\n        }\n        return fieldCoder.encode(fieldValue);\n      })\n    );\n  }\n  decode(data, offset) {\n    if (!this.#hasNestedOption && data.length < this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid struct data size.`);\n    }\n    let newOffset = offset;\n    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      let decoded;\n      [decoded, newOffset] = fieldCoder.decode(data, newOffset);\n      obj[fieldName] = decoded;\n      return obj;\n    }, {});\n    return [decodedValue, newOffset];\n  }\n};\n\n// src/encoding/coders/TupleCoder.ts\n\n\nvar TupleCoder = class extends Coder {\n  static {\n    __name(this, \"TupleCoder\");\n  }\n  coders;\n  #hasNestedOption;\n  constructor(coders) {\n    const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);\n    super(\"tuple\", `(${coders.map((coder) => coder.type).join(\", \")})`, encodedLength);\n    this.coders = coders;\n    this.#hasNestedOption = hasNestedOption(coders);\n  }\n  encode(value) {\n    if (this.coders.length !== value.length) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n    return (0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(this.coders.map((coder, i) => coder.encode(value[i])));\n  }\n  decode(data, offset) {\n    if (!this.#hasNestedOption && data.length < this.encodedLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid tuple data size.`);\n    }\n    let newOffset = offset;\n    const decodedValue = this.coders.map((coder) => {\n      let decoded;\n      [decoded, newOffset] = coder.decode(data, newOffset);\n      return decoded;\n    });\n    return [decodedValue, newOffset];\n  }\n};\n\n// src/encoding/coders/VecCoder.ts\n\n\n\nvar VecCoder = class extends Coder {\n  static {\n    __name(this, \"VecCoder\");\n  }\n  coder;\n  #hasNestedOption;\n  constructor(coder) {\n    super(\"struct\", `struct Vec`, WORD_SIZE);\n    this.coder = coder;\n    this.#hasNestedOption = hasNestedOption([coder]);\n  }\n  encode(value) {\n    if (!Array.isArray(value) && !isUint8Array(value)) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n        _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ENCODE_ERROR,\n        `Expected array value, or a Uint8Array. You can use arrayify to convert a value to a Uint8Array.`\n      );\n    }\n    const lengthCoder = new BigNumberCoder(\"u64\");\n    if (isUint8Array(value)) {\n      return new Uint8Array([...lengthCoder.encode(value.length), ...value]);\n    }\n    const bytes = value.map((v) => this.coder.encode(v));\n    const lengthBytes = lengthCoder.encode(value.length);\n    return new Uint8Array([...lengthBytes, ...(0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(bytes)]);\n  }\n  decode(data, offset) {\n    if (!this.#hasNestedOption && data.length < this.encodedLength || data.length > MAX_BYTES) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid vec data size.`);\n    }\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.bn)(new BigNumberCoder(\"u64\").decode(lengthBytes, 0)[0]).toNumber();\n    const dataLength = length * this.coder.encodedLength;\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + dataLength);\n    if (!this.#hasNestedOption && dataBytes.length !== dataLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(_fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR, `Invalid vec byte data size.`);\n    }\n    let newOffset = offsetAndLength;\n    const chunks = [];\n    for (let i = 0; i < length; i++) {\n      const [decoded, optionOffset] = this.coder.decode(data, newOffset);\n      chunks.push(decoded);\n      newOffset = optionOffset;\n    }\n    return [chunks, newOffset];\n  }\n};\n\n// src/Interface.ts\n\n\n\n// src/ResolvedAbiType.ts\n\n\n// src/utils/json-abi.ts\n\nvar getEncodingVersion = /* @__PURE__ */ __name((encoding) => {\n  switch (encoding) {\n    case void 0:\n    case ENCODING_V1:\n      return ENCODING_V1;\n    default:\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n        _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.UNSUPPORTED_ENCODING_VERSION,\n        `Encoding version '${encoding}' is unsupported.`\n      );\n  }\n}, \"getEncodingVersion\");\nvar findTypeById = /* @__PURE__ */ __name((abi, typeId) => {\n  const type = abi.types.find((t) => t.typeId === typeId);\n  if (!type) {\n    throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n      _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.TYPE_NOT_FOUND,\n      `Type with typeId '${typeId}' doesn't exist in the ABI.`\n    );\n  }\n  return type;\n}, \"findTypeById\");\nvar findNonVoidInputs = /* @__PURE__ */ __name((abi, inputs) => inputs.filter((input) => findTypeById(abi, input.type).type !== VOID_TYPE), \"findNonVoidInputs\");\nvar findVectorBufferArgument = /* @__PURE__ */ __name((components) => {\n  const bufferComponent = components.find((c) => c.name === \"buf\");\n  const bufferTypeArgument = bufferComponent?.originalTypeArguments?.[0];\n  if (!bufferComponent || !bufferTypeArgument) {\n    throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n      _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.INVALID_COMPONENT,\n      `The Vec type provided is missing or has a malformed 'buf' component.`\n    );\n  }\n  return bufferTypeArgument;\n}, \"findVectorBufferArgument\");\n\n// src/ResolvedAbiType.ts\nvar ResolvedAbiType = class _ResolvedAbiType {\n  static {\n    __name(this, \"ResolvedAbiType\");\n  }\n  abi;\n  name;\n  type;\n  originalTypeArguments;\n  components;\n  constructor(abi, argument) {\n    this.abi = abi;\n    this.name = argument.name;\n    const jsonABIType = findTypeById(abi, argument.type);\n    if (jsonABIType.type.length > 256) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n        _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.INVALID_COMPONENT,\n        `The provided ABI type is too long: ${jsonABIType.type}.`\n      );\n    }\n    this.type = jsonABIType.type;\n    this.originalTypeArguments = argument.typeArguments;\n    this.components = _ResolvedAbiType.getResolvedGenericComponents(\n      abi,\n      argument,\n      jsonABIType.components,\n      jsonABIType.typeParameters ?? _ResolvedAbiType.getImplicitGenericTypeParameters(abi, jsonABIType.components)\n    );\n  }\n  static getResolvedGenericComponents(abi, arg, components, typeParameters) {\n    if (components === null) {\n      return null;\n    }\n    if (typeParameters === null || typeParameters.length === 0) {\n      return components.map((c) => new _ResolvedAbiType(abi, c));\n    }\n    const typeParametersAndArgsMap = typeParameters.reduce(\n      (obj, typeParameter, typeParameterIndex) => {\n        const o = { ...obj };\n        o[typeParameter] = structuredClone(\n          arg.typeArguments?.[typeParameterIndex]\n        );\n        return o;\n      },\n      {}\n    );\n    const resolvedComponents = this.resolveGenericArgTypes(\n      abi,\n      components,\n      typeParametersAndArgsMap\n    );\n    return resolvedComponents.map((c) => new _ResolvedAbiType(abi, c));\n  }\n  static resolveGenericArgTypes(abi, args, typeParametersAndArgsMap) {\n    return args.map((arg) => {\n      if (typeParametersAndArgsMap[arg.type] !== void 0) {\n        return {\n          ...typeParametersAndArgsMap[arg.type],\n          name: arg.name\n        };\n      }\n      if (arg.typeArguments) {\n        return {\n          ...structuredClone(arg),\n          typeArguments: this.resolveGenericArgTypes(\n            abi,\n            arg.typeArguments,\n            typeParametersAndArgsMap\n          )\n        };\n      }\n      const argType = findTypeById(abi, arg.type);\n      const implicitTypeParameters = this.getImplicitGenericTypeParameters(abi, argType.components);\n      if (implicitTypeParameters && implicitTypeParameters.length > 0) {\n        return {\n          ...structuredClone(arg),\n          typeArguments: implicitTypeParameters.map((itp) => typeParametersAndArgsMap[itp])\n        };\n      }\n      return arg;\n    });\n  }\n  static getImplicitGenericTypeParameters(abi, args, implicitGenericParametersParam) {\n    if (!Array.isArray(args)) {\n      return null;\n    }\n    const implicitGenericParameters = implicitGenericParametersParam ?? [];\n    args.forEach((a) => {\n      const argType = findTypeById(abi, a.type);\n      if (genericRegEx.test(argType.type)) {\n        implicitGenericParameters.push(argType.typeId);\n        return;\n      }\n      if (!Array.isArray(a.typeArguments)) {\n        return;\n      }\n      this.getImplicitGenericTypeParameters(abi, a.typeArguments, implicitGenericParameters);\n    });\n    return implicitGenericParameters.length > 0 ? implicitGenericParameters : null;\n  }\n  getSignature() {\n    const prefix = this.getArgSignaturePrefix();\n    const content = this.getArgSignatureContent();\n    return `${prefix}${content}`;\n  }\n  getArgSignaturePrefix() {\n    const structMatch = structRegEx.test(this.type);\n    if (structMatch) {\n      return \"s\";\n    }\n    const arrayMatch = arrayRegEx.test(this.type);\n    if (arrayMatch) {\n      return \"a\";\n    }\n    const enumMatch = enumRegEx.test(this.type);\n    if (enumMatch) {\n      return \"e\";\n    }\n    return \"\";\n  }\n  getArgSignatureContent() {\n    if (this.type === \"raw untyped ptr\") {\n      return \"rawptr\";\n    }\n    if (this.type === \"raw untyped slice\") {\n      return \"rawslice\";\n    }\n    const strMatch = stringRegEx.exec(this.type)?.groups;\n    if (strMatch) {\n      return `str[${strMatch.length}]`;\n    }\n    if (this.components === null) {\n      return this.type;\n    }\n    const arrayMatch = arrayRegEx.exec(this.type)?.groups;\n    if (arrayMatch) {\n      return `[${this.components[0].getSignature()};${arrayMatch.length}]`;\n    }\n    const typeArgumentsSignature = this.originalTypeArguments !== null ? `<${this.originalTypeArguments.map((a) => new _ResolvedAbiType(this.abi, a).getSignature()).join(\",\")}>` : \"\";\n    const componentsSignature = `(${this.components.map((c) => c.getSignature()).join(\",\")})`;\n    return `${typeArgumentsSignature}${componentsSignature}`;\n  }\n};\n\n// src/encoding/strategies/getCoderForEncoding.ts\n\n\n// src/encoding/strategies/getCoderV1.ts\n\n\n// src/encoding/coders/VoidCoder.ts\nvar VoidCoder = class extends Coder {\n  static {\n    __name(this, \"VoidCoder\");\n  }\n  constructor() {\n    super(\"void\", VOID_TYPE, 0);\n  }\n  encode(_value) {\n    return new Uint8Array([]);\n  }\n  decode(_data, offset) {\n    return [void 0, offset];\n  }\n};\n\n// src/encoding/strategies/getCoders.ts\nfunction getCoders(components, options) {\n  const { getCoder: getCoder2 } = options;\n  return components.reduce((obj, component) => {\n    const o = obj;\n    o[component.name] = getCoder2(component, options);\n    return o;\n  }, {});\n}\n__name(getCoders, \"getCoders\");\n\n// src/encoding/strategies/getCoderV1.ts\nvar getCoder = /* @__PURE__ */ __name((resolvedAbiType, _options) => {\n  switch (resolvedAbiType.type) {\n    case U8_CODER_TYPE:\n    case U16_CODER_TYPE:\n    case U32_CODER_TYPE:\n      return new NumberCoder(resolvedAbiType.type);\n    case U64_CODER_TYPE:\n    case RAW_PTR_CODER_TYPE:\n      return new BigNumberCoder(\"u64\");\n    case U256_CODER_TYPE:\n      return new BigNumberCoder(\"u256\");\n    case RAW_SLICE_CODER_TYPE:\n      return new RawSliceCoder();\n    case BOOL_CODER_TYPE:\n      return new BooleanCoder();\n    case B256_CODER_TYPE:\n      return new B256Coder();\n    case B512_CODER_TYPE:\n      return new B512Coder();\n    case BYTES_CODER_TYPE:\n      return new ByteCoder();\n    case STD_STRING_CODER_TYPE:\n      return new StdStringCoder();\n    case STR_SLICE_CODER_TYPE:\n      return new StrSliceCoder();\n    case VOID_TYPE:\n      return new VoidCoder();\n    default:\n      break;\n  }\n  const stringMatch = stringRegEx.exec(resolvedAbiType.type)?.groups;\n  if (stringMatch) {\n    const length = parseInt(stringMatch.length, 10);\n    return new StringCoder(length);\n  }\n  const components = resolvedAbiType.components;\n  const arrayMatch = arrayRegEx.exec(resolvedAbiType.type)?.groups;\n  if (arrayMatch) {\n    const length = parseInt(arrayMatch.length, 10);\n    const arg = components[0];\n    if (!arg) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n        _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.INVALID_COMPONENT,\n        `The provided Array type is missing an item of 'component'.`\n      );\n    }\n    const arrayElementCoder = getCoder(arg);\n    return new ArrayCoder(arrayElementCoder, length);\n  }\n  if (resolvedAbiType.type === VEC_CODER_TYPE) {\n    const arg = findVectorBufferArgument(components);\n    const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);\n    const itemCoder = getCoder(argType, { encoding: ENCODING_V1 });\n    return new VecCoder(itemCoder);\n  }\n  const coderName = resolvedAbiType.type.match(fullNameRegExMatch)?.[0];\n  const structMatch = structRegEx.test(resolvedAbiType.type);\n  if (structMatch && coderName) {\n    const coders = getCoders(components, { getCoder });\n    return new StructCoder(coderName, coders);\n  }\n  const enumMatch = enumRegEx.test(resolvedAbiType.type);\n  if (enumMatch && coderName) {\n    const coders = getCoders(components, { getCoder });\n    const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;\n    if (isOptionEnum) {\n      return new OptionCoder(coderName, coders);\n    }\n    return new EnumCoder(coderName, coders);\n  }\n  const tupleMatch = tupleRegEx.exec(resolvedAbiType.type)?.groups;\n  if (tupleMatch) {\n    const coders = components.map((component) => getCoder(component, { encoding: ENCODING_V1 }));\n    return new TupleCoder(coders);\n  }\n  throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n    _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.CODER_NOT_FOUND,\n    `Coder not found: ${JSON.stringify(resolvedAbiType)}.`\n  );\n}, \"getCoder\");\n\n// src/encoding/strategies/getCoderForEncoding.ts\nfunction getCoderForEncoding(encoding = ENCODING_V1) {\n  switch (encoding) {\n    case ENCODING_V1:\n      return getCoder;\n    default:\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n        _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.UNSUPPORTED_ENCODING_VERSION,\n        `Encoding version ${encoding} is unsupported.`\n      );\n  }\n}\n__name(getCoderForEncoding, \"getCoderForEncoding\");\n\n// src/AbiCoder.ts\nvar AbiCoder = class {\n  static {\n    __name(this, \"AbiCoder\");\n  }\n  static getCoder(abi, argument, options = {\n    padToWordSize: false\n  }) {\n    const resolvedAbiType = new ResolvedAbiType(abi, argument);\n    return getCoderForEncoding(options.encoding)(resolvedAbiType, options);\n  }\n  static encode(abi, argument, value, options) {\n    return this.getCoder(abi, argument, options).encode(value);\n  }\n  static decode(abi, argument, data, offset, options) {\n    return this.getCoder(abi, argument, options).decode(data, offset);\n  }\n};\n\n// src/FunctionFragment.ts\n\n\n\n\n\n\n// src/utils/getFunctionInputs.ts\nvar getFunctionInputs = /* @__PURE__ */ __name((params) => {\n  const { jsonAbi, inputs } = params;\n  let isMandatory = false;\n  return inputs.reduceRight((result, input) => {\n    const type = findTypeById(jsonAbi, input.type);\n    isMandatory = isMandatory || type.type !== VOID_TYPE && !optionRegEx.test(type.type);\n    return [{ ...input, isOptional: !isMandatory }, ...result];\n  }, []);\n}, \"getFunctionInputs\");\n\n// src/utils/padValuesWithUndefined.ts\nvar padValuesWithUndefined = /* @__PURE__ */ __name((values, inputs) => {\n  if (values.length >= inputs.length) {\n    return values;\n  }\n  const paddedValues = values.slice();\n  paddedValues.length = inputs.length;\n  paddedValues.fill(void 0, values.length);\n  return paddedValues;\n}, \"padValuesWithUndefined\");\n\n// src/FunctionFragment.ts\nvar FunctionFragment = class _FunctionFragment {\n  static {\n    __name(this, \"FunctionFragment\");\n  }\n  signature;\n  selector;\n  selectorBytes;\n  encoding;\n  name;\n  jsonFn;\n  attributes;\n  jsonAbiOld;\n  jsonFnOld;\n  constructor(jsonAbi, fn) {\n    this.jsonFn = fn;\n    this.jsonAbiOld = jsonAbi;\n    this.jsonFnOld = jsonAbi.functions.find((f) => f.name === fn.name);\n    this.name = fn.name;\n    this.signature = _FunctionFragment.getSignature(this.jsonAbiOld, this.jsonFnOld);\n    this.selector = _FunctionFragment.getFunctionSelector(this.signature);\n    this.selectorBytes = new StdStringCoder().encode(this.name);\n    this.encoding = getEncodingVersion(jsonAbi.encoding);\n    this.attributes = this.jsonFn.attributes ?? [];\n  }\n  static getSignature(abi, fn) {\n    const inputsSignatures = fn.inputs.map(\n      (input) => new ResolvedAbiType(abi, input).getSignature()\n    );\n    return `${fn.name}(${inputsSignatures.join(\",\")})`;\n  }\n  static getFunctionSelector(functionSignature) {\n    const hashedFunctionSignature = (0,_fuel_ts_hasher__WEBPACK_IMPORTED_MODULE_4__.sha256)((0,_fuel_ts_crypto__WEBPACK_IMPORTED_MODULE_3__.bufferFromString)(functionSignature, \"utf-8\"));\n    return (0,_fuel_ts_math__WEBPACK_IMPORTED_MODULE_2__.bn)(hashedFunctionSignature.slice(0, 10)).toHex(8);\n  }\n  encodeArguments(values) {\n    const inputs = getFunctionInputs({ jsonAbi: this.jsonAbiOld, inputs: this.jsonFnOld.inputs });\n    const mandatoryInputLength = inputs.filter((i) => !i.isOptional).length;\n    if (values.length < mandatoryInputLength) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n        _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.ABI_TYPES_AND_VALUES_MISMATCH,\n        `Invalid number of arguments. Expected a minimum of ${mandatoryInputLength} arguments, received ${values.length}`\n      );\n    }\n    const coders = this.jsonFnOld.inputs.map(\n      (t) => AbiCoder.getCoder(this.jsonAbiOld, t, {\n        encoding: this.encoding\n      })\n    );\n    const argumentValues = padValuesWithUndefined(values, this.jsonFn.inputs);\n    return new TupleCoder(coders).encode(argumentValues);\n  }\n  decodeArguments(data) {\n    const bytes = (0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.arrayify)(data);\n    const nonVoidInputs = findNonVoidInputs(this.jsonAbiOld, this.jsonFnOld.inputs);\n    if (nonVoidInputs.length === 0) {\n      if (bytes.length === 0) {\n        return void 0;\n      }\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n        _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.DECODE_ERROR,\n        `Types/values length mismatch during decode. ${JSON.stringify({\n          count: {\n            types: this.jsonFn.inputs.length,\n            nonVoidInputs: nonVoidInputs.length,\n            values: bytes.length\n          },\n          value: {\n            args: this.jsonFn.inputs,\n            nonVoidInputs,\n            values: bytes\n          }\n        })}`\n      );\n    }\n    const result = this.jsonFnOld.inputs.reduce(\n      (obj, input) => {\n        const coder = AbiCoder.getCoder(this.jsonAbiOld, input, { encoding: this.encoding });\n        const [decodedValue, decodedOffset] = coder.decode(bytes, obj.offset);\n        return {\n          decoded: [...obj.decoded, decodedValue],\n          offset: decodedOffset\n        };\n      },\n      { decoded: [], offset: 0 }\n    );\n    return result.decoded;\n  }\n  decodeOutput(data) {\n    const bytes = (0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.arrayify)(data);\n    const coder = AbiCoder.getCoder(this.jsonAbiOld, this.jsonFnOld.output, {\n      encoding: this.encoding\n    });\n    return coder.decode(bytes, 0);\n  }\n  /**\n   * Checks if the function is read-only i.e. it only reads from storage, does not write to it.\n   *\n   * @returns True if the function is read-only or pure, false otherwise.\n   */\n  isReadOnly() {\n    const storageAttribute = this.attributes.find((attr) => attr.name === \"storage\");\n    return !storageAttribute?.arguments?.includes(\"write\");\n  }\n};\n\n// src/utils/transpile-abi.ts\nvar findTypeByConcreteId = /* @__PURE__ */ __name((types, id) => types.find((x) => x.concreteTypeId === id), \"findTypeByConcreteId\");\nvar findConcreteTypeById = /* @__PURE__ */ __name((abi, id) => abi.concreteTypes.find((x) => x.concreteTypeId === id), \"findConcreteTypeById\");\nfunction finsertTypeIdByConcreteTypeId(abi, types, id) {\n  const concreteType = findConcreteTypeById(abi, id);\n  if (concreteType.metadataTypeId !== void 0) {\n    return concreteType.metadataTypeId;\n  }\n  const type = findTypeByConcreteId(types, id);\n  if (type) {\n    return type.typeId;\n  }\n  types.push({\n    typeId: types.length,\n    type: concreteType.type,\n    components: parseComponents(concreteType.components),\n    concreteTypeId: id,\n    typeParameters: concreteType.typeParameters ?? null,\n    originalConcreteTypeId: concreteType?.concreteTypeId\n  });\n  return types.length - 1;\n}\n__name(finsertTypeIdByConcreteTypeId, \"finsertTypeIdByConcreteTypeId\");\nfunction parseFunctionTypeArguments(abi, types, concreteType) {\n  return concreteType.typeArguments?.map((cTypeId) => {\n    const self = findConcreteTypeById(abi, cTypeId);\n    const type = !isNaN(cTypeId) ? cTypeId : finsertTypeIdByConcreteTypeId(abi, types, cTypeId);\n    return {\n      name: \"\",\n      type,\n      // originalTypeId: cTypeId,\n      typeArguments: parseFunctionTypeArguments(abi, types, self)\n    };\n  }) ?? null;\n}\n__name(parseFunctionTypeArguments, \"parseFunctionTypeArguments\");\nfunction parseConcreteType(abi, types, concreteTypeId, name) {\n  const type = finsertTypeIdByConcreteTypeId(abi, types, concreteTypeId);\n  const concrete = findConcreteTypeById(abi, concreteTypeId);\n  return {\n    name: name ?? \"\",\n    type,\n    // concreteTypeId,\n    typeArguments: parseFunctionTypeArguments(abi, types, concrete)\n  };\n}\n__name(parseConcreteType, \"parseConcreteType\");\nfunction parseComponents(abi, types, components) {\n  return components?.map((component) => {\n    const { typeId, name, typeArguments } = component;\n    const type = !isNaN(typeId) ? typeId : finsertTypeIdByConcreteTypeId(abi, types, typeId);\n    return {\n      name,\n      type,\n      // originalTypeId: typeId,\n      typeArguments: parseComponents(abi, types, typeArguments)\n    };\n  }) ?? null;\n}\n__name(parseComponents, \"parseComponents\");\nfunction transpileAbi(abi) {\n  if (!abi.specVersion) {\n    return abi;\n  }\n  const types = [];\n  abi.metadataTypes.forEach((m) => {\n    const t = {\n      typeId: m.metadataTypeId,\n      type: m.type,\n      components: m.components ?? (m.type === \"()\" ? [] : null),\n      typeParameters: m.typeParameters ?? null\n    };\n    types.push(t);\n  });\n  types.forEach((t) => {\n    t.components = parseComponents(abi, types, t.components);\n  });\n  const functions = abi.functions.map((fn) => {\n    const inputs = fn.inputs.map(\n      ({ concreteTypeId, name }) => parseConcreteType(abi, types, concreteTypeId, name)\n    );\n    const output = parseConcreteType(abi, types, fn.output, \"\");\n    return { ...fn, inputs, output };\n  });\n  const configurables = abi.configurables.map((conf) => ({\n    name: conf.name,\n    configurableType: parseConcreteType(abi, types, conf.concreteTypeId),\n    offset: conf.offset\n  }));\n  const loggedTypes = abi.loggedTypes.map((log) => ({\n    logId: log.logId,\n    loggedType: parseConcreteType(abi, types, log.concreteTypeId)\n  }));\n  const transpiled = {\n    encoding: abi.encodingVersion,\n    types,\n    functions,\n    loggedTypes,\n    messagesTypes: abi.messagesTypes,\n    configurables\n  };\n  return transpiled;\n}\n__name(transpileAbi, \"transpileAbi\");\n\n// src/Interface.ts\nvar Interface = class {\n  static {\n    __name(this, \"Interface\");\n  }\n  functions;\n  configurables;\n  jsonAbi;\n  encoding;\n  jsonAbiOld;\n  constructor(jsonAbi) {\n    this.jsonAbi = jsonAbi;\n    this.encoding = getEncodingVersion(jsonAbi.encodingVersion);\n    this.jsonAbiOld = transpileAbi(jsonAbi);\n    this.functions = Object.fromEntries(\n      this.jsonAbi.functions.map((fn) => [fn.name, new FunctionFragment(this.jsonAbiOld, fn)])\n    );\n    this.configurables = Object.fromEntries(this.jsonAbi.configurables.map((x) => [x.name, x]));\n  }\n  /**\n   * Returns function fragment for a dynamic input.\n   * @param nameOrSignatureOrSelector - name (e.g. 'transfer'), signature (e.g. 'transfer(address,uint256)') or selector (e.g. '0x00000000a9059cbb') of the function fragment\n   */\n  getFunction(nameOrSignatureOrSelector) {\n    const fn = Object.values(this.functions).find(\n      (f) => f.name === nameOrSignatureOrSelector || f.signature === nameOrSignatureOrSelector || f.selector === nameOrSignatureOrSelector\n    );\n    if (fn !== void 0) {\n      return fn;\n    }\n    throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n      _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.FUNCTION_NOT_FOUND,\n      `function ${nameOrSignatureOrSelector} not found: ${JSON.stringify(fn)}.`\n    );\n  }\n  // Decode the result of a function call\n  decodeFunctionResult(functionFragment, data) {\n    const fragment = typeof functionFragment === \"string\" ? this.getFunction(functionFragment) : functionFragment;\n    return fragment.decodeOutput(data);\n  }\n  decodeLog(data, logId) {\n    const loggedType = this.jsonAbiOld.loggedTypes.find((type) => type.logId === logId);\n    if (!loggedType) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n        _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.LOG_TYPE_NOT_FOUND,\n        `Log type with logId '${logId}' doesn't exist in the ABI.`\n      );\n    }\n    return AbiCoder.decode(this.jsonAbiOld, loggedType.loggedType, (0,_fuel_ts_utils__WEBPACK_IMPORTED_MODULE_1__.arrayify)(data), 0, {\n      encoding: this.encoding\n    });\n  }\n  encodeConfigurable(name, value) {\n    const configurable = this.jsonAbiOld.configurables.find((c) => c.name === name);\n    if (!configurable) {\n      throw new _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.FuelError(\n        _fuel_ts_errors__WEBPACK_IMPORTED_MODULE_0__.ErrorCode.CONFIGURABLE_NOT_FOUND,\n        `A configurable with the '${name}' was not found in the ABI.`\n      );\n    }\n    return AbiCoder.encode(this.jsonAbiOld, configurable.configurableType, value, {\n      encoding: this.encoding\n    });\n  }\n  encodeType(concreteTypeId, value) {\n    const typeArg = parseConcreteType(\n      this.jsonAbi,\n      this.jsonAbiOld.types,\n      concreteTypeId,\n      \"\"\n    );\n    return AbiCoder.encode(this.jsonAbiOld, typeArg, value, {\n      encoding: this.encoding\n    });\n  }\n  decodeType(concreteTypeId, data) {\n    const typeArg = parseConcreteType(\n      this.jsonAbi,\n      this.jsonAbiOld.types,\n      concreteTypeId,\n      \"\"\n    );\n    return AbiCoder.decode(this.jsonAbiOld, typeArg, data, 0, { encoding: this.encoding });\n  }\n};\n\n// src/utils/scriptData.ts\nvar decodeScriptData = /* @__PURE__ */ __name((scriptData, abi) => {\n  const [amount, amountOffset] = new BigNumberCoder(\"u64\").decode(scriptData, 0);\n  const [assetId, assetIdOffset] = new B256Coder().decode(scriptData, amountOffset);\n  const [contractId, contractIdOffset] = new B256Coder().decode(scriptData, assetIdOffset);\n  const [functionSelector, functionSelectorOffset] = new StdStringCoder().decode(\n    scriptData,\n    contractIdOffset + WORD_SIZE + WORD_SIZE\n  );\n  const functionArgsBytes = scriptData.slice(functionSelectorOffset);\n  const functionArgs = abi ? new Interface(abi).getFunction(functionSelector).decodeArguments(functionArgsBytes) : void 0;\n  return {\n    amount,\n    assetId,\n    contractId,\n    functionSelector,\n    functionArgs\n  };\n}, \"decodeScriptData\");\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGZ1ZWwtdHMrYWJpLWNvZGVyQDAuMTAxLjFfdml0ZXN0QDMuMi40X0B0eXBlcytkZWJ1Z0A0LjEuMTJfQHR5cGVzK25vZGVAMjQuNy4yX2ppdGlAMi42XzY0MDM5ODYyNTRlNjMzNTdhM2RmZmY0NzUyMDljOTNkL25vZGVfbW9kdWxlcy9AZnVlbC10cy9hYmktY29kZXIvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSw0REFBNEQsMkJBQTJCOztBQUV2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3VEO0FBQ2Y7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0RBQVc7QUFDekIsTUFBTSxzREFBVztBQUNqQixrQkFBa0IsMkJBQTJCLGFBQWEsbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFXO0FBQzNCLFFBQVEsc0RBQVc7QUFDbkIsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBLG1FQUFtRSx3REFBUztBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVztBQUMzQixRQUFRLHNEQUFXO0FBQ25CLG9DQUFvQyxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UseUJBQXlCO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQThCQztBQUNGIiwic291cmNlcyI6WyIvVXNlcnMveW91c3VrZS9NeVByb2plY3QvbXktbmV4dXMtYXBwL25vZGVfbW9kdWxlcy8ucG5wbS9AZnVlbC10cythYmktY29kZXJAMC4xMDEuMV92aXRlc3RAMy4yLjRfQHR5cGVzK2RlYnVnQDQuMS4xMl9AdHlwZXMrbm9kZUAyNC43LjJfaml0aUAyLjZfNjQwMzk4NjI1NGU2MzM1N2EzZGZmZjQ3NTIwOWM5M2Qvbm9kZV9tb2R1bGVzL0BmdWVsLXRzL2FiaS1jb2Rlci9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fbmFtZSA9ICh0YXJnZXQsIHZhbHVlKSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIm5hbWVcIiwgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXG4vLyBzcmMvZW5jb2RpbmcvY29kZXJzL0Fic3RyYWN0Q29kZXIudHNcbnZhciBDb2RlciA9IGNsYXNzIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJDb2RlclwiKTtcbiAgfVxuICBuYW1lO1xuICB0eXBlO1xuICBlbmNvZGVkTGVuZ3RoO1xuICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBlbmNvZGVkTGVuZ3RoKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZW5jb2RlZExlbmd0aCA9IGVuY29kZWRMZW5ndGg7XG4gIH1cbn07XG5cbi8vIHNyYy9lbmNvZGluZy9jb2RlcnMvQXJyYXlDb2Rlci50c1xuaW1wb3J0IHsgRXJyb3JDb2RlLCBGdWVsRXJyb3IgfSBmcm9tIFwiQGZ1ZWwtdHMvZXJyb3JzXCI7XG5pbXBvcnQgeyBjb25jYXQgfSBmcm9tIFwiQGZ1ZWwtdHMvdXRpbHNcIjtcblxuLy8gc3JjL3V0aWxzL2NvbnN0YW50cy50c1xudmFyIFU4X0NPREVSX1RZUEUgPSBcInU4XCI7XG52YXIgVTE2X0NPREVSX1RZUEUgPSBcInUxNlwiO1xudmFyIFUzMl9DT0RFUl9UWVBFID0gXCJ1MzJcIjtcbnZhciBVNjRfQ09ERVJfVFlQRSA9IFwidTY0XCI7XG52YXIgVTI1Nl9DT0RFUl9UWVBFID0gXCJ1MjU2XCI7XG52YXIgUkFXX1BUUl9DT0RFUl9UWVBFID0gXCJyYXcgdW50eXBlZCBwdHJcIjtcbnZhciBSQVdfU0xJQ0VfQ09ERVJfVFlQRSA9IFwicmF3IHVudHlwZWQgc2xpY2VcIjtcbnZhciBCT09MX0NPREVSX1RZUEUgPSBcImJvb2xcIjtcbnZhciBCMjU2X0NPREVSX1RZUEUgPSBcImIyNTZcIjtcbnZhciBCNTEyX0NPREVSX1RZUEUgPSBcInN0cnVjdCBzdGQ6OmI1MTI6OkI1MTJcIjtcbnZhciBPUFRJT05fQ09ERVJfVFlQRSA9IFwiZW51bSBzdGQ6Om9wdGlvbjo6T3B0aW9uXCI7XG52YXIgVkVDX0NPREVSX1RZUEUgPSBcInN0cnVjdCBzdGQ6OnZlYzo6VmVjXCI7XG52YXIgQllURVNfQ09ERVJfVFlQRSA9IFwic3RydWN0IHN0ZDo6Ynl0ZXM6OkJ5dGVzXCI7XG52YXIgU1REX1NUUklOR19DT0RFUl9UWVBFID0gXCJzdHJ1Y3Qgc3RkOjpzdHJpbmc6OlN0cmluZ1wiO1xudmFyIFNUUl9TTElDRV9DT0RFUl9UWVBFID0gXCJzdHJcIjtcbnZhciBWT0lEX1RZUEUgPSBcIigpXCI7XG52YXIgb3B0aW9uUmVnRXggPSAvXmVudW0gKHN0ZDo6b3B0aW9uOjopP09wdGlvbiQvbTtcbnZhciBzdHJpbmdSZWdFeCA9IC9ec3RyXFxbKD88bGVuZ3RoPlswLTldKylcXF0vO1xudmFyIGFycmF5UmVnRXggPSAvXlxcWyg/PGl0ZW0+W1xcd1xcc1xcXFxbXFxdXSspO1xccyooPzxsZW5ndGg+WzAtOV0rKVxcXS87XG52YXIgc3RydWN0UmVnRXggPSAvXnN0cnVjdC4rLztcbnZhciBlbnVtUmVnRXggPSAvXmVudW0uKyQvO1xudmFyIHR1cGxlUmVnRXggPSAvXlxcKCg/PGl0ZW1zPi4qKVxcKSQvO1xudmFyIGdlbmVyaWNSZWdFeCA9IC9eZ2VuZXJpYy4rJC87XG52YXIgZnVsbE5hbWVSZWdFeE1hdGNoID0gLyhbXlxcc10rKSQvbTtcbnZhciBFTkNPRElOR19WMSA9IFwiMVwiO1xudmFyIFdPUkRfU0laRSA9IDg7XG52YXIgQllURVNfMzIgPSAzMjtcbnZhciBVVFhPX0lEX0xFTiA9IEJZVEVTXzMyICsgMjtcbnZhciBBU1NFVF9JRF9MRU4gPSBCWVRFU18zMjtcbnZhciBDT05UUkFDVF9JRF9MRU4gPSBCWVRFU18zMjtcbnZhciBBRERSRVNTX0xFTiA9IEJZVEVTXzMyO1xudmFyIE5PTkNFX0xFTiA9IEJZVEVTXzMyO1xudmFyIFRYX0xFTiA9IFdPUkRfU0laRSAqIDQ7XG52YXIgVFhfUE9JTlRFUl9MRU4gPSBXT1JEX1NJWkUgKiAyO1xudmFyIE1BWF9CWVRFUyA9IDIgKiogMzIgLSAxO1xudmFyIGNhbGN1bGF0ZVZtVHhNZW1vcnkgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh7IG1heElucHV0cyB9KSA9PiBCWVRFU18zMiArIC8vIFR4IElEXG5BU1NFVF9JRF9MRU4gKyAvLyBCYXNlIGFzc2V0IElEXG4vLyBBc3NldCBJRC9CYWxhbmNlIGNvaW4gaW5wdXQgcGFpcnNcbm1heElucHV0cyAqIChBU1NFVF9JRF9MRU4gKyBXT1JEX1NJWkUpICsgV09SRF9TSVpFLCBcImNhbGN1bGF0ZVZtVHhNZW1vcnlcIik7XG52YXIgU0NSSVBUX0ZJWEVEX1NJWkUgPSBXT1JEX1NJWkUgKyAvLyBJZGVudGlmaWVyXG5XT1JEX1NJWkUgKyAvLyBHYXMgbGltaXRcbldPUkRfU0laRSArIC8vIFNjcmlwdCBzaXplXG5XT1JEX1NJWkUgKyAvLyBTY3JpcHQgZGF0YSBzaXplXG5XT1JEX1NJWkUgKyAvLyBQb2xpY2llc1xuV09SRF9TSVpFICsgLy8gSW5wdXRzIHNpemVcbldPUkRfU0laRSArIC8vIE91dHB1dHMgc2l6ZVxuV09SRF9TSVpFICsgLy8gV2l0bmVzc2VzIHNpemVcbkJZVEVTXzMyO1xudmFyIElOUFVUX0NPSU5fRklYRURfU0laRSA9IFdPUkRfU0laRSArIC8vIElkZW50aWZpZXJcblRYX0xFTiArIC8vIFV0eG8gTGVuZ3RoXG5XT1JEX1NJWkUgKyAvLyBPdXRwdXQgSW5kZXhcbkFERFJFU1NfTEVOICsgLy8gT3duZXJcbldPUkRfU0laRSArIC8vIEFtb3VudFxuQVNTRVRfSURfTEVOICsgLy8gQXNzZXQgaWRcblRYX1BPSU5URVJfTEVOICsgLy8gVHhQb2ludGVyXG5XT1JEX1NJWkUgKyAvLyBXaXRuZXNzZXMgaW5kZXhcbldPUkRfU0laRSArIC8vIFByZWRpY2F0ZSBzaXplXG5XT1JEX1NJWkUgKyAvLyBQcmVkaWNhdGUgZGF0YSBzaXplXG5XT1JEX1NJWkU7XG52YXIgSU5QVVRfTUVTU0FHRV9GSVhFRF9TSVpFID0gV09SRF9TSVpFICsgLy8gSWRlbnRpZmllclxuQUREUkVTU19MRU4gKyAvLyBTZW5kZXJcbkFERFJFU1NfTEVOICsgLy8gUmVjaXBpZW50XG5XT1JEX1NJWkUgKyAvLyBBbW91bnRcbk5PTkNFX0xFTiArIC8vIE5vbmNlXG5XT1JEX1NJWkUgKyAvLyB3aXRuZXNzX2luZGV4XG5XT1JEX1NJWkUgKyAvLyBEYXRhIHNpemVcbldPUkRfU0laRSArIC8vIFByZWRpY2F0ZSBzaXplXG5XT1JEX1NJWkUgKyAvLyBQcmVkaWNhdGUgZGF0YSBzaXplXG5XT1JEX1NJWkU7XG5cbi8vIHNyYy91dGlscy91dGlsaXRpZXMudHNcbnZhciBpc1VpbnQ4QXJyYXkgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5LCBcImlzVWludDhBcnJheVwiKTtcbnZhciBoYXNOZXN0ZWRPcHRpb24gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChjb2RlcnMpID0+IHtcbiAgY29uc3QgYXJyYXkgPSBBcnJheS5pc0FycmF5KGNvZGVycykgPyBjb2RlcnMgOiBPYmplY3QudmFsdWVzKGNvZGVycyk7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBhcnJheSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IE9QVElPTl9DT0RFUl9UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKFwiY29kZXJcIiBpbiBub2RlICYmIG5vZGUuY29kZXIudHlwZSA9PT0gT1BUSU9OX0NPREVSX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoXCJjb2RlcnNcIiBpbiBub2RlKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGhhc05lc3RlZE9wdGlvbihub2RlLmNvZGVycyk7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn0sIFwiaGFzTmVzdGVkT3B0aW9uXCIpO1xuXG4vLyBzcmMvZW5jb2RpbmcvY29kZXJzL0FycmF5Q29kZXIudHNcbnZhciBBcnJheUNvZGVyID0gY2xhc3MgZXh0ZW5kcyBDb2RlciB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiQXJyYXlDb2RlclwiKTtcbiAgfVxuICBjb2RlcjtcbiAgbGVuZ3RoO1xuICAjaGFzTmVzdGVkT3B0aW9uO1xuICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoKSB7XG4gICAgc3VwZXIoXCJhcnJheVwiLCBgWyR7Y29kZXIudHlwZX07ICR7bGVuZ3RofV1gLCBsZW5ndGggKiBjb2Rlci5lbmNvZGVkTGVuZ3RoKTtcbiAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy4jaGFzTmVzdGVkT3B0aW9uID0gaGFzTmVzdGVkT3B0aW9uKFtjb2Rlcl0pO1xuICB9XG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3IoRXJyb3JDb2RlLkVOQ09ERV9FUlJPUiwgYEV4cGVjdGVkIGFycmF5IHZhbHVlLmApO1xuICAgIH1cbiAgICBpZiAodGhpcy5sZW5ndGggIT09IHZhbHVlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcihFcnJvckNvZGUuRU5DT0RFX0VSUk9SLCBgVHlwZXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChBcnJheS5mcm9tKHZhbHVlKS5tYXAoKHYpID0+IHRoaXMuY29kZXIuZW5jb2RlKHYpKSk7XG4gIH1cbiAgZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGlmICghdGhpcy4jaGFzTmVzdGVkT3B0aW9uICYmIGRhdGEubGVuZ3RoIDwgdGhpcy5lbmNvZGVkTGVuZ3RoIHx8IGRhdGEubGVuZ3RoID4gTUFYX0JZVEVTKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yKEVycm9yQ29kZS5ERUNPREVfRVJST1IsIGBJbnZhbGlkIGFycmF5IGRhdGEgc2l6ZS5gKTtcbiAgICB9XG4gICAgbGV0IG5ld09mZnNldCA9IG9mZnNldDtcbiAgICBjb25zdCBkZWNvZGVkVmFsdWUgPSBBcnJheSh0aGlzLmxlbmd0aCkuZmlsbCgwKS5tYXAoKCkgPT4ge1xuICAgICAgbGV0IGRlY29kZWQ7XG4gICAgICBbZGVjb2RlZCwgbmV3T2Zmc2V0XSA9IHRoaXMuY29kZXIuZGVjb2RlKGRhdGEsIG5ld09mZnNldCk7XG4gICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICB9KTtcbiAgICByZXR1cm4gW2RlY29kZWRWYWx1ZSwgbmV3T2Zmc2V0XTtcbiAgfVxufTtcblxuLy8gc3JjL2VuY29kaW5nL2NvZGVycy9CMjU2Q29kZXIudHNcbmltcG9ydCB7IEVycm9yQ29kZSBhcyBFcnJvckNvZGUyLCBGdWVsRXJyb3IgYXMgRnVlbEVycm9yMiB9IGZyb20gXCJAZnVlbC10cy9lcnJvcnNcIjtcbmltcG9ydCB7IGJuLCB0b0hleCB9IGZyb20gXCJAZnVlbC10cy9tYXRoXCI7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZnVlbC10cy91dGlsc1wiO1xudmFyIEIyNTZDb2RlciA9IGNsYXNzIGV4dGVuZHMgQ29kZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkIyNTZDb2RlclwiKTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcImIyNTZcIiwgXCJiMjU2XCIsIFdPUkRfU0laRSAqIDQpO1xuICB9XG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIGxldCBlbmNvZGVkVmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgIGVuY29kZWRWYWx1ZSA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjIoRXJyb3JDb2RlMi5FTkNPREVfRVJST1IsIGBJbnZhbGlkICR7dGhpcy50eXBlfS5gKTtcbiAgICB9XG4gICAgaWYgKGVuY29kZWRWYWx1ZS5sZW5ndGggIT09IHRoaXMuZW5jb2RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjIoRXJyb3JDb2RlMi5FTkNPREVfRVJST1IsIGBJbnZhbGlkICR7dGhpcy50eXBlfS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZWRWYWx1ZTtcbiAgfVxuICBkZWNvZGUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5lbmNvZGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yMihFcnJvckNvZGUyLkRFQ09ERV9FUlJPUiwgYEludmFsaWQgYjI1NiBkYXRhIHNpemUuYCk7XG4gICAgfVxuICAgIGxldCBieXRlcyA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLmVuY29kZWRMZW5ndGgpO1xuICAgIGNvbnN0IGRlY29kZWQgPSBibihieXRlcyk7XG4gICAgaWYgKGRlY29kZWQuaXNaZXJvKCkpIHtcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIH1cbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSB0aGlzLmVuY29kZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3IyKEVycm9yQ29kZTIuREVDT0RFX0VSUk9SLCBgSW52YWxpZCBiMjU2IGJ5dGUgZGF0YSBzaXplLmApO1xuICAgIH1cbiAgICByZXR1cm4gW3RvSGV4KGJ5dGVzLCAzMiksIG9mZnNldCArIDMyXTtcbiAgfVxufTtcblxuLy8gc3JjL2VuY29kaW5nL2NvZGVycy9CNTEyQ29kZXIudHNcbmltcG9ydCB7IEVycm9yQ29kZSBhcyBFcnJvckNvZGUzLCBGdWVsRXJyb3IgYXMgRnVlbEVycm9yMyB9IGZyb20gXCJAZnVlbC10cy9lcnJvcnNcIjtcbmltcG9ydCB7IGJuIGFzIGJuMiwgdG9IZXggYXMgdG9IZXgyIH0gZnJvbSBcIkBmdWVsLXRzL21hdGhcIjtcbmltcG9ydCB7IGFycmF5aWZ5IGFzIGFycmF5aWZ5MiB9IGZyb20gXCJAZnVlbC10cy91dGlsc1wiO1xudmFyIEI1MTJDb2RlciA9IGNsYXNzIGV4dGVuZHMgQ29kZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkI1MTJDb2RlclwiKTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcImI1MTJcIiwgXCJzdHJ1Y3QgQjUxMlwiLCBXT1JEX1NJWkUgKiA4KTtcbiAgfVxuICBlbmNvZGUodmFsdWUpIHtcbiAgICBsZXQgZW5jb2RlZFZhbHVlO1xuICAgIHRyeSB7XG4gICAgICBlbmNvZGVkVmFsdWUgPSBhcnJheWlmeTIodmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yMyhFcnJvckNvZGUzLkVOQ09ERV9FUlJPUiwgYEludmFsaWQgJHt0aGlzLnR5cGV9LmApO1xuICAgIH1cbiAgICBpZiAoZW5jb2RlZFZhbHVlLmxlbmd0aCAhPT0gdGhpcy5lbmNvZGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yMyhFcnJvckNvZGUzLkVOQ09ERV9FUlJPUiwgYEludmFsaWQgJHt0aGlzLnR5cGV9LmApO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZFZhbHVlO1xuICB9XG4gIGRlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCB0aGlzLmVuY29kZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3IzKEVycm9yQ29kZTMuREVDT0RFX0VSUk9SLCBgSW52YWxpZCBiNTEyIGRhdGEgc2l6ZS5gKTtcbiAgICB9XG4gICAgbGV0IGJ5dGVzID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIHRoaXMuZW5jb2RlZExlbmd0aCk7XG4gICAgY29uc3QgZGVjb2RlZCA9IGJuMihieXRlcyk7XG4gICAgaWYgKGRlY29kZWQuaXNaZXJvKCkpIHtcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgIH1cbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSB0aGlzLmVuY29kZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3IzKEVycm9yQ29kZTMuREVDT0RFX0VSUk9SLCBgSW52YWxpZCBiNTEyIGJ5dGUgZGF0YSBzaXplLmApO1xuICAgIH1cbiAgICByZXR1cm4gW3RvSGV4MihieXRlcywgdGhpcy5lbmNvZGVkTGVuZ3RoKSwgb2Zmc2V0ICsgdGhpcy5lbmNvZGVkTGVuZ3RoXTtcbiAgfVxufTtcblxuLy8gc3JjL2VuY29kaW5nL2NvZGVycy9CaWdOdW1iZXJDb2Rlci50c1xuaW1wb3J0IHsgRXJyb3JDb2RlIGFzIEVycm9yQ29kZTQsIEZ1ZWxFcnJvciBhcyBGdWVsRXJyb3I0IH0gZnJvbSBcIkBmdWVsLXRzL2Vycm9yc1wiO1xuaW1wb3J0IHsgdG9CeXRlcywgYm4gYXMgYm4zIH0gZnJvbSBcIkBmdWVsLXRzL21hdGhcIjtcbnZhciBlbmNvZGVkTGVuZ3RocyA9IHtcbiAgdTY0OiBXT1JEX1NJWkUsXG4gIHUyNTY6IFdPUkRfU0laRSAqIDRcbn07XG52YXIgQmlnTnVtYmVyQ29kZXIgPSBjbGFzcyBleHRlbmRzIENvZGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJCaWdOdW1iZXJDb2RlclwiKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihiYXNlVHlwZSkge1xuICAgIHN1cGVyKFwiYmlnTnVtYmVyXCIsIGJhc2VUeXBlLCBlbmNvZGVkTGVuZ3Roc1tiYXNlVHlwZV0pO1xuICB9XG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIGxldCBieXRlcztcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIHZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3I0KFxuICAgICAgICBFcnJvckNvZGU0LkVOQ09ERV9FUlJPUixcbiAgICAgICAgYEludmFsaWQgJHt0aGlzLnR5cGV9IHR5cGUgLSBudW1iZXIgdmFsdWUgaXMgdG9vIGxhcmdlLiBOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IGhhbmRsZSB1cCB0byA1MyBiaXRzLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBieXRlcyA9IHRvQnl0ZXModmFsdWUsIHRoaXMuZW5jb2RlZExlbmd0aCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3I0KEVycm9yQ29kZTQuRU5DT0RFX0VSUk9SLCBgSW52YWxpZCAke3RoaXMudHlwZX0uYCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfVxuICBkZWNvZGUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5lbmNvZGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yNChFcnJvckNvZGU0LkRFQ09ERV9FUlJPUiwgYEludmFsaWQgJHt0aGlzLnR5cGV9IGRhdGEgc2l6ZS5gKTtcbiAgICB9XG4gICAgbGV0IGJ5dGVzID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIHRoaXMuZW5jb2RlZExlbmd0aCk7XG4gICAgYnl0ZXMgPSBieXRlcy5zbGljZSgwLCB0aGlzLmVuY29kZWRMZW5ndGgpO1xuICAgIGlmIChieXRlcy5sZW5ndGggIT09IHRoaXMuZW5jb2RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjQoRXJyb3JDb2RlNC5ERUNPREVfRVJST1IsIGBJbnZhbGlkICR7dGhpcy50eXBlfSBieXRlIGRhdGEgc2l6ZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFtibjMoYnl0ZXMpLCBvZmZzZXQgKyB0aGlzLmVuY29kZWRMZW5ndGhdO1xuICB9XG59O1xuXG4vLyBzcmMvZW5jb2RpbmcvY29kZXJzL0Jvb2xlYW5Db2Rlci50c1xuaW1wb3J0IHsgRXJyb3JDb2RlIGFzIEVycm9yQ29kZTUsIEZ1ZWxFcnJvciBhcyBGdWVsRXJyb3I1IH0gZnJvbSBcIkBmdWVsLXRzL2Vycm9yc1wiO1xuaW1wb3J0IHsgYm4gYXMgYm40LCB0b0J5dGVzIGFzIHRvQnl0ZXMyIH0gZnJvbSBcIkBmdWVsLXRzL21hdGhcIjtcbnZhciBCb29sZWFuQ29kZXIgPSBjbGFzcyBleHRlbmRzIENvZGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJCb29sZWFuQ29kZXJcIik7XG4gIH1cbiAgb3B0aW9ucztcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHtcbiAgICBwYWRUb1dvcmRTaXplOiBmYWxzZVxuICB9KSB7XG4gICAgY29uc3QgZW5jb2RlZExlbmd0aCA9IG9wdGlvbnMucGFkVG9Xb3JkU2l6ZSA/IFdPUkRfU0laRSA6IDE7XG4gICAgc3VwZXIoXCJib29sZWFuXCIsIFwiYm9vbGVhblwiLCBlbmNvZGVkTGVuZ3RoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIGNvbnN0IGlzVHJ1ZUJvb2wgPSB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgaWYgKCFpc1RydWVCb29sKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yNShFcnJvckNvZGU1LkVOQ09ERV9FUlJPUiwgYEludmFsaWQgYm9vbGVhbiB2YWx1ZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvQnl0ZXMyKHZhbHVlID8gMSA6IDAsIHRoaXMuZW5jb2RlZExlbmd0aCk7XG4gIH1cbiAgZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuZW5jb2RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjUoRXJyb3JDb2RlNS5ERUNPREVfRVJST1IsIGBJbnZhbGlkIGJvb2xlYW4gZGF0YSBzaXplLmApO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IGJuNChkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5lbmNvZGVkTGVuZ3RoKSk7XG4gICAgaWYgKGJ5dGVzLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gW2ZhbHNlLCBvZmZzZXQgKyB0aGlzLmVuY29kZWRMZW5ndGhdO1xuICAgIH1cbiAgICBpZiAoIWJ5dGVzLmVxKGJuNCgxKSkpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3I1KEVycm9yQ29kZTUuREVDT0RFX0VSUk9SLCBgSW52YWxpZCBib29sZWFuIHZhbHVlLmApO1xuICAgIH1cbiAgICByZXR1cm4gW3RydWUsIG9mZnNldCArIHRoaXMuZW5jb2RlZExlbmd0aF07XG4gIH1cbn07XG5cbi8vIHNyYy9lbmNvZGluZy9jb2RlcnMvQnl0ZUNvZGVyLnRzXG5pbXBvcnQgeyBFcnJvckNvZGUgYXMgRXJyb3JDb2RlNiwgRnVlbEVycm9yIGFzIEZ1ZWxFcnJvcjYgfSBmcm9tIFwiQGZ1ZWwtdHMvZXJyb3JzXCI7XG5pbXBvcnQgeyBibiBhcyBibjUgfSBmcm9tIFwiQGZ1ZWwtdHMvbWF0aFwiO1xudmFyIEJ5dGVDb2RlciA9IGNsYXNzIGV4dGVuZHMgQ29kZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkJ5dGVDb2RlclwiKTtcbiAgfVxuICBzdGF0aWMgbWVtb3J5U2l6ZSA9IDE7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwic3RydWN0XCIsIFwic3RydWN0IEJ5dGVzXCIsIFdPUkRfU0laRSk7XG4gIH1cbiAgZW5jb2RlKHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyB2YWx1ZSA6IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICBjb25zdCBsZW5ndGhCeXRlcyA9IG5ldyBCaWdOdW1iZXJDb2RlcihcInU2NFwiKS5lbmNvZGUoYnl0ZXMubGVuZ3RoKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWy4uLmxlbmd0aEJ5dGVzLCAuLi5ieXRlc10pO1xuICB9XG4gIGRlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCBXT1JEX1NJWkUpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3I2KEVycm9yQ29kZTYuREVDT0RFX0VSUk9SLCBgSW52YWxpZCBieXRlIGRhdGEgc2l6ZS5gKTtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0QW5kTGVuZ3RoID0gb2Zmc2V0ICsgV09SRF9TSVpFO1xuICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldEFuZExlbmd0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gYm41KG5ldyBCaWdOdW1iZXJDb2RlcihcInU2NFwiKS5kZWNvZGUobGVuZ3RoQnl0ZXMsIDApWzBdKS50b051bWJlcigpO1xuICAgIGNvbnN0IGRhdGFCeXRlcyA9IGRhdGEuc2xpY2Uob2Zmc2V0QW5kTGVuZ3RoLCBvZmZzZXRBbmRMZW5ndGggKyBsZW5ndGgpO1xuICAgIGlmIChkYXRhQnl0ZXMubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3I2KEVycm9yQ29kZTYuREVDT0RFX0VSUk9SLCBgSW52YWxpZCBieXRlcyBieXRlIGRhdGEgc2l6ZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFtkYXRhQnl0ZXMsIG9mZnNldEFuZExlbmd0aCArIGxlbmd0aF07XG4gIH1cbn07XG5cbi8vIHNyYy9lbmNvZGluZy9jb2RlcnMvRW51bUNvZGVyLnRzXG5pbXBvcnQgeyBFcnJvckNvZGUgYXMgRXJyb3JDb2RlNywgRnVlbEVycm9yIGFzIEZ1ZWxFcnJvcjcgfSBmcm9tIFwiQGZ1ZWwtdHMvZXJyb3JzXCI7XG5pbXBvcnQgeyB0b051bWJlciB9IGZyb20gXCJAZnVlbC10cy9tYXRoXCI7XG5pbXBvcnQgeyBjb25jYXQgYXMgY29uY2F0MiB9IGZyb20gXCJAZnVlbC10cy91dGlsc1wiO1xudmFyIEVudW1Db2RlciA9IGNsYXNzIGV4dGVuZHMgQ29kZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkVudW1Db2RlclwiKTtcbiAgfVxuICBuYW1lO1xuICBjb2RlcnM7XG4gICNjYXNlSW5kZXhDb2RlcjtcbiAgI2VuY29kZWRWYWx1ZVNpemU7XG4gICNzaG91bGRWYWxpZGF0ZUxlbmd0aDtcbiAgY29uc3RydWN0b3IobmFtZSwgY29kZXJzKSB7XG4gICAgY29uc3QgY2FzZUluZGV4Q29kZXIgPSBuZXcgQmlnTnVtYmVyQ29kZXIoXCJ1NjRcIik7XG4gICAgY29uc3QgZW5jb2RlZFZhbHVlU2l6ZSA9IE9iamVjdC52YWx1ZXMoY29kZXJzKS5yZWR1Y2UoXG4gICAgICAobWluLCBjb2RlcikgPT4gTWF0aC5taW4obWluLCBjb2Rlci5lbmNvZGVkTGVuZ3RoKSxcbiAgICAgIDBcbiAgICApO1xuICAgIHN1cGVyKGBlbnVtICR7bmFtZX1gLCBgZW51bSAke25hbWV9YCwgY2FzZUluZGV4Q29kZXIuZW5jb2RlZExlbmd0aCArIGVuY29kZWRWYWx1ZVNpemUpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jb2RlcnMgPSBjb2RlcnM7XG4gICAgdGhpcy4jY2FzZUluZGV4Q29kZXIgPSBjYXNlSW5kZXhDb2RlcjtcbiAgICB0aGlzLiNlbmNvZGVkVmFsdWVTaXplID0gZW5jb2RlZFZhbHVlU2l6ZTtcbiAgICB0aGlzLiNzaG91bGRWYWxpZGF0ZUxlbmd0aCA9ICEob3B0aW9uUmVnRXgudGVzdCh0aGlzLnR5cGUpIHx8IGhhc05lc3RlZE9wdGlvbihjb2RlcnMpKTtcbiAgfVxuICAvLyBDaGVja3MgdGhhdCB3ZSdyZSBoYW5kbGluZyBhIG5hdGl2ZSBlbnVtIHRoYXQgaXMgb2YgdHlwZSB2b2lkLlxuICAjaXNOYXRpdmVFbnVtKGNvZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSAhPT0gT1BUSU9OX0NPREVSX1RZUEUgJiYgY29kZXIudHlwZSA9PT0gVk9JRF9UWVBFO1xuICB9XG4gICNlbmNvZGVOYXRpdmVFbnVtKHZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVDb2RlciA9IHRoaXMuY29kZXJzW3ZhbHVlXTtcbiAgICBjb25zdCBlbmNvZGVkVmFsdWUgPSB2YWx1ZUNvZGVyLmVuY29kZShbXSk7XG4gICAgY29uc3QgY2FzZUluZGV4ID0gT2JqZWN0LmtleXModGhpcy5jb2RlcnMpLmluZGV4T2YodmFsdWUpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBuZXcgVWludDhBcnJheSh0aGlzLiNlbmNvZGVkVmFsdWVTaXplIC0gdmFsdWVDb2Rlci5lbmNvZGVkTGVuZ3RoKTtcbiAgICByZXR1cm4gY29uY2F0MihbdGhpcy4jY2FzZUluZGV4Q29kZXIuZW5jb2RlKGNhc2VJbmRleCksIHBhZGRpbmcsIGVuY29kZWRWYWx1ZV0pO1xuICB9XG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdGhpcy5jb2RlcnNbdmFsdWVdKSB7XG4gICAgICByZXR1cm4gdGhpcy4jZW5jb2RlTmF0aXZlRW51bSh2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0IFtjYXNlS2V5LCAuLi5lbXB0eV0gPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgaWYgKCFjYXNlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yNyhFcnJvckNvZGU3LklOVkFMSURfREVDT0RFX1ZBTFVFLCBcIkEgZmllbGQgZm9yIHRoZSBjYXNlIG11c3QgYmUgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoZW1wdHkubGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yNyhFcnJvckNvZGU3LklOVkFMSURfREVDT0RFX1ZBTFVFLCBcIk9ubHkgb25lIGZpZWxkIG11c3QgYmUgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZUNvZGVyID0gdGhpcy5jb2RlcnNbY2FzZUtleV07XG4gICAgY29uc3QgY2FzZUluZGV4ID0gT2JqZWN0LmtleXModGhpcy5jb2RlcnMpLmluZGV4T2YoY2FzZUtleSk7XG4gICAgaWYgKGNhc2VJbmRleCA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IHZhbGlkQ2FzZXMgPSBPYmplY3Qua2V5cyh0aGlzLmNvZGVycykubWFwKCh2KSA9PiBgJyR7dn0nYCkuam9pbihcIiwgXCIpO1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjcoXG4gICAgICAgIEVycm9yQ29kZTcuSU5WQUxJRF9ERUNPREVfVkFMVUUsXG4gICAgICAgIGBJbnZhbGlkIGNhc2UgJyR7Y2FzZUtleX0nLiBWYWxpZCBjYXNlczogJHt2YWxpZENhc2VzfS5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGVkVmFsdWUgPSB2YWx1ZUNvZGVyLmVuY29kZSh2YWx1ZVtjYXNlS2V5XSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsuLi50aGlzLiNjYXNlSW5kZXhDb2Rlci5lbmNvZGUoY2FzZUluZGV4KSwgLi4uZW5jb2RlZFZhbHVlXSk7XG4gIH1cbiAgI2RlY29kZU5hdGl2ZUVudW0oY2FzZUtleSwgbmV3T2Zmc2V0KSB7XG4gICAgcmV0dXJuIFtjYXNlS2V5LCBuZXdPZmZzZXRdO1xuICB9XG4gIGRlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAodGhpcy4jc2hvdWxkVmFsaWRhdGVMZW5ndGggJiYgZGF0YS5sZW5ndGggPCB0aGlzLmVuY29kZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3I3KEVycm9yQ29kZTcuREVDT0RFX0VSUk9SLCBgSW52YWxpZCBlbnVtIGRhdGEgc2l6ZS5gKTtcbiAgICB9XG4gICAgY29uc3QgY2FzZUJ5dGVzID0gbmV3IEJpZ051bWJlckNvZGVyKFwidTY0XCIpLmRlY29kZShkYXRhLCBvZmZzZXQpWzBdO1xuICAgIGNvbnN0IGNhc2VJbmRleCA9IHRvTnVtYmVyKGNhc2VCeXRlcyk7XG4gICAgY29uc3QgY2FzZUtleSA9IE9iamVjdC5rZXlzKHRoaXMuY29kZXJzKVtjYXNlSW5kZXhdO1xuICAgIGlmICghY2FzZUtleSkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjcoXG4gICAgICAgIEVycm9yQ29kZTcuSU5WQUxJRF9ERUNPREVfVkFMVUUsXG4gICAgICAgIGBJbnZhbGlkIGNhc2VJbmRleCBcIiR7Y2FzZUluZGV4fVwiLiBWYWxpZCBjYXNlczogJHtPYmplY3Qua2V5cyh0aGlzLmNvZGVycyl9LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlQ29kZXIgPSB0aGlzLmNvZGVyc1tjYXNlS2V5XTtcbiAgICBjb25zdCBvZmZzZXRBbmRDYXNlID0gb2Zmc2V0ICsgdGhpcy4jY2FzZUluZGV4Q29kZXIuZW5jb2RlZExlbmd0aDtcbiAgICBpZiAodGhpcy4jc2hvdWxkVmFsaWRhdGVMZW5ndGggJiYgZGF0YS5sZW5ndGggPCBvZmZzZXRBbmRDYXNlICsgdmFsdWVDb2Rlci5lbmNvZGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yNyhFcnJvckNvZGU3LkRFQ09ERV9FUlJPUiwgYEludmFsaWQgZW51bSBkYXRhIHNpemUuYCk7XG4gICAgfVxuICAgIGNvbnN0IFtkZWNvZGVkLCBuZXdPZmZzZXRdID0gdmFsdWVDb2Rlci5kZWNvZGUoZGF0YSwgb2Zmc2V0QW5kQ2FzZSk7XG4gICAgaWYgKHRoaXMuI2lzTmF0aXZlRW51bSh0aGlzLmNvZGVyc1tjYXNlS2V5XSkpIHtcbiAgICAgIHJldHVybiB0aGlzLiNkZWNvZGVOYXRpdmVFbnVtKGNhc2VLZXksIG5ld09mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBbeyBbY2FzZUtleV06IGRlY29kZWQgfSwgbmV3T2Zmc2V0XTtcbiAgfVxufTtcblxuLy8gc3JjL2VuY29kaW5nL2NvZGVycy9OdW1iZXJDb2Rlci50c1xuaW1wb3J0IHsgRXJyb3JDb2RlIGFzIEVycm9yQ29kZTgsIEZ1ZWxFcnJvciBhcyBGdWVsRXJyb3I4IH0gZnJvbSBcIkBmdWVsLXRzL2Vycm9yc1wiO1xuaW1wb3J0IHsgdG9OdW1iZXIgYXMgdG9OdW1iZXIyLCB0b0J5dGVzIGFzIHRvQnl0ZXMzIH0gZnJvbSBcIkBmdWVsLXRzL21hdGhcIjtcbnZhciBnZXRMZW5ndGggPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChiYXNlVHlwZSkgPT4ge1xuICBzd2l0Y2ggKGJhc2VUeXBlKSB7XG4gICAgY2FzZSBcInU4XCI6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlIFwidTE2XCI6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlIFwidTMyXCI6XG4gICAgICByZXR1cm4gNDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjgoRXJyb3JDb2RlOC5UWVBFX05PVF9TVVBQT1JURUQsIGBJbnZhbGlkIG51bWJlciB0eXBlOiAke2Jhc2VUeXBlfWApO1xuICB9XG59LCBcImdldExlbmd0aFwiKTtcbnZhciBOdW1iZXJDb2RlciA9IGNsYXNzIGV4dGVuZHMgQ29kZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIk51bWJlckNvZGVyXCIpO1xuICB9XG4gIGJhc2VUeXBlO1xuICBvcHRpb25zO1xuICBjb25zdHJ1Y3RvcihiYXNlVHlwZSwgb3B0aW9ucyA9IHtcbiAgICBwYWRUb1dvcmRTaXplOiBmYWxzZVxuICB9KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gb3B0aW9ucy5wYWRUb1dvcmRTaXplID8gV09SRF9TSVpFIDogZ2V0TGVuZ3RoKGJhc2VUeXBlKTtcbiAgICBzdXBlcihcIm51bWJlclwiLCBiYXNlVHlwZSwgbGVuZ3RoKTtcbiAgICB0aGlzLmJhc2VUeXBlID0gYmFzZVR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBlbmNvZGUodmFsdWUpIHtcbiAgICBsZXQgYnl0ZXM7XG4gICAgdHJ5IHtcbiAgICAgIGJ5dGVzID0gdG9CeXRlczModmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yOChFcnJvckNvZGU4LkVOQ09ERV9FUlJPUiwgYEludmFsaWQgJHt0aGlzLmJhc2VUeXBlfS5gKTtcbiAgICB9XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHRoaXMuZW5jb2RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjgoRXJyb3JDb2RlOC5FTkNPREVfRVJST1IsIGBJbnZhbGlkICR7dGhpcy5iYXNlVHlwZX0sIHRvbyBtYW55IGJ5dGVzLmApO1xuICAgIH1cbiAgICByZXR1cm4gdG9CeXRlczMoYnl0ZXMsIHRoaXMuZW5jb2RlZExlbmd0aCk7XG4gIH1cbiAgZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuZW5jb2RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjgoRXJyb3JDb2RlOC5ERUNPREVfRVJST1IsIGBJbnZhbGlkIG51bWJlciBkYXRhIHNpemUuYCk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIHRoaXMuZW5jb2RlZExlbmd0aCk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gdGhpcy5lbmNvZGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yOChFcnJvckNvZGU4LkRFQ09ERV9FUlJPUiwgYEludmFsaWQgbnVtYmVyIGJ5dGUgZGF0YSBzaXplLmApO1xuICAgIH1cbiAgICByZXR1cm4gW3RvTnVtYmVyMihieXRlcyksIG9mZnNldCArIHRoaXMuZW5jb2RlZExlbmd0aF07XG4gIH1cbn07XG5cbi8vIHNyYy9lbmNvZGluZy9jb2RlcnMvT3B0aW9uQ29kZXIudHNcbnZhciBPcHRpb25Db2RlciA9IGNsYXNzIGV4dGVuZHMgRW51bUNvZGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJPcHRpb25Db2RlclwiKTtcbiAgfVxuICBlbmNvZGUodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5lbmNvZGUodGhpcy50b1N3YXlPcHRpb24odmFsdWUpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRvU3dheU9wdGlvbihpbnB1dCkge1xuICAgIGlmIChpbnB1dCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBTb21lOiBpbnB1dCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBOb25lOiBbXSB9O1xuICB9XG4gIGRlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBjb25zdCBbZGVjb2RlZCwgbmV3T2Zmc2V0XSA9IHN1cGVyLmRlY29kZShkYXRhLCBvZmZzZXQpO1xuICAgIHJldHVybiBbdGhpcy50b09wdGlvbihkZWNvZGVkKSwgbmV3T2Zmc2V0XTtcbiAgfVxuICB0b09wdGlvbihvdXRwdXQpIHtcbiAgICBpZiAob3V0cHV0ICYmIFwiU29tZVwiIGluIG91dHB1dCkge1xuICAgICAgcmV0dXJuIG91dHB1dC5Tb21lO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBzcmMvZW5jb2RpbmcvY29kZXJzL1Jhd1NsaWNlQ29kZXIudHNcbmltcG9ydCB7IEVycm9yQ29kZSBhcyBFcnJvckNvZGU5LCBGdWVsRXJyb3IgYXMgRnVlbEVycm9yOSB9IGZyb20gXCJAZnVlbC10cy9lcnJvcnNcIjtcbmltcG9ydCB7IGJuIGFzIGJuNiB9IGZyb20gXCJAZnVlbC10cy9tYXRoXCI7XG52YXIgUmF3U2xpY2VDb2RlciA9IGNsYXNzIGV4dGVuZHMgQ29kZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIlJhd1NsaWNlQ29kZXJcIik7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJyYXcgdW50eXBlZCBzbGljZVwiLCBcInJhdyB1bnR5cGVkIHNsaWNlXCIsIFdPUkRfU0laRSk7XG4gIH1cbiAgZW5jb2RlKHZhbHVlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjkoRXJyb3JDb2RlOS5FTkNPREVfRVJST1IsIGBFeHBlY3RlZCBhcnJheSB2YWx1ZS5gKTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJuYWxDb2RlciA9IG5ldyBBcnJheUNvZGVyKG5ldyBOdW1iZXJDb2RlcihcInU4XCIpLCB2YWx1ZS5sZW5ndGgpO1xuICAgIGNvbnN0IGJ5dGVzID0gaW50ZXJuYWxDb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gbmV3IEJpZ051bWJlckNvZGVyKFwidTY0XCIpLmVuY29kZShieXRlcy5sZW5ndGgpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbLi4ubGVuZ3RoQnl0ZXMsIC4uLmJ5dGVzXSk7XG4gIH1cbiAgZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuZW5jb2RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjkoRXJyb3JDb2RlOS5ERUNPREVfRVJST1IsIGBJbnZhbGlkIHJhdyBzbGljZSBkYXRhIHNpemUuYCk7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldEFuZExlbmd0aCA9IG9mZnNldCArIFdPUkRfU0laRTtcbiAgICBjb25zdCBsZW5ndGhCeXRlcyA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXRBbmRMZW5ndGgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGJuNihuZXcgQmlnTnVtYmVyQ29kZXIoXCJ1NjRcIikuZGVjb2RlKGxlbmd0aEJ5dGVzLCAwKVswXSkudG9OdW1iZXIoKTtcbiAgICBjb25zdCBkYXRhQnl0ZXMgPSBkYXRhLnNsaWNlKG9mZnNldEFuZExlbmd0aCwgb2Zmc2V0QW5kTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICBpZiAoZGF0YUJ5dGVzLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yOShFcnJvckNvZGU5LkRFQ09ERV9FUlJPUiwgYEludmFsaWQgcmF3IHNsaWNlIGJ5dGUgZGF0YSBzaXplLmApO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcm5hbENvZGVyID0gbmV3IEFycmF5Q29kZXIobmV3IE51bWJlckNvZGVyKFwidThcIiksIGxlbmd0aCk7XG4gICAgY29uc3QgW2RlY29kZWRWYWx1ZV0gPSBpbnRlcm5hbENvZGVyLmRlY29kZShkYXRhQnl0ZXMsIDApO1xuICAgIHJldHVybiBbZGVjb2RlZFZhbHVlLCBvZmZzZXRBbmRMZW5ndGggKyBsZW5ndGhdO1xuICB9XG59O1xuXG4vLyBzcmMvZW5jb2RpbmcvY29kZXJzL1N0ZFN0cmluZ0NvZGVyLnRzXG5pbXBvcnQgeyBFcnJvckNvZGUgYXMgRXJyb3JDb2RlMTAsIEZ1ZWxFcnJvciBhcyBGdWVsRXJyb3IxMCB9IGZyb20gXCJAZnVlbC10cy9lcnJvcnNcIjtcbmltcG9ydCB7IGJuIGFzIGJuNyB9IGZyb20gXCJAZnVlbC10cy9tYXRoXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBmdWVsLXRzL3V0aWxzXCI7XG52YXIgU3RkU3RyaW5nQ29kZXIgPSBjbGFzcyBleHRlbmRzIENvZGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJTdGRTdHJpbmdDb2RlclwiKTtcbiAgfVxuICBzdGF0aWMgbWVtb3J5U2l6ZSA9IDE7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwic3RydWN0XCIsIFwic3RydWN0IFN0cmluZ1wiLCBXT1JEX1NJWkUpO1xuICB9XG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gdG9VdGY4Qnl0ZXModmFsdWUpO1xuICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gbmV3IEJpZ051bWJlckNvZGVyKFwidTY0XCIpLmVuY29kZSh2YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbLi4ubGVuZ3RoQnl0ZXMsIC4uLmJ5dGVzXSk7XG4gIH1cbiAgZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuZW5jb2RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjEwKEVycm9yQ29kZTEwLkRFQ09ERV9FUlJPUiwgYEludmFsaWQgc3RkIHN0cmluZyBkYXRhIHNpemUuYCk7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldEFuZExlbmd0aCA9IG9mZnNldCArIFdPUkRfU0laRTtcbiAgICBjb25zdCBsZW5ndGhCeXRlcyA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXRBbmRMZW5ndGgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGJuNyhuZXcgQmlnTnVtYmVyQ29kZXIoXCJ1NjRcIikuZGVjb2RlKGxlbmd0aEJ5dGVzLCAwKVswXSkudG9OdW1iZXIoKTtcbiAgICBjb25zdCBkYXRhQnl0ZXMgPSBkYXRhLnNsaWNlKG9mZnNldEFuZExlbmd0aCwgb2Zmc2V0QW5kTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICBpZiAoZGF0YUJ5dGVzLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yMTAoRXJyb3JDb2RlMTAuREVDT0RFX0VSUk9SLCBgSW52YWxpZCBzdGQgc3RyaW5nIGJ5dGUgZGF0YSBzaXplLmApO1xuICAgIH1cbiAgICByZXR1cm4gW3RvVXRmOFN0cmluZyhkYXRhQnl0ZXMpLCBvZmZzZXRBbmRMZW5ndGggKyBsZW5ndGhdO1xuICB9XG59O1xuXG4vLyBzcmMvZW5jb2RpbmcvY29kZXJzL1N0clNsaWNlQ29kZXIudHNcbmltcG9ydCB7IEVycm9yQ29kZSBhcyBFcnJvckNvZGUxMSwgRnVlbEVycm9yIGFzIEZ1ZWxFcnJvcjExIH0gZnJvbSBcIkBmdWVsLXRzL2Vycm9yc1wiO1xuaW1wb3J0IHsgYm4gYXMgYm44IH0gZnJvbSBcIkBmdWVsLXRzL21hdGhcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzIGFzIHRvVXRmOEJ5dGVzMiwgdG9VdGY4U3RyaW5nIGFzIHRvVXRmOFN0cmluZzIgfSBmcm9tIFwiQGZ1ZWwtdHMvdXRpbHNcIjtcbnZhciBTdHJTbGljZUNvZGVyID0gY2xhc3MgZXh0ZW5kcyBDb2RlciB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiU3RyU2xpY2VDb2RlclwiKTtcbiAgfVxuICBzdGF0aWMgbWVtb3J5U2l6ZSA9IDE7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwic3RyU2xpY2VcIiwgXCJzdHJcIiwgV09SRF9TSVpFKTtcbiAgfVxuICBlbmNvZGUodmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IHRvVXRmOEJ5dGVzMih2YWx1ZSk7XG4gICAgY29uc3QgbGVuZ3RoQnl0ZXMgPSBuZXcgQmlnTnVtYmVyQ29kZXIoXCJ1NjRcIikuZW5jb2RlKHZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsuLi5sZW5ndGhCeXRlcywgLi4uYnl0ZXNdKTtcbiAgfVxuICBkZWNvZGUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5lbmNvZGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yMTEoRXJyb3JDb2RlMTEuREVDT0RFX0VSUk9SLCBgSW52YWxpZCBzdHJpbmcgc2xpY2UgZGF0YSBzaXplLmApO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXRBbmRMZW5ndGggPSBvZmZzZXQgKyBXT1JEX1NJWkU7XG4gICAgY29uc3QgbGVuZ3RoQnl0ZXMgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0QW5kTGVuZ3RoKTtcbiAgICBjb25zdCBsZW5ndGggPSBibjgobmV3IEJpZ051bWJlckNvZGVyKFwidTY0XCIpLmRlY29kZShsZW5ndGhCeXRlcywgMClbMF0pLnRvTnVtYmVyKCk7XG4gICAgY29uc3QgYnl0ZXMgPSBkYXRhLnNsaWNlKG9mZnNldEFuZExlbmd0aCwgb2Zmc2V0QW5kTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3IxMShFcnJvckNvZGUxMS5ERUNPREVfRVJST1IsIGBJbnZhbGlkIHN0cmluZyBzbGljZSBieXRlIGRhdGEgc2l6ZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0b1V0ZjhTdHJpbmcyKGJ5dGVzKSwgb2Zmc2V0QW5kTGVuZ3RoICsgbGVuZ3RoXTtcbiAgfVxufTtcblxuLy8gc3JjL2VuY29kaW5nL2NvZGVycy9TdHJpbmdDb2Rlci50c1xuaW1wb3J0IHsgRXJyb3JDb2RlIGFzIEVycm9yQ29kZTEyLCBGdWVsRXJyb3IgYXMgRnVlbEVycm9yMTIgfSBmcm9tIFwiQGZ1ZWwtdHMvZXJyb3JzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyBhcyB0b1V0ZjhCeXRlczMsIHRvVXRmOFN0cmluZyBhcyB0b1V0ZjhTdHJpbmczIH0gZnJvbSBcIkBmdWVsLXRzL3V0aWxzXCI7XG52YXIgU3RyaW5nQ29kZXIgPSBjbGFzcyBleHRlbmRzIENvZGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJTdHJpbmdDb2RlclwiKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICBzdXBlcihcInN0cmluZ1wiLCBgc3RyWyR7bGVuZ3RofV1gLCBsZW5ndGgpO1xuICB9XG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IHRoaXMuZW5jb2RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjEyKEVycm9yQ29kZTEyLkVOQ09ERV9FUlJPUiwgYFZhbHVlIGxlbmd0aCBtaXNtYXRjaCBkdXJpbmcgZW5jb2RlLmApO1xuICAgIH1cbiAgICByZXR1cm4gdG9VdGY4Qnl0ZXMzKHZhbHVlKTtcbiAgfVxuICBkZWNvZGUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5lbmNvZGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yMTIoRXJyb3JDb2RlMTIuREVDT0RFX0VSUk9SLCBgSW52YWxpZCBzdHJpbmcgZGF0YSBzaXplLmApO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLmVuY29kZWRMZW5ndGgpO1xuICAgIGlmIChieXRlcy5sZW5ndGggIT09IHRoaXMuZW5jb2RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjEyKEVycm9yQ29kZTEyLkRFQ09ERV9FUlJPUiwgYEludmFsaWQgc3RyaW5nIGJ5dGUgZGF0YSBzaXplLmApO1xuICAgIH1cbiAgICByZXR1cm4gW3RvVXRmOFN0cmluZzMoYnl0ZXMpLCBvZmZzZXQgKyB0aGlzLmVuY29kZWRMZW5ndGhdO1xuICB9XG59O1xuXG4vLyBzcmMvZW5jb2RpbmcvY29kZXJzL1N0cnVjdENvZGVyLnRzXG5pbXBvcnQgeyBFcnJvckNvZGUgYXMgRXJyb3JDb2RlMTMsIEZ1ZWxFcnJvciBhcyBGdWVsRXJyb3IxMyB9IGZyb20gXCJAZnVlbC10cy9lcnJvcnNcIjtcbmltcG9ydCB7IGNvbmNhdEJ5dGVzIH0gZnJvbSBcIkBmdWVsLXRzL3V0aWxzXCI7XG52YXIgU3RydWN0Q29kZXIgPSBjbGFzcyBleHRlbmRzIENvZGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJTdHJ1Y3RDb2RlclwiKTtcbiAgfVxuICBuYW1lO1xuICBjb2RlcnM7XG4gICNoYXNOZXN0ZWRPcHRpb247XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGNvZGVycykge1xuICAgIGNvbnN0IGVuY29kZWRMZW5ndGggPSBPYmplY3QudmFsdWVzKGNvZGVycykucmVkdWNlKFxuICAgICAgKGFjYywgY29kZXIpID0+IGFjYyArIGNvZGVyLmVuY29kZWRMZW5ndGgsXG4gICAgICAwXG4gICAgKTtcbiAgICBzdXBlcihcInN0cnVjdFwiLCBgc3RydWN0ICR7bmFtZX1gLCBlbmNvZGVkTGVuZ3RoKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY29kZXJzID0gY29kZXJzO1xuICAgIHRoaXMuI2hhc05lc3RlZE9wdGlvbiA9IGhhc05lc3RlZE9wdGlvbihjb2RlcnMpO1xuICB9XG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIHJldHVybiBjb25jYXRCeXRlcyhcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29kZXJzKS5tYXAoKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZENvZGVyID0gdGhpcy5jb2RlcnNbZmllbGROYW1lXTtcbiAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IHZhbHVlW2ZpZWxkTmFtZV07XG4gICAgICAgIGlmICghKGZpZWxkQ29kZXIgaW5zdGFuY2VvZiBPcHRpb25Db2RlcikgJiYgZmllbGRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjEzKFxuICAgICAgICAgICAgRXJyb3JDb2RlMTMuRU5DT0RFX0VSUk9SLFxuICAgICAgICAgICAgYEludmFsaWQgJHt0aGlzLnR5cGV9LiBGaWVsZCBcIiR7ZmllbGROYW1lfVwiIG5vdCBwcmVzZW50LmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZENvZGVyLmVuY29kZShmaWVsZFZhbHVlKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBkZWNvZGUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgaWYgKCF0aGlzLiNoYXNOZXN0ZWRPcHRpb24gJiYgZGF0YS5sZW5ndGggPCB0aGlzLmVuY29kZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3IxMyhFcnJvckNvZGUxMy5ERUNPREVfRVJST1IsIGBJbnZhbGlkIHN0cnVjdCBkYXRhIHNpemUuYCk7XG4gICAgfVxuICAgIGxldCBuZXdPZmZzZXQgPSBvZmZzZXQ7XG4gICAgY29uc3QgZGVjb2RlZFZhbHVlID0gT2JqZWN0LmtleXModGhpcy5jb2RlcnMpLnJlZHVjZSgob2JqLCBmaWVsZE5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGZpZWxkQ29kZXIgPSB0aGlzLmNvZGVyc1tmaWVsZE5hbWVdO1xuICAgICAgbGV0IGRlY29kZWQ7XG4gICAgICBbZGVjb2RlZCwgbmV3T2Zmc2V0XSA9IGZpZWxkQ29kZXIuZGVjb2RlKGRhdGEsIG5ld09mZnNldCk7XG4gICAgICBvYmpbZmllbGROYW1lXSA9IGRlY29kZWQ7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gW2RlY29kZWRWYWx1ZSwgbmV3T2Zmc2V0XTtcbiAgfVxufTtcblxuLy8gc3JjL2VuY29kaW5nL2NvZGVycy9UdXBsZUNvZGVyLnRzXG5pbXBvcnQgeyBFcnJvckNvZGUgYXMgRXJyb3JDb2RlMTQsIEZ1ZWxFcnJvciBhcyBGdWVsRXJyb3IxNCB9IGZyb20gXCJAZnVlbC10cy9lcnJvcnNcIjtcbmltcG9ydCB7IGNvbmNhdEJ5dGVzIGFzIGNvbmNhdEJ5dGVzMiB9IGZyb20gXCJAZnVlbC10cy91dGlsc1wiO1xudmFyIFR1cGxlQ29kZXIgPSBjbGFzcyBleHRlbmRzIENvZGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJUdXBsZUNvZGVyXCIpO1xuICB9XG4gIGNvZGVycztcbiAgI2hhc05lc3RlZE9wdGlvbjtcbiAgY29uc3RydWN0b3IoY29kZXJzKSB7XG4gICAgY29uc3QgZW5jb2RlZExlbmd0aCA9IGNvZGVycy5yZWR1Y2UoKGFjYywgY29kZXIpID0+IGFjYyArIGNvZGVyLmVuY29kZWRMZW5ndGgsIDApO1xuICAgIHN1cGVyKFwidHVwbGVcIiwgYCgke2NvZGVycy5tYXAoKGNvZGVyKSA9PiBjb2Rlci50eXBlKS5qb2luKFwiLCBcIil9KWAsIGVuY29kZWRMZW5ndGgpO1xuICAgIHRoaXMuY29kZXJzID0gY29kZXJzO1xuICAgIHRoaXMuI2hhc05lc3RlZE9wdGlvbiA9IGhhc05lc3RlZE9wdGlvbihjb2RlcnMpO1xuICB9XG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmNvZGVycy5sZW5ndGggIT09IHZhbHVlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjE0KEVycm9yQ29kZTE0LkVOQ09ERV9FUlJPUiwgYFR5cGVzL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2guYCk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXRCeXRlczIodGhpcy5jb2RlcnMubWFwKChjb2RlciwgaSkgPT4gY29kZXIuZW5jb2RlKHZhbHVlW2ldKSkpO1xuICB9XG4gIGRlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAoIXRoaXMuI2hhc05lc3RlZE9wdGlvbiAmJiBkYXRhLmxlbmd0aCA8IHRoaXMuZW5jb2RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjE0KEVycm9yQ29kZTE0LkRFQ09ERV9FUlJPUiwgYEludmFsaWQgdHVwbGUgZGF0YSBzaXplLmApO1xuICAgIH1cbiAgICBsZXQgbmV3T2Zmc2V0ID0gb2Zmc2V0O1xuICAgIGNvbnN0IGRlY29kZWRWYWx1ZSA9IHRoaXMuY29kZXJzLm1hcCgoY29kZXIpID0+IHtcbiAgICAgIGxldCBkZWNvZGVkO1xuICAgICAgW2RlY29kZWQsIG5ld09mZnNldF0gPSBjb2Rlci5kZWNvZGUoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgIH0pO1xuICAgIHJldHVybiBbZGVjb2RlZFZhbHVlLCBuZXdPZmZzZXRdO1xuICB9XG59O1xuXG4vLyBzcmMvZW5jb2RpbmcvY29kZXJzL1ZlY0NvZGVyLnRzXG5pbXBvcnQgeyBFcnJvckNvZGUgYXMgRXJyb3JDb2RlMTUsIEZ1ZWxFcnJvciBhcyBGdWVsRXJyb3IxNSB9IGZyb20gXCJAZnVlbC10cy9lcnJvcnNcIjtcbmltcG9ydCB7IGJuIGFzIGJuOSB9IGZyb20gXCJAZnVlbC10cy9tYXRoXCI7XG5pbXBvcnQgeyBjb25jYXRCeXRlcyBhcyBjb25jYXRCeXRlczMgfSBmcm9tIFwiQGZ1ZWwtdHMvdXRpbHNcIjtcbnZhciBWZWNDb2RlciA9IGNsYXNzIGV4dGVuZHMgQ29kZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIlZlY0NvZGVyXCIpO1xuICB9XG4gIGNvZGVyO1xuICAjaGFzTmVzdGVkT3B0aW9uO1xuICBjb25zdHJ1Y3Rvcihjb2Rlcikge1xuICAgIHN1cGVyKFwic3RydWN0XCIsIGBzdHJ1Y3QgVmVjYCwgV09SRF9TSVpFKTtcbiAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgdGhpcy4jaGFzTmVzdGVkT3B0aW9uID0gaGFzTmVzdGVkT3B0aW9uKFtjb2Rlcl0pO1xuICB9XG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIWlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3IxNShcbiAgICAgICAgRXJyb3JDb2RlMTUuRU5DT0RFX0VSUk9SLFxuICAgICAgICBgRXhwZWN0ZWQgYXJyYXkgdmFsdWUsIG9yIGEgVWludDhBcnJheS4gWW91IGNhbiB1c2UgYXJyYXlpZnkgdG8gY29udmVydCBhIHZhbHVlIHRvIGEgVWludDhBcnJheS5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGhDb2RlciA9IG5ldyBCaWdOdW1iZXJDb2RlcihcInU2NFwiKTtcbiAgICBpZiAoaXNVaW50OEFycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsuLi5sZW5ndGhDb2Rlci5lbmNvZGUodmFsdWUubGVuZ3RoKSwgLi4udmFsdWVdKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSB2YWx1ZS5tYXAoKHYpID0+IHRoaXMuY29kZXIuZW5jb2RlKHYpKTtcbiAgICBjb25zdCBsZW5ndGhCeXRlcyA9IGxlbmd0aENvZGVyLmVuY29kZSh2YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbLi4ubGVuZ3RoQnl0ZXMsIC4uLmNvbmNhdEJ5dGVzMyhieXRlcyldKTtcbiAgfVxuICBkZWNvZGUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgaWYgKCF0aGlzLiNoYXNOZXN0ZWRPcHRpb24gJiYgZGF0YS5sZW5ndGggPCB0aGlzLmVuY29kZWRMZW5ndGggfHwgZGF0YS5sZW5ndGggPiBNQVhfQllURVMpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3IxNShFcnJvckNvZGUxNS5ERUNPREVfRVJST1IsIGBJbnZhbGlkIHZlYyBkYXRhIHNpemUuYCk7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldEFuZExlbmd0aCA9IG9mZnNldCArIFdPUkRfU0laRTtcbiAgICBjb25zdCBsZW5ndGhCeXRlcyA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXRBbmRMZW5ndGgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGJuOShuZXcgQmlnTnVtYmVyQ29kZXIoXCJ1NjRcIikuZGVjb2RlKGxlbmd0aEJ5dGVzLCAwKVswXSkudG9OdW1iZXIoKTtcbiAgICBjb25zdCBkYXRhTGVuZ3RoID0gbGVuZ3RoICogdGhpcy5jb2Rlci5lbmNvZGVkTGVuZ3RoO1xuICAgIGNvbnN0IGRhdGFCeXRlcyA9IGRhdGEuc2xpY2Uob2Zmc2V0QW5kTGVuZ3RoLCBvZmZzZXRBbmRMZW5ndGggKyBkYXRhTGVuZ3RoKTtcbiAgICBpZiAoIXRoaXMuI2hhc05lc3RlZE9wdGlvbiAmJiBkYXRhQnl0ZXMubGVuZ3RoICE9PSBkYXRhTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yMTUoRXJyb3JDb2RlMTUuREVDT0RFX0VSUk9SLCBgSW52YWxpZCB2ZWMgYnl0ZSBkYXRhIHNpemUuYCk7XG4gICAgfVxuICAgIGxldCBuZXdPZmZzZXQgPSBvZmZzZXRBbmRMZW5ndGg7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgW2RlY29kZWQsIG9wdGlvbk9mZnNldF0gPSB0aGlzLmNvZGVyLmRlY29kZShkYXRhLCBuZXdPZmZzZXQpO1xuICAgICAgY2h1bmtzLnB1c2goZGVjb2RlZCk7XG4gICAgICBuZXdPZmZzZXQgPSBvcHRpb25PZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiBbY2h1bmtzLCBuZXdPZmZzZXRdO1xuICB9XG59O1xuXG4vLyBzcmMvSW50ZXJmYWNlLnRzXG5pbXBvcnQgeyBFcnJvckNvZGUgYXMgRXJyb3JDb2RlMjEsIEZ1ZWxFcnJvciBhcyBGdWVsRXJyb3IyMSB9IGZyb20gXCJAZnVlbC10cy9lcnJvcnNcIjtcbmltcG9ydCB7IGFycmF5aWZ5IGFzIGFycmF5aWZ5NCB9IGZyb20gXCJAZnVlbC10cy91dGlsc1wiO1xuXG4vLyBzcmMvUmVzb2x2ZWRBYmlUeXBlLnRzXG5pbXBvcnQgeyBGdWVsRXJyb3IgYXMgRnVlbEVycm9yMTcsIEVycm9yQ29kZSBhcyBFcnJvckNvZGUxNyB9IGZyb20gXCJAZnVlbC10cy9lcnJvcnNcIjtcblxuLy8gc3JjL3V0aWxzL2pzb24tYWJpLnRzXG5pbXBvcnQgeyBFcnJvckNvZGUgYXMgRXJyb3JDb2RlMTYsIEZ1ZWxFcnJvciBhcyBGdWVsRXJyb3IxNiB9IGZyb20gXCJAZnVlbC10cy9lcnJvcnNcIjtcbnZhciBnZXRFbmNvZGluZ1ZlcnNpb24gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChlbmNvZGluZykgPT4ge1xuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSB2b2lkIDA6XG4gICAgY2FzZSBFTkNPRElOR19WMTpcbiAgICAgIHJldHVybiBFTkNPRElOR19WMTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjE2KFxuICAgICAgICBFcnJvckNvZGUxNi5VTlNVUFBPUlRFRF9FTkNPRElOR19WRVJTSU9OLFxuICAgICAgICBgRW5jb2RpbmcgdmVyc2lvbiAnJHtlbmNvZGluZ30nIGlzIHVuc3VwcG9ydGVkLmBcbiAgICAgICk7XG4gIH1cbn0sIFwiZ2V0RW5jb2RpbmdWZXJzaW9uXCIpO1xudmFyIGZpbmRUeXBlQnlJZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGFiaSwgdHlwZUlkKSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBhYmkudHlwZXMuZmluZCgodCkgPT4gdC50eXBlSWQgPT09IHR5cGVJZCk7XG4gIGlmICghdHlwZSkge1xuICAgIHRocm93IG5ldyBGdWVsRXJyb3IxNihcbiAgICAgIEVycm9yQ29kZTE2LlRZUEVfTk9UX0ZPVU5ELFxuICAgICAgYFR5cGUgd2l0aCB0eXBlSWQgJyR7dHlwZUlkfScgZG9lc24ndCBleGlzdCBpbiB0aGUgQUJJLmBcbiAgICApO1xuICB9XG4gIHJldHVybiB0eXBlO1xufSwgXCJmaW5kVHlwZUJ5SWRcIik7XG52YXIgZmluZE5vblZvaWRJbnB1dHMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChhYmksIGlucHV0cykgPT4gaW5wdXRzLmZpbHRlcigoaW5wdXQpID0+IGZpbmRUeXBlQnlJZChhYmksIGlucHV0LnR5cGUpLnR5cGUgIT09IFZPSURfVFlQRSksIFwiZmluZE5vblZvaWRJbnB1dHNcIik7XG52YXIgZmluZFZlY3RvckJ1ZmZlckFyZ3VtZW50ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoY29tcG9uZW50cykgPT4ge1xuICBjb25zdCBidWZmZXJDb21wb25lbnQgPSBjb21wb25lbnRzLmZpbmQoKGMpID0+IGMubmFtZSA9PT0gXCJidWZcIik7XG4gIGNvbnN0IGJ1ZmZlclR5cGVBcmd1bWVudCA9IGJ1ZmZlckNvbXBvbmVudD8ub3JpZ2luYWxUeXBlQXJndW1lbnRzPy5bMF07XG4gIGlmICghYnVmZmVyQ29tcG9uZW50IHx8ICFidWZmZXJUeXBlQXJndW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRnVlbEVycm9yMTYoXG4gICAgICBFcnJvckNvZGUxNi5JTlZBTElEX0NPTVBPTkVOVCxcbiAgICAgIGBUaGUgVmVjIHR5cGUgcHJvdmlkZWQgaXMgbWlzc2luZyBvciBoYXMgYSBtYWxmb3JtZWQgJ2J1ZicgY29tcG9uZW50LmBcbiAgICApO1xuICB9XG4gIHJldHVybiBidWZmZXJUeXBlQXJndW1lbnQ7XG59LCBcImZpbmRWZWN0b3JCdWZmZXJBcmd1bWVudFwiKTtcblxuLy8gc3JjL1Jlc29sdmVkQWJpVHlwZS50c1xudmFyIFJlc29sdmVkQWJpVHlwZSA9IGNsYXNzIF9SZXNvbHZlZEFiaVR5cGUge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIlJlc29sdmVkQWJpVHlwZVwiKTtcbiAgfVxuICBhYmk7XG4gIG5hbWU7XG4gIHR5cGU7XG4gIG9yaWdpbmFsVHlwZUFyZ3VtZW50cztcbiAgY29tcG9uZW50cztcbiAgY29uc3RydWN0b3IoYWJpLCBhcmd1bWVudCkge1xuICAgIHRoaXMuYWJpID0gYWJpO1xuICAgIHRoaXMubmFtZSA9IGFyZ3VtZW50Lm5hbWU7XG4gICAgY29uc3QganNvbkFCSVR5cGUgPSBmaW5kVHlwZUJ5SWQoYWJpLCBhcmd1bWVudC50eXBlKTtcbiAgICBpZiAoanNvbkFCSVR5cGUudHlwZS5sZW5ndGggPiAyNTYpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3IxNyhcbiAgICAgICAgRXJyb3JDb2RlMTcuSU5WQUxJRF9DT01QT05FTlQsXG4gICAgICAgIGBUaGUgcHJvdmlkZWQgQUJJIHR5cGUgaXMgdG9vIGxvbmc6ICR7anNvbkFCSVR5cGUudHlwZX0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy50eXBlID0ganNvbkFCSVR5cGUudHlwZTtcbiAgICB0aGlzLm9yaWdpbmFsVHlwZUFyZ3VtZW50cyA9IGFyZ3VtZW50LnR5cGVBcmd1bWVudHM7XG4gICAgdGhpcy5jb21wb25lbnRzID0gX1Jlc29sdmVkQWJpVHlwZS5nZXRSZXNvbHZlZEdlbmVyaWNDb21wb25lbnRzKFxuICAgICAgYWJpLFxuICAgICAgYXJndW1lbnQsXG4gICAgICBqc29uQUJJVHlwZS5jb21wb25lbnRzLFxuICAgICAganNvbkFCSVR5cGUudHlwZVBhcmFtZXRlcnMgPz8gX1Jlc29sdmVkQWJpVHlwZS5nZXRJbXBsaWNpdEdlbmVyaWNUeXBlUGFyYW1ldGVycyhhYmksIGpzb25BQklUeXBlLmNvbXBvbmVudHMpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgZ2V0UmVzb2x2ZWRHZW5lcmljQ29tcG9uZW50cyhhYmksIGFyZywgY29tcG9uZW50cywgdHlwZVBhcmFtZXRlcnMpIHtcbiAgICBpZiAoY29tcG9uZW50cyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlUGFyYW1ldGVycyA9PT0gbnVsbCB8fCB0eXBlUGFyYW1ldGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRzLm1hcCgoYykgPT4gbmV3IF9SZXNvbHZlZEFiaVR5cGUoYWJpLCBjKSk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzQW5kQXJnc01hcCA9IHR5cGVQYXJhbWV0ZXJzLnJlZHVjZShcbiAgICAgIChvYmosIHR5cGVQYXJhbWV0ZXIsIHR5cGVQYXJhbWV0ZXJJbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBvID0geyAuLi5vYmogfTtcbiAgICAgICAgb1t0eXBlUGFyYW1ldGVyXSA9IHN0cnVjdHVyZWRDbG9uZShcbiAgICAgICAgICBhcmcudHlwZUFyZ3VtZW50cz8uW3R5cGVQYXJhbWV0ZXJJbmRleF1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9LFxuICAgICAge31cbiAgICApO1xuICAgIGNvbnN0IHJlc29sdmVkQ29tcG9uZW50cyA9IHRoaXMucmVzb2x2ZUdlbmVyaWNBcmdUeXBlcyhcbiAgICAgIGFiaSxcbiAgICAgIGNvbXBvbmVudHMsXG4gICAgICB0eXBlUGFyYW1ldGVyc0FuZEFyZ3NNYXBcbiAgICApO1xuICAgIHJldHVybiByZXNvbHZlZENvbXBvbmVudHMubWFwKChjKSA9PiBuZXcgX1Jlc29sdmVkQWJpVHlwZShhYmksIGMpKTtcbiAgfVxuICBzdGF0aWMgcmVzb2x2ZUdlbmVyaWNBcmdUeXBlcyhhYmksIGFyZ3MsIHR5cGVQYXJhbWV0ZXJzQW5kQXJnc01hcCkge1xuICAgIHJldHVybiBhcmdzLm1hcCgoYXJnKSA9PiB7XG4gICAgICBpZiAodHlwZVBhcmFtZXRlcnNBbmRBcmdzTWFwW2FyZy50eXBlXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udHlwZVBhcmFtZXRlcnNBbmRBcmdzTWFwW2FyZy50eXBlXSxcbiAgICAgICAgICBuYW1lOiBhcmcubmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGFyZy50eXBlQXJndW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RydWN0dXJlZENsb25lKGFyZyksXG4gICAgICAgICAgdHlwZUFyZ3VtZW50czogdGhpcy5yZXNvbHZlR2VuZXJpY0FyZ1R5cGVzKFxuICAgICAgICAgICAgYWJpLFxuICAgICAgICAgICAgYXJnLnR5cGVBcmd1bWVudHMsXG4gICAgICAgICAgICB0eXBlUGFyYW1ldGVyc0FuZEFyZ3NNYXBcbiAgICAgICAgICApXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBhcmdUeXBlID0gZmluZFR5cGVCeUlkKGFiaSwgYXJnLnR5cGUpO1xuICAgICAgY29uc3QgaW1wbGljaXRUeXBlUGFyYW1ldGVycyA9IHRoaXMuZ2V0SW1wbGljaXRHZW5lcmljVHlwZVBhcmFtZXRlcnMoYWJpLCBhcmdUeXBlLmNvbXBvbmVudHMpO1xuICAgICAgaWYgKGltcGxpY2l0VHlwZVBhcmFtZXRlcnMgJiYgaW1wbGljaXRUeXBlUGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc3RydWN0dXJlZENsb25lKGFyZyksXG4gICAgICAgICAgdHlwZUFyZ3VtZW50czogaW1wbGljaXRUeXBlUGFyYW1ldGVycy5tYXAoKGl0cCkgPT4gdHlwZVBhcmFtZXRlcnNBbmRBcmdzTWFwW2l0cF0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbXBsaWNpdEdlbmVyaWNUeXBlUGFyYW1ldGVycyhhYmksIGFyZ3MsIGltcGxpY2l0R2VuZXJpY1BhcmFtZXRlcnNQYXJhbSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGltcGxpY2l0R2VuZXJpY1BhcmFtZXRlcnMgPSBpbXBsaWNpdEdlbmVyaWNQYXJhbWV0ZXJzUGFyYW0gPz8gW107XG4gICAgYXJncy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBjb25zdCBhcmdUeXBlID0gZmluZFR5cGVCeUlkKGFiaSwgYS50eXBlKTtcbiAgICAgIGlmIChnZW5lcmljUmVnRXgudGVzdChhcmdUeXBlLnR5cGUpKSB7XG4gICAgICAgIGltcGxpY2l0R2VuZXJpY1BhcmFtZXRlcnMucHVzaChhcmdUeXBlLnR5cGVJZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhLnR5cGVBcmd1bWVudHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0SW1wbGljaXRHZW5lcmljVHlwZVBhcmFtZXRlcnMoYWJpLCBhLnR5cGVBcmd1bWVudHMsIGltcGxpY2l0R2VuZXJpY1BhcmFtZXRlcnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBpbXBsaWNpdEdlbmVyaWNQYXJhbWV0ZXJzLmxlbmd0aCA+IDAgPyBpbXBsaWNpdEdlbmVyaWNQYXJhbWV0ZXJzIDogbnVsbDtcbiAgfVxuICBnZXRTaWduYXR1cmUoKSB7XG4gICAgY29uc3QgcHJlZml4ID0gdGhpcy5nZXRBcmdTaWduYXR1cmVQcmVmaXgoKTtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5nZXRBcmdTaWduYXR1cmVDb250ZW50KCk7XG4gICAgcmV0dXJuIGAke3ByZWZpeH0ke2NvbnRlbnR9YDtcbiAgfVxuICBnZXRBcmdTaWduYXR1cmVQcmVmaXgoKSB7XG4gICAgY29uc3Qgc3RydWN0TWF0Y2ggPSBzdHJ1Y3RSZWdFeC50ZXN0KHRoaXMudHlwZSk7XG4gICAgaWYgKHN0cnVjdE1hdGNoKSB7XG4gICAgICByZXR1cm4gXCJzXCI7XG4gICAgfVxuICAgIGNvbnN0IGFycmF5TWF0Y2ggPSBhcnJheVJlZ0V4LnRlc3QodGhpcy50eXBlKTtcbiAgICBpZiAoYXJyYXlNYXRjaCkge1xuICAgICAgcmV0dXJuIFwiYVwiO1xuICAgIH1cbiAgICBjb25zdCBlbnVtTWF0Y2ggPSBlbnVtUmVnRXgudGVzdCh0aGlzLnR5cGUpO1xuICAgIGlmIChlbnVtTWF0Y2gpIHtcbiAgICAgIHJldHVybiBcImVcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZ2V0QXJnU2lnbmF0dXJlQ29udGVudCgpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSBcInJhdyB1bnR5cGVkIHB0clwiKSB7XG4gICAgICByZXR1cm4gXCJyYXdwdHJcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gXCJyYXcgdW50eXBlZCBzbGljZVwiKSB7XG4gICAgICByZXR1cm4gXCJyYXdzbGljZVwiO1xuICAgIH1cbiAgICBjb25zdCBzdHJNYXRjaCA9IHN0cmluZ1JlZ0V4LmV4ZWModGhpcy50eXBlKT8uZ3JvdXBzO1xuICAgIGlmIChzdHJNYXRjaCkge1xuICAgICAgcmV0dXJuIGBzdHJbJHtzdHJNYXRjaC5sZW5ndGh9XWA7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbXBvbmVudHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfVxuICAgIGNvbnN0IGFycmF5TWF0Y2ggPSBhcnJheVJlZ0V4LmV4ZWModGhpcy50eXBlKT8uZ3JvdXBzO1xuICAgIGlmIChhcnJheU1hdGNoKSB7XG4gICAgICByZXR1cm4gYFske3RoaXMuY29tcG9uZW50c1swXS5nZXRTaWduYXR1cmUoKX07JHthcnJheU1hdGNoLmxlbmd0aH1dYDtcbiAgICB9XG4gICAgY29uc3QgdHlwZUFyZ3VtZW50c1NpZ25hdHVyZSA9IHRoaXMub3JpZ2luYWxUeXBlQXJndW1lbnRzICE9PSBudWxsID8gYDwke3RoaXMub3JpZ2luYWxUeXBlQXJndW1lbnRzLm1hcCgoYSkgPT4gbmV3IF9SZXNvbHZlZEFiaVR5cGUodGhpcy5hYmksIGEpLmdldFNpZ25hdHVyZSgpKS5qb2luKFwiLFwiKX0+YCA6IFwiXCI7XG4gICAgY29uc3QgY29tcG9uZW50c1NpZ25hdHVyZSA9IGAoJHt0aGlzLmNvbXBvbmVudHMubWFwKChjKSA9PiBjLmdldFNpZ25hdHVyZSgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICByZXR1cm4gYCR7dHlwZUFyZ3VtZW50c1NpZ25hdHVyZX0ke2NvbXBvbmVudHNTaWduYXR1cmV9YDtcbiAgfVxufTtcblxuLy8gc3JjL2VuY29kaW5nL3N0cmF0ZWdpZXMvZ2V0Q29kZXJGb3JFbmNvZGluZy50c1xuaW1wb3J0IHsgRXJyb3JDb2RlIGFzIEVycm9yQ29kZTE5LCBGdWVsRXJyb3IgYXMgRnVlbEVycm9yMTkgfSBmcm9tIFwiQGZ1ZWwtdHMvZXJyb3JzXCI7XG5cbi8vIHNyYy9lbmNvZGluZy9zdHJhdGVnaWVzL2dldENvZGVyVjEudHNcbmltcG9ydCB7IEVycm9yQ29kZSBhcyBFcnJvckNvZGUxOCwgRnVlbEVycm9yIGFzIEZ1ZWxFcnJvcjE4IH0gZnJvbSBcIkBmdWVsLXRzL2Vycm9yc1wiO1xuXG4vLyBzcmMvZW5jb2RpbmcvY29kZXJzL1ZvaWRDb2Rlci50c1xudmFyIFZvaWRDb2RlciA9IGNsYXNzIGV4dGVuZHMgQ29kZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIlZvaWRDb2RlclwiKTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInZvaWRcIiwgVk9JRF9UWVBFLCAwKTtcbiAgfVxuICBlbmNvZGUoX3ZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtdKTtcbiAgfVxuICBkZWNvZGUoX2RhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBbdm9pZCAwLCBvZmZzZXRdO1xuICB9XG59O1xuXG4vLyBzcmMvZW5jb2Rpbmcvc3RyYXRlZ2llcy9nZXRDb2RlcnMudHNcbmZ1bmN0aW9uIGdldENvZGVycyhjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgZ2V0Q29kZXI6IGdldENvZGVyMiB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIGNvbXBvbmVudHMucmVkdWNlKChvYmosIGNvbXBvbmVudCkgPT4ge1xuICAgIGNvbnN0IG8gPSBvYmo7XG4gICAgb1tjb21wb25lbnQubmFtZV0gPSBnZXRDb2RlcjIoY29tcG9uZW50LCBvcHRpb25zKTtcbiAgICByZXR1cm4gbztcbiAgfSwge30pO1xufVxuX19uYW1lKGdldENvZGVycywgXCJnZXRDb2RlcnNcIik7XG5cbi8vIHNyYy9lbmNvZGluZy9zdHJhdGVnaWVzL2dldENvZGVyVjEudHNcbnZhciBnZXRDb2RlciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHJlc29sdmVkQWJpVHlwZSwgX29wdGlvbnMpID0+IHtcbiAgc3dpdGNoIChyZXNvbHZlZEFiaVR5cGUudHlwZSkge1xuICAgIGNhc2UgVThfQ09ERVJfVFlQRTpcbiAgICBjYXNlIFUxNl9DT0RFUl9UWVBFOlxuICAgIGNhc2UgVTMyX0NPREVSX1RZUEU6XG4gICAgICByZXR1cm4gbmV3IE51bWJlckNvZGVyKHJlc29sdmVkQWJpVHlwZS50eXBlKTtcbiAgICBjYXNlIFU2NF9DT0RFUl9UWVBFOlxuICAgIGNhc2UgUkFXX1BUUl9DT0RFUl9UWVBFOlxuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXJDb2RlcihcInU2NFwiKTtcbiAgICBjYXNlIFUyNTZfQ09ERVJfVFlQRTpcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyQ29kZXIoXCJ1MjU2XCIpO1xuICAgIGNhc2UgUkFXX1NMSUNFX0NPREVSX1RZUEU6XG4gICAgICByZXR1cm4gbmV3IFJhd1NsaWNlQ29kZXIoKTtcbiAgICBjYXNlIEJPT0xfQ09ERVJfVFlQRTpcbiAgICAgIHJldHVybiBuZXcgQm9vbGVhbkNvZGVyKCk7XG4gICAgY2FzZSBCMjU2X0NPREVSX1RZUEU6XG4gICAgICByZXR1cm4gbmV3IEIyNTZDb2RlcigpO1xuICAgIGNhc2UgQjUxMl9DT0RFUl9UWVBFOlxuICAgICAgcmV0dXJuIG5ldyBCNTEyQ29kZXIoKTtcbiAgICBjYXNlIEJZVEVTX0NPREVSX1RZUEU6XG4gICAgICByZXR1cm4gbmV3IEJ5dGVDb2RlcigpO1xuICAgIGNhc2UgU1REX1NUUklOR19DT0RFUl9UWVBFOlxuICAgICAgcmV0dXJuIG5ldyBTdGRTdHJpbmdDb2RlcigpO1xuICAgIGNhc2UgU1RSX1NMSUNFX0NPREVSX1RZUEU6XG4gICAgICByZXR1cm4gbmV3IFN0clNsaWNlQ29kZXIoKTtcbiAgICBjYXNlIFZPSURfVFlQRTpcbiAgICAgIHJldHVybiBuZXcgVm9pZENvZGVyKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG4gIGNvbnN0IHN0cmluZ01hdGNoID0gc3RyaW5nUmVnRXguZXhlYyhyZXNvbHZlZEFiaVR5cGUudHlwZSk/Lmdyb3VwcztcbiAgaWYgKHN0cmluZ01hdGNoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoc3RyaW5nTWF0Y2gubGVuZ3RoLCAxMCk7XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdDb2RlcihsZW5ndGgpO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSByZXNvbHZlZEFiaVR5cGUuY29tcG9uZW50cztcbiAgY29uc3QgYXJyYXlNYXRjaCA9IGFycmF5UmVnRXguZXhlYyhyZXNvbHZlZEFiaVR5cGUudHlwZSk/Lmdyb3VwcztcbiAgaWYgKGFycmF5TWF0Y2gpIHtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChhcnJheU1hdGNoLmxlbmd0aCwgMTApO1xuICAgIGNvbnN0IGFyZyA9IGNvbXBvbmVudHNbMF07XG4gICAgaWYgKCFhcmcpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3IxOChcbiAgICAgICAgRXJyb3JDb2RlMTguSU5WQUxJRF9DT01QT05FTlQsXG4gICAgICAgIGBUaGUgcHJvdmlkZWQgQXJyYXkgdHlwZSBpcyBtaXNzaW5nIGFuIGl0ZW0gb2YgJ2NvbXBvbmVudCcuYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYXJyYXlFbGVtZW50Q29kZXIgPSBnZXRDb2RlcihhcmcpO1xuICAgIHJldHVybiBuZXcgQXJyYXlDb2RlcihhcnJheUVsZW1lbnRDb2RlciwgbGVuZ3RoKTtcbiAgfVxuICBpZiAocmVzb2x2ZWRBYmlUeXBlLnR5cGUgPT09IFZFQ19DT0RFUl9UWVBFKSB7XG4gICAgY29uc3QgYXJnID0gZmluZFZlY3RvckJ1ZmZlckFyZ3VtZW50KGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGFyZ1R5cGUgPSBuZXcgUmVzb2x2ZWRBYmlUeXBlKHJlc29sdmVkQWJpVHlwZS5hYmksIGFyZyk7XG4gICAgY29uc3QgaXRlbUNvZGVyID0gZ2V0Q29kZXIoYXJnVHlwZSwgeyBlbmNvZGluZzogRU5DT0RJTkdfVjEgfSk7XG4gICAgcmV0dXJuIG5ldyBWZWNDb2RlcihpdGVtQ29kZXIpO1xuICB9XG4gIGNvbnN0IGNvZGVyTmFtZSA9IHJlc29sdmVkQWJpVHlwZS50eXBlLm1hdGNoKGZ1bGxOYW1lUmVnRXhNYXRjaCk/LlswXTtcbiAgY29uc3Qgc3RydWN0TWF0Y2ggPSBzdHJ1Y3RSZWdFeC50ZXN0KHJlc29sdmVkQWJpVHlwZS50eXBlKTtcbiAgaWYgKHN0cnVjdE1hdGNoICYmIGNvZGVyTmFtZSkge1xuICAgIGNvbnN0IGNvZGVycyA9IGdldENvZGVycyhjb21wb25lbnRzLCB7IGdldENvZGVyIH0pO1xuICAgIHJldHVybiBuZXcgU3RydWN0Q29kZXIoY29kZXJOYW1lLCBjb2RlcnMpO1xuICB9XG4gIGNvbnN0IGVudW1NYXRjaCA9IGVudW1SZWdFeC50ZXN0KHJlc29sdmVkQWJpVHlwZS50eXBlKTtcbiAgaWYgKGVudW1NYXRjaCAmJiBjb2Rlck5hbWUpIHtcbiAgICBjb25zdCBjb2RlcnMgPSBnZXRDb2RlcnMoY29tcG9uZW50cywgeyBnZXRDb2RlciB9KTtcbiAgICBjb25zdCBpc09wdGlvbkVudW0gPSByZXNvbHZlZEFiaVR5cGUudHlwZSA9PT0gT1BUSU9OX0NPREVSX1RZUEU7XG4gICAgaWYgKGlzT3B0aW9uRW51bSkge1xuICAgICAgcmV0dXJuIG5ldyBPcHRpb25Db2Rlcihjb2Rlck5hbWUsIGNvZGVycyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRW51bUNvZGVyKGNvZGVyTmFtZSwgY29kZXJzKTtcbiAgfVxuICBjb25zdCB0dXBsZU1hdGNoID0gdHVwbGVSZWdFeC5leGVjKHJlc29sdmVkQWJpVHlwZS50eXBlKT8uZ3JvdXBzO1xuICBpZiAodHVwbGVNYXRjaCkge1xuICAgIGNvbnN0IGNvZGVycyA9IGNvbXBvbmVudHMubWFwKChjb21wb25lbnQpID0+IGdldENvZGVyKGNvbXBvbmVudCwgeyBlbmNvZGluZzogRU5DT0RJTkdfVjEgfSkpO1xuICAgIHJldHVybiBuZXcgVHVwbGVDb2Rlcihjb2RlcnMpO1xuICB9XG4gIHRocm93IG5ldyBGdWVsRXJyb3IxOChcbiAgICBFcnJvckNvZGUxOC5DT0RFUl9OT1RfRk9VTkQsXG4gICAgYENvZGVyIG5vdCBmb3VuZDogJHtKU09OLnN0cmluZ2lmeShyZXNvbHZlZEFiaVR5cGUpfS5gXG4gICk7XG59LCBcImdldENvZGVyXCIpO1xuXG4vLyBzcmMvZW5jb2Rpbmcvc3RyYXRlZ2llcy9nZXRDb2RlckZvckVuY29kaW5nLnRzXG5mdW5jdGlvbiBnZXRDb2RlckZvckVuY29kaW5nKGVuY29kaW5nID0gRU5DT0RJTkdfVjEpIHtcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgRU5DT0RJTkdfVjE6XG4gICAgICByZXR1cm4gZ2V0Q29kZXI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3IxOShcbiAgICAgICAgRXJyb3JDb2RlMTkuVU5TVVBQT1JURURfRU5DT0RJTkdfVkVSU0lPTixcbiAgICAgICAgYEVuY29kaW5nIHZlcnNpb24gJHtlbmNvZGluZ30gaXMgdW5zdXBwb3J0ZWQuYFxuICAgICAgKTtcbiAgfVxufVxuX19uYW1lKGdldENvZGVyRm9yRW5jb2RpbmcsIFwiZ2V0Q29kZXJGb3JFbmNvZGluZ1wiKTtcblxuLy8gc3JjL0FiaUNvZGVyLnRzXG52YXIgQWJpQ29kZXIgPSBjbGFzcyB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiQWJpQ29kZXJcIik7XG4gIH1cbiAgc3RhdGljIGdldENvZGVyKGFiaSwgYXJndW1lbnQsIG9wdGlvbnMgPSB7XG4gICAgcGFkVG9Xb3JkU2l6ZTogZmFsc2VcbiAgfSkge1xuICAgIGNvbnN0IHJlc29sdmVkQWJpVHlwZSA9IG5ldyBSZXNvbHZlZEFiaVR5cGUoYWJpLCBhcmd1bWVudCk7XG4gICAgcmV0dXJuIGdldENvZGVyRm9yRW5jb2Rpbmcob3B0aW9ucy5lbmNvZGluZykocmVzb2x2ZWRBYmlUeXBlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZW5jb2RlKGFiaSwgYXJndW1lbnQsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29kZXIoYWJpLCBhcmd1bWVudCwgb3B0aW9ucykuZW5jb2RlKHZhbHVlKTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlKGFiaSwgYXJndW1lbnQsIGRhdGEsIG9mZnNldCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmdldENvZGVyKGFiaSwgYXJndW1lbnQsIG9wdGlvbnMpLmRlY29kZShkYXRhLCBvZmZzZXQpO1xuICB9XG59O1xuXG4vLyBzcmMvRnVuY3Rpb25GcmFnbWVudC50c1xuaW1wb3J0IHsgYnVmZmVyRnJvbVN0cmluZyB9IGZyb20gXCJAZnVlbC10cy9jcnlwdG9cIjtcbmltcG9ydCB7IEVycm9yQ29kZSBhcyBFcnJvckNvZGUyMCwgRnVlbEVycm9yIGFzIEZ1ZWxFcnJvcjIwIH0gZnJvbSBcIkBmdWVsLXRzL2Vycm9yc1wiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBmdWVsLXRzL2hhc2hlclwiO1xuaW1wb3J0IHsgYm4gYXMgYm4xMCB9IGZyb20gXCJAZnVlbC10cy9tYXRoXCI7XG5pbXBvcnQgeyBhcnJheWlmeSBhcyBhcnJheWlmeTMgfSBmcm9tIFwiQGZ1ZWwtdHMvdXRpbHNcIjtcblxuLy8gc3JjL3V0aWxzL2dldEZ1bmN0aW9uSW5wdXRzLnRzXG52YXIgZ2V0RnVuY3Rpb25JbnB1dHMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChwYXJhbXMpID0+IHtcbiAgY29uc3QgeyBqc29uQWJpLCBpbnB1dHMgfSA9IHBhcmFtcztcbiAgbGV0IGlzTWFuZGF0b3J5ID0gZmFsc2U7XG4gIHJldHVybiBpbnB1dHMucmVkdWNlUmlnaHQoKHJlc3VsdCwgaW5wdXQpID0+IHtcbiAgICBjb25zdCB0eXBlID0gZmluZFR5cGVCeUlkKGpzb25BYmksIGlucHV0LnR5cGUpO1xuICAgIGlzTWFuZGF0b3J5ID0gaXNNYW5kYXRvcnkgfHwgdHlwZS50eXBlICE9PSBWT0lEX1RZUEUgJiYgIW9wdGlvblJlZ0V4LnRlc3QodHlwZS50eXBlKTtcbiAgICByZXR1cm4gW3sgLi4uaW5wdXQsIGlzT3B0aW9uYWw6ICFpc01hbmRhdG9yeSB9LCAuLi5yZXN1bHRdO1xuICB9LCBbXSk7XG59LCBcImdldEZ1bmN0aW9uSW5wdXRzXCIpO1xuXG4vLyBzcmMvdXRpbHMvcGFkVmFsdWVzV2l0aFVuZGVmaW5lZC50c1xudmFyIHBhZFZhbHVlc1dpdGhVbmRlZmluZWQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh2YWx1ZXMsIGlucHV0cykgPT4ge1xuICBpZiAodmFsdWVzLmxlbmd0aCA+PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBjb25zdCBwYWRkZWRWYWx1ZXMgPSB2YWx1ZXMuc2xpY2UoKTtcbiAgcGFkZGVkVmFsdWVzLmxlbmd0aCA9IGlucHV0cy5sZW5ndGg7XG4gIHBhZGRlZFZhbHVlcy5maWxsKHZvaWQgMCwgdmFsdWVzLmxlbmd0aCk7XG4gIHJldHVybiBwYWRkZWRWYWx1ZXM7XG59LCBcInBhZFZhbHVlc1dpdGhVbmRlZmluZWRcIik7XG5cbi8vIHNyYy9GdW5jdGlvbkZyYWdtZW50LnRzXG52YXIgRnVuY3Rpb25GcmFnbWVudCA9IGNsYXNzIF9GdW5jdGlvbkZyYWdtZW50IHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJGdW5jdGlvbkZyYWdtZW50XCIpO1xuICB9XG4gIHNpZ25hdHVyZTtcbiAgc2VsZWN0b3I7XG4gIHNlbGVjdG9yQnl0ZXM7XG4gIGVuY29kaW5nO1xuICBuYW1lO1xuICBqc29uRm47XG4gIGF0dHJpYnV0ZXM7XG4gIGpzb25BYmlPbGQ7XG4gIGpzb25Gbk9sZDtcbiAgY29uc3RydWN0b3IoanNvbkFiaSwgZm4pIHtcbiAgICB0aGlzLmpzb25GbiA9IGZuO1xuICAgIHRoaXMuanNvbkFiaU9sZCA9IGpzb25BYmk7XG4gICAgdGhpcy5qc29uRm5PbGQgPSBqc29uQWJpLmZ1bmN0aW9ucy5maW5kKChmKSA9PiBmLm5hbWUgPT09IGZuLm5hbWUpO1xuICAgIHRoaXMubmFtZSA9IGZuLm5hbWU7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBfRnVuY3Rpb25GcmFnbWVudC5nZXRTaWduYXR1cmUodGhpcy5qc29uQWJpT2xkLCB0aGlzLmpzb25Gbk9sZCk7XG4gICAgdGhpcy5zZWxlY3RvciA9IF9GdW5jdGlvbkZyYWdtZW50LmdldEZ1bmN0aW9uU2VsZWN0b3IodGhpcy5zaWduYXR1cmUpO1xuICAgIHRoaXMuc2VsZWN0b3JCeXRlcyA9IG5ldyBTdGRTdHJpbmdDb2RlcigpLmVuY29kZSh0aGlzLm5hbWUpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBnZXRFbmNvZGluZ1ZlcnNpb24oanNvbkFiaS5lbmNvZGluZyk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gdGhpcy5qc29uRm4uYXR0cmlidXRlcyA/PyBbXTtcbiAgfVxuICBzdGF0aWMgZ2V0U2lnbmF0dXJlKGFiaSwgZm4pIHtcbiAgICBjb25zdCBpbnB1dHNTaWduYXR1cmVzID0gZm4uaW5wdXRzLm1hcChcbiAgICAgIChpbnB1dCkgPT4gbmV3IFJlc29sdmVkQWJpVHlwZShhYmksIGlucHV0KS5nZXRTaWduYXR1cmUoKVxuICAgICk7XG4gICAgcmV0dXJuIGAke2ZuLm5hbWV9KCR7aW5wdXRzU2lnbmF0dXJlcy5qb2luKFwiLFwiKX0pYDtcbiAgfVxuICBzdGF0aWMgZ2V0RnVuY3Rpb25TZWxlY3RvcihmdW5jdGlvblNpZ25hdHVyZSkge1xuICAgIGNvbnN0IGhhc2hlZEZ1bmN0aW9uU2lnbmF0dXJlID0gc2hhMjU2KGJ1ZmZlckZyb21TdHJpbmcoZnVuY3Rpb25TaWduYXR1cmUsIFwidXRmLThcIikpO1xuICAgIHJldHVybiBibjEwKGhhc2hlZEZ1bmN0aW9uU2lnbmF0dXJlLnNsaWNlKDAsIDEwKSkudG9IZXgoOCk7XG4gIH1cbiAgZW5jb2RlQXJndW1lbnRzKHZhbHVlcykge1xuICAgIGNvbnN0IGlucHV0cyA9IGdldEZ1bmN0aW9uSW5wdXRzKHsganNvbkFiaTogdGhpcy5qc29uQWJpT2xkLCBpbnB1dHM6IHRoaXMuanNvbkZuT2xkLmlucHV0cyB9KTtcbiAgICBjb25zdCBtYW5kYXRvcnlJbnB1dExlbmd0aCA9IGlucHV0cy5maWx0ZXIoKGkpID0+ICFpLmlzT3B0aW9uYWwpLmxlbmd0aDtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA8IG1hbmRhdG9yeUlucHV0TGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yMjAoXG4gICAgICAgIEVycm9yQ29kZTIwLkFCSV9UWVBFU19BTkRfVkFMVUVTX01JU01BVENILFxuICAgICAgICBgSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzLiBFeHBlY3RlZCBhIG1pbmltdW0gb2YgJHttYW5kYXRvcnlJbnB1dExlbmd0aH0gYXJndW1lbnRzLCByZWNlaXZlZCAke3ZhbHVlcy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgY29kZXJzID0gdGhpcy5qc29uRm5PbGQuaW5wdXRzLm1hcChcbiAgICAgICh0KSA9PiBBYmlDb2Rlci5nZXRDb2Rlcih0aGlzLmpzb25BYmlPbGQsIHQsIHtcbiAgICAgICAgZW5jb2Rpbmc6IHRoaXMuZW5jb2RpbmdcbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCBhcmd1bWVudFZhbHVlcyA9IHBhZFZhbHVlc1dpdGhVbmRlZmluZWQodmFsdWVzLCB0aGlzLmpzb25Gbi5pbnB1dHMpO1xuICAgIHJldHVybiBuZXcgVHVwbGVDb2Rlcihjb2RlcnMpLmVuY29kZShhcmd1bWVudFZhbHVlcyk7XG4gIH1cbiAgZGVjb2RlQXJndW1lbnRzKGRhdGEpIHtcbiAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5MyhkYXRhKTtcbiAgICBjb25zdCBub25Wb2lkSW5wdXRzID0gZmluZE5vblZvaWRJbnB1dHModGhpcy5qc29uQWJpT2xkLCB0aGlzLmpzb25Gbk9sZC5pbnB1dHMpO1xuICAgIGlmIChub25Wb2lkSW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEZ1ZWxFcnJvcjIwKFxuICAgICAgICBFcnJvckNvZGUyMC5ERUNPREVfRVJST1IsXG4gICAgICAgIGBUeXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoIGR1cmluZyBkZWNvZGUuICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGNvdW50OiB7XG4gICAgICAgICAgICB0eXBlczogdGhpcy5qc29uRm4uaW5wdXRzLmxlbmd0aCxcbiAgICAgICAgICAgIG5vblZvaWRJbnB1dHM6IG5vblZvaWRJbnB1dHMubGVuZ3RoLFxuICAgICAgICAgICAgdmFsdWVzOiBieXRlcy5sZW5ndGhcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBhcmdzOiB0aGlzLmpzb25Gbi5pbnB1dHMsXG4gICAgICAgICAgICBub25Wb2lkSW5wdXRzLFxuICAgICAgICAgICAgdmFsdWVzOiBieXRlc1xuICAgICAgICAgIH1cbiAgICAgICAgfSl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5qc29uRm5PbGQuaW5wdXRzLnJlZHVjZShcbiAgICAgIChvYmosIGlucHV0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gQWJpQ29kZXIuZ2V0Q29kZXIodGhpcy5qc29uQWJpT2xkLCBpbnB1dCwgeyBlbmNvZGluZzogdGhpcy5lbmNvZGluZyB9KTtcbiAgICAgICAgY29uc3QgW2RlY29kZWRWYWx1ZSwgZGVjb2RlZE9mZnNldF0gPSBjb2Rlci5kZWNvZGUoYnl0ZXMsIG9iai5vZmZzZXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlY29kZWQ6IFsuLi5vYmouZGVjb2RlZCwgZGVjb2RlZFZhbHVlXSxcbiAgICAgICAgICBvZmZzZXQ6IGRlY29kZWRPZmZzZXRcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB7IGRlY29kZWQ6IFtdLCBvZmZzZXQ6IDAgfVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdC5kZWNvZGVkO1xuICB9XG4gIGRlY29kZU91dHB1dChkYXRhKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeTMoZGF0YSk7XG4gICAgY29uc3QgY29kZXIgPSBBYmlDb2Rlci5nZXRDb2Rlcih0aGlzLmpzb25BYmlPbGQsIHRoaXMuanNvbkZuT2xkLm91dHB1dCwge1xuICAgICAgZW5jb2Rpbmc6IHRoaXMuZW5jb2RpbmdcbiAgICB9KTtcbiAgICByZXR1cm4gY29kZXIuZGVjb2RlKGJ5dGVzLCAwKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBmdW5jdGlvbiBpcyByZWFkLW9ubHkgaS5lLiBpdCBvbmx5IHJlYWRzIGZyb20gc3RvcmFnZSwgZG9lcyBub3Qgd3JpdGUgdG8gaXQuXG4gICAqXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGZ1bmN0aW9uIGlzIHJlYWQtb25seSBvciBwdXJlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1JlYWRPbmx5KCkge1xuICAgIGNvbnN0IHN0b3JhZ2VBdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSBcInN0b3JhZ2VcIik7XG4gICAgcmV0dXJuICFzdG9yYWdlQXR0cmlidXRlPy5hcmd1bWVudHM/LmluY2x1ZGVzKFwid3JpdGVcIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy90cmFuc3BpbGUtYWJpLnRzXG52YXIgZmluZFR5cGVCeUNvbmNyZXRlSWQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCh0eXBlcywgaWQpID0+IHR5cGVzLmZpbmQoKHgpID0+IHguY29uY3JldGVUeXBlSWQgPT09IGlkKSwgXCJmaW5kVHlwZUJ5Q29uY3JldGVJZFwiKTtcbnZhciBmaW5kQ29uY3JldGVUeXBlQnlJZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGFiaSwgaWQpID0+IGFiaS5jb25jcmV0ZVR5cGVzLmZpbmQoKHgpID0+IHguY29uY3JldGVUeXBlSWQgPT09IGlkKSwgXCJmaW5kQ29uY3JldGVUeXBlQnlJZFwiKTtcbmZ1bmN0aW9uIGZpbnNlcnRUeXBlSWRCeUNvbmNyZXRlVHlwZUlkKGFiaSwgdHlwZXMsIGlkKSB7XG4gIGNvbnN0IGNvbmNyZXRlVHlwZSA9IGZpbmRDb25jcmV0ZVR5cGVCeUlkKGFiaSwgaWQpO1xuICBpZiAoY29uY3JldGVUeXBlLm1ldGFkYXRhVHlwZUlkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gY29uY3JldGVUeXBlLm1ldGFkYXRhVHlwZUlkO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBmaW5kVHlwZUJ5Q29uY3JldGVJZCh0eXBlcywgaWQpO1xuICBpZiAodHlwZSkge1xuICAgIHJldHVybiB0eXBlLnR5cGVJZDtcbiAgfVxuICB0eXBlcy5wdXNoKHtcbiAgICB0eXBlSWQ6IHR5cGVzLmxlbmd0aCxcbiAgICB0eXBlOiBjb25jcmV0ZVR5cGUudHlwZSxcbiAgICBjb21wb25lbnRzOiBwYXJzZUNvbXBvbmVudHMoY29uY3JldGVUeXBlLmNvbXBvbmVudHMpLFxuICAgIGNvbmNyZXRlVHlwZUlkOiBpZCxcbiAgICB0eXBlUGFyYW1ldGVyczogY29uY3JldGVUeXBlLnR5cGVQYXJhbWV0ZXJzID8/IG51bGwsXG4gICAgb3JpZ2luYWxDb25jcmV0ZVR5cGVJZDogY29uY3JldGVUeXBlPy5jb25jcmV0ZVR5cGVJZFxuICB9KTtcbiAgcmV0dXJuIHR5cGVzLmxlbmd0aCAtIDE7XG59XG5fX25hbWUoZmluc2VydFR5cGVJZEJ5Q29uY3JldGVUeXBlSWQsIFwiZmluc2VydFR5cGVJZEJ5Q29uY3JldGVUeXBlSWRcIik7XG5mdW5jdGlvbiBwYXJzZUZ1bmN0aW9uVHlwZUFyZ3VtZW50cyhhYmksIHR5cGVzLCBjb25jcmV0ZVR5cGUpIHtcbiAgcmV0dXJuIGNvbmNyZXRlVHlwZS50eXBlQXJndW1lbnRzPy5tYXAoKGNUeXBlSWQpID0+IHtcbiAgICBjb25zdCBzZWxmID0gZmluZENvbmNyZXRlVHlwZUJ5SWQoYWJpLCBjVHlwZUlkKTtcbiAgICBjb25zdCB0eXBlID0gIWlzTmFOKGNUeXBlSWQpID8gY1R5cGVJZCA6IGZpbnNlcnRUeXBlSWRCeUNvbmNyZXRlVHlwZUlkKGFiaSwgdHlwZXMsIGNUeXBlSWQpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBcIlwiLFxuICAgICAgdHlwZSxcbiAgICAgIC8vIG9yaWdpbmFsVHlwZUlkOiBjVHlwZUlkLFxuICAgICAgdHlwZUFyZ3VtZW50czogcGFyc2VGdW5jdGlvblR5cGVBcmd1bWVudHMoYWJpLCB0eXBlcywgc2VsZilcbiAgICB9O1xuICB9KSA/PyBudWxsO1xufVxuX19uYW1lKHBhcnNlRnVuY3Rpb25UeXBlQXJndW1lbnRzLCBcInBhcnNlRnVuY3Rpb25UeXBlQXJndW1lbnRzXCIpO1xuZnVuY3Rpb24gcGFyc2VDb25jcmV0ZVR5cGUoYWJpLCB0eXBlcywgY29uY3JldGVUeXBlSWQsIG5hbWUpIHtcbiAgY29uc3QgdHlwZSA9IGZpbnNlcnRUeXBlSWRCeUNvbmNyZXRlVHlwZUlkKGFiaSwgdHlwZXMsIGNvbmNyZXRlVHlwZUlkKTtcbiAgY29uc3QgY29uY3JldGUgPSBmaW5kQ29uY3JldGVUeXBlQnlJZChhYmksIGNvbmNyZXRlVHlwZUlkKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lID8/IFwiXCIsXG4gICAgdHlwZSxcbiAgICAvLyBjb25jcmV0ZVR5cGVJZCxcbiAgICB0eXBlQXJndW1lbnRzOiBwYXJzZUZ1bmN0aW9uVHlwZUFyZ3VtZW50cyhhYmksIHR5cGVzLCBjb25jcmV0ZSlcbiAgfTtcbn1cbl9fbmFtZShwYXJzZUNvbmNyZXRlVHlwZSwgXCJwYXJzZUNvbmNyZXRlVHlwZVwiKTtcbmZ1bmN0aW9uIHBhcnNlQ29tcG9uZW50cyhhYmksIHR5cGVzLCBjb21wb25lbnRzKSB7XG4gIHJldHVybiBjb21wb25lbnRzPy5tYXAoKGNvbXBvbmVudCkgPT4ge1xuICAgIGNvbnN0IHsgdHlwZUlkLCBuYW1lLCB0eXBlQXJndW1lbnRzIH0gPSBjb21wb25lbnQ7XG4gICAgY29uc3QgdHlwZSA9ICFpc05hTih0eXBlSWQpID8gdHlwZUlkIDogZmluc2VydFR5cGVJZEJ5Q29uY3JldGVUeXBlSWQoYWJpLCB0eXBlcywgdHlwZUlkKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZSxcbiAgICAgIHR5cGUsXG4gICAgICAvLyBvcmlnaW5hbFR5cGVJZDogdHlwZUlkLFxuICAgICAgdHlwZUFyZ3VtZW50czogcGFyc2VDb21wb25lbnRzKGFiaSwgdHlwZXMsIHR5cGVBcmd1bWVudHMpXG4gICAgfTtcbiAgfSkgPz8gbnVsbDtcbn1cbl9fbmFtZShwYXJzZUNvbXBvbmVudHMsIFwicGFyc2VDb21wb25lbnRzXCIpO1xuZnVuY3Rpb24gdHJhbnNwaWxlQWJpKGFiaSkge1xuICBpZiAoIWFiaS5zcGVjVmVyc2lvbikge1xuICAgIHJldHVybiBhYmk7XG4gIH1cbiAgY29uc3QgdHlwZXMgPSBbXTtcbiAgYWJpLm1ldGFkYXRhVHlwZXMuZm9yRWFjaCgobSkgPT4ge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICB0eXBlSWQ6IG0ubWV0YWRhdGFUeXBlSWQsXG4gICAgICB0eXBlOiBtLnR5cGUsXG4gICAgICBjb21wb25lbnRzOiBtLmNvbXBvbmVudHMgPz8gKG0udHlwZSA9PT0gXCIoKVwiID8gW10gOiBudWxsKSxcbiAgICAgIHR5cGVQYXJhbWV0ZXJzOiBtLnR5cGVQYXJhbWV0ZXJzID8/IG51bGxcbiAgICB9O1xuICAgIHR5cGVzLnB1c2godCk7XG4gIH0pO1xuICB0eXBlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgdC5jb21wb25lbnRzID0gcGFyc2VDb21wb25lbnRzKGFiaSwgdHlwZXMsIHQuY29tcG9uZW50cyk7XG4gIH0pO1xuICBjb25zdCBmdW5jdGlvbnMgPSBhYmkuZnVuY3Rpb25zLm1hcCgoZm4pID0+IHtcbiAgICBjb25zdCBpbnB1dHMgPSBmbi5pbnB1dHMubWFwKFxuICAgICAgKHsgY29uY3JldGVUeXBlSWQsIG5hbWUgfSkgPT4gcGFyc2VDb25jcmV0ZVR5cGUoYWJpLCB0eXBlcywgY29uY3JldGVUeXBlSWQsIG5hbWUpXG4gICAgKTtcbiAgICBjb25zdCBvdXRwdXQgPSBwYXJzZUNvbmNyZXRlVHlwZShhYmksIHR5cGVzLCBmbi5vdXRwdXQsIFwiXCIpO1xuICAgIHJldHVybiB7IC4uLmZuLCBpbnB1dHMsIG91dHB1dCB9O1xuICB9KTtcbiAgY29uc3QgY29uZmlndXJhYmxlcyA9IGFiaS5jb25maWd1cmFibGVzLm1hcCgoY29uZikgPT4gKHtcbiAgICBuYW1lOiBjb25mLm5hbWUsXG4gICAgY29uZmlndXJhYmxlVHlwZTogcGFyc2VDb25jcmV0ZVR5cGUoYWJpLCB0eXBlcywgY29uZi5jb25jcmV0ZVR5cGVJZCksXG4gICAgb2Zmc2V0OiBjb25mLm9mZnNldFxuICB9KSk7XG4gIGNvbnN0IGxvZ2dlZFR5cGVzID0gYWJpLmxvZ2dlZFR5cGVzLm1hcCgobG9nKSA9PiAoe1xuICAgIGxvZ0lkOiBsb2cubG9nSWQsXG4gICAgbG9nZ2VkVHlwZTogcGFyc2VDb25jcmV0ZVR5cGUoYWJpLCB0eXBlcywgbG9nLmNvbmNyZXRlVHlwZUlkKVxuICB9KSk7XG4gIGNvbnN0IHRyYW5zcGlsZWQgPSB7XG4gICAgZW5jb2Rpbmc6IGFiaS5lbmNvZGluZ1ZlcnNpb24sXG4gICAgdHlwZXMsXG4gICAgZnVuY3Rpb25zLFxuICAgIGxvZ2dlZFR5cGVzLFxuICAgIG1lc3NhZ2VzVHlwZXM6IGFiaS5tZXNzYWdlc1R5cGVzLFxuICAgIGNvbmZpZ3VyYWJsZXNcbiAgfTtcbiAgcmV0dXJuIHRyYW5zcGlsZWQ7XG59XG5fX25hbWUodHJhbnNwaWxlQWJpLCBcInRyYW5zcGlsZUFiaVwiKTtcblxuLy8gc3JjL0ludGVyZmFjZS50c1xudmFyIEludGVyZmFjZSA9IGNsYXNzIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJJbnRlcmZhY2VcIik7XG4gIH1cbiAgZnVuY3Rpb25zO1xuICBjb25maWd1cmFibGVzO1xuICBqc29uQWJpO1xuICBlbmNvZGluZztcbiAganNvbkFiaU9sZDtcbiAgY29uc3RydWN0b3IoanNvbkFiaSkge1xuICAgIHRoaXMuanNvbkFiaSA9IGpzb25BYmk7XG4gICAgdGhpcy5lbmNvZGluZyA9IGdldEVuY29kaW5nVmVyc2lvbihqc29uQWJpLmVuY29kaW5nVmVyc2lvbik7XG4gICAgdGhpcy5qc29uQWJpT2xkID0gdHJhbnNwaWxlQWJpKGpzb25BYmkpO1xuICAgIHRoaXMuZnVuY3Rpb25zID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgdGhpcy5qc29uQWJpLmZ1bmN0aW9ucy5tYXAoKGZuKSA9PiBbZm4ubmFtZSwgbmV3IEZ1bmN0aW9uRnJhZ21lbnQodGhpcy5qc29uQWJpT2xkLCBmbildKVxuICAgICk7XG4gICAgdGhpcy5jb25maWd1cmFibGVzID0gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuanNvbkFiaS5jb25maWd1cmFibGVzLm1hcCgoeCkgPT4gW3gubmFtZSwgeF0pKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBmdW5jdGlvbiBmcmFnbWVudCBmb3IgYSBkeW5hbWljIGlucHV0LlxuICAgKiBAcGFyYW0gbmFtZU9yU2lnbmF0dXJlT3JTZWxlY3RvciAtIG5hbWUgKGUuZy4gJ3RyYW5zZmVyJyksIHNpZ25hdHVyZSAoZS5nLiAndHJhbnNmZXIoYWRkcmVzcyx1aW50MjU2KScpIG9yIHNlbGVjdG9yIChlLmcuICcweDAwMDAwMDAwYTkwNTljYmInKSBvZiB0aGUgZnVuY3Rpb24gZnJhZ21lbnRcbiAgICovXG4gIGdldEZ1bmN0aW9uKG5hbWVPclNpZ25hdHVyZU9yU2VsZWN0b3IpIHtcbiAgICBjb25zdCBmbiA9IE9iamVjdC52YWx1ZXModGhpcy5mdW5jdGlvbnMpLmZpbmQoXG4gICAgICAoZikgPT4gZi5uYW1lID09PSBuYW1lT3JTaWduYXR1cmVPclNlbGVjdG9yIHx8IGYuc2lnbmF0dXJlID09PSBuYW1lT3JTaWduYXR1cmVPclNlbGVjdG9yIHx8IGYuc2VsZWN0b3IgPT09IG5hbWVPclNpZ25hdHVyZU9yU2VsZWN0b3JcbiAgICApO1xuICAgIGlmIChmbiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIHRocm93IG5ldyBGdWVsRXJyb3IyMShcbiAgICAgIEVycm9yQ29kZTIxLkZVTkNUSU9OX05PVF9GT1VORCxcbiAgICAgIGBmdW5jdGlvbiAke25hbWVPclNpZ25hdHVyZU9yU2VsZWN0b3J9IG5vdCBmb3VuZDogJHtKU09OLnN0cmluZ2lmeShmbil9LmBcbiAgICApO1xuICB9XG4gIC8vIERlY29kZSB0aGUgcmVzdWx0IG9mIGEgZnVuY3Rpb24gY2FsbFxuICBkZWNvZGVGdW5jdGlvblJlc3VsdChmdW5jdGlvbkZyYWdtZW50LCBkYXRhKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSB0eXBlb2YgZnVuY3Rpb25GcmFnbWVudCA9PT0gXCJzdHJpbmdcIiA/IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCkgOiBmdW5jdGlvbkZyYWdtZW50O1xuICAgIHJldHVybiBmcmFnbWVudC5kZWNvZGVPdXRwdXQoZGF0YSk7XG4gIH1cbiAgZGVjb2RlTG9nKGRhdGEsIGxvZ0lkKSB7XG4gICAgY29uc3QgbG9nZ2VkVHlwZSA9IHRoaXMuanNvbkFiaU9sZC5sb2dnZWRUeXBlcy5maW5kKCh0eXBlKSA9PiB0eXBlLmxvZ0lkID09PSBsb2dJZCk7XG4gICAgaWYgKCFsb2dnZWRUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRnVlbEVycm9yMjEoXG4gICAgICAgIEVycm9yQ29kZTIxLkxPR19UWVBFX05PVF9GT1VORCxcbiAgICAgICAgYExvZyB0eXBlIHdpdGggbG9nSWQgJyR7bG9nSWR9JyBkb2Vzbid0IGV4aXN0IGluIHRoZSBBQkkuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIEFiaUNvZGVyLmRlY29kZSh0aGlzLmpzb25BYmlPbGQsIGxvZ2dlZFR5cGUubG9nZ2VkVHlwZSwgYXJyYXlpZnk0KGRhdGEpLCAwLCB7XG4gICAgICBlbmNvZGluZzogdGhpcy5lbmNvZGluZ1xuICAgIH0pO1xuICB9XG4gIGVuY29kZUNvbmZpZ3VyYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IGNvbmZpZ3VyYWJsZSA9IHRoaXMuanNvbkFiaU9sZC5jb25maWd1cmFibGVzLmZpbmQoKGMpID0+IGMubmFtZSA9PT0gbmFtZSk7XG4gICAgaWYgKCFjb25maWd1cmFibGUpIHtcbiAgICAgIHRocm93IG5ldyBGdWVsRXJyb3IyMShcbiAgICAgICAgRXJyb3JDb2RlMjEuQ09ORklHVVJBQkxFX05PVF9GT1VORCxcbiAgICAgICAgYEEgY29uZmlndXJhYmxlIHdpdGggdGhlICcke25hbWV9JyB3YXMgbm90IGZvdW5kIGluIHRoZSBBQkkuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIEFiaUNvZGVyLmVuY29kZSh0aGlzLmpzb25BYmlPbGQsIGNvbmZpZ3VyYWJsZS5jb25maWd1cmFibGVUeXBlLCB2YWx1ZSwge1xuICAgICAgZW5jb2Rpbmc6IHRoaXMuZW5jb2RpbmdcbiAgICB9KTtcbiAgfVxuICBlbmNvZGVUeXBlKGNvbmNyZXRlVHlwZUlkLCB2YWx1ZSkge1xuICAgIGNvbnN0IHR5cGVBcmcgPSBwYXJzZUNvbmNyZXRlVHlwZShcbiAgICAgIHRoaXMuanNvbkFiaSxcbiAgICAgIHRoaXMuanNvbkFiaU9sZC50eXBlcyxcbiAgICAgIGNvbmNyZXRlVHlwZUlkLFxuICAgICAgXCJcIlxuICAgICk7XG4gICAgcmV0dXJuIEFiaUNvZGVyLmVuY29kZSh0aGlzLmpzb25BYmlPbGQsIHR5cGVBcmcsIHZhbHVlLCB7XG4gICAgICBlbmNvZGluZzogdGhpcy5lbmNvZGluZ1xuICAgIH0pO1xuICB9XG4gIGRlY29kZVR5cGUoY29uY3JldGVUeXBlSWQsIGRhdGEpIHtcbiAgICBjb25zdCB0eXBlQXJnID0gcGFyc2VDb25jcmV0ZVR5cGUoXG4gICAgICB0aGlzLmpzb25BYmksXG4gICAgICB0aGlzLmpzb25BYmlPbGQudHlwZXMsXG4gICAgICBjb25jcmV0ZVR5cGVJZCxcbiAgICAgIFwiXCJcbiAgICApO1xuICAgIHJldHVybiBBYmlDb2Rlci5kZWNvZGUodGhpcy5qc29uQWJpT2xkLCB0eXBlQXJnLCBkYXRhLCAwLCB7IGVuY29kaW5nOiB0aGlzLmVuY29kaW5nIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvc2NyaXB0RGF0YS50c1xudmFyIGRlY29kZVNjcmlwdERhdGEgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzY3JpcHREYXRhLCBhYmkpID0+IHtcbiAgY29uc3QgW2Ftb3VudCwgYW1vdW50T2Zmc2V0XSA9IG5ldyBCaWdOdW1iZXJDb2RlcihcInU2NFwiKS5kZWNvZGUoc2NyaXB0RGF0YSwgMCk7XG4gIGNvbnN0IFthc3NldElkLCBhc3NldElkT2Zmc2V0XSA9IG5ldyBCMjU2Q29kZXIoKS5kZWNvZGUoc2NyaXB0RGF0YSwgYW1vdW50T2Zmc2V0KTtcbiAgY29uc3QgW2NvbnRyYWN0SWQsIGNvbnRyYWN0SWRPZmZzZXRdID0gbmV3IEIyNTZDb2RlcigpLmRlY29kZShzY3JpcHREYXRhLCBhc3NldElkT2Zmc2V0KTtcbiAgY29uc3QgW2Z1bmN0aW9uU2VsZWN0b3IsIGZ1bmN0aW9uU2VsZWN0b3JPZmZzZXRdID0gbmV3IFN0ZFN0cmluZ0NvZGVyKCkuZGVjb2RlKFxuICAgIHNjcmlwdERhdGEsXG4gICAgY29udHJhY3RJZE9mZnNldCArIFdPUkRfU0laRSArIFdPUkRfU0laRVxuICApO1xuICBjb25zdCBmdW5jdGlvbkFyZ3NCeXRlcyA9IHNjcmlwdERhdGEuc2xpY2UoZnVuY3Rpb25TZWxlY3Rvck9mZnNldCk7XG4gIGNvbnN0IGZ1bmN0aW9uQXJncyA9IGFiaSA/IG5ldyBJbnRlcmZhY2UoYWJpKS5nZXRGdW5jdGlvbihmdW5jdGlvblNlbGVjdG9yKS5kZWNvZGVBcmd1bWVudHMoZnVuY3Rpb25BcmdzQnl0ZXMpIDogdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIGFtb3VudCxcbiAgICBhc3NldElkLFxuICAgIGNvbnRyYWN0SWQsXG4gICAgZnVuY3Rpb25TZWxlY3RvcixcbiAgICBmdW5jdGlvbkFyZ3NcbiAgfTtcbn0sIFwiZGVjb2RlU2NyaXB0RGF0YVwiKTtcbmV4cG9ydCB7XG4gIEFTU0VUX0lEX0xFTixcbiAgQXJyYXlDb2RlcixcbiAgQjI1NkNvZGVyLFxuICBCNTEyQ29kZXIsXG4gIEJZVEVTXzMyLFxuICBCaWdOdW1iZXJDb2RlcixcbiAgQm9vbGVhbkNvZGVyLFxuICBCeXRlQ29kZXIsXG4gIENPTlRSQUNUX0lEX0xFTixcbiAgQ29kZXIsXG4gIEVOQ09ESU5HX1YxLFxuICBFbnVtQ29kZXIsXG4gIElOUFVUX0NPSU5fRklYRURfU0laRSxcbiAgSW50ZXJmYWNlLFxuICBOdW1iZXJDb2RlcixcbiAgT3B0aW9uQ29kZXIsXG4gIFJhd1NsaWNlQ29kZXIsXG4gIFNDUklQVF9GSVhFRF9TSVpFLFxuICBTdGRTdHJpbmdDb2RlcixcbiAgU3RyU2xpY2VDb2RlcixcbiAgU3RyaW5nQ29kZXIsXG4gIFN0cnVjdENvZGVyLFxuICBUdXBsZUNvZGVyLFxuICBVVFhPX0lEX0xFTixcbiAgVmVjQ29kZXIsXG4gIFdPUkRfU0laRSxcbiAgY2FsY3VsYXRlVm1UeE1lbW9yeSxcbiAgZGVjb2RlU2NyaXB0RGF0YVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@fuel-ts+abi-coder@0.101.1_vitest@3.2.4_@types+debug@4.1.12_@types+node@24.7.2_jiti@2.6_6403986254e63357a3dfff475209c93d/node_modules/@fuel-ts/abi-coder/dist/index.mjs\n");

/***/ })

};
;