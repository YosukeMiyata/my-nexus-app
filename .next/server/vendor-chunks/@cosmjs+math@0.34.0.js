"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@cosmjs+math@0.34.0";
exports.ids = ["vendor-chunks/@cosmjs+math@0.34.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/decimal.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/decimal.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Decimal = void 0;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js\"));\n// Too large values lead to massive memory usage. Limit to something sensible.\n// The largest value we need is 18 (Ether).\nconst maxFractionalDigits = 100;\n/**\n * A type for arbitrary precision, non-negative decimals.\n *\n * Instances of this class are immutable.\n */\nclass Decimal {\n    static fromUserInput(input, fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        const badCharacter = input.match(/[^0-9.]/);\n        if (badCharacter) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            throw new Error(`Invalid character at position ${badCharacter.index + 1}`);\n        }\n        let whole;\n        let fractional;\n        if (input === \"\") {\n            whole = \"0\";\n            fractional = \"\";\n        }\n        else if (input.search(/\\./) === -1) {\n            // integer format, no separator\n            whole = input;\n            fractional = \"\";\n        }\n        else {\n            const parts = input.split(\".\");\n            switch (parts.length) {\n                case 0:\n                case 1:\n                    throw new Error(\"Fewer than two elements in split result. This must not happen here.\");\n                case 2:\n                    if (!parts[1])\n                        throw new Error(\"Fractional part missing\");\n                    whole = parts[0];\n                    fractional = parts[1].replace(/0+$/, \"\");\n                    break;\n                default:\n                    throw new Error(\"More than one separator found\");\n            }\n        }\n        if (fractional.length > fractionalDigits) {\n            throw new Error(\"Got more fractional digits than supported\");\n        }\n        const quantity = `${whole}${fractional.padEnd(fractionalDigits, \"0\")}`;\n        return new Decimal(quantity, fractionalDigits);\n    }\n    static fromAtomics(atomics, fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(atomics, fractionalDigits);\n    }\n    /**\n     * Creates a Decimal with value 0.0 and the given number of fractial digits.\n     *\n     * Fractional digits are not relevant for the value but needed to be able\n     * to perform arithmetic operations with other decimals.\n     */\n    static zero(fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(\"0\", fractionalDigits);\n    }\n    /**\n     * Creates a Decimal with value 1.0 and the given number of fractial digits.\n     *\n     * Fractional digits are not relevant for the value but needed to be able\n     * to perform arithmetic operations with other decimals.\n     */\n    static one(fractionalDigits) {\n        Decimal.verifyFractionalDigits(fractionalDigits);\n        return new Decimal(\"1\" + \"0\".repeat(fractionalDigits), fractionalDigits);\n    }\n    static verifyFractionalDigits(fractionalDigits) {\n        if (!Number.isInteger(fractionalDigits))\n            throw new Error(\"Fractional digits is not an integer\");\n        if (fractionalDigits < 0)\n            throw new Error(\"Fractional digits must not be negative\");\n        if (fractionalDigits > maxFractionalDigits) {\n            throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);\n        }\n    }\n    static compare(a, b) {\n        if (a.fractionalDigits !== b.fractionalDigits)\n            throw new Error(\"Fractional digits do not match\");\n        return a.data.atomics.cmp(new bn_js_1.default(b.atomics));\n    }\n    get atomics() {\n        return this.data.atomics.toString();\n    }\n    get fractionalDigits() {\n        return this.data.fractionalDigits;\n    }\n    constructor(atomics, fractionalDigits) {\n        if (!atomics.match(/^[0-9]+$/)) {\n            throw new Error(\"Invalid string format. Only non-negative integers in decimal representation supported.\");\n        }\n        this.data = {\n            atomics: new bn_js_1.default(atomics),\n            fractionalDigits: fractionalDigits,\n        };\n    }\n    /** Creates a new instance with the same value */\n    clone() {\n        return new Decimal(this.atomics, this.fractionalDigits);\n    }\n    /** Returns the greatest decimal <= this which has no fractional part (rounding down) */\n    floor() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return this.clone();\n        }\n        else {\n            return Decimal.fromAtomics(whole.mul(factor).toString(), this.fractionalDigits);\n        }\n    }\n    /** Returns the smallest decimal >= this which has no fractional part (rounding up) */\n    ceil() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return this.clone();\n        }\n        else {\n            return Decimal.fromAtomics(whole.addn(1).mul(factor).toString(), this.fractionalDigits);\n        }\n    }\n    toString() {\n        const factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n        const whole = this.data.atomics.div(factor);\n        const fractional = this.data.atomics.mod(factor);\n        if (fractional.isZero()) {\n            return whole.toString();\n        }\n        else {\n            const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, \"0\");\n            const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, \"\");\n            return `${whole.toString()}.${trimmedFractionalPart}`;\n        }\n    }\n    /**\n     * Returns an approximation as a float type. Only use this if no\n     * exact calculation is required.\n     */\n    toFloatApproximation() {\n        const out = Number(this.toString());\n        if (Number.isNaN(out))\n            throw new Error(\"Conversion to number failed\");\n        return out;\n    }\n    /**\n     * a.plus(b) returns a+b.\n     *\n     * Both values need to have the same fractional digits.\n     */\n    plus(b) {\n        if (this.fractionalDigits !== b.fractionalDigits)\n            throw new Error(\"Fractional digits do not match\");\n        const sum = this.data.atomics.add(new bn_js_1.default(b.atomics));\n        return new Decimal(sum.toString(), this.fractionalDigits);\n    }\n    /**\n     * a.minus(b) returns a-b.\n     *\n     * Both values need to have the same fractional digits.\n     * The resulting difference needs to be non-negative.\n     */\n    minus(b) {\n        if (this.fractionalDigits !== b.fractionalDigits)\n            throw new Error(\"Fractional digits do not match\");\n        const difference = this.data.atomics.sub(new bn_js_1.default(b.atomics));\n        if (difference.ltn(0))\n            throw new Error(\"Difference must not be negative\");\n        return new Decimal(difference.toString(), this.fractionalDigits);\n    }\n    /**\n     * a.multiply(b) returns a*b.\n     *\n     * We only allow multiplication by unsigned integers to avoid rounding errors.\n     */\n    multiply(b) {\n        const product = this.data.atomics.mul(new bn_js_1.default(b.toString()));\n        return new Decimal(product.toString(), this.fractionalDigits);\n    }\n    equals(b) {\n        return Decimal.compare(this, b) === 0;\n    }\n    isLessThan(b) {\n        return Decimal.compare(this, b) < 0;\n    }\n    isLessThanOrEqual(b) {\n        return Decimal.compare(this, b) <= 0;\n    }\n    isGreaterThan(b) {\n        return Decimal.compare(this, b) > 0;\n    }\n    isGreaterThanOrEqual(b) {\n        return Decimal.compare(this, b) >= 0;\n    }\n}\nexports.Decimal = Decimal;\n//# sourceMappingURL=decimal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvc21qcyttYXRoQDAuMzQuMC9ub2RlX21vZHVsZXMvQGNvc21qcy9tYXRoL2J1aWxkL2RlY2ltYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Y7QUFDQSxnQ0FBZ0MsbUJBQU8sQ0FBQyxrRkFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHVCQUF1QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNLEVBQUUseUNBQXlDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsb0JBQW9CO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUIsR0FBRyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3lvdXN1a2UvTXlQcm9qZWN0L215LW5leHVzLWFwcC9ub2RlX21vZHVsZXMvLnBucG0vQGNvc21qcyttYXRoQDAuMzQuMC9ub2RlX21vZHVsZXMvQGNvc21qcy9tYXRoL2J1aWxkL2RlY2ltYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlY2ltYWwgPSB2b2lkIDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG4vLyBUb28gbGFyZ2UgdmFsdWVzIGxlYWQgdG8gbWFzc2l2ZSBtZW1vcnkgdXNhZ2UuIExpbWl0IHRvIHNvbWV0aGluZyBzZW5zaWJsZS5cbi8vIFRoZSBsYXJnZXN0IHZhbHVlIHdlIG5lZWQgaXMgMTggKEV0aGVyKS5cbmNvbnN0IG1heEZyYWN0aW9uYWxEaWdpdHMgPSAxMDA7XG4vKipcbiAqIEEgdHlwZSBmb3IgYXJiaXRyYXJ5IHByZWNpc2lvbiwgbm9uLW5lZ2F0aXZlIGRlY2ltYWxzLlxuICpcbiAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBpbW11dGFibGUuXG4gKi9cbmNsYXNzIERlY2ltYWwge1xuICAgIHN0YXRpYyBmcm9tVXNlcklucHV0KGlucHV0LCBmcmFjdGlvbmFsRGlnaXRzKSB7XG4gICAgICAgIERlY2ltYWwudmVyaWZ5RnJhY3Rpb25hbERpZ2l0cyhmcmFjdGlvbmFsRGlnaXRzKTtcbiAgICAgICAgY29uc3QgYmFkQ2hhcmFjdGVyID0gaW5wdXQubWF0Y2goL1teMC05Ll0vKTtcbiAgICAgICAgaWYgKGJhZENoYXJhY3Rlcikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gJHtiYWRDaGFyYWN0ZXIuaW5kZXggKyAxfWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3aG9sZTtcbiAgICAgICAgbGV0IGZyYWN0aW9uYWw7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgd2hvbGUgPSBcIjBcIjtcbiAgICAgICAgICAgIGZyYWN0aW9uYWwgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LnNlYXJjaCgvXFwuLykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBpbnRlZ2VyIGZvcm1hdCwgbm8gc2VwYXJhdG9yXG4gICAgICAgICAgICB3aG9sZSA9IGlucHV0O1xuICAgICAgICAgICAgZnJhY3Rpb25hbCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGlucHV0LnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmV3ZXIgdGhhbiB0d28gZWxlbWVudHMgaW4gc3BsaXQgcmVzdWx0LiBUaGlzIG11c3Qgbm90IGhhcHBlbiBoZXJlLlwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFydHNbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcmFjdGlvbmFsIHBhcnQgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgd2hvbGUgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgICAgICAgZnJhY3Rpb25hbCA9IHBhcnRzWzFdLnJlcGxhY2UoLzArJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb3JlIHRoYW4gb25lIHNlcGFyYXRvciBmb3VuZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhY3Rpb25hbC5sZW5ndGggPiBmcmFjdGlvbmFsRGlnaXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHb3QgbW9yZSBmcmFjdGlvbmFsIGRpZ2l0cyB0aGFuIHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWFudGl0eSA9IGAke3dob2xlfSR7ZnJhY3Rpb25hbC5wYWRFbmQoZnJhY3Rpb25hbERpZ2l0cywgXCIwXCIpfWA7XG4gICAgICAgIHJldHVybiBuZXcgRGVjaW1hbChxdWFudGl0eSwgZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQXRvbWljcyhhdG9taWNzLCBmcmFjdGlvbmFsRGlnaXRzKSB7XG4gICAgICAgIERlY2ltYWwudmVyaWZ5RnJhY3Rpb25hbERpZ2l0cyhmcmFjdGlvbmFsRGlnaXRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsKGF0b21pY3MsIGZyYWN0aW9uYWxEaWdpdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRGVjaW1hbCB3aXRoIHZhbHVlIDAuMCBhbmQgdGhlIGdpdmVuIG51bWJlciBvZiBmcmFjdGlhbCBkaWdpdHMuXG4gICAgICpcbiAgICAgKiBGcmFjdGlvbmFsIGRpZ2l0cyBhcmUgbm90IHJlbGV2YW50IGZvciB0aGUgdmFsdWUgYnV0IG5lZWRlZCB0byBiZSBhYmxlXG4gICAgICogdG8gcGVyZm9ybSBhcml0aG1ldGljIG9wZXJhdGlvbnMgd2l0aCBvdGhlciBkZWNpbWFscy5cbiAgICAgKi9cbiAgICBzdGF0aWMgemVybyhmcmFjdGlvbmFsRGlnaXRzKSB7XG4gICAgICAgIERlY2ltYWwudmVyaWZ5RnJhY3Rpb25hbERpZ2l0cyhmcmFjdGlvbmFsRGlnaXRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsKFwiMFwiLCBmcmFjdGlvbmFsRGlnaXRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERlY2ltYWwgd2l0aCB2YWx1ZSAxLjAgYW5kIHRoZSBnaXZlbiBudW1iZXIgb2YgZnJhY3RpYWwgZGlnaXRzLlxuICAgICAqXG4gICAgICogRnJhY3Rpb25hbCBkaWdpdHMgYXJlIG5vdCByZWxldmFudCBmb3IgdGhlIHZhbHVlIGJ1dCBuZWVkZWQgdG8gYmUgYWJsZVxuICAgICAqIHRvIHBlcmZvcm0gYXJpdGhtZXRpYyBvcGVyYXRpb25zIHdpdGggb3RoZXIgZGVjaW1hbHMuXG4gICAgICovXG4gICAgc3RhdGljIG9uZShmcmFjdGlvbmFsRGlnaXRzKSB7XG4gICAgICAgIERlY2ltYWwudmVyaWZ5RnJhY3Rpb25hbERpZ2l0cyhmcmFjdGlvbmFsRGlnaXRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsKFwiMVwiICsgXCIwXCIucmVwZWF0KGZyYWN0aW9uYWxEaWdpdHMpLCBmcmFjdGlvbmFsRGlnaXRzKTtcbiAgICB9XG4gICAgc3RhdGljIHZlcmlmeUZyYWN0aW9uYWxEaWdpdHMoZnJhY3Rpb25hbERpZ2l0cykge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoZnJhY3Rpb25hbERpZ2l0cykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcmFjdGlvbmFsIGRpZ2l0cyBpcyBub3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgaWYgKGZyYWN0aW9uYWxEaWdpdHMgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhY3Rpb25hbCBkaWdpdHMgbXVzdCBub3QgYmUgbmVnYXRpdmVcIik7XG4gICAgICAgIGlmIChmcmFjdGlvbmFsRGlnaXRzID4gbWF4RnJhY3Rpb25hbERpZ2l0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcmFjdGlvbmFsIGRpZ2l0cyBtdXN0IG5vdCBleGNlZWQgJHttYXhGcmFjdGlvbmFsRGlnaXRzfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZnJhY3Rpb25hbERpZ2l0cyAhPT0gYi5mcmFjdGlvbmFsRGlnaXRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhY3Rpb25hbCBkaWdpdHMgZG8gbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gYS5kYXRhLmF0b21pY3MuY21wKG5ldyBibl9qc18xLmRlZmF1bHQoYi5hdG9taWNzKSk7XG4gICAgfVxuICAgIGdldCBhdG9taWNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmF0b21pY3MudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0IGZyYWN0aW9uYWxEaWdpdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuZnJhY3Rpb25hbERpZ2l0cztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYXRvbWljcywgZnJhY3Rpb25hbERpZ2l0cykge1xuICAgICAgICBpZiAoIWF0b21pY3MubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nIGZvcm1hdC4gT25seSBub24tbmVnYXRpdmUgaW50ZWdlcnMgaW4gZGVjaW1hbCByZXByZXNlbnRhdGlvbiBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgICAgIGF0b21pY3M6IG5ldyBibl9qc18xLmRlZmF1bHQoYXRvbWljcyksXG4gICAgICAgICAgICBmcmFjdGlvbmFsRGlnaXRzOiBmcmFjdGlvbmFsRGlnaXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHZhbHVlICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjaW1hbCh0aGlzLmF0b21pY3MsIHRoaXMuZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBncmVhdGVzdCBkZWNpbWFsIDw9IHRoaXMgd2hpY2ggaGFzIG5vIGZyYWN0aW9uYWwgcGFydCAocm91bmRpbmcgZG93bikgKi9cbiAgICBmbG9vcigpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgxMCkucG93KG5ldyBibl9qc18xLmRlZmF1bHQodGhpcy5kYXRhLmZyYWN0aW9uYWxEaWdpdHMpKTtcbiAgICAgICAgY29uc3Qgd2hvbGUgPSB0aGlzLmRhdGEuYXRvbWljcy5kaXYoZmFjdG9yKTtcbiAgICAgICAgY29uc3QgZnJhY3Rpb25hbCA9IHRoaXMuZGF0YS5hdG9taWNzLm1vZChmYWN0b3IpO1xuICAgICAgICBpZiAoZnJhY3Rpb25hbC5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEZWNpbWFsLmZyb21BdG9taWNzKHdob2xlLm11bChmYWN0b3IpLnRvU3RyaW5nKCksIHRoaXMuZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIHNtYWxsZXN0IGRlY2ltYWwgPj0gdGhpcyB3aGljaCBoYXMgbm8gZnJhY3Rpb25hbCBwYXJ0IChyb3VuZGluZyB1cCkgKi9cbiAgICBjZWlsKCkge1xuICAgICAgICBjb25zdCBmYWN0b3IgPSBuZXcgYm5fanNfMS5kZWZhdWx0KDEwKS5wb3cobmV3IGJuX2pzXzEuZGVmYXVsdCh0aGlzLmRhdGEuZnJhY3Rpb25hbERpZ2l0cykpO1xuICAgICAgICBjb25zdCB3aG9sZSA9IHRoaXMuZGF0YS5hdG9taWNzLmRpdihmYWN0b3IpO1xuICAgICAgICBjb25zdCBmcmFjdGlvbmFsID0gdGhpcy5kYXRhLmF0b21pY3MubW9kKGZhY3Rvcik7XG4gICAgICAgIGlmIChmcmFjdGlvbmFsLmlzWmVybygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERlY2ltYWwuZnJvbUF0b21pY3Mod2hvbGUuYWRkbigxKS5tdWwoZmFjdG9yKS50b1N0cmluZygpLCB0aGlzLmZyYWN0aW9uYWxEaWdpdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBmYWN0b3IgPSBuZXcgYm5fanNfMS5kZWZhdWx0KDEwKS5wb3cobmV3IGJuX2pzXzEuZGVmYXVsdCh0aGlzLmRhdGEuZnJhY3Rpb25hbERpZ2l0cykpO1xuICAgICAgICBjb25zdCB3aG9sZSA9IHRoaXMuZGF0YS5hdG9taWNzLmRpdihmYWN0b3IpO1xuICAgICAgICBjb25zdCBmcmFjdGlvbmFsID0gdGhpcy5kYXRhLmF0b21pY3MubW9kKGZhY3Rvcik7XG4gICAgICAgIGlmIChmcmFjdGlvbmFsLmlzWmVybygpKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hvbGUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxGcmFjdGlvbmFsUGFydCA9IGZyYWN0aW9uYWwudG9TdHJpbmcoKS5wYWRTdGFydCh0aGlzLmRhdGEuZnJhY3Rpb25hbERpZ2l0cywgXCIwXCIpO1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZEZyYWN0aW9uYWxQYXJ0ID0gZnVsbEZyYWN0aW9uYWxQYXJ0LnJlcGxhY2UoLzArJC8sIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGAke3dob2xlLnRvU3RyaW5nKCl9LiR7dHJpbW1lZEZyYWN0aW9uYWxQYXJ0fWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcHByb3hpbWF0aW9uIGFzIGEgZmxvYXQgdHlwZS4gT25seSB1c2UgdGhpcyBpZiBub1xuICAgICAqIGV4YWN0IGNhbGN1bGF0aW9uIGlzIHJlcXVpcmVkLlxuICAgICAqL1xuICAgIHRvRmxvYXRBcHByb3hpbWF0aW9uKCkge1xuICAgICAgICBjb25zdCBvdXQgPSBOdW1iZXIodGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihvdXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmVyc2lvbiB0byBudW1iZXIgZmFpbGVkXCIpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhLnBsdXMoYikgcmV0dXJucyBhK2IuXG4gICAgICpcbiAgICAgKiBCb3RoIHZhbHVlcyBuZWVkIHRvIGhhdmUgdGhlIHNhbWUgZnJhY3Rpb25hbCBkaWdpdHMuXG4gICAgICovXG4gICAgcGx1cyhiKSB7XG4gICAgICAgIGlmICh0aGlzLmZyYWN0aW9uYWxEaWdpdHMgIT09IGIuZnJhY3Rpb25hbERpZ2l0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyYWN0aW9uYWwgZGlnaXRzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgY29uc3Qgc3VtID0gdGhpcy5kYXRhLmF0b21pY3MuYWRkKG5ldyBibl9qc18xLmRlZmF1bHQoYi5hdG9taWNzKSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjaW1hbChzdW0udG9TdHJpbmcoKSwgdGhpcy5mcmFjdGlvbmFsRGlnaXRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYS5taW51cyhiKSByZXR1cm5zIGEtYi5cbiAgICAgKlxuICAgICAqIEJvdGggdmFsdWVzIG5lZWQgdG8gaGF2ZSB0aGUgc2FtZSBmcmFjdGlvbmFsIGRpZ2l0cy5cbiAgICAgKiBUaGUgcmVzdWx0aW5nIGRpZmZlcmVuY2UgbmVlZHMgdG8gYmUgbm9uLW5lZ2F0aXZlLlxuICAgICAqL1xuICAgIG1pbnVzKGIpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJhY3Rpb25hbERpZ2l0cyAhPT0gYi5mcmFjdGlvbmFsRGlnaXRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhY3Rpb25hbCBkaWdpdHMgZG8gbm90IG1hdGNoXCIpO1xuICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gdGhpcy5kYXRhLmF0b21pY3Muc3ViKG5ldyBibl9qc18xLmRlZmF1bHQoYi5hdG9taWNzKSk7XG4gICAgICAgIGlmIChkaWZmZXJlbmNlLmx0bigwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpZmZlcmVuY2UgbXVzdCBub3QgYmUgbmVnYXRpdmVcIik7XG4gICAgICAgIHJldHVybiBuZXcgRGVjaW1hbChkaWZmZXJlbmNlLnRvU3RyaW5nKCksIHRoaXMuZnJhY3Rpb25hbERpZ2l0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGEubXVsdGlwbHkoYikgcmV0dXJucyBhKmIuXG4gICAgICpcbiAgICAgKiBXZSBvbmx5IGFsbG93IG11bHRpcGxpY2F0aW9uIGJ5IHVuc2lnbmVkIGludGVnZXJzIHRvIGF2b2lkIHJvdW5kaW5nIGVycm9ycy5cbiAgICAgKi9cbiAgICBtdWx0aXBseShiKSB7XG4gICAgICAgIGNvbnN0IHByb2R1Y3QgPSB0aGlzLmRhdGEuYXRvbWljcy5tdWwobmV3IGJuX2pzXzEuZGVmYXVsdChiLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsKHByb2R1Y3QudG9TdHJpbmcoKSwgdGhpcy5mcmFjdGlvbmFsRGlnaXRzKTtcbiAgICB9XG4gICAgZXF1YWxzKGIpIHtcbiAgICAgICAgcmV0dXJuIERlY2ltYWwuY29tcGFyZSh0aGlzLCBiKSA9PT0gMDtcbiAgICB9XG4gICAgaXNMZXNzVGhhbihiKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsLmNvbXBhcmUodGhpcywgYikgPCAwO1xuICAgIH1cbiAgICBpc0xlc3NUaGFuT3JFcXVhbChiKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsLmNvbXBhcmUodGhpcywgYikgPD0gMDtcbiAgICB9XG4gICAgaXNHcmVhdGVyVGhhbihiKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsLmNvbXBhcmUodGhpcywgYikgPiAwO1xuICAgIH1cbiAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbChiKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsLmNvbXBhcmUodGhpcywgYikgPj0gMDtcbiAgICB9XG59XG5leHBvcnRzLkRlY2ltYWwgPSBEZWNpbWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjaW1hbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/decimal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Uint64 = exports.Uint53 = exports.Uint32 = exports.Int53 = exports.Decimal = void 0;\nvar decimal_1 = __webpack_require__(/*! ./decimal */ \"(ssr)/./node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/decimal.js\");\nObject.defineProperty(exports, \"Decimal\", ({ enumerable: true, get: function () { return decimal_1.Decimal; } }));\nvar integers_1 = __webpack_require__(/*! ./integers */ \"(ssr)/./node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/integers.js\");\nObject.defineProperty(exports, \"Int53\", ({ enumerable: true, get: function () { return integers_1.Int53; } }));\nObject.defineProperty(exports, \"Uint32\", ({ enumerable: true, get: function () { return integers_1.Uint32; } }));\nObject.defineProperty(exports, \"Uint53\", ({ enumerable: true, get: function () { return integers_1.Uint53; } }));\nObject.defineProperty(exports, \"Uint64\", ({ enumerable: true, get: function () { return integers_1.Uint64; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvc21qcyttYXRoQDAuMzQuMC9ub2RlX21vZHVsZXMvQGNvc21qcy9tYXRoL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxlQUFlO0FBQ2xGLGdCQUFnQixtQkFBTyxDQUFDLDRHQUFXO0FBQ25DLDJDQUEwQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUMvRyxpQkFBaUIsbUJBQU8sQ0FBQyw4R0FBWTtBQUNyQyx5Q0FBd0MsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDNUcsMENBQXlDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzlHLDBDQUF5QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUM5RywwQ0FBeUMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDOUciLCJzb3VyY2VzIjpbIi9Vc2Vycy95b3VzdWtlL015UHJvamVjdC9teS1uZXh1cy1hcHAvbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb3NtanMrbWF0aEAwLjM0LjAvbm9kZV9tb2R1bGVzL0Bjb3NtanMvbWF0aC9idWlsZC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVWludDY0ID0gZXhwb3J0cy5VaW50NTMgPSBleHBvcnRzLlVpbnQzMiA9IGV4cG9ydHMuSW50NTMgPSBleHBvcnRzLkRlY2ltYWwgPSB2b2lkIDA7XG52YXIgZGVjaW1hbF8xID0gcmVxdWlyZShcIi4vZGVjaW1hbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlY2ltYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY2ltYWxfMS5EZWNpbWFsOyB9IH0pO1xudmFyIGludGVnZXJzXzEgPSByZXF1aXJlKFwiLi9pbnRlZ2Vyc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludDUzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlZ2Vyc18xLkludDUzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVWludDMyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlZ2Vyc18xLlVpbnQzMjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVpbnQ1M1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZWdlcnNfMS5VaW50NTM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVaW50NjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVnZXJzXzEuVWludDY0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/integers.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/integers.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* eslint-disable no-bitwise */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js\"));\nconst uint64MaxValue = new bn_js_1.default(\"18446744073709551615\", 10, \"be\");\nclass Uint32 {\n    /** @deprecated use Uint32.fromBytes */\n    static fromBigEndianBytes(bytes) {\n        return Uint32.fromBytes(bytes);\n    }\n    /**\n     * Creates a Uint32 from a fixed length byte array.\n     *\n     * @param bytes a list of exactly 4 bytes\n     * @param endianess defaults to big endian\n     */\n    static fromBytes(bytes, endianess = \"be\") {\n        if (bytes.length !== 4) {\n            throw new Error(\"Invalid input length. Expected 4 bytes.\");\n        }\n        for (let i = 0; i < bytes.length; ++i) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n                throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n            }\n        }\n        const beBytes = endianess === \"be\" ? bytes : Array.from(bytes).reverse();\n        // Use multiplication instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 2 ** 8 + beBytes[3]);\n    }\n    static fromString(str) {\n        if (!str.match(/^[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Uint32(Number.parseInt(str, 10));\n    }\n    constructor(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        if (input < 0 || input > 4294967295) {\n            throw new Error(\"Input not in uint32 range: \" + input.toString());\n        }\n        this.data = input;\n    }\n    toBytesBigEndian() {\n        // Use division instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint8Array([\n            Math.floor(this.data / 2 ** 24) & 0xff,\n            Math.floor(this.data / 2 ** 16) & 0xff,\n            Math.floor(this.data / 2 ** 8) & 0xff,\n            Math.floor(this.data / 2 ** 0) & 0xff,\n        ]);\n    }\n    toBytesLittleEndian() {\n        // Use division instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint8Array([\n            Math.floor(this.data / 2 ** 0) & 0xff,\n            Math.floor(this.data / 2 ** 8) & 0xff,\n            Math.floor(this.data / 2 ** 16) & 0xff,\n            Math.floor(this.data / 2 ** 24) & 0xff,\n        ]);\n    }\n    toNumber() {\n        return this.data;\n    }\n    toBigInt() {\n        return BigInt(this.toNumber());\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Uint32 = Uint32;\nclass Int53 {\n    static fromString(str) {\n        if (!str.match(/^-?[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Int53(Number.parseInt(str, 10));\n    }\n    constructor(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\"Input not in int53 range: \" + input.toString());\n        }\n        this.data = input;\n    }\n    toNumber() {\n        return this.data;\n    }\n    toBigInt() {\n        return BigInt(this.toNumber());\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Int53 = Int53;\nclass Uint53 {\n    static fromString(str) {\n        const signed = Int53.fromString(str);\n        return new Uint53(signed.toNumber());\n    }\n    constructor(input) {\n        const signed = new Int53(input);\n        if (signed.toNumber() < 0) {\n            throw new Error(\"Input is negative\");\n        }\n        this.data = signed;\n    }\n    toNumber() {\n        return this.data.toNumber();\n    }\n    toBigInt() {\n        return BigInt(this.toNumber());\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Uint53 = Uint53;\nclass Uint64 {\n    /** @deprecated use Uint64.fromBytes */\n    static fromBytesBigEndian(bytes) {\n        return Uint64.fromBytes(bytes);\n    }\n    /**\n     * Creates a Uint64 from a fixed length byte array.\n     *\n     * @param bytes a list of exactly 8 bytes\n     * @param endianess defaults to big endian\n     */\n    static fromBytes(bytes, endianess = \"be\") {\n        if (bytes.length !== 8) {\n            throw new Error(\"Invalid input length. Expected 8 bytes.\");\n        }\n        for (let i = 0; i < bytes.length; ++i) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n                throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n            }\n        }\n        const beBytes = endianess === \"be\" ? Array.from(bytes) : Array.from(bytes).reverse();\n        return new Uint64(new bn_js_1.default(beBytes));\n    }\n    static fromString(str) {\n        if (!str.match(/^[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Uint64(new bn_js_1.default(str, 10, \"be\"));\n    }\n    static fromNumber(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        let bigint;\n        try {\n            bigint = new bn_js_1.default(input);\n        }\n        catch {\n            throw new Error(\"Input is not a safe integer\");\n        }\n        return new Uint64(bigint);\n    }\n    constructor(data) {\n        if (data.isNeg()) {\n            throw new Error(\"Input is negative\");\n        }\n        if (data.gt(uint64MaxValue)) {\n            throw new Error(\"Input exceeds uint64 range\");\n        }\n        this.data = data;\n    }\n    toBytesBigEndian() {\n        return Uint8Array.from(this.data.toArray(\"be\", 8));\n    }\n    toBytesLittleEndian() {\n        return Uint8Array.from(this.data.toArray(\"le\", 8));\n    }\n    toString() {\n        return this.data.toString(10);\n    }\n    toBigInt() {\n        return BigInt(this.toString());\n    }\n    toNumber() {\n        return this.data.toNumber();\n    }\n}\nexports.Uint64 = Uint64;\n// Assign classes to unused variables in order to verify static interface conformance at compile time.\n// Workaround for https://github.com/microsoft/TypeScript/issues/33892\nconst _int53Class = Int53;\nconst _uint53Class = Uint53;\nconst _uint32Class = Uint32;\nconst _uint64Class = Uint64;\n//# sourceMappingURL=integers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvc21qcyttYXRoQDAuMzQuMC9ub2RlX21vZHVsZXMvQGNvc21qcy9tYXRoL2J1aWxkL2ludGVnZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxjQUFjO0FBQ2hFO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsa0ZBQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMveW91c3VrZS9NeVByb2plY3QvbXktbmV4dXMtYXBwL25vZGVfbW9kdWxlcy8ucG5wbS9AY29zbWpzK21hdGhAMC4zNC4wL25vZGVfbW9kdWxlcy9AY29zbWpzL21hdGgvYnVpbGQvaW50ZWdlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVpbnQ2NCA9IGV4cG9ydHMuVWludDUzID0gZXhwb3J0cy5JbnQ1MyA9IGV4cG9ydHMuVWludDMyID0gdm9pZCAwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuY29uc3QgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xuY29uc3QgdWludDY0TWF4VmFsdWUgPSBuZXcgYm5fanNfMS5kZWZhdWx0KFwiMTg0NDY3NDQwNzM3MDk1NTE2MTVcIiwgMTAsIFwiYmVcIik7XG5jbGFzcyBVaW50MzIge1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgVWludDMyLmZyb21CeXRlcyAqL1xuICAgIHN0YXRpYyBmcm9tQmlnRW5kaWFuQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQzMi5mcm9tQnl0ZXMoYnl0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVWludDMyIGZyb20gYSBmaXhlZCBsZW5ndGggYnl0ZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyBhIGxpc3Qgb2YgZXhhY3RseSA0IGJ5dGVzXG4gICAgICogQHBhcmFtIGVuZGlhbmVzcyBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcywgZW5kaWFuZXNzID0gXCJiZVwiKSB7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgbGVuZ3RoLiBFeHBlY3RlZCA0IGJ5dGVzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYnl0ZXNbaV0pIHx8IGJ5dGVzW2ldID4gMjU1IHx8IGJ5dGVzW2ldIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgaW4gYnl0ZS4gRm91bmQ6IFwiICsgYnl0ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJlQnl0ZXMgPSBlbmRpYW5lc3MgPT09IFwiYmVcIiA/IGJ5dGVzIDogQXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpO1xuICAgICAgICAvLyBVc2UgbXVsdGlwbGljYXRpb24gaW5zdGVhZCBvZiBzaGlmdGluZyBzaW5jZSBiaXR3aXNlIG9wZXJhdG9ycyBhcmUgZGVmaW5lZFxuICAgICAgICAvLyBvbiBTSUdORUQgaW50MzIgaW4gSmF2YVNjcmlwdCBhbmQgd2UgZG9uJ3Qgd2FudCB0byByaXNrIHN1cnByaXNlc1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQzMihiZUJ5dGVzWzBdICogMiAqKiAyNCArIGJlQnl0ZXNbMV0gKiAyICoqIDE2ICsgYmVCeXRlc1syXSAqIDIgKiogOCArIGJlQnl0ZXNbM10pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nIGZvcm1hdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQzMihOdW1iZXIucGFyc2VJbnQoc3RyLCAxMCkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbm90IGEgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCA8IDAgfHwgaW5wdXQgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBub3QgaW4gdWludDMyIHJhbmdlOiBcIiArIGlucHV0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IGlucHV0O1xuICAgIH1cbiAgICB0b0J5dGVzQmlnRW5kaWFuKCkge1xuICAgICAgICAvLyBVc2UgZGl2aXNpb24gaW5zdGVhZCBvZiBzaGlmdGluZyBzaW5jZSBiaXR3aXNlIG9wZXJhdG9ycyBhcmUgZGVmaW5lZFxuICAgICAgICAvLyBvbiBTSUdORUQgaW50MzIgaW4gSmF2YVNjcmlwdCBhbmQgd2UgZG9uJ3Qgd2FudCB0byByaXNrIHN1cnByaXNlc1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzLmRhdGEgLyAyICoqIDI0KSAmIDB4ZmYsXG4gICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuZGF0YSAvIDIgKiogMTYpICYgMHhmZixcbiAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5kYXRhIC8gMiAqKiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuZGF0YSAvIDIgKiogMCkgJiAweGZmLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgdG9CeXRlc0xpdHRsZUVuZGlhbigpIHtcbiAgICAgICAgLy8gVXNlIGRpdmlzaW9uIGluc3RlYWQgb2Ygc2hpZnRpbmcgc2luY2UgYml0d2lzZSBvcGVyYXRvcnMgYXJlIGRlZmluZWRcbiAgICAgICAgLy8gb24gU0lHTkVEIGludDMyIGluIEphdmFTY3JpcHQgYW5kIHdlIGRvbid0IHdhbnQgdG8gcmlzayBzdXJwcmlzZXNcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5kYXRhIC8gMiAqKiAwKSAmIDB4ZmYsXG4gICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuZGF0YSAvIDIgKiogOCkgJiAweGZmLFxuICAgICAgICAgICAgTWF0aC5mbG9vcih0aGlzLmRhdGEgLyAyICoqIDE2KSAmIDB4ZmYsXG4gICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMuZGF0YSAvIDIgKiogMjQpICYgMHhmZixcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHRvTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cbiAgICB0b0JpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLnRvTnVtYmVyKCkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuVWludDMyID0gVWludDMyO1xuY2xhc3MgSW50NTMge1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuICAgICAgICBpZiAoIXN0ci5tYXRjaCgvXi0/WzAtOV0rJC8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZyBmb3JtYXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ1MyhOdW1iZXIucGFyc2VJbnQoc3RyLCAxMCkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbm90IGEgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCA8IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IGlucHV0ID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IG5vdCBpbiBpbnQ1MyByYW5nZTogXCIgKyBpbnB1dC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGEgPSBpbnB1dDtcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfVxuICAgIHRvQmlnSW50KCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMudG9OdW1iZXIoKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnQ1MyA9IEludDUzO1xuY2xhc3MgVWludDUzIHtcbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkID0gSW50NTMuZnJvbVN0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ1MyhzaWduZWQudG9OdW1iZXIoKSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZCA9IG5ldyBJbnQ1MyhpbnB1dCk7XG4gICAgICAgIGlmIChzaWduZWQudG9OdW1iZXIoKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG5lZ2F0aXZlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IHNpZ25lZDtcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy50b051bWJlcigpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLlVpbnQ1MyA9IFVpbnQ1MztcbmNsYXNzIFVpbnQ2NCB7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBVaW50NjQuZnJvbUJ5dGVzICovXG4gICAgc3RhdGljIGZyb21CeXRlc0JpZ0VuZGlhbihieXRlcykge1xuICAgICAgICByZXR1cm4gVWludDY0LmZyb21CeXRlcyhieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVaW50NjQgZnJvbSBhIGZpeGVkIGxlbmd0aCBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ5dGVzIGEgbGlzdCBvZiBleGFjdGx5IDggYnl0ZXNcbiAgICAgKiBAcGFyYW0gZW5kaWFuZXNzIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzLCBlbmRpYW5lc3MgPSBcImJlXCIpIHtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBsZW5ndGguIEV4cGVjdGVkIDggYnl0ZXMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihieXRlc1tpXSkgfHwgYnl0ZXNbaV0gPiAyNTUgfHwgYnl0ZXNbaV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBpbiBieXRlLiBGb3VuZDogXCIgKyBieXRlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmVCeXRlcyA9IGVuZGlhbmVzcyA9PT0gXCJiZVwiID8gQXJyYXkuZnJvbShieXRlcykgOiBBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDY0KG5ldyBibl9qc18xLmRlZmF1bHQoYmVCeXRlcykpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nIGZvcm1hdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ2NChuZXcgYm5fanNfMS5kZWZhdWx0KHN0ciwgMTAsIFwiYmVcIikpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU51bWJlcihpbnB1dCkge1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbm90IGEgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBiaWdpbnQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBiaWdpbnQgPSBuZXcgYm5fanNfMS5kZWZhdWx0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBub3QgYSBzYWZlIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50NjQoYmlnaW50KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBuZWdhdGl2ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5ndCh1aW50NjRNYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGV4Y2VlZHMgdWludDY0IHJhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHRvQnl0ZXNCaWdFbmRpYW4oKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20odGhpcy5kYXRhLnRvQXJyYXkoXCJiZVwiLCA4KSk7XG4gICAgfVxuICAgIHRvQnl0ZXNMaXR0bGVFbmRpYW4oKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20odGhpcy5kYXRhLnRvQXJyYXkoXCJsZVwiLCA4KSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudG9OdW1iZXIoKTtcbiAgICB9XG59XG5leHBvcnRzLlVpbnQ2NCA9IFVpbnQ2NDtcbi8vIEFzc2lnbiBjbGFzc2VzIHRvIHVudXNlZCB2YXJpYWJsZXMgaW4gb3JkZXIgdG8gdmVyaWZ5IHN0YXRpYyBpbnRlcmZhY2UgY29uZm9ybWFuY2UgYXQgY29tcGlsZSB0aW1lLlxuLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMzg5MlxuY29uc3QgX2ludDUzQ2xhc3MgPSBJbnQ1MztcbmNvbnN0IF91aW50NTNDbGFzcyA9IFVpbnQ1MztcbmNvbnN0IF91aW50MzJDbGFzcyA9IFVpbnQzMjtcbmNvbnN0IF91aW50NjRDbGFzcyA9IFVpbnQ2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVnZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@cosmjs+math@0.34.0/node_modules/@cosmjs/math/build/integers.js\n");

/***/ })

};
;